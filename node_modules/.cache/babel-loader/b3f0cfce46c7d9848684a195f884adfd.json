{"ast":null,"code":"import { cloneArr, cloneObj, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values } from \"../../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../../grammar/keys\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException } from \"../../exceptions_public\";\nimport { PROD_TYPE } from \"../../grammar/lookahead\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker } from \"../../grammar/interpreter\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\";\nimport { EOF } from \"../../../scan/tokens_public\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../../scan/tokens\";\nimport { classNameFromInstance } from \"../../../lang/lang_extensions\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\n\nvar RecognizerEngine = function () {\n  function RecognizerEngine() {}\n\n  RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n    this.className = classNameFromInstance(this); // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.allRuleNames = [];\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" + \"\\tFor Further details.\");\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\" + \"\\tNote that the first argument for the parser constructor\\n\" + \"\\tis no longer a Token vector (since v4.0).\");\n      }\n\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" + \"\\tFor Further details.\");\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = reduce(tokenVocabulary, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (has(tokenVocabulary, \"modes\") && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n      var allTokenTypes = flatten(values(tokenVocabulary.modes));\n      var uniqueTokens = uniq(allTokenTypes);\n      this.tokensMap = reduce(uniqueTokens, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = cloneObj(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" + \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    } // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n\n    /* tslint:disable */\n\n\n    this.tokensMap[\"EOF\"] = EOF; // TODO: This check may not be accurate for multi mode lexers\n\n    var noTokenCategoriesUsed = every(values(tokenVocabulary), function (tokenConstructor) {\n      return isEmpty(tokenConstructor.categoryMatches);\n    });\n    this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher; // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n\n    augmentTokenTypes(values(this.tokensMap));\n  };\n\n  RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" + \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n    }\n\n    var resyncEnabled = has(config, \"resyncEnabled\") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;\n    var recoveryValueFunc = has(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc; // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n\n    /* tslint:disable */\n\n    var shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;\n    /* tslint:enable */\n\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n\n    function invokeRuleWithTry(args) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args);\n          var cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } else {\n          return impl.apply(this, args);\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n      } finally {\n        this.ruleFinallyStateUpdate();\n      }\n    }\n\n    var wrappedGrammarRule;\n\n    wrappedGrammarRule = function (idxInCallingRule, args) {\n      if (idxInCallingRule === void 0) {\n        idxInCallingRule = 0;\n      }\n\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n      return invokeRuleWithTry.call(this, args);\n    };\n\n    var ruleNamePropName = \"ruleName\";\n    wrappedGrammarRule[ruleNamePropName] = ruleName;\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n    return wrappedGrammarRule;\n  };\n\n  RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n    var isFirstInvokedRule = this.RULE_STACK.length === 1; // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n\n    var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n\n    if (isRecognitionException(e)) {\n      var recogError = e;\n\n      if (reSyncEnabled) {\n        var reSyncTokType = this.findReSyncTokenType();\n\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc();\n          }\n        } else {\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          } // to be handled Further up the call stack\n\n\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState(); // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n\n        return recoveryValueFunc();\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  }; // Implementation of parsing DSL\n\n\n  RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, key);\n\n    try {\n      return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(key, nestedName);\n      }\n    }\n  };\n\n  RecognizerEngine.prototype.optionInternalNoCst = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  };\n\n  RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n    var _this = this;\n\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_1 = lookAheadFunc;\n\n        lookAheadFunc = function () {\n          return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n\n    return undefined;\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n    var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n\n    try {\n      return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n    var key = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n    this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key);\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_2 = lookAheadFunc;\n\n        lookAheadFunc = function () {\n          return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      var notStuck = this.doSingleRepetition(action);\n\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    } // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    var nestedName = this.nestedRuleBeforeClause(options, laKey);\n\n    try {\n      this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalNoCst = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLookaheadFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;\n      action.call(this); //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n\n      var separatorLookAheadFunc = function () {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  };\n\n  RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n\n    try {\n      return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n\n  RecognizerEngine.prototype.manyInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n\n  RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n\n    var lookaheadFunction = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_3 = lookaheadFunction;\n\n        lookaheadFunction = function () {\n          return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    var notStuck = true;\n\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n    // An infinite loop cannot occur as:\n    // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n    notStuck);\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n    var nestedName = this.nestedRuleBeforeClause(options, laKey);\n\n    try {\n      this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternalNoCst = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLaFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n\n      var separatorLookAheadFunc = function () {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator); // No need for checking infinite loop here due to consuming the separator.\n\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterManySepWalker], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n    }\n  };\n\n  RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    } // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n    /* istanbul ignore else */\n\n\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  };\n\n  RecognizerEngine.prototype.doSingleRepetition = function (action) {\n    var beforeIteration = this.getLexerPosition();\n    action.call(this);\n    var afterIteration = this.getLexerPosition(); // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n\n    return afterIteration > beforeIteration;\n  };\n\n  RecognizerEngine.prototype.orInternalNoCst = function (altsOrOpts, occurrence) {\n    var alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    var laFunc = this.getLaFuncFromCache(laKey);\n    var altIdxToTake = laFunc.call(this, alts);\n\n    if (altIdxToTake !== undefined) {\n      var chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  };\n\n  RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n    var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    var nestedName = this.nestedRuleBeforeClause(altsOrOpts, laKey);\n\n    try {\n      var alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n      var laFunc = this.getLaFuncFromCache(laKey);\n      var altIdxToTake = laFunc.call(this, alts);\n\n      if (altIdxToTake !== undefined) {\n        var chosenAlternative = alts[altIdxToTake];\n        var nestedAltBeforeClauseResult = this.nestedAltBeforeClause(chosenAlternative, occurrence, OR_IDX, altIdxToTake);\n\n        try {\n          return chosenAlternative.ALT.call(this);\n        } finally {\n          if (nestedAltBeforeClauseResult !== undefined) {\n            this.nestedRuleFinallyClause(nestedAltBeforeClauseResult.shortName, nestedAltBeforeClauseResult.nestedName);\n          }\n        }\n      }\n\n      this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    } finally {\n      if (nestedName !== undefined) {\n        this.nestedRuleFinallyClause(laKey, nestedName);\n      }\n    }\n  };\n\n  RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop(); // NOOP when cst is disabled\n\n    this.cstFinallyStateUpdate();\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      var firstRedundantTok = this.LA(1);\n      var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  };\n\n  RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n    var ruleResult;\n\n    try {\n      var args = options !== undefined ? options.ARGS : undefined;\n      ruleResult = ruleToCall.call(this, idx, args);\n      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  };\n\n  RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n\n    throw e;\n  };\n\n  RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n    var consumedToken;\n\n    try {\n      var nextToken = this.LA(1);\n\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n\n    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  };\n\n  RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n    var msg;\n    var previousToken = this.LA(0);\n\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n\n    throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n  };\n\n  RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  };\n\n  RecognizerEngine.prototype.saveRecogState = function () {\n    // errors is a getter which will clone the errors array\n    var savedErrors = this.errors;\n    var savedRuleStack = cloneArr(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK,\n      LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK\n    };\n  };\n\n  RecognizerEngine.prototype.reloadRecogState = function (newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  };\n\n  RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName); // NOOP when cst is disabled\n\n    this.cstInvocationStateUpdate(fullName, shortName);\n  };\n\n  RecognizerEngine.prototype.isBackTracking = function () {\n    return this.isBackTrackingStack.length !== 0;\n  };\n\n  RecognizerEngine.prototype.getCurrRuleFullName = function () {\n    var shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  };\n\n  RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n    return this.shortRuleNameToFull[shortName];\n  };\n\n  RecognizerEngine.prototype.isAtEndOfInput = function () {\n    return this.tokenMatcher(this.LA(1), EOF);\n  };\n\n  RecognizerEngine.prototype.reset = function () {\n    this.resetLexerState();\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    this.LAST_EXPLICIT_RULE_STACK = []; // TODO: extract a specific rest for TreeBuilder trait\n\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  };\n\n  return RecognizerEngine;\n}();\n\nexport { RecognizerEngine };","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js"],"names":["cloneArr","cloneObj","every","flatten","has","isArray","isEmpty","isObject","reduce","uniq","values","AT_LEAST_ONE_IDX","AT_LEAST_ONE_SEP_IDX","BITS_FOR_METHOD_TYPE","BITS_FOR_OCCURRENCE_IDX","MANY_IDX","MANY_SEP_IDX","OPTION_IDX","OR_IDX","isRecognitionException","MismatchedTokenException","NotAllInputParsedException","PROD_TYPE","NextTerminalAfterAtLeastOneSepWalker","NextTerminalAfterAtLeastOneWalker","NextTerminalAfterManySepWalker","NextTerminalAfterManyWalker","DEFAULT_RULE_CONFIG","IN_RULE_RECOVERY_EXCEPTION","EOF","augmentTokenTypes","isTokenType","tokenStructuredMatcher","tokenStructuredMatcherNoCategories","classNameFromInstance","RecognizerEngine","prototype","initRecognizerEngine","tokenVocabulary","config","className","shortRuleNameToFull","fullRuleNameToShort","ruleShortNameIdx","tokenMatcher","definedRulesNames","tokensMap","allRuleNames","isBackTrackingStack","RULE_STACK","RULE_OCCURRENCE_STACK","gastProductionsCache","Error","startOffset","acc","tokType","name","modes","allTokenTypes","uniqueTokens","noTokenCategoriesUsed","tokenConstructor","categoryMatches","defineRule","ruleName","impl","selfAnalysisDone","resyncEnabled","recoveryValueFunc","shortName","invokeRuleWithTry","args","outputCst","apply","cst","CST_STACK","length","cstPostRule","e","invokeRuleCatch","ruleFinallyStateUpdate","wrappedGrammarRule","idxInCallingRule","ruleInvocationStateUpdate","call","ruleNamePropName","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","isBackTracking","recoveryEnabled","recogError","reSyncTokType","findReSyncTokenType","isInCurrentRuleReSyncSet","resyncedTokens","reSyncTo","partialCstResult","recoveredNode","moveToTerminatedState","optionInternal","actionORMethodDef","occurrence","key","getKeyForAutomaticLookahead","nestedName","nestedRuleBeforeClause","optionInternalLogic","undefined","nestedRuleFinallyClause","optionInternalNoCst","_this","lookAheadFunc","getLaFuncFromCache","action","predicate","DEF","GATE","orgLookaheadFunction_1","atLeastOneInternal","prodOccurrence","laKey","atLeastOneInternalLogic","atLeastOneInternalNoCst","orgLookaheadFunction_2","notStuck","doSingleRepetition","raiseEarlyExitException","REPETITION_MANDATORY","ERR_MSG","attemptInRepetitionRecovery","atLeastOneSepFirstInternal","options","atLeastOneSepFirstInternalLogic","atLeastOneSepFirstInternalNoCst","separator","SEP","firstIterationLookaheadFunc","separatorLookAheadFunc","LA","CONSUME","repetitionSepSecondInternal","REPETITION_MANDATORY_WITH_SEPARATOR","manyInternal","manyInternalLogic","manyInternalNoCst","lookaheadFunction","orgLookaheadFunction_3","manySepFirstInternal","manySepFirstInternalLogic","manySepFirstInternalNoCst","firstIterationLaFunc","nextTerminalAfterWalker","beforeIteration","getLexerPosition","afterIteration","orInternalNoCst","altsOrOpts","alts","laFunc","altIdxToTake","chosenAlternative","ALT","raiseNoAltException","orInternal","nestedAltBeforeClauseResult","nestedAltBeforeClause","pop","cstFinallyStateUpdate","isAtEndOfInput","firstRedundantTok","errMsg","errorMessageProvider","buildNotAllInputParsedMessage","firstRedundant","getCurrRuleFullName","SAVE_ERROR","subruleInternal","ruleToCall","idx","ruleResult","ARGS","cstPostNonTerminal","LABEL","subruleInternalError","consumeInternal","consumedToken","nextToken","consumeToken","consumeInternalError","eFromConsumption","consumeInternalRecovery","cstPostTerminal","msg","previousToken","buildMismatchTokenMessage","expected","actual","previous","follows","getFollowsForInRuleRecovery","tryInRuleRecovery","eFromInRuleRecovery","saveRecogState","savedErrors","errors","savedRuleStack","lexerState","exportLexerState","LAST_EXPLICIT_RULE_STACK","reloadRecogState","newState","importLexerState","fullName","push","cstInvocationStateUpdate","getLastExplicitRuleShortName","shortRuleNameToFullName","reset","resetLexerState"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,QAAnB,EAA6BC,KAA7B,EAAoCC,OAApC,EAA6CC,GAA7C,EAAkDC,OAAlD,EAA2DC,OAA3D,EAAoEC,QAApE,EAA8EC,MAA9E,EAAsFC,IAAtF,EAA4FC,MAA5F,QAA0G,sBAA1G;AACA,SAASC,gBAAT,EAA2BC,oBAA3B,EAAiDC,oBAAjD,EAAuEC,uBAAvE,EAAgGC,QAAhG,EAA0GC,YAA1G,EAAwHC,UAAxH,EAAoIC,MAApI,QAAkJ,oBAAlJ;AACA,SAASC,sBAAT,EAAiCC,wBAAjC,EAA2DC,0BAA3D,QAA6F,yBAA7F;AACA,SAASC,SAAT,QAA0B,yBAA1B;AACA,SAASC,oCAAT,EAA+CC,iCAA/C,EAAkFC,8BAAlF,EAAkHC,2BAAlH,QAAqJ,2BAArJ;AACA,SAASC,mBAAT,QAAoC,WAApC;AACA,SAASC,0BAAT,QAA2C,eAA3C;AACA,SAASC,GAAT,QAAoB,6BAApB;AACA,SAASC,iBAAT,EAA4BC,WAA5B,EAAyCC,sBAAzC,EAAiEC,kCAAjE,QAA2G,sBAA3G;AACA,SAASC,qBAAT,QAAsC,+BAAtC;AACA;AACA;AACA;AACA;;AACA,IAAIC,gBAAgB,GAAkB,YAAY;AAC9C,WAASA,gBAAT,GAA4B,CAC3B;;AACDA,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BC,oBAA3B,GAAkD,UAAUC,eAAV,EAA2BC,MAA3B,EAAmC;AACjF,SAAKC,SAAL,GAAiBN,qBAAqB,CAAC,IAAD,CAAtC,CADiF,CAEjF;;AACA,SAAKO,mBAAL,GAA2B,EAA3B;AACA,SAAKC,mBAAL,GAA2B,EAA3B;AACA,SAAKC,gBAAL,GAAwB,GAAxB;AACA,SAAKC,YAAL,GAAoBX,kCAApB;AACA,SAAKY,iBAAL,GAAyB,EAAzB;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,mBAAL,GAA2B,EAA3B;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,qBAAL,GAA6B,EAA7B;AACA,SAAKC,oBAAL,GAA4B,EAA5B;;AACA,QAAI/C,GAAG,CAACmC,MAAD,EAAS,mBAAT,CAAP,EAAsC;AAClC,YAAMa,KAAK,CAAC,uFACR,qFADQ,GAER,wBAFO,CAAX;AAGH;;AACD,QAAI/C,OAAO,CAACiC,eAAD,CAAX,EAA8B;AAC1B;AACA;AACA;AACA,UAAIhC,OAAO,CAACgC,eAAD,CAAX,EAA8B;AAC1B,cAAMc,KAAK,CAAC,0CACR,6DADQ,GAER,6CAFO,CAAX;AAGH;;AACD,UAAI,OAAOd,eAAe,CAAC,CAAD,CAAf,CAAmBe,WAA1B,KAA0C,QAA9C,EAAwD;AACpD,cAAMD,KAAK,CAAC,qFACR,qFADQ,GAER,wBAFO,CAAX;AAGH;AACJ;;AACD,QAAI/C,OAAO,CAACiC,eAAD,CAAX,EAA8B;AAC1B,WAAKQ,SAAL,GAAiBtC,MAAM,CAAC8B,eAAD,EAAkB,UAAUgB,GAAV,EAAeC,OAAf,EAAwB;AAC7DD,QAAAA,GAAG,CAACC,OAAO,CAACC,IAAT,CAAH,GAAoBD,OAApB;AACA,eAAOD,GAAP;AACH,OAHsB,EAGpB,EAHoB,CAAvB;AAIH,KALD,MAMK,IAAIlD,GAAG,CAACkC,eAAD,EAAkB,OAAlB,CAAH,IACLpC,KAAK,CAACC,OAAO,CAACO,MAAM,CAAC4B,eAAe,CAACmB,KAAjB,CAAP,CAAR,EAAyC1B,WAAzC,CADJ,EAC2D;AAC5D,UAAI2B,aAAa,GAAGvD,OAAO,CAACO,MAAM,CAAC4B,eAAe,CAACmB,KAAjB,CAAP,CAA3B;AACA,UAAIE,YAAY,GAAGlD,IAAI,CAACiD,aAAD,CAAvB;AACA,WAAKZ,SAAL,GAAiBtC,MAAM,CAACmD,YAAD,EAAe,UAAUL,GAAV,EAAeC,OAAf,EAAwB;AAC1DD,QAAAA,GAAG,CAACC,OAAO,CAACC,IAAT,CAAH,GAAoBD,OAApB;AACA,eAAOD,GAAP;AACH,OAHsB,EAGpB,EAHoB,CAAvB;AAIH,KARI,MASA,IAAI/C,QAAQ,CAAC+B,eAAD,CAAZ,EAA+B;AAChC,WAAKQ,SAAL,GAAiB7C,QAAQ,CAACqC,eAAD,CAAzB;AACH,KAFI,MAGA;AACD,YAAM,IAAIc,KAAJ,CAAU,wEACZ,qEADE,CAAN;AAEH,KAvDgF,CAwDjF;AACA;;AACA;;;AACA,SAAKN,SAAL,CAAe,KAAf,IAAwBjB,GAAxB,CA3DiF,CA4DjF;;AACA,QAAI+B,qBAAqB,GAAG1D,KAAK,CAACQ,MAAM,CAAC4B,eAAD,CAAP,EAA0B,UAAUuB,gBAAV,EAA4B;AAAE,aAAOvD,OAAO,CAACuD,gBAAgB,CAACC,eAAlB,CAAd;AAAmD,KAA3G,CAAjC;AACA,SAAKlB,YAAL,GAAoBgB,qBAAqB,GACnC3B,kCADmC,GAEnCD,sBAFN,CA9DiF,CAiEjF;AACA;AACA;;AACAF,IAAAA,iBAAiB,CAACpB,MAAM,CAAC,KAAKoC,SAAN,CAAP,CAAjB;AACH,GArED;;AAsEAX,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B2B,UAA3B,GAAwC,UAAUC,QAAV,EAAoBC,IAApB,EAA0B1B,MAA1B,EAAkC;AACtE,QAAI,KAAK2B,gBAAT,EAA2B;AACvB,YAAMd,KAAK,CAAC,mBAAmBY,QAAnB,GAA8B,gFAA9B,GACR,8FADO,CAAX;AAEH;;AACD,QAAIG,aAAa,GAAG/D,GAAG,CAACmC,MAAD,EAAS,eAAT,CAAH,GACdA,MAAM,CAAC4B,aADO,GAEdxC,mBAAmB,CAACwC,aAF1B;AAGA,QAAIC,iBAAiB,GAAGhE,GAAG,CAACmC,MAAD,EAAS,mBAAT,CAAH,GAClBA,MAAM,CAAC6B,iBADW,GAElBzC,mBAAmB,CAACyC,iBAF1B,CARsE,CAWtE;AACA;;AACA;;AACA,QAAIC,SAAS,GAAG,KAAK1B,gBAAL,IACX9B,oBAAoB,GAAGC,uBAD5B;AAEA;;AACA,SAAK6B,gBAAL;AACA,SAAKF,mBAAL,CAAyB4B,SAAzB,IAAsCL,QAAtC;AACA,SAAKtB,mBAAL,CAAyBsB,QAAzB,IAAqCK,SAArC;;AACA,aAASC,iBAAT,CAA2BC,IAA3B,EAAiC;AAC7B,UAAI;AACA,YAAI,KAAKC,SAAL,KAAmB,IAAvB,EAA6B;AACzBP,UAAAA,IAAI,CAACQ,KAAL,CAAW,IAAX,EAAiBF,IAAjB;AACA,cAAIG,GAAG,GAAG,KAAKC,SAAL,CAAe,KAAKA,SAAL,CAAeC,MAAf,GAAwB,CAAvC,CAAV;AACA,eAAKC,WAAL,CAAiBH,GAAjB;AACA,iBAAOA,GAAP;AACH,SALD,MAMK;AACD,iBAAOT,IAAI,CAACQ,KAAL,CAAW,IAAX,EAAiBF,IAAjB,CAAP;AACH;AACJ,OAVD,CAWA,OAAOO,CAAP,EAAU;AACN,eAAO,KAAKC,eAAL,CAAqBD,CAArB,EAAwBX,aAAxB,EAAuCC,iBAAvC,CAAP;AACH,OAbD,SAcQ;AACJ,aAAKY,sBAAL;AACH;AACJ;;AACD,QAAIC,kBAAJ;;AACAA,IAAAA,kBAAkB,GAAG,UAAUC,gBAAV,EAA4BX,IAA5B,EAAkC;AACnD,UAAIW,gBAAgB,KAAK,KAAK,CAA9B,EAAiC;AAAEA,QAAAA,gBAAgB,GAAG,CAAnB;AAAuB;;AAC1D,WAAKC,yBAAL,CAA+Bd,SAA/B,EAA0CL,QAA1C,EAAoDkB,gBAApD;AACA,aAAOZ,iBAAiB,CAACc,IAAlB,CAAuB,IAAvB,EAA6Bb,IAA7B,CAAP;AACH,KAJD;;AAKA,QAAIc,gBAAgB,GAAG,UAAvB;AACAJ,IAAAA,kBAAkB,CAACI,gBAAD,CAAlB,GAAuCrB,QAAvC;AACAiB,IAAAA,kBAAkB,CAAC,uBAAD,CAAlB,GAA8ChB,IAA9C;AACA,WAAOgB,kBAAP;AACH,GAjDD;;AAkDA9C,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B2C,eAA3B,GAA6C,UAAUD,CAAV,EAAaQ,mBAAb,EAAkClB,iBAAlC,EAAqD;AAC9F,QAAImB,kBAAkB,GAAG,KAAKtC,UAAL,CAAgB2B,MAAhB,KAA2B,CAApD,CAD8F,CAE9F;AACA;AACA;AACA;;AACA,QAAIY,aAAa,GAAGF,mBAAmB,IACnC,CAAC,KAAKG,cAAL,EADe,IAEhB,KAAKC,eAFT;;AAGA,QAAIvE,sBAAsB,CAAC2D,CAAD,CAA1B,EAA+B;AAC3B,UAAIa,UAAU,GAAGb,CAAjB;;AACA,UAAIU,aAAJ,EAAmB;AACf,YAAII,aAAa,GAAG,KAAKC,mBAAL,EAApB;;AACA,YAAI,KAAKC,wBAAL,CAA8BF,aAA9B,CAAJ,EAAkD;AAC9CD,UAAAA,UAAU,CAACI,cAAX,GAA4B,KAAKC,QAAL,CAAcJ,aAAd,CAA5B;;AACA,cAAI,KAAKpB,SAAT,EAAoB;AAChB,gBAAIyB,gBAAgB,GAAG,KAAKtB,SAAL,CAAe,KAAKA,SAAL,CAAeC,MAAf,GAAwB,CAAvC,CAAvB;AACAqB,YAAAA,gBAAgB,CAACC,aAAjB,GAAiC,IAAjC;AACA,mBAAOD,gBAAP;AACH,WAJD,MAKK;AACD,mBAAO7B,iBAAiB,EAAxB;AACH;AACJ,SAVD,MAWK;AACD,cAAI,KAAKI,SAAT,EAAoB;AAChB,gBAAIyB,gBAAgB,GAAG,KAAKtB,SAAL,CAAe,KAAKA,SAAL,CAAeC,MAAf,GAAwB,CAAvC,CAAvB;AACAqB,YAAAA,gBAAgB,CAACC,aAAjB,GAAiC,IAAjC;AACAP,YAAAA,UAAU,CAACM,gBAAX,GAA8BA,gBAA9B;AACH,WALA,CAMD;;;AACA,gBAAMN,UAAN;AACH;AACJ,OAtBD,MAuBK,IAAIJ,kBAAJ,EAAwB;AACzB;AACA,aAAKY,qBAAL,GAFyB,CAGzB;AACA;;AACA,eAAO/B,iBAAiB,EAAxB;AACH,OANI,MAOA;AACD;AACA,cAAMuB,UAAN;AACH;AACJ,KApCD,MAqCK;AACD;AACA,YAAMb,CAAN;AACH;AACJ,GAlDD,CA3H8C,CA8K9C;;;AACA3C,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BgE,cAA3B,GAA4C,UAAUC,iBAAV,EAA6BC,UAA7B,EAAyC;AACjF,QAAIC,GAAG,GAAG,KAAKC,2BAAL,CAAiCvF,UAAjC,EAA6CqF,UAA7C,CAAV;AACA,QAAIG,UAAU,GAAG,KAAKC,sBAAL,CAA4BL,iBAA5B,EAA+CE,GAA/C,CAAjB;;AACA,QAAI;AACA,aAAO,KAAKI,mBAAL,CAAyBN,iBAAzB,EAA4CC,UAA5C,EAAwDC,GAAxD,CAAP;AACH,KAFD,SAGQ;AACJ,UAAIE,UAAU,KAAKG,SAAnB,EAA8B;AAC1B,aAAKC,uBAAL,CAA6BN,GAA7B,EAAkCE,UAAlC;AACH;AACJ;AACJ,GAXD;;AAYAtE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B0E,mBAA3B,GAAiD,UAAUT,iBAAV,EAA6BC,UAA7B,EAAyC;AACtF,QAAIC,GAAG,GAAG,KAAKC,2BAAL,CAAiCvF,UAAjC,EAA6CqF,UAA7C,CAAV;AACA,WAAO,KAAKK,mBAAL,CAAyBN,iBAAzB,EAA4CC,UAA5C,EAAwDC,GAAxD,CAAP;AACH,GAHD;;AAIApE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BuE,mBAA3B,GAAiD,UAAUN,iBAAV,EAA6BC,UAA7B,EAAyCC,GAAzC,EAA8C;AAC3F,QAAIQ,KAAK,GAAG,IAAZ;;AACA,QAAIC,aAAa,GAAG,KAAKC,kBAAL,CAAwBV,GAAxB,CAApB;AACA,QAAIW,MAAJ;AACA,QAAIC,SAAJ;;AACA,QAAId,iBAAiB,CAACe,GAAlB,KAA0BR,SAA9B,EAAyC;AACrCM,MAAAA,MAAM,GAAGb,iBAAiB,CAACe,GAA3B;AACAD,MAAAA,SAAS,GAAGd,iBAAiB,CAACgB,IAA9B,CAFqC,CAGrC;;AACA,UAAIF,SAAS,KAAKP,SAAlB,EAA6B;AACzB,YAAIU,sBAAsB,GAAGN,aAA7B;;AACAA,QAAAA,aAAa,GAAG,YAAY;AACxB,iBAAQG,SAAS,CAAC/B,IAAV,CAAe2B,KAAf,KAAyBO,sBAAsB,CAAClC,IAAvB,CAA4B2B,KAA5B,CAAjC;AACH,SAFD;AAGH;AACJ,KAVD,MAWK;AACDG,MAAAA,MAAM,GAAGb,iBAAT;AACH;;AACD,QAAIW,aAAa,CAAC5B,IAAd,CAAmB,IAAnB,MAA6B,IAAjC,EAAuC;AACnC,aAAO8B,MAAM,CAAC9B,IAAP,CAAY,IAAZ,CAAP;AACH;;AACD,WAAOwB,SAAP;AACH,GAvBD;;AAwBAzE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BmF,kBAA3B,GAAgD,UAAUC,cAAV,EAA0BnB,iBAA1B,EAA6C;AACzF,QAAIoB,KAAK,GAAG,KAAKjB,2BAAL,CAAiC7F,gBAAjC,EAAmD6G,cAAnD,CAAZ;AACA,QAAIf,UAAU,GAAG,KAAKC,sBAAL,CAA4BL,iBAA5B,EAA+CoB,KAA/C,CAAjB;;AACA,QAAI;AACA,aAAO,KAAKC,uBAAL,CAA6BF,cAA7B,EAA6CnB,iBAA7C,EAAgEoB,KAAhE,CAAP;AACH,KAFD,SAGQ;AACJ,UAAIhB,UAAU,KAAKG,SAAnB,EAA8B;AAC1B,aAAKC,uBAAL,CAA6BY,KAA7B,EAAoChB,UAApC;AACH;AACJ;AACJ,GAXD;;AAYAtE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BuF,uBAA3B,GAAqD,UAAUH,cAAV,EAA0BnB,iBAA1B,EAA6C;AAC9F,QAAIE,GAAG,GAAG,KAAKC,2BAAL,CAAiC7F,gBAAjC,EAAmD6G,cAAnD,CAAV;AACA,SAAKE,uBAAL,CAA6BF,cAA7B,EAA6CnB,iBAA7C,EAAgEE,GAAhE;AACH,GAHD;;AAIApE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BsF,uBAA3B,GAAqD,UAAUF,cAAV,EAA0BnB,iBAA1B,EAA6CE,GAA7C,EAAkD;AACnG,QAAIQ,KAAK,GAAG,IAAZ;;AACA,QAAIC,aAAa,GAAG,KAAKC,kBAAL,CAAwBV,GAAxB,CAApB;AACA,QAAIW,MAAJ;AACA,QAAIC,SAAJ;;AACA,QAAId,iBAAiB,CAACe,GAAlB,KAA0BR,SAA9B,EAAyC;AACrCM,MAAAA,MAAM,GAAGb,iBAAiB,CAACe,GAA3B;AACAD,MAAAA,SAAS,GAAGd,iBAAiB,CAACgB,IAA9B,CAFqC,CAGrC;;AACA,UAAIF,SAAS,KAAKP,SAAlB,EAA6B;AACzB,YAAIgB,sBAAsB,GAAGZ,aAA7B;;AACAA,QAAAA,aAAa,GAAG,YAAY;AACxB,iBAAQG,SAAS,CAAC/B,IAAV,CAAe2B,KAAf,KAAyBa,sBAAsB,CAACxC,IAAvB,CAA4B2B,KAA5B,CAAjC;AACH,SAFD;AAGH;AACJ,KAVD,MAWK;AACDG,MAAAA,MAAM,GAAGb,iBAAT;AACH;;AACD,QAAIW,aAAa,CAAC5B,IAAd,CAAmB,IAAnB,MAA6B,IAAjC,EAAuC;AACnC,UAAIyC,QAAQ,GAAG,KAAKC,kBAAL,CAAwBZ,MAAxB,CAAf;;AACA,aAAOF,aAAa,CAAC5B,IAAd,CAAmB,IAAnB,MAA6B,IAA7B,IACHyC,QAAQ,KAAK,IADjB,EACuB;AACnBA,QAAAA,QAAQ,GAAG,KAAKC,kBAAL,CAAwBZ,MAAxB,CAAX;AACH;AACJ,KAND,MAOK;AACD,YAAM,KAAKa,uBAAL,CAA6BP,cAA7B,EAA6ClG,SAAS,CAAC0G,oBAAvD,EAA6E3B,iBAAiB,CAAC4B,OAA/F,CAAN;AACH,KA5BkG,CA6BnG;AACA;AACA;AACA;;;AACA,SAAKC,2BAAL,CAAiC,KAAKX,kBAAtC,EAA0D,CAACC,cAAD,EAAiBnB,iBAAjB,CAA1D,EAA+FW,aAA/F,EAA8GrG,gBAA9G,EAAgI6G,cAAhI,EAAgJhG,iCAAhJ;AACH,GAlCD;;AAmCAW,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B+F,0BAA3B,GAAwD,UAAUX,cAAV,EAA0BY,OAA1B,EAAmC;AACvF,QAAIX,KAAK,GAAG,KAAKjB,2BAAL,CAAiC5F,oBAAjC,EAAuD4G,cAAvD,CAAZ;AACA,QAAIf,UAAU,GAAG,KAAKC,sBAAL,CAA4B0B,OAA5B,EAAqCX,KAArC,CAAjB;;AACA,QAAI;AACA,WAAKY,+BAAL,CAAqCb,cAArC,EAAqDY,OAArD,EAA8DX,KAA9D;AACH,KAFD,SAGQ;AACJ,UAAIhB,UAAU,KAAKG,SAAnB,EAA8B;AAC1B,aAAKC,uBAAL,CAA6BY,KAA7B,EAAoChB,UAApC;AACH;AACJ;AACJ,GAXD;;AAYAtE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BkG,+BAA3B,GAA6D,UAAUd,cAAV,EAA0BY,OAA1B,EAAmC;AAC5F,QAAIX,KAAK,GAAG,KAAKjB,2BAAL,CAAiC5F,oBAAjC,EAAuD4G,cAAvD,CAAZ;AACA,SAAKa,+BAAL,CAAqCb,cAArC,EAAqDY,OAArD,EAA8DX,KAA9D;AACH,GAHD;;AAIAtF,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BiG,+BAA3B,GAA6D,UAAUb,cAAV,EAA0BY,OAA1B,EAAmC7B,GAAnC,EAAwC;AACjG,QAAIQ,KAAK,GAAG,IAAZ;;AACA,QAAIG,MAAM,GAAGkB,OAAO,CAAChB,GAArB;AACA,QAAImB,SAAS,GAAGH,OAAO,CAACI,GAAxB;AACA,QAAIC,2BAA2B,GAAG,KAAKxB,kBAAL,CAAwBV,GAAxB,CAAlC,CAJiG,CAKjG;;AACA,QAAIkC,2BAA2B,CAACrD,IAA5B,CAAiC,IAAjC,MAA2C,IAA/C,EAAqD;AACjD;AACA8B,MAAAA,MAAM,CAAC9B,IAAP,CAAY,IAAZ,EAFiD,CAGjD;AACA;;AACA,UAAIsD,sBAAsB,GAAG,YAAY;AACrC,eAAO3B,KAAK,CAACnE,YAAN,CAAmBmE,KAAK,CAAC4B,EAAN,CAAS,CAAT,CAAnB,EAAgCJ,SAAhC,CAAP;AACH,OAFD,CALiD,CAQjD;;;AACA,aAAO,KAAK3F,YAAL,CAAkB,KAAK+F,EAAL,CAAQ,CAAR,CAAlB,EAA8BJ,SAA9B,MAA6C,IAApD,EAA0D;AACtD;AACA;AACA,aAAKK,OAAL,CAAaL,SAAb;AACArB,QAAAA,MAAM,CAAC9B,IAAP,CAAY,IAAZ;AACH,OAdgD,CAejD;;;AACA,WAAK8C,2BAAL,CAAiC,KAAKW,2BAAtC,EAAmE,CAC/DrB,cAD+D,EAE/De,SAF+D,EAG/DG,sBAH+D,EAI/DxB,MAJ+D,EAK/D3F,oCAL+D,CAAnE,EAMGmH,sBANH,EAM2B9H,oBAN3B,EAMiD4G,cANjD,EAMiEjG,oCANjE;AAOH,KAvBD,MAwBK;AACD,YAAM,KAAKwG,uBAAL,CAA6BP,cAA7B,EAA6ClG,SAAS,CAACwH,mCAAvD,EAA4FV,OAAO,CAACH,OAApG,CAAN;AACH;AACJ,GAjCD;;AAkCA9F,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B2G,YAA3B,GAA0C,UAAUvB,cAAV,EAA0BnB,iBAA1B,EAA6C;AACnF,QAAIoB,KAAK,GAAG,KAAKjB,2BAAL,CAAiCzF,QAAjC,EAA2CyG,cAA3C,CAAZ;AACA,QAAIf,UAAU,GAAG,KAAKC,sBAAL,CAA4BL,iBAA5B,EAA+CoB,KAA/C,CAAjB;;AACA,QAAI;AACA,aAAO,KAAKuB,iBAAL,CAAuBxB,cAAvB,EAAuCnB,iBAAvC,EAA0DoB,KAA1D,CAAP;AACH,KAFD,SAGQ;AACJ,UAAIhB,UAAU,KAAKG,SAAnB,EAA8B;AAC1B,aAAKC,uBAAL,CAA6BY,KAA7B,EAAoChB,UAApC;AACH;AACJ;AACJ,GAXD;;AAYAtE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B6G,iBAA3B,GAA+C,UAAUzB,cAAV,EAA0BnB,iBAA1B,EAA6C;AACxF,QAAIoB,KAAK,GAAG,KAAKjB,2BAAL,CAAiCzF,QAAjC,EAA2CyG,cAA3C,CAAZ;AACA,WAAO,KAAKwB,iBAAL,CAAuBxB,cAAvB,EAAuCnB,iBAAvC,EAA0DoB,KAA1D,CAAP;AACH,GAHD;;AAIAtF,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B4G,iBAA3B,GAA+C,UAAUxB,cAAV,EAA0BnB,iBAA1B,EAA6CE,GAA7C,EAAkD;AAC7F,QAAIQ,KAAK,GAAG,IAAZ;;AACA,QAAImC,iBAAiB,GAAG,KAAKjC,kBAAL,CAAwBV,GAAxB,CAAxB;AACA,QAAIW,MAAJ;AACA,QAAIC,SAAJ;;AACA,QAAId,iBAAiB,CAACe,GAAlB,KAA0BR,SAA9B,EAAyC;AACrCM,MAAAA,MAAM,GAAGb,iBAAiB,CAACe,GAA3B;AACAD,MAAAA,SAAS,GAAGd,iBAAiB,CAACgB,IAA9B,CAFqC,CAGrC;;AACA,UAAIF,SAAS,KAAKP,SAAlB,EAA6B;AACzB,YAAIuC,sBAAsB,GAAGD,iBAA7B;;AACAA,QAAAA,iBAAiB,GAAG,YAAY;AAC5B,iBAAQ/B,SAAS,CAAC/B,IAAV,CAAe2B,KAAf,KAAyBoC,sBAAsB,CAAC/D,IAAvB,CAA4B2B,KAA5B,CAAjC;AACH,SAFD;AAGH;AACJ,KAVD,MAWK;AACDG,MAAAA,MAAM,GAAGb,iBAAT;AACH;;AACD,QAAIwB,QAAQ,GAAG,IAAf;;AACA,WAAOqB,iBAAiB,CAAC9D,IAAlB,CAAuB,IAAvB,MAAiC,IAAjC,IAAyCyC,QAAQ,KAAK,IAA7D,EAAmE;AAC/DA,MAAAA,QAAQ,GAAG,KAAKC,kBAAL,CAAwBZ,MAAxB,CAAX;AACH,KAtB4F,CAuB7F;;;AACA,SAAKgB,2BAAL,CAAiC,KAAKa,YAAtC,EAAoD,CAACvB,cAAD,EAAiBnB,iBAAjB,CAApD,EAAyF6C,iBAAzF,EAA4GnI,QAA5G,EAAsHyG,cAAtH,EAAsI9F,2BAAtI,EACA;AACA;AACA;AACA;AACA;AACAmG,IAAAA,QANA;AAOH,GA/BD;;AAgCA1F,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BgH,oBAA3B,GAAkD,UAAU5B,cAAV,EAA0BY,OAA1B,EAAmC;AACjF,QAAIX,KAAK,GAAG,KAAKjB,2BAAL,CAAiCxF,YAAjC,EAA+CwG,cAA/C,CAAZ;AACA,QAAIf,UAAU,GAAG,KAAKC,sBAAL,CAA4B0B,OAA5B,EAAqCX,KAArC,CAAjB;;AACA,QAAI;AACA,WAAK4B,yBAAL,CAA+B7B,cAA/B,EAA+CY,OAA/C,EAAwDX,KAAxD;AACH,KAFD,SAGQ;AACJ,UAAIhB,UAAU,KAAKG,SAAnB,EAA8B;AAC1B,aAAKC,uBAAL,CAA6BY,KAA7B,EAAoChB,UAApC;AACH;AACJ;AACJ,GAXD;;AAYAtE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BkH,yBAA3B,GAAuD,UAAU9B,cAAV,EAA0BY,OAA1B,EAAmC;AACtF,QAAIX,KAAK,GAAG,KAAKjB,2BAAL,CAAiCxF,YAAjC,EAA+CwG,cAA/C,CAAZ;AACA,SAAK6B,yBAAL,CAA+B7B,cAA/B,EAA+CY,OAA/C,EAAwDX,KAAxD;AACH,GAHD;;AAIAtF,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BiH,yBAA3B,GAAuD,UAAU7B,cAAV,EAA0BY,OAA1B,EAAmC7B,GAAnC,EAAwC;AAC3F,QAAIQ,KAAK,GAAG,IAAZ;;AACA,QAAIG,MAAM,GAAGkB,OAAO,CAAChB,GAArB;AACA,QAAImB,SAAS,GAAGH,OAAO,CAACI,GAAxB;AACA,QAAIe,oBAAoB,GAAG,KAAKtC,kBAAL,CAAwBV,GAAxB,CAA3B,CAJ2F,CAK3F;;AACA,QAAIgD,oBAAoB,CAACnE,IAArB,CAA0B,IAA1B,MAAoC,IAAxC,EAA8C;AAC1C8B,MAAAA,MAAM,CAAC9B,IAAP,CAAY,IAAZ;;AACA,UAAIsD,sBAAsB,GAAG,YAAY;AACrC,eAAO3B,KAAK,CAACnE,YAAN,CAAmBmE,KAAK,CAAC4B,EAAN,CAAS,CAAT,CAAnB,EAAgCJ,SAAhC,CAAP;AACH,OAFD,CAF0C,CAK1C;;;AACA,aAAO,KAAK3F,YAAL,CAAkB,KAAK+F,EAAL,CAAQ,CAAR,CAAlB,EAA8BJ,SAA9B,MAA6C,IAApD,EAA0D;AACtD;AACA;AACA,aAAKK,OAAL,CAAaL,SAAb,EAHsD,CAItD;;AACArB,QAAAA,MAAM,CAAC9B,IAAP,CAAY,IAAZ;AACH,OAZyC,CAa1C;;;AACA,WAAK8C,2BAAL,CAAiC,KAAKW,2BAAtC,EAAmE,CAC/DrB,cAD+D,EAE/De,SAF+D,EAG/DG,sBAH+D,EAI/DxB,MAJ+D,EAK/DzF,8BAL+D,CAAnE,EAMGiH,sBANH,EAM2B1H,YAN3B,EAMyCwG,cANzC,EAMyD/F,8BANzD;AAOH;AACJ,GA5BD;;AA6BAU,EAAAA,gBAAgB,CAACC,SAAjB,CAA2ByG,2BAA3B,GAAyD,UAAUrB,cAAV,EAA0Be,SAA1B,EAAqCG,sBAArC,EAA6DxB,MAA7D,EAAqEsC,uBAArE,EAA8F;AACnJ,WAAOd,sBAAsB,EAA7B,EAAiC;AAC7B;AACA;AACA,WAAKE,OAAL,CAAaL,SAAb;AACArB,MAAAA,MAAM,CAAC9B,IAAP,CAAY,IAAZ;AACH,KANkJ,CAOnJ;AACA;AACA;AACA;AACA;;AACA;;;AACA,SAAK8C,2BAAL,CAAiC,KAAKW,2BAAtC,EAAmE,CAC/DrB,cAD+D,EAE/De,SAF+D,EAG/DG,sBAH+D,EAI/DxB,MAJ+D,EAK/DsC,uBAL+D,CAAnE,EAMGd,sBANH,EAM2B9H,oBAN3B,EAMiD4G,cANjD,EAMiEgC,uBANjE;AAOH,GApBD;;AAqBArH,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B0F,kBAA3B,GAAgD,UAAUZ,MAAV,EAAkB;AAC9D,QAAIuC,eAAe,GAAG,KAAKC,gBAAL,EAAtB;AACAxC,IAAAA,MAAM,CAAC9B,IAAP,CAAY,IAAZ;AACA,QAAIuE,cAAc,GAAG,KAAKD,gBAAL,EAArB,CAH8D,CAI9D;AACA;;AACA,WAAOC,cAAc,GAAGF,eAAxB;AACH,GAPD;;AAQAtH,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BwH,eAA3B,GAA6C,UAAUC,UAAV,EAAsBvD,UAAtB,EAAkC;AAC3E,QAAIwD,IAAI,GAAGzJ,OAAO,CAACwJ,UAAD,CAAP,GACLA,UADK,GAELA,UAAU,CAACzC,GAFjB;AAGA,QAAIK,KAAK,GAAG,KAAKjB,2BAAL,CAAiCtF,MAAjC,EAAyCoF,UAAzC,CAAZ;AACA,QAAIyD,MAAM,GAAG,KAAK9C,kBAAL,CAAwBQ,KAAxB,CAAb;AACA,QAAIuC,YAAY,GAAGD,MAAM,CAAC3E,IAAP,CAAY,IAAZ,EAAkB0E,IAAlB,CAAnB;;AACA,QAAIE,YAAY,KAAKpD,SAArB,EAAgC;AAC5B,UAAIqD,iBAAiB,GAAGH,IAAI,CAACE,YAAD,CAA5B;AACA,aAAOC,iBAAiB,CAACC,GAAlB,CAAsB9E,IAAtB,CAA2B,IAA3B,CAAP;AACH;;AACD,SAAK+E,mBAAL,CAAyB7D,UAAzB,EAAqCuD,UAAU,CAAC5B,OAAhD;AACH,GAZD;;AAaA9F,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BgI,UAA3B,GAAwC,UAAUP,UAAV,EAAsBvD,UAAtB,EAAkC;AACtE,QAAImB,KAAK,GAAG,KAAKjB,2BAAL,CAAiCtF,MAAjC,EAAyCoF,UAAzC,CAAZ;AACA,QAAIG,UAAU,GAAG,KAAKC,sBAAL,CAA4BmD,UAA5B,EAAwCpC,KAAxC,CAAjB;;AACA,QAAI;AACA,UAAIqC,IAAI,GAAGzJ,OAAO,CAACwJ,UAAD,CAAP,GACLA,UADK,GAELA,UAAU,CAACzC,GAFjB;AAGA,UAAI2C,MAAM,GAAG,KAAK9C,kBAAL,CAAwBQ,KAAxB,CAAb;AACA,UAAIuC,YAAY,GAAGD,MAAM,CAAC3E,IAAP,CAAY,IAAZ,EAAkB0E,IAAlB,CAAnB;;AACA,UAAIE,YAAY,KAAKpD,SAArB,EAAgC;AAC5B,YAAIqD,iBAAiB,GAAGH,IAAI,CAACE,YAAD,CAA5B;AACA,YAAIK,2BAA2B,GAAG,KAAKC,qBAAL,CAA2BL,iBAA3B,EAA8C3D,UAA9C,EAA0DpF,MAA1D,EAAkE8I,YAAlE,CAAlC;;AACA,YAAI;AACA,iBAAOC,iBAAiB,CAACC,GAAlB,CAAsB9E,IAAtB,CAA2B,IAA3B,CAAP;AACH,SAFD,SAGQ;AACJ,cAAIiF,2BAA2B,KAAKzD,SAApC,EAA+C;AAC3C,iBAAKC,uBAAL,CAA6BwD,2BAA2B,CAAChG,SAAzD,EAAoEgG,2BAA2B,CAAC5D,UAAhG;AACH;AACJ;AACJ;;AACD,WAAK0D,mBAAL,CAAyB7D,UAAzB,EAAqCuD,UAAU,CAAC5B,OAAhD;AACH,KAnBD,SAoBQ;AACJ,UAAIxB,UAAU,KAAKG,SAAnB,EAA8B;AAC1B,aAAKC,uBAAL,CAA6BY,KAA7B,EAAoChB,UAApC;AACH;AACJ;AACJ,GA5BD;;AA6BAtE,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B4C,sBAA3B,GAAoD,YAAY;AAC5D,SAAK/B,UAAL,CAAgBsH,GAAhB;AACA,SAAKrH,qBAAL,CAA2BqH,GAA3B,GAF4D,CAG5D;;AACA,SAAKC,qBAAL;;AACA,QAAI,KAAKvH,UAAL,CAAgB2B,MAAhB,KAA2B,CAA3B,IAAgC,KAAK6F,cAAL,OAA0B,KAA9D,EAAqE;AACjE,UAAIC,iBAAiB,GAAG,KAAK/B,EAAL,CAAQ,CAAR,CAAxB;AACA,UAAIgC,MAAM,GAAG,KAAKC,oBAAL,CAA0BC,6BAA1B,CAAwD;AACjEC,QAAAA,cAAc,EAAEJ,iBADiD;AAEjE1G,QAAAA,QAAQ,EAAE,KAAK+G,mBAAL;AAFuD,OAAxD,CAAb;AAIA,WAAKC,UAAL,CAAgB,IAAI3J,0BAAJ,CAA+BsJ,MAA/B,EAAuCD,iBAAvC,CAAhB;AACH;AACJ,GAbD;;AAcAvI,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B6I,eAA3B,GAA6C,UAAUC,UAAV,EAAsBC,GAAtB,EAA2B/C,OAA3B,EAAoC;AAC7E,QAAIgD,UAAJ;;AACA,QAAI;AACA,UAAI7G,IAAI,GAAG6D,OAAO,KAAKxB,SAAZ,GAAwBwB,OAAO,CAACiD,IAAhC,GAAuCzE,SAAlD;AACAwE,MAAAA,UAAU,GAAGF,UAAU,CAAC9F,IAAX,CAAgB,IAAhB,EAAsB+F,GAAtB,EAA2B5G,IAA3B,CAAb;AACA,WAAK+G,kBAAL,CAAwBF,UAAxB,EAAoChD,OAAO,KAAKxB,SAAZ,IAAyBwB,OAAO,CAACmD,KAAR,KAAkB3E,SAA3C,GAC9BwB,OAAO,CAACmD,KADsB,GAE9BL,UAAU,CAAClH,QAFjB;AAGA,aAAOoH,UAAP;AACH,KAPD,CAQA,OAAOtG,CAAP,EAAU;AACN,WAAK0G,oBAAL,CAA0B1G,CAA1B,EAA6BsD,OAA7B,EAAsC8C,UAAU,CAAClH,QAAjD;AACH;AACJ,GAbD;;AAcA7B,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BoJ,oBAA3B,GAAkD,UAAU1G,CAAV,EAAasD,OAAb,EAAsBpE,QAAtB,EAAgC;AAC9E,QAAI7C,sBAAsB,CAAC2D,CAAD,CAAtB,IAA6BA,CAAC,CAACmB,gBAAF,KAAuBW,SAAxD,EAAmE;AAC/D,WAAK0E,kBAAL,CAAwBxG,CAAC,CAACmB,gBAA1B,EAA4CmC,OAAO,KAAKxB,SAAZ,IAAyBwB,OAAO,CAACmD,KAAR,KAAkB3E,SAA3C,GACtCwB,OAAO,CAACmD,KAD8B,GAEtCvH,QAFN;AAGA,aAAOc,CAAC,CAACmB,gBAAT;AACH;;AACD,UAAMnB,CAAN;AACH,GARD;;AASA3C,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BqJ,eAA3B,GAA6C,UAAUlI,OAAV,EAAmB4H,GAAnB,EAAwB/C,OAAxB,EAAiC;AAC1E,QAAIsD,aAAJ;;AACA,QAAI;AACA,UAAIC,SAAS,GAAG,KAAKhD,EAAL,CAAQ,CAAR,CAAhB;;AACA,UAAI,KAAK/F,YAAL,CAAkB+I,SAAlB,EAA6BpI,OAA7B,MAA0C,IAA9C,EAAoD;AAChD,aAAKqI,YAAL;AACAF,QAAAA,aAAa,GAAGC,SAAhB;AACH,OAHD,MAIK;AACD,aAAKE,oBAAL,CAA0BtI,OAA1B,EAAmCoI,SAAnC,EAA8CvD,OAA9C;AACH;AACJ,KATD,CAUA,OAAO0D,gBAAP,EAAyB;AACrBJ,MAAAA,aAAa,GAAG,KAAKK,uBAAL,CAA6BxI,OAA7B,EAAsC4H,GAAtC,EAA2CW,gBAA3C,CAAhB;AACH;;AACD,SAAKE,eAAL,CAAqB5D,OAAO,KAAKxB,SAAZ,IAAyBwB,OAAO,CAACmD,KAAR,KAAkB3E,SAA3C,GACfwB,OAAO,CAACmD,KADO,GAEfhI,OAAO,CAACC,IAFd,EAEoBkI,aAFpB;AAGA,WAAOA,aAAP;AACH,GAnBD;;AAoBAvJ,EAAAA,gBAAgB,CAACC,SAAjB,CAA2ByJ,oBAA3B,GAAkD,UAAUtI,OAAV,EAAmBoI,SAAnB,EAA8BvD,OAA9B,EAAuC;AACrF,QAAI6D,GAAJ;AACA,QAAIC,aAAa,GAAG,KAAKvD,EAAL,CAAQ,CAAR,CAApB;;AACA,QAAIP,OAAO,KAAKxB,SAAZ,IAAyBwB,OAAO,CAACH,OAArC,EAA8C;AAC1CgE,MAAAA,GAAG,GAAG7D,OAAO,CAACH,OAAd;AACH,KAFD,MAGK;AACDgE,MAAAA,GAAG,GAAG,KAAKrB,oBAAL,CAA0BuB,yBAA1B,CAAoD;AACtDC,QAAAA,QAAQ,EAAE7I,OAD4C;AAEtD8I,QAAAA,MAAM,EAAEV,SAF8C;AAGtDW,QAAAA,QAAQ,EAAEJ,aAH4C;AAItDlI,QAAAA,QAAQ,EAAE,KAAK+G,mBAAL;AAJ4C,OAApD,CAAN;AAMH;;AACD,UAAM,KAAKC,UAAL,CAAgB,IAAI5J,wBAAJ,CAA6B6K,GAA7B,EAAkCN,SAAlC,EAA6CO,aAA7C,CAAhB,CAAN;AACH,GAfD;;AAgBA/J,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B2J,uBAA3B,GAAqD,UAAUxI,OAAV,EAAmB4H,GAAnB,EAAwBW,gBAAxB,EAA0C;AAC3F;AACA;AACA,QAAI,KAAKpG,eAAL,IACA;AACAoG,IAAAA,gBAAgB,CAACtI,IAAjB,KAA0B,0BAF1B,IAGA,CAAC,KAAKiC,cAAL,EAHL,EAG4B;AACxB,UAAI8G,OAAO,GAAG,KAAKC,2BAAL,CAAiCjJ,OAAjC,EAA0C4H,GAA1C,CAAd;;AACA,UAAI;AACA,eAAO,KAAKsB,iBAAL,CAAuBlJ,OAAvB,EAAgCgJ,OAAhC,CAAP;AACH,OAFD,CAGA,OAAOG,mBAAP,EAA4B;AACxB,YAAIA,mBAAmB,CAAClJ,IAApB,KAA6B5B,0BAAjC,EAA6D;AACzD;AACA;AACA,gBAAMkK,gBAAN;AACH,SAJD,MAKK;AACD,gBAAMY,mBAAN;AACH;AACJ;AACJ,KAlBD,MAmBK;AACD,YAAMZ,gBAAN;AACH;AACJ,GAzBD;;AA0BA3J,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BuK,cAA3B,GAA4C,YAAY;AACpD;AACA,QAAIC,WAAW,GAAG,KAAKC,MAAvB;AACA,QAAIC,cAAc,GAAG9M,QAAQ,CAAC,KAAKiD,UAAN,CAA7B;AACA,WAAO;AACH4J,MAAAA,MAAM,EAAED,WADL;AAEHG,MAAAA,UAAU,EAAE,KAAKC,gBAAL,EAFT;AAGH/J,MAAAA,UAAU,EAAE6J,cAHT;AAIHnI,MAAAA,SAAS,EAAE,KAAKA,SAJb;AAKHsI,MAAAA,wBAAwB,EAAE,KAAKA;AAL5B,KAAP;AAOH,GAXD;;AAYA9K,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B8K,gBAA3B,GAA8C,UAAUC,QAAV,EAAoB;AAC9D,SAAKN,MAAL,GAAcM,QAAQ,CAACN,MAAvB;AACA,SAAKO,gBAAL,CAAsBD,QAAQ,CAACJ,UAA/B;AACA,SAAK9J,UAAL,GAAkBkK,QAAQ,CAAClK,UAA3B;AACH,GAJD;;AAKAd,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B+C,yBAA3B,GAAuD,UAAUd,SAAV,EAAqBgJ,QAArB,EAA+BnI,gBAA/B,EAAiD;AACpG,SAAKhC,qBAAL,CAA2BoK,IAA3B,CAAgCpI,gBAAhC;AACA,SAAKjC,UAAL,CAAgBqK,IAAhB,CAAqBjJ,SAArB,EAFoG,CAGpG;;AACA,SAAKkJ,wBAAL,CAA8BF,QAA9B,EAAwChJ,SAAxC;AACH,GALD;;AAMAlC,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BqD,cAA3B,GAA4C,YAAY;AACpD,WAAO,KAAKzC,mBAAL,CAAyB4B,MAAzB,KAAoC,CAA3C;AACH,GAFD;;AAGAzC,EAAAA,gBAAgB,CAACC,SAAjB,CAA2B2I,mBAA3B,GAAiD,YAAY;AACzD,QAAI1G,SAAS,GAAG,KAAKmJ,4BAAL,EAAhB;AACA,WAAO,KAAK/K,mBAAL,CAAyB4B,SAAzB,CAAP;AACH,GAHD;;AAIAlC,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BqL,uBAA3B,GAAqD,UAAUpJ,SAAV,EAAqB;AACtE,WAAO,KAAK5B,mBAAL,CAAyB4B,SAAzB,CAAP;AACH,GAFD;;AAGAlC,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BqI,cAA3B,GAA4C,YAAY;AACpD,WAAO,KAAK7H,YAAL,CAAkB,KAAK+F,EAAL,CAAQ,CAAR,CAAlB,EAA8B9G,GAA9B,CAAP;AACH,GAFD;;AAGAM,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BsL,KAA3B,GAAmC,YAAY;AAC3C,SAAKC,eAAL;AACA,SAAK3K,mBAAL,GAA2B,EAA3B;AACA,SAAK6J,MAAL,GAAc,EAAd;AACA,SAAK5J,UAAL,GAAkB,EAAlB;AACA,SAAKgK,wBAAL,GAAgC,EAAhC,CAL2C,CAM3C;;AACA,SAAKtI,SAAL,GAAiB,EAAjB;AACA,SAAKzB,qBAAL,GAA6B,EAA7B;AACH,GATD;;AAUA,SAAOf,gBAAP;AACH,CAlnBqC,EAAtC;;AAmnBA,SAASA,gBAAT","sourcesContent":["import { cloneArr, cloneObj, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values } from \"../../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../../grammar/keys\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException } from \"../../exceptions_public\";\nimport { PROD_TYPE } from \"../../grammar/lookahead\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker } from \"../../grammar/interpreter\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\";\nimport { EOF } from \"../../../scan/tokens_public\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../../scan/tokens\";\nimport { classNameFromInstance } from \"../../../lang/lang_extensions\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */ (function () {\n    function RecognizerEngine() {\n    }\n    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n        this.className = classNameFromInstance(this);\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokenStructuredMatcherNoCategories;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.allRuleNames = [];\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if (has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if (isArray(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if (isEmpty(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if (isArray(tokenVocabulary)) {\n            this.tokensMap = reduce(tokenVocabulary, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (has(tokenVocabulary, \"modes\") &&\n            every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n            var allTokenTypes = flatten(values(tokenVocabulary.modes));\n            var uniqueTokens = uniq(allTokenTypes);\n            this.tokensMap = reduce(uniqueTokens, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (isObject(tokenVocabulary)) {\n            this.tokensMap = cloneObj(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        /* tslint:disable */\n        this.tokensMap[\"EOF\"] = EOF;\n        // TODO: This check may not be accurate for multi mode lexers\n        var noTokenCategoriesUsed = every(values(tokenVocabulary), function (tokenConstructor) { return isEmpty(tokenConstructor.categoryMatches); });\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokenStructuredMatcherNoCategories\n            : tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        augmentTokenTypes(values(this.tokensMap));\n    };\n    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" +\n                \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n        }\n        var resyncEnabled = has(config, \"resyncEnabled\")\n            ? config.resyncEnabled\n            : DEFAULT_RULE_CONFIG.resyncEnabled;\n        var recoveryValueFunc = has(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc\n            : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        /* tslint:disable */\n        var shortName = this.ruleShortNameIdx <<\n            (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n        /* tslint:enable */\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        function invokeRuleWithTry(args) {\n            try {\n                if (this.outputCst === true) {\n                    impl.apply(this, args);\n                    var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                else {\n                    return impl.apply(this, args);\n                }\n            }\n            catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n            }\n            finally {\n                this.ruleFinallyStateUpdate();\n            }\n        }\n        var wrappedGrammarRule;\n        wrappedGrammarRule = function (idxInCallingRule, args) {\n            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }\n            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n            return invokeRuleWithTry.call(this, args);\n        };\n        var ruleNamePropName = \"ruleName\";\n        wrappedGrammarRule[ruleNamePropName] = ruleName;\n        wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n        return wrappedGrammarRule;\n    };\n    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n        var isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        var reSyncEnabled = resyncEnabledConfig &&\n            !this.isBackTracking() &&\n            this.recoveryEnabled;\n        if (isRecognitionException(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n                var reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc();\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc();\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    };\n    // Implementation of parsing DSL\n    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, key);\n        try {\n            return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(key, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.optionInternalNoCst = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    };\n    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_1 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_1.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    };\n    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n        try {\n            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.atLeastOneInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n        var key = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key);\n    };\n    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_2 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_2.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(options, laKey);\n        try {\n            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalNoCst = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            ;\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterAtLeastOneSepWalker\n            ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    };\n    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n        try {\n            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.manyInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookaheadFunction = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_3 = lookaheadFunction;\n                lookaheadFunction = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_3.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        var notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    };\n    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(options, laKey);\n        try {\n            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.manySepFirstInternalNoCst = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterManySepWalker\n            ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n        }\n    };\n    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    };\n    RecognizerEngine.prototype.doSingleRepetition = function (action) {\n        var beforeIteration = this.getLexerPosition();\n        action.call(this);\n        var afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    };\n    RecognizerEngine.prototype.orInternalNoCst = function (altsOrOpts, occurrence) {\n        var alts = isArray(altsOrOpts)\n            ? altsOrOpts\n            : altsOrOpts.DEF;\n        var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        var laFunc = this.getLaFuncFromCache(laKey);\n        var altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    };\n    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n        var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        var nestedName = this.nestedRuleBeforeClause(altsOrOpts, laKey);\n        try {\n            var alts = isArray(altsOrOpts)\n                ? altsOrOpts\n                : altsOrOpts.DEF;\n            var laFunc = this.getLaFuncFromCache(laKey);\n            var altIdxToTake = laFunc.call(this, alts);\n            if (altIdxToTake !== undefined) {\n                var chosenAlternative = alts[altIdxToTake];\n                var nestedAltBeforeClauseResult = this.nestedAltBeforeClause(chosenAlternative, occurrence, OR_IDX, altIdxToTake);\n                try {\n                    return chosenAlternative.ALT.call(this);\n                }\n                finally {\n                    if (nestedAltBeforeClauseResult !== undefined) {\n                        this.nestedRuleFinallyClause(nestedAltBeforeClauseResult.shortName, nestedAltBeforeClauseResult.nestedName);\n                    }\n                }\n            }\n            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    };\n    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n        var ruleResult;\n        try {\n            var args = options !== undefined ? options.ARGS : undefined;\n            ruleResult = ruleToCall.call(this, idx, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    };\n    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n        if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    };\n    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n        var consumedToken;\n        try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    };\n    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n        var msg;\n        var previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n        }\n        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n    };\n    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    };\n    RecognizerEngine.prototype.saveRecogState = function () {\n        // errors is a getter which will clone the errors array\n        var savedErrors = this.errors;\n        var savedRuleStack = cloneArr(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK,\n            LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK\n        };\n    };\n    RecognizerEngine.prototype.reloadRecogState = function (newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    };\n    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName, shortName);\n    };\n    RecognizerEngine.prototype.isBackTracking = function () {\n        return this.isBackTrackingStack.length !== 0;\n    };\n    RecognizerEngine.prototype.getCurrRuleFullName = function () {\n        var shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.isAtEndOfInput = function () {\n        return this.tokenMatcher(this.LA(1), EOF);\n    };\n    RecognizerEngine.prototype.reset = function () {\n        this.resetLexerState();\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        this.LAST_EXPLICIT_RULE_STACK = [];\n        // TODO: extract a specific rest for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    };\n    return RecognizerEngine;\n}());\nexport { RecognizerEngine };\n//# sourceMappingURL=recognizer_engine.js.map"]},"metadata":{},"sourceType":"module"}