{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { AbsoluteCellRange } from '../AbsoluteCellRange';\nimport { CellError } from '../Cell';\nimport { ErroredMatrix, Matrix, MatrixSize, NotComputedMatrix } from '../Matrix';\nimport { ColumnsSpan, RowsSpan } from '../Span';\nexport var MatrixVertex = /*#__PURE__*/function () {\n  function MatrixVertex(cellAddress, width, height, formula) {\n    _classCallCheck(this, MatrixVertex);\n\n    this.cellAddress = cellAddress;\n    this.formula = formula || null;\n    this.matrix = new NotComputedMatrix(new MatrixSize(width, height));\n  }\n\n  _createClass(MatrixVertex, [{\n    key: \"width\",\n    get: function get() {\n      return this.matrix.width();\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.matrix.height();\n    }\n  }, {\n    key: \"sheet\",\n    get: function get() {\n      return this.cellAddress.sheet;\n    }\n  }, {\n    key: \"setCellValue\",\n    value: function setCellValue(matrix) {\n      this.matrix = matrix;\n    }\n  }, {\n    key: \"setErrorValue\",\n    value: function setErrorValue(error) {\n      this.matrix = new ErroredMatrix(error, this.matrix.size);\n    }\n  }, {\n    key: \"getCellValue\",\n    value: function getCellValue() {\n      if (this.matrix instanceof NotComputedMatrix) {\n        throw Error('Matrix not computed yet.');\n      }\n\n      return this.matrix;\n    }\n  }, {\n    key: \"getMatrixCellValue\",\n    value: function getMatrixCellValue(address) {\n      var col = address.col - this.cellAddress.col;\n      var row = address.row - this.cellAddress.row;\n      return this.matrix.get(col, row);\n    }\n  }, {\n    key: \"getMatrixCellRawValue\",\n    value: function getMatrixCellRawValue(address) {\n      var val = this.getMatrixCellValue(address);\n      return val instanceof CellError ? undefined : val;\n    }\n  }, {\n    key: \"setMatrixCellValue\",\n    value: function setMatrixCellValue(address, value) {\n      var col = address.col - this.cellAddress.col;\n      var row = address.row - this.cellAddress.row;\n\n      if (this.matrix instanceof Matrix) {\n        this.matrix.set(col, row, value);\n      }\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      return AbsoluteCellRange.spanFrom(this.cellAddress, this.width, this.height);\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return this.cellAddress;\n    }\n  }, {\n    key: \"setAddress\",\n    value: function setAddress(address) {\n      this.cellAddress = address;\n    }\n  }, {\n    key: \"getFormula\",\n    value: function getFormula() {\n      return this.formula;\n    }\n  }, {\n    key: \"setFormula\",\n    value: function setFormula(newFormula) {\n      this.formula = newFormula;\n    }\n  }, {\n    key: \"isFormula\",\n    value: function isFormula() {\n      return this.formula !== null;\n    }\n  }, {\n    key: \"isNumeric\",\n    value: function isNumeric() {\n      return this.formula === null;\n    }\n  }, {\n    key: \"spansThroughSheetRows\",\n    value: function spansThroughSheetRows(sheet, startRow) {\n      var endRow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startRow;\n      return this.cellAddress.sheet === sheet && this.cellAddress.row <= endRow && startRow < this.cellAddress.row + this.height;\n    }\n  }, {\n    key: \"spansThroughSheetColumn\",\n    value: function spansThroughSheetColumn(sheet, col) {\n      var columnEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : col;\n      return this.cellAddress.sheet === sheet && this.cellAddress.col <= columnEnd && col < this.cellAddress.col + this.width;\n    }\n  }, {\n    key: \"addRows\",\n    value: function addRows(sheet, row, numberOfRows) {\n      if (this.matrix instanceof Matrix) {\n        this.matrix.addRows(row - this.getAddress().row, numberOfRows);\n      }\n    }\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(sheet, column, numberOfColumns) {\n      if (this.matrix instanceof Matrix) {\n        this.matrix.addColumns(column - this.getAddress().col, numberOfColumns);\n      }\n    }\n  }, {\n    key: \"removeRows\",\n    value: function removeRows(removedRows) {\n      if (this.matrix instanceof Matrix) {\n        var removedRowsFromMatrix = this.rowsFromMatrix().intersect(removedRows);\n        this.matrix.removeRows(removedRowsFromMatrix.rowStart - this.getAddress().row, removedRowsFromMatrix.rowEnd - this.getAddress().row);\n      }\n    }\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(removedColumns) {\n      if (this.matrix instanceof Matrix) {\n        var removedColumnsFromMatrix = this.columnsFromMatrix().intersect(removedColumns);\n        this.matrix.removeColumns(removedColumnsFromMatrix.columnStart - this.getAddress().col, removedColumnsFromMatrix.columnEnd - this.getAddress().col);\n      }\n    }\n  }, {\n    key: \"isComputed\",\n    value: function isComputed() {\n      return !(this.matrix instanceof NotComputedMatrix);\n    }\n  }, {\n    key: \"columnsFromMatrix\",\n    value: function columnsFromMatrix() {\n      return ColumnsSpan.fromNumberOfColumns(this.cellAddress.sheet, this.cellAddress.col, this.width);\n    }\n  }, {\n    key: \"rowsFromMatrix\",\n    value: function rowsFromMatrix() {\n      return RowsSpan.fromNumberOfRows(this.cellAddress.sheet, this.cellAddress.row, this.height);\n    }\n  }], [{\n    key: \"fromRange\",\n    value: function fromRange(range, formula) {\n      return new MatrixVertex(range.start, range.width(), range.height(), formula);\n    }\n  }]);\n\n  return MatrixVertex;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/DependencyGraph/MatrixVertex.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","AbsoluteCellRange","CellError","ErroredMatrix","Matrix","MatrixSize","NotComputedMatrix","ColumnsSpan","RowsSpan","MatrixVertex","cellAddress","width","height","formula","matrix","get","sheet","value","setCellValue","setErrorValue","error","size","getCellValue","Error","getMatrixCellValue","address","col","row","getMatrixCellRawValue","val","undefined","setMatrixCellValue","set","getRange","spanFrom","getAddress","setAddress","getFormula","setFormula","newFormula","isFormula","isNumeric","spansThroughSheetRows","startRow","endRow","arguments","spansThroughSheetColumn","columnEnd","addRows","numberOfRows","addColumns","column","numberOfColumns","removeRows","removedRows","removedRowsFromMatrix","rowsFromMatrix","intersect","rowStart","rowEnd","removeColumns","removedColumns","removedColumnsFromMatrix","columnsFromMatrix","columnStart","isComputed","fromNumberOfColumns","fromNumberOfRows","fromRange","range","start"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AbsoluteCellRange } from '../AbsoluteCellRange';\nimport { CellError } from '../Cell';\nimport { ErroredMatrix, Matrix, MatrixSize, NotComputedMatrix } from '../Matrix';\nimport { ColumnsSpan, RowsSpan } from '../Span';\nexport var MatrixVertex = /*#__PURE__*/function () {\n  function MatrixVertex(cellAddress, width, height, formula) {\n    _classCallCheck(this, MatrixVertex);\n\n    this.cellAddress = cellAddress;\n    this.formula = formula || null;\n    this.matrix = new NotComputedMatrix(new MatrixSize(width, height));\n  }\n\n  _createClass(MatrixVertex, [{\n    key: \"width\",\n    get: function get() {\n      return this.matrix.width();\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.matrix.height();\n    }\n  }, {\n    key: \"sheet\",\n    get: function get() {\n      return this.cellAddress.sheet;\n    }\n  }, {\n    key: \"setCellValue\",\n    value: function setCellValue(matrix) {\n      this.matrix = matrix;\n    }\n  }, {\n    key: \"setErrorValue\",\n    value: function setErrorValue(error) {\n      this.matrix = new ErroredMatrix(error, this.matrix.size);\n    }\n  }, {\n    key: \"getCellValue\",\n    value: function getCellValue() {\n      if (this.matrix instanceof NotComputedMatrix) {\n        throw Error('Matrix not computed yet.');\n      }\n\n      return this.matrix;\n    }\n  }, {\n    key: \"getMatrixCellValue\",\n    value: function getMatrixCellValue(address) {\n      var col = address.col - this.cellAddress.col;\n      var row = address.row - this.cellAddress.row;\n      return this.matrix.get(col, row);\n    }\n  }, {\n    key: \"getMatrixCellRawValue\",\n    value: function getMatrixCellRawValue(address) {\n      var val = this.getMatrixCellValue(address);\n      return val instanceof CellError ? undefined : val;\n    }\n  }, {\n    key: \"setMatrixCellValue\",\n    value: function setMatrixCellValue(address, value) {\n      var col = address.col - this.cellAddress.col;\n      var row = address.row - this.cellAddress.row;\n\n      if (this.matrix instanceof Matrix) {\n        this.matrix.set(col, row, value);\n      }\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      return AbsoluteCellRange.spanFrom(this.cellAddress, this.width, this.height);\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return this.cellAddress;\n    }\n  }, {\n    key: \"setAddress\",\n    value: function setAddress(address) {\n      this.cellAddress = address;\n    }\n  }, {\n    key: \"getFormula\",\n    value: function getFormula() {\n      return this.formula;\n    }\n  }, {\n    key: \"setFormula\",\n    value: function setFormula(newFormula) {\n      this.formula = newFormula;\n    }\n  }, {\n    key: \"isFormula\",\n    value: function isFormula() {\n      return this.formula !== null;\n    }\n  }, {\n    key: \"isNumeric\",\n    value: function isNumeric() {\n      return this.formula === null;\n    }\n  }, {\n    key: \"spansThroughSheetRows\",\n    value: function spansThroughSheetRows(sheet, startRow) {\n      var endRow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startRow;\n      return this.cellAddress.sheet === sheet && this.cellAddress.row <= endRow && startRow < this.cellAddress.row + this.height;\n    }\n  }, {\n    key: \"spansThroughSheetColumn\",\n    value: function spansThroughSheetColumn(sheet, col) {\n      var columnEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : col;\n      return this.cellAddress.sheet === sheet && this.cellAddress.col <= columnEnd && col < this.cellAddress.col + this.width;\n    }\n  }, {\n    key: \"addRows\",\n    value: function addRows(sheet, row, numberOfRows) {\n      if (this.matrix instanceof Matrix) {\n        this.matrix.addRows(row - this.getAddress().row, numberOfRows);\n      }\n    }\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(sheet, column, numberOfColumns) {\n      if (this.matrix instanceof Matrix) {\n        this.matrix.addColumns(column - this.getAddress().col, numberOfColumns);\n      }\n    }\n  }, {\n    key: \"removeRows\",\n    value: function removeRows(removedRows) {\n      if (this.matrix instanceof Matrix) {\n        var removedRowsFromMatrix = this.rowsFromMatrix().intersect(removedRows);\n        this.matrix.removeRows(removedRowsFromMatrix.rowStart - this.getAddress().row, removedRowsFromMatrix.rowEnd - this.getAddress().row);\n      }\n    }\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(removedColumns) {\n      if (this.matrix instanceof Matrix) {\n        var removedColumnsFromMatrix = this.columnsFromMatrix().intersect(removedColumns);\n        this.matrix.removeColumns(removedColumnsFromMatrix.columnStart - this.getAddress().col, removedColumnsFromMatrix.columnEnd - this.getAddress().col);\n      }\n    }\n  }, {\n    key: \"isComputed\",\n    value: function isComputed() {\n      return !(this.matrix instanceof NotComputedMatrix);\n    }\n  }, {\n    key: \"columnsFromMatrix\",\n    value: function columnsFromMatrix() {\n      return ColumnsSpan.fromNumberOfColumns(this.cellAddress.sheet, this.cellAddress.col, this.width);\n    }\n  }, {\n    key: \"rowsFromMatrix\",\n    value: function rowsFromMatrix() {\n      return RowsSpan.fromNumberOfRows(this.cellAddress.sheet, this.cellAddress.row, this.height);\n    }\n  }], [{\n    key: \"fromRange\",\n    value: function fromRange(range, formula) {\n      return new MatrixVertex(range.start, range.width(), range.height(), formula);\n    }\n  }]);\n\n  return MatrixVertex;\n}();"]},"metadata":{},"sourceType":"module"}