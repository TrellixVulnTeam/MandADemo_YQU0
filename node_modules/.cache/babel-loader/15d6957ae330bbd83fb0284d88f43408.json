{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { AbsoluteCellRange } from '../../AbsoluteCellRange';\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { AstNodeType } from '../../parser';\nimport { coerceScalarToBoolean, coerceScalarToString, coerceToRange } from '../ArithmeticHelper';\nimport { getRawValue, isExtendedNumber } from '../InterpreterValue';\nimport { SimpleRangeValue } from '../SimpleRangeValue';\nexport var ArgumentTypes;\n\n(function (ArgumentTypes) {\n  /**\n   * String type.\n   */\n  ArgumentTypes[\"STRING\"] = \"STRING\";\n  /**\n   * Floating point type.\n   */\n\n  ArgumentTypes[\"NUMBER\"] = \"NUMBER\";\n  /**\n   * Boolean type.\n   */\n\n  ArgumentTypes[\"BOOLEAN\"] = \"BOOLEAN\";\n  /**\n   * Any non-range value.\n   */\n\n  ArgumentTypes[\"SCALAR\"] = \"SCALAR\";\n  /**\n   * Any non-range, no-error type.\n   */\n\n  ArgumentTypes[\"NOERROR\"] = \"NOERROR\";\n  /**\n   * Range type.\n   */\n\n  ArgumentTypes[\"RANGE\"] = \"RANGE\";\n  /**\n   * Integer type.\n   */\n\n  ArgumentTypes[\"INTEGER\"] = \"INTEGER\";\n  /**\n   * String representing complex number.\n   */\n\n  ArgumentTypes[\"COMPLEX\"] = \"COMPLEX\";\n  /**\n   * Range or scalar.\n   */\n\n  ArgumentTypes[\"ANY\"] = \"ANY\";\n})(ArgumentTypes || (ArgumentTypes = {}));\n/**\n * Abstract class representing interpreter function plugin.\n * Plugin may contain multiple functions. Each function should be of type {@link PluginFunctionType} and needs to be\n * included in {@link implementedFunctions}\n */\n\n\nexport var FunctionPlugin = /*#__PURE__*/function () {\n  function FunctionPlugin(interpreter) {\n    var _this = this;\n\n    _classCallCheck(this, FunctionPlugin);\n\n    this.coerceScalarToNumberOrError = function (arg) {\n      return _this.interpreter.arithmeticHelper.coerceScalarToNumberOrError(arg);\n    };\n\n    this.runFunction = function (args, formulaAddress, functionDefinition, fn) {\n      return _this.runFunctionTemplate(args, formulaAddress, functionDefinition, fn);\n    };\n\n    this.runMatrixFunction = function (args, formulaAddress, functionDefinition, fn) {\n      return _this.runFunctionTemplate(args, formulaAddress, functionDefinition, fn);\n    };\n\n    this.runFunctionTemplate = function (args, formulaAddress, functionDefinition, fn) {\n      var _a, _b, _c;\n\n      var argumentDefinitions = functionDefinition.parameters;\n      var scalarValues;\n\n      if (functionDefinition.expandRanges) {\n        scalarValues = _this.listOfScalarValues(args, formulaAddress);\n      } else {\n        scalarValues = args.map(function (ast) {\n          return [_this.evaluateAst(ast, formulaAddress), false];\n        });\n      }\n\n      var coercedArguments = [];\n      var argCoerceFailure = undefined;\n\n      if (functionDefinition.repeatLastArgs === undefined && argumentDefinitions.length < scalarValues.length) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n\n      if (functionDefinition.repeatLastArgs !== undefined && scalarValues.length > argumentDefinitions.length && (scalarValues.length - argumentDefinitions.length) % functionDefinition.repeatLastArgs !== 0) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n\n      for (var i = 0, j = 0; i < Math.max(scalarValues.length, argumentDefinitions.length); i++, j++) {\n        // i points to where are we in the scalarValues list,\n        // j points to where are we in the argumentDefinitions list\n        if (j === argumentDefinitions.length) {\n          j -= functionDefinition.repeatLastArgs;\n        }\n\n        var _ref = (_a = scalarValues[i]) !== null && _a !== void 0 ? _a : [undefined, undefined],\n            _ref2 = _slicedToArray(_ref, 2),\n            val = _ref2[0],\n            ignorable = _ref2[1];\n\n        var arg = val !== null && val !== void 0 ? val : (_b = argumentDefinitions[j]) === null || _b === void 0 ? void 0 : _b.defaultValue;\n\n        if (arg === undefined) {\n          if ((_c = argumentDefinitions[j]) === null || _c === void 0 ? void 0 : _c.optionalArg) {\n            coercedArguments.push(undefined);\n          } else {\n            //not enough values passed as arguments, and there was no default value and argument was not optional\n            return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n          }\n        } else {\n          //we apply coerce only to non-default values\n          var coercedArg = val !== undefined ? _this.coerceToType(arg, argumentDefinitions[j]) : arg;\n\n          if (coercedArg !== undefined) {\n            if (coercedArg instanceof CellError && argumentDefinitions[j].argumentType !== ArgumentTypes.SCALAR) {\n              //if this is first error encountered, store it\n              argCoerceFailure = argCoerceFailure !== null && argCoerceFailure !== void 0 ? argCoerceFailure : coercedArg;\n            }\n\n            coercedArguments.push(coercedArg);\n          } else if (!ignorable) {\n            //if this is first error encountered, store it\n            argCoerceFailure = argCoerceFailure !== null && argCoerceFailure !== void 0 ? argCoerceFailure : new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n          }\n        }\n      }\n\n      return argCoerceFailure !== null && argCoerceFailure !== void 0 ? argCoerceFailure : _this.returnNumberWrapper(fn.apply(void 0, coercedArguments), functionDefinition.returnNumberType);\n    };\n\n    this.runFunctionWithReferenceArgument = function (args, formulaAddress, argumentDefinitions, noArgCallback, referenceCallback) {\n      var nonReferenceCallback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function () {\n        return new CellError(ErrorType.NA, ErrorMessage.CellRefExpected);\n      };\n\n      if (args.length === 0) {\n        return _this.returnNumberWrapper(noArgCallback(), argumentDefinitions.returnNumberType);\n      } else if (args.length > 1) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n\n      var arg = args[0];\n\n      while (arg.type === AstNodeType.PARENTHESIS) {\n        arg = arg.expression;\n      }\n\n      var cellReference;\n\n      if (arg.type === AstNodeType.CELL_REFERENCE) {\n        cellReference = arg.reference.toSimpleCellAddress(formulaAddress);\n      } else if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {\n        try {\n          cellReference = AbsoluteCellRange.fromAst(arg, formulaAddress).start;\n        } catch (e) {\n          return new CellError(ErrorType.REF, ErrorMessage.CellRefExpected);\n        }\n      }\n\n      if (cellReference !== undefined) {\n        return _this.returnNumberWrapper(referenceCallback(cellReference), argumentDefinitions.returnNumberType);\n      }\n\n      return _this.runFunction(args, formulaAddress, argumentDefinitions, nonReferenceCallback);\n    };\n\n    this.interpreter = interpreter;\n    this.dependencyGraph = interpreter.dependencyGraph;\n    this.columnSearch = interpreter.columnSearch;\n    this.config = interpreter.config;\n    this.serialization = interpreter.serialization;\n  }\n\n  _createClass(FunctionPlugin, [{\n    key: \"evaluateAst\",\n    value: function evaluateAst(ast, formulaAddress) {\n      return this.interpreter.evaluateAst(ast, formulaAddress);\n    }\n  }, {\n    key: \"listOfScalarValues\",\n    value: function listOfScalarValues(asts, formulaAddress) {\n      var ret = [];\n\n      var _iterator = _createForOfIteratorHelper(asts),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var argAst = _step.value;\n          var value = this.evaluateAst(argAst, formulaAddress);\n\n          if (value instanceof SimpleRangeValue) {\n            var _iterator2 = _createForOfIteratorHelper(value.valuesFromTopLeftCorner()),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var scalarValue = _step2.value;\n                ret.push([scalarValue, true]);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          } else {\n            ret.push([value, false]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"coerceToType\",\n    value: function coerceToType(arg, coercedType) {\n      var ret;\n\n      if (arg instanceof SimpleRangeValue) {\n        switch (coercedType.argumentType) {\n          case ArgumentTypes.RANGE:\n          case ArgumentTypes.ANY:\n            ret = arg;\n            break;\n\n          default:\n            return undefined;\n        }\n      } else {\n        switch (coercedType.argumentType) {\n          case ArgumentTypes.INTEGER:\n          case ArgumentTypes.NUMBER:\n            // eslint-disable-next-line no-case-declarations\n            var coerced = this.coerceScalarToNumberOrError(arg);\n\n            if (!isExtendedNumber(coerced)) {\n              ret = coerced;\n              break;\n            } // eslint-disable-next-line no-case-declarations\n\n\n            var value = getRawValue(coerced);\n\n            if (coercedType.maxValue !== undefined && value > coercedType.maxValue) {\n              return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n            }\n\n            if (coercedType.minValue !== undefined && value < coercedType.minValue) {\n              return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n            }\n\n            if (coercedType.lessThan !== undefined && value >= coercedType.lessThan) {\n              return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n            }\n\n            if (coercedType.greaterThan !== undefined && value <= coercedType.greaterThan) {\n              return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n            }\n\n            if (coercedType.argumentType === ArgumentTypes.INTEGER && !Number.isInteger(value)) {\n              return new CellError(ErrorType.NUM, ErrorMessage.IntegerExpected);\n            }\n\n            ret = coerced;\n            break;\n\n          case ArgumentTypes.STRING:\n            ret = coerceScalarToString(arg);\n            break;\n\n          case ArgumentTypes.BOOLEAN:\n            ret = coerceScalarToBoolean(arg);\n            break;\n\n          case ArgumentTypes.SCALAR:\n          case ArgumentTypes.NOERROR:\n          case ArgumentTypes.ANY:\n            ret = arg;\n            break;\n\n          case ArgumentTypes.RANGE:\n            if (arg instanceof CellError) {\n              return arg;\n            }\n\n            ret = coerceToRange(getRawValue(arg));\n            break;\n\n          case ArgumentTypes.COMPLEX:\n            return this.interpreter.arithmeticHelper.coerceScalarToComplex(getRawValue(arg));\n        }\n      }\n\n      if (coercedType.passSubtype || ret === undefined) {\n        return ret;\n      } else {\n        return getRawValue(ret);\n      }\n    }\n  }, {\n    key: \"metadata\",\n    value: function metadata(name) {\n      var params = this.constructor.implementedFunctions[name];\n\n      if (params !== undefined) {\n        return params;\n      }\n\n      throw new Error(\"No metadata for function \".concat(name, \".\"));\n    }\n  }, {\n    key: \"returnNumberWrapper\",\n    value: function returnNumberWrapper(val, type, format) {\n      if (type !== undefined && isExtendedNumber(val)) {\n        return this.interpreter.arithmeticHelper.ExtendedNumberFactory(getRawValue(val), {\n          type: type,\n          format: format\n        });\n      } else {\n        return val;\n      }\n    }\n  }]);\n\n  return FunctionPlugin;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/interpreter/plugin/FunctionPlugin.js"],"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e2","f","TypeError","normalCompletion","didErr","err","call","step","next","_e3","return","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","minLen","_arrayLikeToArray","Object","prototype","toString","slice","constructor","name","from","test","len","arr2","_i","_arr","_n","_d","_s","_e","push","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","AbsoluteCellRange","CellError","ErrorType","ErrorMessage","AstNodeType","coerceScalarToBoolean","coerceScalarToString","coerceToRange","getRawValue","isExtendedNumber","SimpleRangeValue","ArgumentTypes","FunctionPlugin","interpreter","_this","coerceScalarToNumberOrError","arg","arithmeticHelper","runFunction","args","formulaAddress","functionDefinition","fn","runFunctionTemplate","runMatrixFunction","_a","_b","_c","argumentDefinitions","parameters","scalarValues","expandRanges","listOfScalarValues","map","ast","evaluateAst","coercedArguments","argCoerceFailure","undefined","repeatLastArgs","NA","WrongArgNumber","j","Math","max","_ref","_ref2","val","ignorable","defaultValue","optionalArg","coercedArg","coerceToType","argumentType","SCALAR","VALUE","WrongType","returnNumberWrapper","apply","returnNumberType","runFunctionWithReferenceArgument","noArgCallback","referenceCallback","nonReferenceCallback","arguments","CellRefExpected","type","PARENTHESIS","expression","cellReference","CELL_REFERENCE","reference","toSimpleCellAddress","CELL_RANGE","COLUMN_RANGE","ROW_RANGE","fromAst","start","REF","dependencyGraph","columnSearch","config","serialization","asts","ret","_iterator","_step","argAst","_iterator2","valuesFromTopLeftCorner","_step2","scalarValue","coercedType","RANGE","ANY","INTEGER","NUMBER","coerced","maxValue","NUM","ValueLarge","minValue","ValueSmall","lessThan","greaterThan","Number","isInteger","IntegerExpected","STRING","BOOLEAN","NOERROR","COMPLEX","coerceScalarToComplex","passSubtype","metadata","params","implementedFunctions","Error","concat","format","ExtendedNumberFactory"],"mappings":"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","sourcesContent":["function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AbsoluteCellRange } from '../../AbsoluteCellRange';\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { AstNodeType } from '../../parser';\nimport { coerceScalarToBoolean, coerceScalarToString, coerceToRange } from '../ArithmeticHelper';\nimport { getRawValue, isExtendedNumber } from '../InterpreterValue';\nimport { SimpleRangeValue } from '../SimpleRangeValue';\nexport var ArgumentTypes;\n\n(function (ArgumentTypes) {\n  /**\n   * String type.\n   */\n  ArgumentTypes[\"STRING\"] = \"STRING\";\n  /**\n   * Floating point type.\n   */\n\n  ArgumentTypes[\"NUMBER\"] = \"NUMBER\";\n  /**\n   * Boolean type.\n   */\n\n  ArgumentTypes[\"BOOLEAN\"] = \"BOOLEAN\";\n  /**\n   * Any non-range value.\n   */\n\n  ArgumentTypes[\"SCALAR\"] = \"SCALAR\";\n  /**\n   * Any non-range, no-error type.\n   */\n\n  ArgumentTypes[\"NOERROR\"] = \"NOERROR\";\n  /**\n   * Range type.\n   */\n\n  ArgumentTypes[\"RANGE\"] = \"RANGE\";\n  /**\n   * Integer type.\n   */\n\n  ArgumentTypes[\"INTEGER\"] = \"INTEGER\";\n  /**\n   * String representing complex number.\n   */\n\n  ArgumentTypes[\"COMPLEX\"] = \"COMPLEX\";\n  /**\n   * Range or scalar.\n   */\n\n  ArgumentTypes[\"ANY\"] = \"ANY\";\n})(ArgumentTypes || (ArgumentTypes = {}));\n/**\n * Abstract class representing interpreter function plugin.\n * Plugin may contain multiple functions. Each function should be of type {@link PluginFunctionType} and needs to be\n * included in {@link implementedFunctions}\n */\n\n\nexport var FunctionPlugin = /*#__PURE__*/function () {\n  function FunctionPlugin(interpreter) {\n    var _this = this;\n\n    _classCallCheck(this, FunctionPlugin);\n\n    this.coerceScalarToNumberOrError = function (arg) {\n      return _this.interpreter.arithmeticHelper.coerceScalarToNumberOrError(arg);\n    };\n\n    this.runFunction = function (args, formulaAddress, functionDefinition, fn) {\n      return _this.runFunctionTemplate(args, formulaAddress, functionDefinition, fn);\n    };\n\n    this.runMatrixFunction = function (args, formulaAddress, functionDefinition, fn) {\n      return _this.runFunctionTemplate(args, formulaAddress, functionDefinition, fn);\n    };\n\n    this.runFunctionTemplate = function (args, formulaAddress, functionDefinition, fn) {\n      var _a, _b, _c;\n\n      var argumentDefinitions = functionDefinition.parameters;\n      var scalarValues;\n\n      if (functionDefinition.expandRanges) {\n        scalarValues = _this.listOfScalarValues(args, formulaAddress);\n      } else {\n        scalarValues = args.map(function (ast) {\n          return [_this.evaluateAst(ast, formulaAddress), false];\n        });\n      }\n\n      var coercedArguments = [];\n      var argCoerceFailure = undefined;\n\n      if (functionDefinition.repeatLastArgs === undefined && argumentDefinitions.length < scalarValues.length) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n\n      if (functionDefinition.repeatLastArgs !== undefined && scalarValues.length > argumentDefinitions.length && (scalarValues.length - argumentDefinitions.length) % functionDefinition.repeatLastArgs !== 0) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n\n      for (var i = 0, j = 0; i < Math.max(scalarValues.length, argumentDefinitions.length); i++, j++) {\n        // i points to where are we in the scalarValues list,\n        // j points to where are we in the argumentDefinitions list\n        if (j === argumentDefinitions.length) {\n          j -= functionDefinition.repeatLastArgs;\n        }\n\n        var _ref = (_a = scalarValues[i]) !== null && _a !== void 0 ? _a : [undefined, undefined],\n            _ref2 = _slicedToArray(_ref, 2),\n            val = _ref2[0],\n            ignorable = _ref2[1];\n\n        var arg = val !== null && val !== void 0 ? val : (_b = argumentDefinitions[j]) === null || _b === void 0 ? void 0 : _b.defaultValue;\n\n        if (arg === undefined) {\n          if ((_c = argumentDefinitions[j]) === null || _c === void 0 ? void 0 : _c.optionalArg) {\n            coercedArguments.push(undefined);\n          } else {\n            //not enough values passed as arguments, and there was no default value and argument was not optional\n            return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n          }\n        } else {\n          //we apply coerce only to non-default values\n          var coercedArg = val !== undefined ? _this.coerceToType(arg, argumentDefinitions[j]) : arg;\n\n          if (coercedArg !== undefined) {\n            if (coercedArg instanceof CellError && argumentDefinitions[j].argumentType !== ArgumentTypes.SCALAR) {\n              //if this is first error encountered, store it\n              argCoerceFailure = argCoerceFailure !== null && argCoerceFailure !== void 0 ? argCoerceFailure : coercedArg;\n            }\n\n            coercedArguments.push(coercedArg);\n          } else if (!ignorable) {\n            //if this is first error encountered, store it\n            argCoerceFailure = argCoerceFailure !== null && argCoerceFailure !== void 0 ? argCoerceFailure : new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n          }\n        }\n      }\n\n      return argCoerceFailure !== null && argCoerceFailure !== void 0 ? argCoerceFailure : _this.returnNumberWrapper(fn.apply(void 0, coercedArguments), functionDefinition.returnNumberType);\n    };\n\n    this.runFunctionWithReferenceArgument = function (args, formulaAddress, argumentDefinitions, noArgCallback, referenceCallback) {\n      var nonReferenceCallback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function () {\n        return new CellError(ErrorType.NA, ErrorMessage.CellRefExpected);\n      };\n\n      if (args.length === 0) {\n        return _this.returnNumberWrapper(noArgCallback(), argumentDefinitions.returnNumberType);\n      } else if (args.length > 1) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n\n      var arg = args[0];\n\n      while (arg.type === AstNodeType.PARENTHESIS) {\n        arg = arg.expression;\n      }\n\n      var cellReference;\n\n      if (arg.type === AstNodeType.CELL_REFERENCE) {\n        cellReference = arg.reference.toSimpleCellAddress(formulaAddress);\n      } else if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {\n        try {\n          cellReference = AbsoluteCellRange.fromAst(arg, formulaAddress).start;\n        } catch (e) {\n          return new CellError(ErrorType.REF, ErrorMessage.CellRefExpected);\n        }\n      }\n\n      if (cellReference !== undefined) {\n        return _this.returnNumberWrapper(referenceCallback(cellReference), argumentDefinitions.returnNumberType);\n      }\n\n      return _this.runFunction(args, formulaAddress, argumentDefinitions, nonReferenceCallback);\n    };\n\n    this.interpreter = interpreter;\n    this.dependencyGraph = interpreter.dependencyGraph;\n    this.columnSearch = interpreter.columnSearch;\n    this.config = interpreter.config;\n    this.serialization = interpreter.serialization;\n  }\n\n  _createClass(FunctionPlugin, [{\n    key: \"evaluateAst\",\n    value: function evaluateAst(ast, formulaAddress) {\n      return this.interpreter.evaluateAst(ast, formulaAddress);\n    }\n  }, {\n    key: \"listOfScalarValues\",\n    value: function listOfScalarValues(asts, formulaAddress) {\n      var ret = [];\n\n      var _iterator = _createForOfIteratorHelper(asts),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var argAst = _step.value;\n          var value = this.evaluateAst(argAst, formulaAddress);\n\n          if (value instanceof SimpleRangeValue) {\n            var _iterator2 = _createForOfIteratorHelper(value.valuesFromTopLeftCorner()),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var scalarValue = _step2.value;\n                ret.push([scalarValue, true]);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          } else {\n            ret.push([value, false]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"coerceToType\",\n    value: function coerceToType(arg, coercedType) {\n      var ret;\n\n      if (arg instanceof SimpleRangeValue) {\n        switch (coercedType.argumentType) {\n          case ArgumentTypes.RANGE:\n          case ArgumentTypes.ANY:\n            ret = arg;\n            break;\n\n          default:\n            return undefined;\n        }\n      } else {\n        switch (coercedType.argumentType) {\n          case ArgumentTypes.INTEGER:\n          case ArgumentTypes.NUMBER:\n            // eslint-disable-next-line no-case-declarations\n            var coerced = this.coerceScalarToNumberOrError(arg);\n\n            if (!isExtendedNumber(coerced)) {\n              ret = coerced;\n              break;\n            } // eslint-disable-next-line no-case-declarations\n\n\n            var value = getRawValue(coerced);\n\n            if (coercedType.maxValue !== undefined && value > coercedType.maxValue) {\n              return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n            }\n\n            if (coercedType.minValue !== undefined && value < coercedType.minValue) {\n              return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n            }\n\n            if (coercedType.lessThan !== undefined && value >= coercedType.lessThan) {\n              return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n            }\n\n            if (coercedType.greaterThan !== undefined && value <= coercedType.greaterThan) {\n              return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n            }\n\n            if (coercedType.argumentType === ArgumentTypes.INTEGER && !Number.isInteger(value)) {\n              return new CellError(ErrorType.NUM, ErrorMessage.IntegerExpected);\n            }\n\n            ret = coerced;\n            break;\n\n          case ArgumentTypes.STRING:\n            ret = coerceScalarToString(arg);\n            break;\n\n          case ArgumentTypes.BOOLEAN:\n            ret = coerceScalarToBoolean(arg);\n            break;\n\n          case ArgumentTypes.SCALAR:\n          case ArgumentTypes.NOERROR:\n          case ArgumentTypes.ANY:\n            ret = arg;\n            break;\n\n          case ArgumentTypes.RANGE:\n            if (arg instanceof CellError) {\n              return arg;\n            }\n\n            ret = coerceToRange(getRawValue(arg));\n            break;\n\n          case ArgumentTypes.COMPLEX:\n            return this.interpreter.arithmeticHelper.coerceScalarToComplex(getRawValue(arg));\n        }\n      }\n\n      if (coercedType.passSubtype || ret === undefined) {\n        return ret;\n      } else {\n        return getRawValue(ret);\n      }\n    }\n  }, {\n    key: \"metadata\",\n    value: function metadata(name) {\n      var params = this.constructor.implementedFunctions[name];\n\n      if (params !== undefined) {\n        return params;\n      }\n\n      throw new Error(\"No metadata for function \".concat(name, \".\"));\n    }\n  }, {\n    key: \"returnNumberWrapper\",\n    value: function returnNumberWrapper(val, type, format) {\n      if (type !== undefined && isExtendedNumber(val)) {\n        return this.interpreter.arithmeticHelper.ExtendedNumberFactory(getRawValue(val), {\n          type: type,\n          format: format\n        });\n      } else {\n        return val;\n      }\n    }\n  }]);\n\n  return FunctionPlugin;\n}();"]},"metadata":{},"sourceType":"module"}