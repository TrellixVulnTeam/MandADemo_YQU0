{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AddressDependency, collectDependencies } from '../parser';\nimport { FormulaVertex } from './FormulaCellVertex';\nimport { RangeVertex } from './RangeVertex';\nexport var collectAddressesDependentToRange = function collectAddressesDependentToRange(funcitonRegistry, vertex, range, lazilyTransformingAstService, dependencyGraph) {\n  if (vertex instanceof RangeVertex) {\n    var intersection = vertex.range.intersectionWith(range);\n\n    if (intersection !== undefined) {\n      return Array.from(intersection.addresses(dependencyGraph));\n    } else {\n      return [];\n    }\n  }\n\n  var formula;\n  var address;\n\n  if (vertex instanceof FormulaVertex) {\n    formula = vertex.getFormula(lazilyTransformingAstService);\n    address = vertex.getAddress(lazilyTransformingAstService);\n  } else {\n    return [];\n  }\n\n  return collectDependencies(formula, funcitonRegistry).filter(function (d) {\n    return d instanceof AddressDependency;\n  }).map(function (d) {\n    return d.dependency.toSimpleCellAddress(address);\n  }).filter(function (d) {\n    return range.addressInRange(d);\n  });\n};","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/DependencyGraph/collectAddressesDependentToRange.js"],"names":["AddressDependency","collectDependencies","FormulaVertex","RangeVertex","collectAddressesDependentToRange","funcitonRegistry","vertex","range","lazilyTransformingAstService","dependencyGraph","intersection","intersectionWith","undefined","Array","from","addresses","formula","address","getFormula","getAddress","filter","d","map","dependency","toSimpleCellAddress","addressInRange"],"mappings":"AAKA;AACA;AACA;AACA;AACA,SAASA,iBAAT,EAA4BC,mBAA5B,QAAuD,WAAvD;AACA,SAASC,aAAT,QAA8B,qBAA9B;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,OAAO,IAAIC,gCAAgC,GAAG,SAASA,gCAAT,CAA0CC,gBAA1C,EAA4DC,MAA5D,EAAoEC,KAApE,EAA2EC,4BAA3E,EAAyGC,eAAzG,EAA0H;AACtK,MAAIH,MAAM,YAAYH,WAAtB,EAAmC;AACjC,QAAIO,YAAY,GAAGJ,MAAM,CAACC,KAAP,CAAaI,gBAAb,CAA8BJ,KAA9B,CAAnB;;AAEA,QAAIG,YAAY,KAAKE,SAArB,EAAgC;AAC9B,aAAOC,KAAK,CAACC,IAAN,CAAWJ,YAAY,CAACK,SAAb,CAAuBN,eAAvB,CAAX,CAAP;AACD,KAFD,MAEO;AACL,aAAO,EAAP;AACD;AACF;;AAED,MAAIO,OAAJ;AACA,MAAIC,OAAJ;;AAEA,MAAIX,MAAM,YAAYJ,aAAtB,EAAqC;AACnCc,IAAAA,OAAO,GAAGV,MAAM,CAACY,UAAP,CAAkBV,4BAAlB,CAAV;AACAS,IAAAA,OAAO,GAAGX,MAAM,CAACa,UAAP,CAAkBX,4BAAlB,CAAV;AACD,GAHD,MAGO;AACL,WAAO,EAAP;AACD;;AAED,SAAOP,mBAAmB,CAACe,OAAD,EAAUX,gBAAV,CAAnB,CAA+Ce,MAA/C,CAAsD,UAAUC,CAAV,EAAa;AACxE,WAAOA,CAAC,YAAYrB,iBAApB;AACD,GAFM,EAEJsB,GAFI,CAEA,UAAUD,CAAV,EAAa;AAClB,WAAOA,CAAC,CAACE,UAAF,CAAaC,mBAAb,CAAiCP,OAAjC,CAAP;AACD,GAJM,EAIJG,MAJI,CAIG,UAAUC,CAAV,EAAa;AACrB,WAAOd,KAAK,CAACkB,cAAN,CAAqBJ,CAArB,CAAP;AACD,GANM,CAAP;AAOD,CA5BM","sourcesContent":["import \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AddressDependency, collectDependencies } from '../parser';\nimport { FormulaVertex } from './FormulaCellVertex';\nimport { RangeVertex } from './RangeVertex';\nexport var collectAddressesDependentToRange = function collectAddressesDependentToRange(funcitonRegistry, vertex, range, lazilyTransformingAstService, dependencyGraph) {\n  if (vertex instanceof RangeVertex) {\n    var intersection = vertex.range.intersectionWith(range);\n\n    if (intersection !== undefined) {\n      return Array.from(intersection.addresses(dependencyGraph));\n    } else {\n      return [];\n    }\n  }\n\n  var formula;\n  var address;\n\n  if (vertex instanceof FormulaVertex) {\n    formula = vertex.getFormula(lazilyTransformingAstService);\n    address = vertex.getAddress(lazilyTransformingAstService);\n  } else {\n    return [];\n  }\n\n  return collectDependencies(formula, funcitonRegistry).filter(function (d) {\n    return d instanceof AddressDependency;\n  }).map(function (d) {\n    return d.dependency.toSimpleCellAddress(address);\n  }).filter(function (d) {\n    return range.addressInRange(d);\n  });\n};"]},"metadata":{},"sourceType":"module"}