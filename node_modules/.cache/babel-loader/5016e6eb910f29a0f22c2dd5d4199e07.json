{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { RestWalker } from \"./rest\";\nimport { cloneArr, drop, dropRight, first as _first, forEach, isEmpty, last } from \"../../utils/utils\";\nimport { first } from \"./first\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"./gast/gast_public\";\n\nvar AbstractNextPossibleTokensWalker = function (_super) {\n  __extends(AbstractNextPossibleTokensWalker, _super);\n\n  function AbstractNextPossibleTokensWalker(topProd, path) {\n    var _this = _super.call(this) || this;\n\n    _this.topProd = topProd;\n    _this.path = path;\n    _this.possibleTokTypes = [];\n    _this.nextProductionName = \"\";\n    _this.nextProductionOccurrence = 0;\n    _this.found = false;\n    _this.isAtEndOfPath = false;\n    return _this;\n  }\n\n  AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n    this.found = false;\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    } // immutable for the win\n\n\n    this.ruleStack = cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n\n    this.occurrenceStack = cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n    // already verified that the first production is valid, we now seek the 2nd production\n\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n    if (prevRest === void 0) {\n      prevRest = [];\n    } // stop scanning once we found the path\n\n\n    if (!this.found) {\n      _super.prototype.walk.call(this, prod, prevRest);\n    }\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n    // found the next production, need to keep walking in it\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      var fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  };\n\n  return AbstractNextPossibleTokensWalker;\n}(RestWalker);\n\nexport { AbstractNextPossibleTokensWalker };\n\nvar NextAfterTokenWalker = function (_super) {\n  __extends(NextAfterTokenWalker, _super);\n\n  function NextAfterTokenWalker(topProd, path) {\n    var _this = _super.call(this, topProd, path) || this;\n\n    _this.path = path;\n    _this.nextTerminalName = \"\";\n    _this.nextTerminalOccurrence = 0;\n    _this.nextTerminalName = _this.path.lastTok.name;\n    _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n    return _this;\n  }\n\n  NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      var fullRest = currRest.concat(prevRest);\n      var restProd = new Flat({\n        definition: fullRest\n      });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  };\n\n  return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker);\n\nexport { NextAfterTokenWalker };\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\n\nvar AbstractNextTerminalAfterProductionWalker = function (_super) {\n  __extends(AbstractNextTerminalAfterProductionWalker, _super);\n\n  function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n    var _this = _super.call(this) || this;\n\n    _this.topRule = topRule;\n    _this.occurrence = occurrence;\n    _this.result = {\n      token: undefined,\n      occurrence: undefined,\n      isEndOfRule: undefined\n    };\n    return _this;\n  }\n\n  AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n    this.walk(this.topRule);\n    return this.result;\n  };\n\n  return AbstractNextTerminalAfterProductionWalker;\n}(RestWalker);\n\nexport { AbstractNextTerminalAfterProductionWalker };\n\nvar NextTerminalAfterManyWalker = function (_super) {\n  __extends(NextTerminalAfterManyWalker, _super);\n\n  function NextTerminalAfterManyWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      var firstAfterMany = _first(currRest.concat(prevRest));\n\n      this.result.isEndOfRule = firstAfterMany === undefined;\n\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexport { NextTerminalAfterManyWalker };\n\nvar NextTerminalAfterManySepWalker = function (_super) {\n  __extends(NextTerminalAfterManySepWalker, _super);\n\n  function NextTerminalAfterManySepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      var firstAfterManySep = _first(currRest.concat(prevRest));\n\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexport { NextTerminalAfterManySepWalker };\n\nvar NextTerminalAfterAtLeastOneWalker = function (_super) {\n  __extends(NextTerminalAfterAtLeastOneWalker, _super);\n\n  function NextTerminalAfterAtLeastOneWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      var firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexport { NextTerminalAfterAtLeastOneWalker }; // TODO: reduce code duplication in the AfterWalkers\n\nvar NextTerminalAfterAtLeastOneSepWalker = function (_super) {\n  __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n\n  function NextTerminalAfterAtLeastOneSepWalker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      var firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexport { NextTerminalAfterAtLeastOneSepWalker };\nexport function possiblePathsFrom(targetDef, maxLength, currPath) {\n  if (currPath === void 0) {\n    currPath = [];\n  } // avoid side effects\n\n\n  currPath = cloneArr(currPath);\n  var result = [];\n  var i = 0; // TODO: avoid inner funcs\n\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  } // TODO: avoid inner funcs\n\n\n  function getAlternativesForProd(definition) {\n    var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n\n\n  while (currPath.length < maxLength && i < targetDef.length) {\n    var prod = targetDef[i];\n    /* istanbul ignore else */\n\n    if (prod instanceof Flat) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      var newDef = [new Flat({\n        definition: prod.definition\n      }), new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      var newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, function (currAlt) {\n        result = getAlternativesForProd(currAlt.definition);\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n\n    i++;\n  }\n\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  });\n  return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\"; // to avoid creating a new Array each time.\n\n  var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  var foundCompletePath = false;\n  var tokenVectorLength = tokenVector.length;\n  var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  var result = [];\n  var possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n\n  while (!isEmpty(possiblePaths)) {\n    var currPath = possiblePaths.pop(); // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n\n      continue;\n    }\n\n    var currDef = currPath.def;\n    var currIdx = currPath.idx;\n    var currRuleStack = currPath.ruleStack;\n    var currOccurrenceStack = currPath.occurrenceStack; // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n\n    if (isEmpty(currDef)) {\n      continue;\n    }\n\n    var prod = currDef[0];\n    /* istanbul ignore else */\n\n    if (prod === EXIT_NON_TERMINAL) {\n      var nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        var nextIdx = currIdx + 1;\n        var actualToken = tokenVector[nextIdx];\n\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          var nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        } // end of the line\n\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      var newRuleStack = cloneArr(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      var newOccurrenceStack = cloneArr(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      var nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      var secondIteration = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      var nthRepetition = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE); // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n\n      var nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (var i = prod.definition.length - 1; i >= 0; i--) {\n        var currAlt = prod.definition[i];\n        var currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Flat) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n\n  return result;\n}\n\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  var newRuleStack = cloneArr(currRuleStack);\n  newRuleStack.push(topRule.name);\n  var newCurrOccurrenceStack = cloneArr(currOccurrenceStack); // top rule is always assumed to have been called with occurrence index 1\n\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","RestWalker","cloneArr","drop","dropRight","first","_first","forEach","isEmpty","last","Alternation","Flat","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Rule","Terminal","AbstractNextPossibleTokensWalker","_super","topProd","path","_this","call","possibleTokTypes","nextProductionName","nextProductionOccurrence","found","isAtEndOfPath","startWalking","ruleStack","name","Error","reverse","occurrenceStack","pop","updateExpectedNext","walk","prod","prevRest","walkProdRef","refProd","currRest","referencedRule","idx","fullRest","concat","NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","walkTerminal","terminal","terminalType","restProd","definition","AbstractNextTerminalAfterProductionWalker","topRule","occurrence","result","token","undefined","isEndOfRule","NextTerminalAfterManyWalker","apply","arguments","walkMany","manyProd","firstAfterMany","NextTerminalAfterManySepWalker","walkManySep","manySepProd","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","walkAtLeastOne","atLeastOneProd","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","walkAtLeastOneSep","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","currPath","i","remainingPathWith","nextDef","getAlternativesForProd","alternatives","length","newDef","separator","currAlt","push","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokenVector","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currIdx","currRuleStack","currOccurrenceStack","nextPath","nextIdx","actualToken","nextTokenType","nextTokenOccurrence","newRuleStack","nonTerminalName","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { RestWalker } from \"./rest\";\nimport { cloneArr, drop, dropRight, first as _first, forEach, isEmpty, last } from \"../../utils/utils\";\nimport { first } from \"./first\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"./gast/gast_public\";\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextPossibleTokensWalker, _super);\n    function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.path = path;\n        _this.possibleTokTypes = [];\n        _this.nextProductionName = \"\";\n        _this.nextProductionOccurrence = 0;\n        _this.found = false;\n        _this.isAtEndOfPath = false;\n        return _this;\n    }\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    };\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n        if (prevRest === void 0) { prevRest = []; }\n        // stop scanning once we found the path\n        if (!this.found) {\n            _super.prototype.walk.call(this, prod, prevRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n        // need to consume the Terminal\n        if (isEmpty(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    };\n    return AbstractNextPossibleTokensWalker;\n}(RestWalker));\nexport { AbstractNextPossibleTokensWalker };\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\n    __extends(NextAfterTokenWalker, _super);\n    function NextAfterTokenWalker(topProd, path) {\n        var _this = _super.call(this, topProd, path) || this;\n        _this.path = path;\n        _this.nextTerminalName = \"\";\n        _this.nextTerminalOccurrence = 0;\n        _this.nextTerminalName = _this.path.lastTok.name;\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n        return _this;\n    }\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new Flat({ definition: fullRest });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n        }\n    };\n    return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker));\nexport { NextAfterTokenWalker };\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this = _super.call(this) || this;\n        _this.topRule = topRule;\n        _this.occurrence = occurrence;\n        _this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined\n        };\n        return _this;\n    }\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n        this.walk(this.topRule);\n        return this.result;\n    };\n    return AbstractNextTerminalAfterProductionWalker;\n}(RestWalker));\nexport { AbstractNextTerminalAfterProductionWalker };\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManyWalker, _super);\n    function NextTerminalAfterManyWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterManyWalker };\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManySepWalker, _super);\n    function NextTerminalAfterManySepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterManySepWalker };\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\n    function NextTerminalAfterAtLeastOneWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterAtLeastOneWalker };\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n    function NextTerminalAfterAtLeastOneSepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule =\n                firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n                this.result.token =\n                    firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexport { NextTerminalAfterAtLeastOneSepWalker };\nexport function possiblePathsFrom(targetDef, maxLength, currPath) {\n    if (currPath === void 0) { currPath = []; }\n    // avoid side effects\n    currPath = cloneArr(currPath);\n    var result = [];\n    var i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof Flat) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            var newDef = [\n                new Flat({ definition: prod.definition }),\n                new Repetition({\n                    definition: [\n                        new Terminal({ terminalType: prod.separator })\n                    ].concat(prod.definition)\n                })\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: [\n                        new Terminal({ terminalType: prod.separator })\n                    ].concat(prod.definition)\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Repetition) {\n            var newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Alternation) {\n            forEach(prod.definition, function (currAlt) {\n                result = getAlternativesForProd(currAlt.definition);\n            });\n            return result;\n        }\n        else if (prod instanceof Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i)\n    });\n    return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    var foundCompletePath = false;\n    var tokenVectorLength = tokenVector.length;\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    var result = [];\n    var possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n    });\n    while (!isEmpty(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                last(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (isEmpty(currDef)) {\n            continue;\n        }\n        var prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            var nextPath = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: dropRight(currRuleStack),\n                occurrenceStack: dropRight(currOccurrenceStack)\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                var nextIdx = currIdx + 1;\n                var actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    var nextPath = {\n                        idx: nextIdx,\n                        def: drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof NonTerminal) {\n            var newRuleStack = cloneArr(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            var newOccurrenceStack = cloneArr(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            var nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var secondIteration = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var separatorGast = new Terminal({\n                terminalType: prod.separator\n            });\n            var secondIteration = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var separatorGast = new Terminal({\n                terminalType: prod.separator\n            });\n            var nthRepetition = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            var nthRepetition = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\n                var currAlt = prod.definition[i];\n                var currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof Flat) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            });\n        }\n        else if (prod instanceof Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    var newRuleStack = cloneArr(currRuleStack);\n    newRuleStack.push(topRule.name);\n    var newCurrOccurrenceStack = cloneArr(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n    };\n}\n//# sourceMappingURL=interpreter.js.map"]},"metadata":{},"sourceType":"module"}