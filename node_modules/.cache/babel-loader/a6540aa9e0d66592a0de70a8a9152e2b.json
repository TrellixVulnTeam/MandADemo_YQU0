{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { tokenMatcher } from 'chevrotain';\nimport { ErrorType } from '../Cell';\nimport { AstNodeType, buildParsingErrorAst } from './';\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from './addressRepresentationConverters';\nimport { imageWithWhitespace, ParsingErrorType, RangeSheetReferenceType } from './Ast';\nimport { binaryOpTokenMap } from './binaryOpTokenMap';\nimport { Cache } from './Cache';\nimport { FormulaLexer, FormulaParser } from './FormulaParser';\nimport { buildLexerConfig, CellReference, ColumnRange, ProcedureName, RowRange, WhiteSpace } from './LexerConfig';\nimport { formatNumber } from './Unparser';\n/**\n * Parses formula using caching if feasible.\n */\n\nexport var ParserWithCaching = /*#__PURE__*/function () {\n  function ParserWithCaching(config, functionRegistry, sheetMapping) {\n    _classCallCheck(this, ParserWithCaching);\n\n    this.config = config;\n    this.functionRegistry = functionRegistry;\n    this.sheetMapping = sheetMapping;\n    this.statsCacheUsed = 0;\n    this.lexerConfig = buildLexerConfig(config);\n    this.lexer = new FormulaLexer(this.lexerConfig);\n    this.formulaParser = new FormulaParser(this.lexerConfig, this.sheetMapping);\n    this.cache = new Cache(this.functionRegistry);\n  }\n  /**\n   * Parses a formula.\n   *\n   * @param text - formula to parse\n   * @param formulaAddress - address with regard to which formula should be parsed. Impacts computed addresses in R0C0 format.\n   */\n\n\n  _createClass(ParserWithCaching, [{\n    key: \"parse\",\n    value: function parse(text, formulaAddress) {\n      var lexerResult = this.lexer.tokenizeFormula(text);\n\n      if (lexerResult.errors.length > 0) {\n        var errors = lexerResult.errors.map(function (e) {\n          return {\n            type: ParsingErrorType.LexingError,\n            message: e.message\n          };\n        });\n        return {\n          ast: buildParsingErrorAst(),\n          errors: errors,\n          hasVolatileFunction: false,\n          hasStructuralChangeFunction: false,\n          dependencies: []\n        };\n      }\n\n      var hash = this.computeHashFromTokens(lexerResult.tokens, formulaAddress);\n      var cacheResult = this.cache.get(hash);\n\n      if (cacheResult !== undefined) {\n        ++this.statsCacheUsed;\n      } else {\n        var processedTokens = bindWhitespacesToTokens(lexerResult.tokens);\n        var parsingResult = this.formulaParser.parseFromTokens(processedTokens, formulaAddress);\n\n        if (parsingResult.errors.length > 0) {\n          return Object.assign(Object.assign({}, parsingResult), {\n            hasVolatileFunction: false,\n            hasStructuralChangeFunction: false,\n            dependencies: []\n          });\n        } else {\n          cacheResult = this.cache.set(hash, parsingResult.ast);\n        }\n      }\n\n      var _cacheResult = cacheResult,\n          ast = _cacheResult.ast,\n          hasVolatileFunction = _cacheResult.hasVolatileFunction,\n          hasStructuralChangeFunction = _cacheResult.hasStructuralChangeFunction,\n          relativeDependencies = _cacheResult.relativeDependencies;\n      return {\n        ast: ast,\n        errors: [],\n        hasVolatileFunction: hasVolatileFunction,\n        hasStructuralChangeFunction: hasStructuralChangeFunction,\n        dependencies: relativeDependencies\n      };\n    }\n  }, {\n    key: \"fetchCachedResultForAst\",\n    value: function fetchCachedResultForAst(ast) {\n      var hash = this.computeHashFromAst(ast);\n      return this.fetchCachedResult(hash);\n    }\n  }, {\n    key: \"fetchCachedResult\",\n    value: function fetchCachedResult(hash) {\n      var cacheResult = this.cache.get(hash);\n\n      if (cacheResult === undefined) {\n        throw new Error('There is no AST with such key in the cache');\n      } else {\n        var ast = cacheResult.ast,\n            hasVolatileFunction = cacheResult.hasVolatileFunction,\n            hasStructuralChangeFunction = cacheResult.hasStructuralChangeFunction,\n            relativeDependencies = cacheResult.relativeDependencies;\n        return {\n          ast: ast,\n          errors: [],\n          hasVolatileFunction: hasVolatileFunction,\n          hasStructuralChangeFunction: hasStructuralChangeFunction,\n          dependencies: relativeDependencies\n        };\n      }\n    }\n  }, {\n    key: \"computeHashFromTokens\",\n    value: function computeHashFromTokens(tokens, baseAddress) {\n      var _a;\n\n      var hash = '';\n      var idx = 0;\n\n      while (idx < tokens.length) {\n        var token = tokens[idx];\n\n        if (tokenMatcher(token, CellReference)) {\n          var cellAddress = cellAddressFromString(this.sheetMapping, token.image, baseAddress);\n\n          if (cellAddress === undefined) {\n            hash = hash.concat(token.image);\n          } else {\n            hash = hash.concat(cellAddress.hash(true));\n          }\n        } else if (tokenMatcher(token, ProcedureName)) {\n          var procedureName = token.image.toUpperCase().slice(0, -1);\n          var canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n          hash = hash.concat(canonicalProcedureName, '(');\n        } else if (tokenMatcher(token, ColumnRange)) {\n          var _token$image$split = token.image.split(':'),\n              _token$image$split2 = _slicedToArray(_token$image$split, 2),\n              start = _token$image$split2[0],\n              end = _token$image$split2[1];\n\n          var startAddress = columnAddressFromString(this.sheetMapping, start, baseAddress);\n          var endAddress = columnAddressFromString(this.sheetMapping, end, baseAddress);\n\n          if (startAddress === undefined || endAddress === undefined) {\n            hash = hash.concat('!REF');\n          } else {\n            hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));\n          }\n        } else if (tokenMatcher(token, RowRange)) {\n          var _token$image$split3 = token.image.split(':'),\n              _token$image$split4 = _slicedToArray(_token$image$split3, 2),\n              _start = _token$image$split4[0],\n              _end = _token$image$split4[1];\n\n          var _startAddress = rowAddressFromString(this.sheetMapping, _start, baseAddress);\n\n          var _endAddress = rowAddressFromString(this.sheetMapping, _end, baseAddress);\n\n          if (_startAddress === undefined || _endAddress === undefined) {\n            hash = hash.concat('!REF');\n          } else {\n            hash = hash.concat(_startAddress.hash(true), ':', _endAddress.hash(true));\n          }\n        } else {\n          hash = hash.concat(token.image);\n        }\n\n        idx++;\n      }\n\n      return hash;\n    }\n  }, {\n    key: \"rememberNewAst\",\n    value: function rememberNewAst(ast) {\n      var hash = this.computeHashFromAst(ast);\n      return this.cache.maybeSetAndThenGet(hash, ast);\n    }\n  }, {\n    key: \"computeHashFromAst\",\n    value: function computeHashFromAst(ast) {\n      return '=' + this.computeHashOfAstNode(ast);\n    }\n  }, {\n    key: \"computeHashOfAstNode\",\n    value: function computeHashOfAstNode(ast) {\n      var _this = this;\n\n      switch (ast.type) {\n        case AstNodeType.EMPTY:\n          {\n            return ast.leadingWhitespace || '';\n          }\n\n        case AstNodeType.NUMBER:\n          {\n            return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.STRING:\n          {\n            return imageWithWhitespace('\"' + ast.value + '\"', ast.leadingWhitespace);\n          }\n\n        case AstNodeType.NAMED_EXPRESSION:\n          {\n            return imageWithWhitespace(ast.expressionName, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.FUNCTION_CALL:\n          {\n            var args = ast.args.map(function (arg) {\n              return _this.computeHashOfAstNode(arg);\n            }).join(this.config.functionArgSeparator);\n            var rightPart = ast.procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);\n            return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.CELL_REFERENCE:\n          {\n            return imageWithWhitespace(ast.reference.hash(true), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.COLUMN_RANGE:\n        case AstNodeType.ROW_RANGE:\n        case AstNodeType.CELL_RANGE:\n          {\n            var start = ast.start.hash(ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE);\n            var end = ast.end.hash(ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE);\n            return imageWithWhitespace(start + ':' + end, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.MINUS_UNARY_OP:\n          {\n            return imageWithWhitespace('-' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.PLUS_UNARY_OP:\n          {\n            return imageWithWhitespace('+' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.PERCENT_OP:\n          {\n            return this.computeHashOfAstNode(ast.value) + imageWithWhitespace('%', ast.leadingWhitespace);\n          }\n\n        case AstNodeType.ERROR:\n          {\n            var image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);\n            return imageWithWhitespace(image, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.ERROR_WITH_RAW_INPUT:\n          {\n            return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.ARRAY:\n          {\n            var _args = ast.args.map(function (row) {\n              return row.map(function (val) {\n                return _this.computeHashOfAstNode(val);\n              }).join(',');\n            }).join(';');\n\n            return imageWithWhitespace('{' + _args + imageWithWhitespace('}', ast.internalWhitespace), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.PARENTHESIS:\n          {\n            var expression = this.computeHashOfAstNode(ast.expression);\n\n            var _rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);\n\n            return imageWithWhitespace(_rightPart, ast.leadingWhitespace);\n          }\n\n        default:\n          {\n            return this.computeHashOfAstNode(ast.left) + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + this.computeHashOfAstNode(ast.right);\n          }\n      }\n    }\n  }]);\n\n  return ParserWithCaching;\n}();\nexport function bindWhitespacesToTokens(tokens) {\n  var processedTokens = [];\n  var first = tokens[0];\n\n  if (!tokenMatcher(first, WhiteSpace)) {\n    processedTokens.push(first);\n  }\n\n  for (var i = 1; i < tokens.length; ++i) {\n    var current = tokens[i];\n\n    if (tokenMatcher(current, WhiteSpace)) {\n      continue;\n    }\n\n    var previous = tokens[i - 1];\n\n    if (tokenMatcher(previous, WhiteSpace)) {\n      current.leadingWhitespace = previous;\n    }\n\n    processedTokens.push(current);\n  }\n\n  return processedTokens;\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/ParserWithCaching.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","tokenMatcher","ErrorType","AstNodeType","buildParsingErrorAst","cellAddressFromString","columnAddressFromString","rowAddressFromString","imageWithWhitespace","ParsingErrorType","RangeSheetReferenceType","binaryOpTokenMap","Cache","FormulaLexer","FormulaParser","buildLexerConfig","CellReference","ColumnRange","ProcedureName","RowRange","WhiteSpace","formatNumber","ParserWithCaching","config","functionRegistry","sheetMapping","statsCacheUsed","lexerConfig","lexer","formulaParser","cache","parse","text","formulaAddress","lexerResult","tokenizeFormula","errors","map","e","type","LexingError","message","ast","hasVolatileFunction","hasStructuralChangeFunction","dependencies","hash","computeHashFromTokens","tokens","cacheResult","get","undefined","processedTokens","bindWhitespacesToTokens","parsingResult","parseFromTokens","assign","set","_cacheResult","relativeDependencies","fetchCachedResultForAst","computeHashFromAst","fetchCachedResult","Error","baseAddress","_a","idx","token","cellAddress","image","concat","procedureName","toUpperCase","canonicalProcedureName","functionMapping","_token$image$split","split","_token$image$split2","start","end","startAddress","endAddress","_token$image$split3","_token$image$split4","_start","_end","_startAddress","_endAddress","rememberNewAst","maybeSetAndThenGet","computeHashOfAstNode","_this","EMPTY","leadingWhitespace","NUMBER","decimalSeparator","STRING","NAMED_EXPRESSION","expressionName","FUNCTION_CALL","args","arg","join","functionArgSeparator","rightPart","internalWhitespace","CELL_REFERENCE","reference","COLUMN_RANGE","ROW_RANGE","CELL_RANGE","sheetReferenceType","RELATIVE","BOTH_ABSOLUTE","MINUS_UNARY_OP","PLUS_UNARY_OP","PERCENT_OP","ERROR","translationPackage","getErrorTranslation","error","ERROR_WITH_RAW_INPUT","rawInput","ARRAY","_args","row","val","PARENTHESIS","expression","_rightPart","left","right","first","current","previous"],"mappings":"AAAA,SAASA,cAAT,CAAwBC,GAAxB,EAA6BC,CAA7B,EAAgC;AAAE,SAAOC,eAAe,CAACF,GAAD,CAAf,IAAwBG,qBAAqB,CAACH,GAAD,EAAMC,CAAN,CAA7C,IAAyDG,2BAA2B,CAACJ,GAAD,EAAMC,CAAN,CAApF,IAAgGI,gBAAgB,EAAvH;AAA4H;;AAE9J,SAASA,gBAAT,GAA4B;AAAE,QAAM,IAAIC,SAAJ,CAAc,2IAAd,CAAN;AAAmK;;AAEjM,SAASF,2BAAT,CAAqCG,CAArC,EAAwCC,MAAxC,EAAgD;AAAE,MAAI,CAACD,CAAL,EAAQ;AAAQ,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOE,iBAAiB,CAACF,CAAD,EAAIC,MAAJ,CAAxB;AAAqC,MAAIE,CAAC,GAAGC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BP,CAA/B,EAAkCQ,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;AAAwD,MAAIL,CAAC,KAAK,QAAN,IAAkBH,CAAC,CAACS,WAAxB,EAAqCN,CAAC,GAAGH,CAAC,CAACS,WAAF,CAAcC,IAAlB;AAAwB,MAAIP,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOQ,KAAK,CAACC,IAAN,CAAWZ,CAAX,CAAP;AAAsB,MAAIG,CAAC,KAAK,WAAN,IAAqB,2CAA2CU,IAA3C,CAAgDV,CAAhD,CAAzB,EAA6E,OAAOD,iBAAiB,CAACF,CAAD,EAAIC,MAAJ,CAAxB;AAAsC;;AAEha,SAASC,iBAAT,CAA2BT,GAA3B,EAAgCqB,GAAhC,EAAqC;AAAE,MAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGrB,GAAG,CAACsB,MAA7B,EAAqCD,GAAG,GAAGrB,GAAG,CAACsB,MAAV;;AAAkB,OAAK,IAAIrB,CAAC,GAAG,CAAR,EAAWsB,IAAI,GAAG,IAAIL,KAAJ,CAAUG,GAAV,CAAvB,EAAuCpB,CAAC,GAAGoB,GAA3C,EAAgDpB,CAAC,EAAjD,EAAqD;AAAEsB,IAAAA,IAAI,CAACtB,CAAD,CAAJ,GAAUD,GAAG,CAACC,CAAD,CAAb;AAAmB;;AAAC,SAAOsB,IAAP;AAAc;;AAEvL,SAASpB,qBAAT,CAA+BH,GAA/B,EAAoCC,CAApC,EAAuC;AAAE,MAAIuB,EAAE,GAAGxB,GAAG,IAAI,IAAP,GAAc,IAAd,GAAqB,OAAOyB,MAAP,KAAkB,WAAlB,IAAiCzB,GAAG,CAACyB,MAAM,CAACC,QAAR,CAApC,IAAyD1B,GAAG,CAAC,YAAD,CAA1F;;AAA0G,MAAIwB,EAAE,IAAI,IAAV,EAAgB;AAAQ,MAAIG,IAAI,GAAG,EAAX;AAAe,MAAIC,EAAE,GAAG,IAAT;AAAe,MAAIC,EAAE,GAAG,KAAT;;AAAgB,MAAIC,EAAJ,EAAQC,EAAR;;AAAY,MAAI;AAAE,SAAKP,EAAE,GAAGA,EAAE,CAACV,IAAH,CAAQd,GAAR,CAAV,EAAwB,EAAE4B,EAAE,GAAG,CAACE,EAAE,GAAGN,EAAE,CAACQ,IAAH,EAAN,EAAiBC,IAAxB,CAAxB,EAAuDL,EAAE,GAAG,IAA5D,EAAkE;AAAED,MAAAA,IAAI,CAACO,IAAL,CAAUJ,EAAE,CAACK,KAAb;;AAAqB,UAAIlC,CAAC,IAAI0B,IAAI,CAACL,MAAL,KAAgBrB,CAAzB,EAA4B;AAAQ;AAAE,GAArI,CAAsI,OAAOmC,GAAP,EAAY;AAAEP,IAAAA,EAAE,GAAG,IAAL;AAAWE,IAAAA,EAAE,GAAGK,GAAL;AAAW,GAA1K,SAAmL;AAAE,QAAI;AAAE,UAAI,CAACR,EAAD,IAAOJ,EAAE,CAAC,QAAD,CAAF,IAAgB,IAA3B,EAAiCA,EAAE,CAAC,QAAD,CAAF;AAAiB,KAAxD,SAAiE;AAAE,UAAIK,EAAJ,EAAQ,MAAME,EAAN;AAAW;AAAE;;AAAC,SAAOJ,IAAP;AAAc;;AAEjgB,SAASzB,eAAT,CAAyBF,GAAzB,EAA8B;AAAE,MAAIkB,KAAK,CAACmB,OAAN,CAAcrC,GAAd,CAAJ,EAAwB,OAAOA,GAAP;AAAa;;AAmBrE,SAASsC,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIlC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASmC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAI1C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0C,KAAK,CAACrB,MAA1B,EAAkCrB,CAAC,EAAnC,EAAuC;AAAE,QAAI2C,UAAU,GAAGD,KAAK,CAAC1C,CAAD,CAAtB;AAA2B2C,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BpC,IAAAA,MAAM,CAACqC,cAAP,CAAsBN,MAAtB,EAA8BE,UAAU,CAACK,GAAzC,EAA8CL,UAA9C;AAA4D;AAAE;;AAE7T,SAASM,YAAT,CAAsBV,WAAtB,EAAmCW,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBV,iBAAiB,CAACD,WAAW,CAAC5B,SAAb,EAAwBuC,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBX,iBAAiB,CAACD,WAAD,EAAcY,WAAd,CAAjB;AAA6C,SAAOZ,WAAP;AAAqB;AAEvN;AACA;AACA;AACA;;;AACA,SAASa,YAAT,QAA6B,YAA7B;AACA,SAASC,SAAT,QAA0B,SAA1B;AACA,SAASC,WAAT,EAAsBC,oBAAtB,QAAkD,IAAlD;AACA,SAASC,qBAAT,EAAgCC,uBAAhC,EAAyDC,oBAAzD,QAAqF,mCAArF;AACA,SAASC,mBAAT,EAA8BC,gBAA9B,EAAgDC,uBAAhD,QAA+E,OAA/E;AACA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,YAAT,EAAuBC,aAAvB,QAA4C,iBAA5C;AACA,SAASC,gBAAT,EAA2BC,aAA3B,EAA0CC,WAA1C,EAAuDC,aAAvD,EAAsEC,QAAtE,EAAgFC,UAAhF,QAAkG,eAAlG;AACA,SAASC,YAAT,QAA6B,YAA7B;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,iBAAiB,GAAG,aAAa,YAAY;AACtD,WAASA,iBAAT,CAA2BC,MAA3B,EAAmCC,gBAAnC,EAAqDC,YAArD,EAAmE;AACjEvC,IAAAA,eAAe,CAAC,IAAD,EAAOoC,iBAAP,CAAf;;AAEA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,WAAL,GAAmBZ,gBAAgB,CAACQ,MAAD,CAAnC;AACA,SAAKK,KAAL,GAAa,IAAIf,YAAJ,CAAiB,KAAKc,WAAtB,CAAb;AACA,SAAKE,aAAL,GAAqB,IAAIf,aAAJ,CAAkB,KAAKa,WAAvB,EAAoC,KAAKF,YAAzC,CAArB;AACA,SAAKK,KAAL,GAAa,IAAIlB,KAAJ,CAAU,KAAKY,gBAAf,CAAb;AACD;AACD;AACF;AACA;AACA;AACA;AACA;;;AAGE1B,EAAAA,YAAY,CAACwB,iBAAD,EAAoB,CAAC;AAC/BzB,IAAAA,GAAG,EAAE,OAD0B;AAE/Bd,IAAAA,KAAK,EAAE,SAASgD,KAAT,CAAeC,IAAf,EAAqBC,cAArB,EAAqC;AAC1C,UAAIC,WAAW,GAAG,KAAKN,KAAL,CAAWO,eAAX,CAA2BH,IAA3B,CAAlB;;AAEA,UAAIE,WAAW,CAACE,MAAZ,CAAmBlE,MAAnB,GAA4B,CAAhC,EAAmC;AACjC,YAAIkE,MAAM,GAAGF,WAAW,CAACE,MAAZ,CAAmBC,GAAnB,CAAuB,UAAUC,CAAV,EAAa;AAC/C,iBAAO;AACLC,YAAAA,IAAI,EAAE9B,gBAAgB,CAAC+B,WADlB;AAELC,YAAAA,OAAO,EAAEH,CAAC,CAACG;AAFN,WAAP;AAID,SALY,CAAb;AAMA,eAAO;AACLC,UAAAA,GAAG,EAAEtC,oBAAoB,EADpB;AAELgC,UAAAA,MAAM,EAAEA,MAFH;AAGLO,UAAAA,mBAAmB,EAAE,KAHhB;AAILC,UAAAA,2BAA2B,EAAE,KAJxB;AAKLC,UAAAA,YAAY,EAAE;AALT,SAAP;AAOD;;AAED,UAAIC,IAAI,GAAG,KAAKC,qBAAL,CAA2Bb,WAAW,CAACc,MAAvC,EAA+Cf,cAA/C,CAAX;AACA,UAAIgB,WAAW,GAAG,KAAKnB,KAAL,CAAWoB,GAAX,CAAeJ,IAAf,CAAlB;;AAEA,UAAIG,WAAW,KAAKE,SAApB,EAA+B;AAC7B,UAAE,KAAKzB,cAAP;AACD,OAFD,MAEO;AACL,YAAI0B,eAAe,GAAGC,uBAAuB,CAACnB,WAAW,CAACc,MAAb,CAA7C;AACA,YAAIM,aAAa,GAAG,KAAKzB,aAAL,CAAmB0B,eAAnB,CAAmCH,eAAnC,EAAoDnB,cAApD,CAApB;;AAEA,YAAIqB,aAAa,CAAClB,MAAd,CAAqBlE,MAArB,GAA8B,CAAlC,EAAqC;AACnC,iBAAOX,MAAM,CAACiG,MAAP,CAAcjG,MAAM,CAACiG,MAAP,CAAc,EAAd,EAAkBF,aAAlB,CAAd,EAAgD;AACrDX,YAAAA,mBAAmB,EAAE,KADgC;AAErDC,YAAAA,2BAA2B,EAAE,KAFwB;AAGrDC,YAAAA,YAAY,EAAE;AAHuC,WAAhD,CAAP;AAKD,SAND,MAMO;AACLI,UAAAA,WAAW,GAAG,KAAKnB,KAAL,CAAW2B,GAAX,CAAeX,IAAf,EAAqBQ,aAAa,CAACZ,GAAnC,CAAd;AACD;AACF;;AAED,UAAIgB,YAAY,GAAGT,WAAnB;AAAA,UACIP,GAAG,GAAGgB,YAAY,CAAChB,GADvB;AAAA,UAEIC,mBAAmB,GAAGe,YAAY,CAACf,mBAFvC;AAAA,UAGIC,2BAA2B,GAAGc,YAAY,CAACd,2BAH/C;AAAA,UAIIe,oBAAoB,GAAGD,YAAY,CAACC,oBAJxC;AAKA,aAAO;AACLjB,QAAAA,GAAG,EAAEA,GADA;AAELN,QAAAA,MAAM,EAAE,EAFH;AAGLO,QAAAA,mBAAmB,EAAEA,mBAHhB;AAILC,QAAAA,2BAA2B,EAAEA,2BAJxB;AAKLC,QAAAA,YAAY,EAAEc;AALT,OAAP;AAOD;AArD8B,GAAD,EAsD7B;AACD9D,IAAAA,GAAG,EAAE,yBADJ;AAEDd,IAAAA,KAAK,EAAE,SAAS6E,uBAAT,CAAiClB,GAAjC,EAAsC;AAC3C,UAAII,IAAI,GAAG,KAAKe,kBAAL,CAAwBnB,GAAxB,CAAX;AACA,aAAO,KAAKoB,iBAAL,CAAuBhB,IAAvB,CAAP;AACD;AALA,GAtD6B,EA4D7B;AACDjD,IAAAA,GAAG,EAAE,mBADJ;AAEDd,IAAAA,KAAK,EAAE,SAAS+E,iBAAT,CAA2BhB,IAA3B,EAAiC;AACtC,UAAIG,WAAW,GAAG,KAAKnB,KAAL,CAAWoB,GAAX,CAAeJ,IAAf,CAAlB;;AAEA,UAAIG,WAAW,KAAKE,SAApB,EAA+B;AAC7B,cAAM,IAAIY,KAAJ,CAAU,4CAAV,CAAN;AACD,OAFD,MAEO;AACL,YAAIrB,GAAG,GAAGO,WAAW,CAACP,GAAtB;AAAA,YACIC,mBAAmB,GAAGM,WAAW,CAACN,mBADtC;AAAA,YAEIC,2BAA2B,GAAGK,WAAW,CAACL,2BAF9C;AAAA,YAGIe,oBAAoB,GAAGV,WAAW,CAACU,oBAHvC;AAIA,eAAO;AACLjB,UAAAA,GAAG,EAAEA,GADA;AAELN,UAAAA,MAAM,EAAE,EAFH;AAGLO,UAAAA,mBAAmB,EAAEA,mBAHhB;AAILC,UAAAA,2BAA2B,EAAEA,2BAJxB;AAKLC,UAAAA,YAAY,EAAEc;AALT,SAAP;AAOD;AACF;AApBA,GA5D6B,EAiF7B;AACD9D,IAAAA,GAAG,EAAE,uBADJ;AAEDd,IAAAA,KAAK,EAAE,SAASgE,qBAAT,CAA+BC,MAA/B,EAAuCgB,WAAvC,EAAoD;AACzD,UAAIC,EAAJ;;AAEA,UAAInB,IAAI,GAAG,EAAX;AACA,UAAIoB,GAAG,GAAG,CAAV;;AAEA,aAAOA,GAAG,GAAGlB,MAAM,CAAC9E,MAApB,EAA4B;AAC1B,YAAIiG,KAAK,GAAGnB,MAAM,CAACkB,GAAD,CAAlB;;AAEA,YAAIjE,YAAY,CAACkE,KAAD,EAAQnD,aAAR,CAAhB,EAAwC;AACtC,cAAIoD,WAAW,GAAG/D,qBAAqB,CAAC,KAAKoB,YAAN,EAAoB0C,KAAK,CAACE,KAA1B,EAAiCL,WAAjC,CAAvC;;AAEA,cAAII,WAAW,KAAKjB,SAApB,EAA+B;AAC7BL,YAAAA,IAAI,GAAGA,IAAI,CAACwB,MAAL,CAAYH,KAAK,CAACE,KAAlB,CAAP;AACD,WAFD,MAEO;AACLvB,YAAAA,IAAI,GAAGA,IAAI,CAACwB,MAAL,CAAYF,WAAW,CAACtB,IAAZ,CAAiB,IAAjB,CAAZ,CAAP;AACD;AACF,SARD,MAQO,IAAI7C,YAAY,CAACkE,KAAD,EAAQjD,aAAR,CAAhB,EAAwC;AAC7C,cAAIqD,aAAa,GAAGJ,KAAK,CAACE,KAAN,CAAYG,WAAZ,GAA0B7G,KAA1B,CAAgC,CAAhC,EAAmC,CAAC,CAApC,CAApB;AACA,cAAI8G,sBAAsB,GAAG,CAACR,EAAE,GAAG,KAAKtC,WAAL,CAAiB+C,eAAjB,CAAiCH,aAAjC,CAAN,MAA2D,IAA3D,IAAmEN,EAAE,KAAK,KAAK,CAA/E,GAAmFA,EAAnF,GAAwFM,aAArH;AACAzB,UAAAA,IAAI,GAAGA,IAAI,CAACwB,MAAL,CAAYG,sBAAZ,EAAoC,GAApC,CAAP;AACD,SAJM,MAIA,IAAIxE,YAAY,CAACkE,KAAD,EAAQlD,WAAR,CAAhB,EAAsC;AAC3C,cAAI0D,kBAAkB,GAAGR,KAAK,CAACE,KAAN,CAAYO,KAAZ,CAAkB,GAAlB,CAAzB;AAAA,cACIC,mBAAmB,GAAGlI,cAAc,CAACgI,kBAAD,EAAqB,CAArB,CADxC;AAAA,cAEIG,KAAK,GAAGD,mBAAmB,CAAC,CAAD,CAF/B;AAAA,cAGIE,GAAG,GAAGF,mBAAmB,CAAC,CAAD,CAH7B;;AAKA,cAAIG,YAAY,GAAG1E,uBAAuB,CAAC,KAAKmB,YAAN,EAAoBqD,KAApB,EAA2Bd,WAA3B,CAA1C;AACA,cAAIiB,UAAU,GAAG3E,uBAAuB,CAAC,KAAKmB,YAAN,EAAoBsD,GAApB,EAAyBf,WAAzB,CAAxC;;AAEA,cAAIgB,YAAY,KAAK7B,SAAjB,IAA8B8B,UAAU,KAAK9B,SAAjD,EAA4D;AAC1DL,YAAAA,IAAI,GAAGA,IAAI,CAACwB,MAAL,CAAY,MAAZ,CAAP;AACD,WAFD,MAEO;AACLxB,YAAAA,IAAI,GAAGA,IAAI,CAACwB,MAAL,CAAYU,YAAY,CAAClC,IAAb,CAAkB,IAAlB,CAAZ,EAAqC,GAArC,EAA0CmC,UAAU,CAACnC,IAAX,CAAgB,IAAhB,CAA1C,CAAP;AACD;AACF,SAdM,MAcA,IAAI7C,YAAY,CAACkE,KAAD,EAAQhD,QAAR,CAAhB,EAAmC;AACxC,cAAI+D,mBAAmB,GAAGf,KAAK,CAACE,KAAN,CAAYO,KAAZ,CAAkB,GAAlB,CAA1B;AAAA,cACIO,mBAAmB,GAAGxI,cAAc,CAACuI,mBAAD,EAAsB,CAAtB,CADxC;AAAA,cAEIE,MAAM,GAAGD,mBAAmB,CAAC,CAAD,CAFhC;AAAA,cAGIE,IAAI,GAAGF,mBAAmB,CAAC,CAAD,CAH9B;;AAKA,cAAIG,aAAa,GAAG/E,oBAAoB,CAAC,KAAKkB,YAAN,EAAoB2D,MAApB,EAA4BpB,WAA5B,CAAxC;;AAEA,cAAIuB,WAAW,GAAGhF,oBAAoB,CAAC,KAAKkB,YAAN,EAAoB4D,IAApB,EAA0BrB,WAA1B,CAAtC;;AAEA,cAAIsB,aAAa,KAAKnC,SAAlB,IAA+BoC,WAAW,KAAKpC,SAAnD,EAA8D;AAC5DL,YAAAA,IAAI,GAAGA,IAAI,CAACwB,MAAL,CAAY,MAAZ,CAAP;AACD,WAFD,MAEO;AACLxB,YAAAA,IAAI,GAAGA,IAAI,CAACwB,MAAL,CAAYgB,aAAa,CAACxC,IAAd,CAAmB,IAAnB,CAAZ,EAAsC,GAAtC,EAA2CyC,WAAW,CAACzC,IAAZ,CAAiB,IAAjB,CAA3C,CAAP;AACD;AACF,SAfM,MAeA;AACLA,UAAAA,IAAI,GAAGA,IAAI,CAACwB,MAAL,CAAYH,KAAK,CAACE,KAAlB,CAAP;AACD;;AAEDH,QAAAA,GAAG;AACJ;;AAED,aAAOpB,IAAP;AACD;AA5DA,GAjF6B,EA8I7B;AACDjD,IAAAA,GAAG,EAAE,gBADJ;AAEDd,IAAAA,KAAK,EAAE,SAASyG,cAAT,CAAwB9C,GAAxB,EAA6B;AAClC,UAAII,IAAI,GAAG,KAAKe,kBAAL,CAAwBnB,GAAxB,CAAX;AACA,aAAO,KAAKZ,KAAL,CAAW2D,kBAAX,CAA8B3C,IAA9B,EAAoCJ,GAApC,CAAP;AACD;AALA,GA9I6B,EAoJ7B;AACD7C,IAAAA,GAAG,EAAE,oBADJ;AAEDd,IAAAA,KAAK,EAAE,SAAS8E,kBAAT,CAA4BnB,GAA5B,EAAiC;AACtC,aAAO,MAAM,KAAKgD,oBAAL,CAA0BhD,GAA1B,CAAb;AACD;AAJA,GApJ6B,EAyJ7B;AACD7C,IAAAA,GAAG,EAAE,sBADJ;AAEDd,IAAAA,KAAK,EAAE,SAAS2G,oBAAT,CAA8BhD,GAA9B,EAAmC;AACxC,UAAIiD,KAAK,GAAG,IAAZ;;AAEA,cAAQjD,GAAG,CAACH,IAAZ;AACE,aAAKpC,WAAW,CAACyF,KAAjB;AACE;AACE,mBAAOlD,GAAG,CAACmD,iBAAJ,IAAyB,EAAhC;AACD;;AAEH,aAAK1F,WAAW,CAAC2F,MAAjB;AACE;AACE,mBAAOtF,mBAAmB,CAACa,YAAY,CAACqB,GAAG,CAAC3D,KAAL,EAAY,KAAKwC,MAAL,CAAYwE,gBAAxB,CAAb,EAAwDrD,GAAG,CAACmD,iBAA5D,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAAC6F,MAAjB;AACE;AACE,mBAAOxF,mBAAmB,CAAC,MAAMkC,GAAG,CAAC3D,KAAV,GAAkB,GAAnB,EAAwB2D,GAAG,CAACmD,iBAA5B,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAAC8F,gBAAjB;AACE;AACE,mBAAOzF,mBAAmB,CAACkC,GAAG,CAACwD,cAAL,EAAqBxD,GAAG,CAACmD,iBAAzB,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAACgG,aAAjB;AACE;AACE,gBAAIC,IAAI,GAAG1D,GAAG,CAAC0D,IAAJ,CAAS/D,GAAT,CAAa,UAAUgE,GAAV,EAAe;AACrC,qBAAOV,KAAK,CAACD,oBAAN,CAA2BW,GAA3B,CAAP;AACD,aAFU,EAERC,IAFQ,CAEH,KAAK/E,MAAL,CAAYgF,oBAFT,CAAX;AAGA,gBAAIC,SAAS,GAAG9D,GAAG,CAAC6B,aAAJ,GAAoB,GAApB,GAA0B6B,IAA1B,GAAiC5F,mBAAmB,CAAC,GAAD,EAAMkC,GAAG,CAAC+D,kBAAV,CAApE;AACA,mBAAOjG,mBAAmB,CAACgG,SAAD,EAAY9D,GAAG,CAACmD,iBAAhB,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAACuG,cAAjB;AACE;AACE,mBAAOlG,mBAAmB,CAACkC,GAAG,CAACiE,SAAJ,CAAc7D,IAAd,CAAmB,IAAnB,CAAD,EAA2BJ,GAAG,CAACmD,iBAA/B,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAACyG,YAAjB;AACA,aAAKzG,WAAW,CAAC0G,SAAjB;AACA,aAAK1G,WAAW,CAAC2G,UAAjB;AACE;AACE,gBAAIhC,KAAK,GAAGpC,GAAG,CAACoC,KAAJ,CAAUhC,IAAV,CAAeJ,GAAG,CAACqE,kBAAJ,KAA2BrG,uBAAuB,CAACsG,QAAlE,CAAZ;AACA,gBAAIjC,GAAG,GAAGrC,GAAG,CAACqC,GAAJ,CAAQjC,IAAR,CAAaJ,GAAG,CAACqE,kBAAJ,KAA2BrG,uBAAuB,CAACuG,aAAhE,CAAV;AACA,mBAAOzG,mBAAmB,CAACsE,KAAK,GAAG,GAAR,GAAcC,GAAf,EAAoBrC,GAAG,CAACmD,iBAAxB,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAAC+G,cAAjB;AACE;AACE,mBAAO1G,mBAAmB,CAAC,MAAM,KAAKkF,oBAAL,CAA0BhD,GAAG,CAAC3D,KAA9B,CAAP,EAA6C2D,GAAG,CAACmD,iBAAjD,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAACgH,aAAjB;AACE;AACE,mBAAO3G,mBAAmB,CAAC,MAAM,KAAKkF,oBAAL,CAA0BhD,GAAG,CAAC3D,KAA9B,CAAP,EAA6C2D,GAAG,CAACmD,iBAAjD,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAACiH,UAAjB;AACE;AACE,mBAAO,KAAK1B,oBAAL,CAA0BhD,GAAG,CAAC3D,KAA9B,IAAuCyB,mBAAmB,CAAC,GAAD,EAAMkC,GAAG,CAACmD,iBAAV,CAAjE;AACD;;AAEH,aAAK1F,WAAW,CAACkH,KAAjB;AACE;AACE,gBAAIhD,KAAK,GAAG,KAAK9C,MAAL,CAAY+F,kBAAZ,CAA+BC,mBAA/B,CAAmD7E,GAAG,CAAC8E,KAAJ,GAAY9E,GAAG,CAAC8E,KAAJ,CAAUjF,IAAtB,GAA6BrC,SAAS,CAACmH,KAA1F,CAAZ;AACA,mBAAO7G,mBAAmB,CAAC6D,KAAD,EAAQ3B,GAAG,CAACmD,iBAAZ,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAACsH,oBAAjB;AACE;AACE,mBAAOjH,mBAAmB,CAACkC,GAAG,CAACgF,QAAL,EAAehF,GAAG,CAACmD,iBAAnB,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAACwH,KAAjB;AACE;AACE,gBAAIC,KAAK,GAAGlF,GAAG,CAAC0D,IAAJ,CAAS/D,GAAT,CAAa,UAAUwF,GAAV,EAAe;AACtC,qBAAOA,GAAG,CAACxF,GAAJ,CAAQ,UAAUyF,GAAV,EAAe;AAC5B,uBAAOnC,KAAK,CAACD,oBAAN,CAA2BoC,GAA3B,CAAP;AACD,eAFM,EAEJxB,IAFI,CAEC,GAFD,CAAP;AAGD,aAJW,EAITA,IAJS,CAIJ,GAJI,CAAZ;;AAMA,mBAAO9F,mBAAmB,CAAC,MAAMoH,KAAN,GAAcpH,mBAAmB,CAAC,GAAD,EAAMkC,GAAG,CAAC+D,kBAAV,CAAlC,EAAiE/D,GAAG,CAACmD,iBAArE,CAA1B;AACD;;AAEH,aAAK1F,WAAW,CAAC4H,WAAjB;AACE;AACE,gBAAIC,UAAU,GAAG,KAAKtC,oBAAL,CAA0BhD,GAAG,CAACsF,UAA9B,CAAjB;;AAEA,gBAAIC,UAAU,GAAG,MAAMD,UAAN,GAAmBxH,mBAAmB,CAAC,GAAD,EAAMkC,GAAG,CAAC+D,kBAAV,CAAvD;;AAEA,mBAAOjG,mBAAmB,CAACyH,UAAD,EAAavF,GAAG,CAACmD,iBAAjB,CAA1B;AACD;;AAEH;AACE;AACE,mBAAO,KAAKH,oBAAL,CAA0BhD,GAAG,CAACwF,IAA9B,IAAsC1H,mBAAmB,CAACG,gBAAgB,CAAC+B,GAAG,CAACH,IAAL,CAAjB,EAA6BG,GAAG,CAACmD,iBAAjC,CAAzD,GAA+G,KAAKH,oBAAL,CAA0BhD,GAAG,CAACyF,KAA9B,CAAtH;AACD;AA7FL;AA+FD;AApGA,GAzJ6B,CAApB,CAAZ;;AAgQA,SAAO7G,iBAAP;AACD,CAtR2C,EAArC;AAuRP,OAAO,SAAS+B,uBAAT,CAAiCL,MAAjC,EAAyC;AAC9C,MAAII,eAAe,GAAG,EAAtB;AACA,MAAIgF,KAAK,GAAGpF,MAAM,CAAC,CAAD,CAAlB;;AAEA,MAAI,CAAC/C,YAAY,CAACmI,KAAD,EAAQhH,UAAR,CAAjB,EAAsC;AACpCgC,IAAAA,eAAe,CAACtE,IAAhB,CAAqBsJ,KAArB;AACD;;AAED,OAAK,IAAIvL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmG,MAAM,CAAC9E,MAA3B,EAAmC,EAAErB,CAArC,EAAwC;AACtC,QAAIwL,OAAO,GAAGrF,MAAM,CAACnG,CAAD,CAApB;;AAEA,QAAIoD,YAAY,CAACoI,OAAD,EAAUjH,UAAV,CAAhB,EAAuC;AACrC;AACD;;AAED,QAAIkH,QAAQ,GAAGtF,MAAM,CAACnG,CAAC,GAAG,CAAL,CAArB;;AAEA,QAAIoD,YAAY,CAACqI,QAAD,EAAWlH,UAAX,CAAhB,EAAwC;AACtCiH,MAAAA,OAAO,CAACxC,iBAAR,GAA4ByC,QAA5B;AACD;;AAEDlF,IAAAA,eAAe,CAACtE,IAAhB,CAAqBuJ,OAArB;AACD;;AAED,SAAOjF,eAAP;AACD","sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { tokenMatcher } from 'chevrotain';\nimport { ErrorType } from '../Cell';\nimport { AstNodeType, buildParsingErrorAst } from './';\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from './addressRepresentationConverters';\nimport { imageWithWhitespace, ParsingErrorType, RangeSheetReferenceType } from './Ast';\nimport { binaryOpTokenMap } from './binaryOpTokenMap';\nimport { Cache } from './Cache';\nimport { FormulaLexer, FormulaParser } from './FormulaParser';\nimport { buildLexerConfig, CellReference, ColumnRange, ProcedureName, RowRange, WhiteSpace } from './LexerConfig';\nimport { formatNumber } from './Unparser';\n/**\n * Parses formula using caching if feasible.\n */\n\nexport var ParserWithCaching = /*#__PURE__*/function () {\n  function ParserWithCaching(config, functionRegistry, sheetMapping) {\n    _classCallCheck(this, ParserWithCaching);\n\n    this.config = config;\n    this.functionRegistry = functionRegistry;\n    this.sheetMapping = sheetMapping;\n    this.statsCacheUsed = 0;\n    this.lexerConfig = buildLexerConfig(config);\n    this.lexer = new FormulaLexer(this.lexerConfig);\n    this.formulaParser = new FormulaParser(this.lexerConfig, this.sheetMapping);\n    this.cache = new Cache(this.functionRegistry);\n  }\n  /**\n   * Parses a formula.\n   *\n   * @param text - formula to parse\n   * @param formulaAddress - address with regard to which formula should be parsed. Impacts computed addresses in R0C0 format.\n   */\n\n\n  _createClass(ParserWithCaching, [{\n    key: \"parse\",\n    value: function parse(text, formulaAddress) {\n      var lexerResult = this.lexer.tokenizeFormula(text);\n\n      if (lexerResult.errors.length > 0) {\n        var errors = lexerResult.errors.map(function (e) {\n          return {\n            type: ParsingErrorType.LexingError,\n            message: e.message\n          };\n        });\n        return {\n          ast: buildParsingErrorAst(),\n          errors: errors,\n          hasVolatileFunction: false,\n          hasStructuralChangeFunction: false,\n          dependencies: []\n        };\n      }\n\n      var hash = this.computeHashFromTokens(lexerResult.tokens, formulaAddress);\n      var cacheResult = this.cache.get(hash);\n\n      if (cacheResult !== undefined) {\n        ++this.statsCacheUsed;\n      } else {\n        var processedTokens = bindWhitespacesToTokens(lexerResult.tokens);\n        var parsingResult = this.formulaParser.parseFromTokens(processedTokens, formulaAddress);\n\n        if (parsingResult.errors.length > 0) {\n          return Object.assign(Object.assign({}, parsingResult), {\n            hasVolatileFunction: false,\n            hasStructuralChangeFunction: false,\n            dependencies: []\n          });\n        } else {\n          cacheResult = this.cache.set(hash, parsingResult.ast);\n        }\n      }\n\n      var _cacheResult = cacheResult,\n          ast = _cacheResult.ast,\n          hasVolatileFunction = _cacheResult.hasVolatileFunction,\n          hasStructuralChangeFunction = _cacheResult.hasStructuralChangeFunction,\n          relativeDependencies = _cacheResult.relativeDependencies;\n      return {\n        ast: ast,\n        errors: [],\n        hasVolatileFunction: hasVolatileFunction,\n        hasStructuralChangeFunction: hasStructuralChangeFunction,\n        dependencies: relativeDependencies\n      };\n    }\n  }, {\n    key: \"fetchCachedResultForAst\",\n    value: function fetchCachedResultForAst(ast) {\n      var hash = this.computeHashFromAst(ast);\n      return this.fetchCachedResult(hash);\n    }\n  }, {\n    key: \"fetchCachedResult\",\n    value: function fetchCachedResult(hash) {\n      var cacheResult = this.cache.get(hash);\n\n      if (cacheResult === undefined) {\n        throw new Error('There is no AST with such key in the cache');\n      } else {\n        var ast = cacheResult.ast,\n            hasVolatileFunction = cacheResult.hasVolatileFunction,\n            hasStructuralChangeFunction = cacheResult.hasStructuralChangeFunction,\n            relativeDependencies = cacheResult.relativeDependencies;\n        return {\n          ast: ast,\n          errors: [],\n          hasVolatileFunction: hasVolatileFunction,\n          hasStructuralChangeFunction: hasStructuralChangeFunction,\n          dependencies: relativeDependencies\n        };\n      }\n    }\n  }, {\n    key: \"computeHashFromTokens\",\n    value: function computeHashFromTokens(tokens, baseAddress) {\n      var _a;\n\n      var hash = '';\n      var idx = 0;\n\n      while (idx < tokens.length) {\n        var token = tokens[idx];\n\n        if (tokenMatcher(token, CellReference)) {\n          var cellAddress = cellAddressFromString(this.sheetMapping, token.image, baseAddress);\n\n          if (cellAddress === undefined) {\n            hash = hash.concat(token.image);\n          } else {\n            hash = hash.concat(cellAddress.hash(true));\n          }\n        } else if (tokenMatcher(token, ProcedureName)) {\n          var procedureName = token.image.toUpperCase().slice(0, -1);\n          var canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n          hash = hash.concat(canonicalProcedureName, '(');\n        } else if (tokenMatcher(token, ColumnRange)) {\n          var _token$image$split = token.image.split(':'),\n              _token$image$split2 = _slicedToArray(_token$image$split, 2),\n              start = _token$image$split2[0],\n              end = _token$image$split2[1];\n\n          var startAddress = columnAddressFromString(this.sheetMapping, start, baseAddress);\n          var endAddress = columnAddressFromString(this.sheetMapping, end, baseAddress);\n\n          if (startAddress === undefined || endAddress === undefined) {\n            hash = hash.concat('!REF');\n          } else {\n            hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));\n          }\n        } else if (tokenMatcher(token, RowRange)) {\n          var _token$image$split3 = token.image.split(':'),\n              _token$image$split4 = _slicedToArray(_token$image$split3, 2),\n              _start = _token$image$split4[0],\n              _end = _token$image$split4[1];\n\n          var _startAddress = rowAddressFromString(this.sheetMapping, _start, baseAddress);\n\n          var _endAddress = rowAddressFromString(this.sheetMapping, _end, baseAddress);\n\n          if (_startAddress === undefined || _endAddress === undefined) {\n            hash = hash.concat('!REF');\n          } else {\n            hash = hash.concat(_startAddress.hash(true), ':', _endAddress.hash(true));\n          }\n        } else {\n          hash = hash.concat(token.image);\n        }\n\n        idx++;\n      }\n\n      return hash;\n    }\n  }, {\n    key: \"rememberNewAst\",\n    value: function rememberNewAst(ast) {\n      var hash = this.computeHashFromAst(ast);\n      return this.cache.maybeSetAndThenGet(hash, ast);\n    }\n  }, {\n    key: \"computeHashFromAst\",\n    value: function computeHashFromAst(ast) {\n      return '=' + this.computeHashOfAstNode(ast);\n    }\n  }, {\n    key: \"computeHashOfAstNode\",\n    value: function computeHashOfAstNode(ast) {\n      var _this = this;\n\n      switch (ast.type) {\n        case AstNodeType.EMPTY:\n          {\n            return ast.leadingWhitespace || '';\n          }\n\n        case AstNodeType.NUMBER:\n          {\n            return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.STRING:\n          {\n            return imageWithWhitespace('\"' + ast.value + '\"', ast.leadingWhitespace);\n          }\n\n        case AstNodeType.NAMED_EXPRESSION:\n          {\n            return imageWithWhitespace(ast.expressionName, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.FUNCTION_CALL:\n          {\n            var args = ast.args.map(function (arg) {\n              return _this.computeHashOfAstNode(arg);\n            }).join(this.config.functionArgSeparator);\n            var rightPart = ast.procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);\n            return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.CELL_REFERENCE:\n          {\n            return imageWithWhitespace(ast.reference.hash(true), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.COLUMN_RANGE:\n        case AstNodeType.ROW_RANGE:\n        case AstNodeType.CELL_RANGE:\n          {\n            var start = ast.start.hash(ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE);\n            var end = ast.end.hash(ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE);\n            return imageWithWhitespace(start + ':' + end, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.MINUS_UNARY_OP:\n          {\n            return imageWithWhitespace('-' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.PLUS_UNARY_OP:\n          {\n            return imageWithWhitespace('+' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.PERCENT_OP:\n          {\n            return this.computeHashOfAstNode(ast.value) + imageWithWhitespace('%', ast.leadingWhitespace);\n          }\n\n        case AstNodeType.ERROR:\n          {\n            var image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);\n            return imageWithWhitespace(image, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.ERROR_WITH_RAW_INPUT:\n          {\n            return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);\n          }\n\n        case AstNodeType.ARRAY:\n          {\n            var _args = ast.args.map(function (row) {\n              return row.map(function (val) {\n                return _this.computeHashOfAstNode(val);\n              }).join(',');\n            }).join(';');\n\n            return imageWithWhitespace('{' + _args + imageWithWhitespace('}', ast.internalWhitespace), ast.leadingWhitespace);\n          }\n\n        case AstNodeType.PARENTHESIS:\n          {\n            var expression = this.computeHashOfAstNode(ast.expression);\n\n            var _rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);\n\n            return imageWithWhitespace(_rightPart, ast.leadingWhitespace);\n          }\n\n        default:\n          {\n            return this.computeHashOfAstNode(ast.left) + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + this.computeHashOfAstNode(ast.right);\n          }\n      }\n    }\n  }]);\n\n  return ParserWithCaching;\n}();\nexport function bindWhitespacesToTokens(tokens) {\n  var processedTokens = [];\n  var first = tokens[0];\n\n  if (!tokenMatcher(first, WhiteSpace)) {\n    processedTokens.push(first);\n  }\n\n  for (var i = 1; i < tokens.length; ++i) {\n    var current = tokens[i];\n\n    if (tokenMatcher(current, WhiteSpace)) {\n      continue;\n    }\n\n    var previous = tokens[i - 1];\n\n    if (tokenMatcher(previous, WhiteSpace)) {\n      current.leadingWhitespace = previous;\n    }\n\n    processedTokens.push(current);\n  }\n\n  return processedTokens;\n}"]},"metadata":{},"sourceType":"module"}