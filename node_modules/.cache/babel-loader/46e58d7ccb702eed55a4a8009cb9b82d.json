{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { createToken, Lexer } from 'chevrotain';\nexport var RANGE_OPERATOR = ':';\nexport var ABSOLUTE_OPERATOR = '$';\n/* arithmetic */\n// abstract for + -\n\nexport var AdditionOp = createToken({\n  name: 'AdditionOp',\n  pattern: Lexer.NA\n});\nexport var PlusOp = createToken({\n  name: 'PlusOp',\n  pattern: /\\+/,\n  categories: AdditionOp\n});\nexport var MinusOp = createToken({\n  name: 'MinusOp',\n  pattern: /-/,\n  categories: AdditionOp\n}); // abstract for * /\n\nexport var MultiplicationOp = createToken({\n  name: 'MultiplicationOp',\n  pattern: Lexer.NA\n});\nexport var TimesOp = createToken({\n  name: 'TimesOp',\n  pattern: /\\*/,\n  categories: MultiplicationOp\n});\nexport var DivOp = createToken({\n  name: 'DivOp',\n  pattern: /\\//,\n  categories: MultiplicationOp\n});\nexport var PowerOp = createToken({\n  name: 'PowerOp',\n  pattern: /\\^/\n});\nexport var PercentOp = createToken({\n  name: 'PercentOp',\n  pattern: /%/\n});\nexport var BooleanOp = createToken({\n  name: 'BooleanOp',\n  pattern: Lexer.NA\n});\nexport var EqualsOp = createToken({\n  name: 'EqualsOp',\n  pattern: /=/,\n  categories: BooleanOp\n});\nexport var NotEqualOp = createToken({\n  name: 'NotEqualOp',\n  pattern: /<>/,\n  categories: BooleanOp\n});\nexport var GreaterThanOp = createToken({\n  name: 'GreaterThanOp',\n  pattern: />/,\n  categories: BooleanOp\n});\nexport var LessThanOp = createToken({\n  name: 'LessThanOp',\n  pattern: /</,\n  categories: BooleanOp\n});\nexport var GreaterThanOrEqualOp = createToken({\n  name: 'GreaterThanOrEqualOp',\n  pattern: />=/,\n  categories: BooleanOp\n});\nexport var LessThanOrEqualOp = createToken({\n  name: 'LessThanOrEqualOp',\n  pattern: /<=/,\n  categories: BooleanOp\n});\nexport var ConcatenateOp = createToken({\n  name: 'ConcatenateOp',\n  pattern: /&/\n});\n/* addresses */\n\nexport var simpleSheetName = \"[A-Za-z0-9_\\xC0-\\u02AF]+\";\nexport var quotedSheetName = \"'(((?!').|'')*)'\";\nexport var sheetNameRegexp = \"(\".concat(simpleSheetName, \"|\").concat(quotedSheetName, \")!\");\nexport var CellReference = createToken({\n  name: 'CellReference',\n  pattern: new RegExp(\"(\".concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[A-Za-z]+\\\\\").concat(ABSOLUTE_OPERATOR, \"?[0-9]+\"))\n});\nexport var ColumnRange = createToken({\n  name: 'ColumnRange',\n  pattern: new RegExp(\"(\".concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[A-Za-z]+\").concat(RANGE_OPERATOR, \"(\").concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[A-Za-z]+\"))\n});\nexport var RowRange = createToken({\n  name: 'RowRange',\n  pattern: new RegExp(\"(\".concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[0-9]+\").concat(RANGE_OPERATOR, \"(\").concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[0-9]+\"))\n});\nexport var RangeSeparator = createToken({\n  name: 'RangeSeparator',\n  pattern: \"\".concat(RANGE_OPERATOR)\n});\n/* parenthesis */\n\nexport var LParen = createToken({\n  name: 'LParen',\n  pattern: /\\(/\n});\nexport var RParen = createToken({\n  name: 'RParen',\n  pattern: /\\)/\n});\n/* array parenthesis */\n\nexport var ArrayLParen = createToken({\n  name: 'ArrayLParen',\n  pattern: /{/\n});\nexport var ArrayRParen = createToken({\n  name: 'ArrayRParen',\n  pattern: /}/\n});\n/* procedures */\n\nexport var ProcedureName = createToken({\n  name: 'ProcedureName',\n  pattern: /([A-Za-z\\u00C0-\\u02AF][A-Za-z0-9\\u00C0-\\u02AF._]*)\\(/\n});\n/* named expressions */\n\nexport var NamedExpression = createToken({\n  name: 'NamedExpression',\n  pattern: /[A-Za-z\\u00C0-\\u02AF_][A-Za-z0-9\\u00C0-\\u02AF._]*/\n});\n/* string literal */\n\nexport var StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/\n});\n/* error literal */\n\nexport var ErrorLiteral = createToken({\n  name: 'ErrorLiteral',\n  pattern: /#[A-Za-z0-9\\/]+[?!]?/\n});\n/* skipping whitespaces */\n\nexport var WhiteSpace = createToken({\n  name: 'WhiteSpace',\n  pattern: /[ \\t\\n\\r]+/\n});\nexport var buildLexerConfig = function buildLexerConfig(config) {\n  var offsetProcedureNameLiteral = config.translationPackage.getFunctionTranslation('OFFSET');\n  var errorMapping = config.errorMapping;\n  var functionMapping = config.translationPackage.buildFunctionMapping();\n  var ArrayRowSeparator = createToken({\n    name: 'ArrayRowSep',\n    pattern: config.arrayRowSeparator\n  });\n  var ArrayColSeparator = createToken({\n    name: 'ArrayColSep',\n    pattern: config.arrayColumnSeparator\n  });\n  /* configurable tokens */\n\n  var ArgSeparator, inject;\n\n  if (config.functionArgSeparator === config.arrayColumnSeparator) {\n    ArgSeparator = ArrayColSeparator;\n    inject = [];\n  } else if (config.functionArgSeparator === config.arrayRowSeparator) {\n    ArgSeparator = ArrayRowSeparator;\n    inject = [];\n  } else {\n    ArgSeparator = createToken({\n      name: 'ArgSeparator',\n      pattern: config.functionArgSeparator\n    });\n    inject = [ArgSeparator];\n  }\n\n  var NumberLiteral = createToken({\n    name: 'NumberLiteral',\n    pattern: new RegExp(\"(([\".concat(config.decimalSeparator, \"]\\\\d+)|(\\\\d+([\").concat(config.decimalSeparator, \"]\\\\d*)?))(e[+-]?\\\\d+)?\"))\n  });\n  var OffsetProcedureName = createToken({\n    name: 'OffsetProcedureName',\n    pattern: new RegExp(offsetProcedureNameLiteral, 'i')\n  });\n  /* order is important, first pattern is used */\n\n  var allTokens = [WhiteSpace, PlusOp, MinusOp, TimesOp, DivOp, PowerOp, EqualsOp, NotEqualOp, PercentOp, GreaterThanOrEqualOp, LessThanOrEqualOp, GreaterThanOp, LessThanOp, LParen, RParen, ArrayLParen, ArrayRParen, OffsetProcedureName, ProcedureName, RangeSeparator].concat(_toConsumableArray(inject), [ColumnRange, RowRange, NumberLiteral, StringLiteral, ErrorLiteral, ConcatenateOp, BooleanOp, AdditionOp, MultiplicationOp, CellReference, NamedExpression, ArrayRowSeparator, ArrayColSeparator]);\n  return {\n    ArgSeparator: ArgSeparator,\n    NumberLiteral: NumberLiteral,\n    OffsetProcedureName: OffsetProcedureName,\n    ArrayRowSeparator: ArrayRowSeparator,\n    ArrayColSeparator: ArrayColSeparator,\n    allTokens: allTokens,\n    errorMapping: errorMapping,\n    functionMapping: functionMapping,\n    decimalSeparator: config.decimalSeparator,\n    maxColumns: config.maxColumns,\n    maxRows: config.maxRows\n  };\n};","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/LexerConfig.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","createToken","Lexer","RANGE_OPERATOR","ABSOLUTE_OPERATOR","AdditionOp","pattern","NA","PlusOp","categories","MinusOp","MultiplicationOp","TimesOp","DivOp","PowerOp","PercentOp","BooleanOp","EqualsOp","NotEqualOp","GreaterThanOp","LessThanOp","GreaterThanOrEqualOp","LessThanOrEqualOp","ConcatenateOp","simpleSheetName","quotedSheetName","sheetNameRegexp","concat","CellReference","RegExp","ColumnRange","RowRange","RangeSeparator","LParen","RParen","ArrayLParen","ArrayRParen","ProcedureName","NamedExpression","StringLiteral","ErrorLiteral","WhiteSpace","buildLexerConfig","config","offsetProcedureNameLiteral","translationPackage","getFunctionTranslation","errorMapping","functionMapping","buildFunctionMapping","ArrayRowSeparator","arrayRowSeparator","ArrayColSeparator","arrayColumnSeparator","ArgSeparator","inject","functionArgSeparator","NumberLiteral","decimalSeparator","OffsetProcedureName","allTokens","maxColumns","maxRows"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { createToken, Lexer } from 'chevrotain';\nexport var RANGE_OPERATOR = ':';\nexport var ABSOLUTE_OPERATOR = '$';\n/* arithmetic */\n// abstract for + -\n\nexport var AdditionOp = createToken({\n  name: 'AdditionOp',\n  pattern: Lexer.NA\n});\nexport var PlusOp = createToken({\n  name: 'PlusOp',\n  pattern: /\\+/,\n  categories: AdditionOp\n});\nexport var MinusOp = createToken({\n  name: 'MinusOp',\n  pattern: /-/,\n  categories: AdditionOp\n}); // abstract for * /\n\nexport var MultiplicationOp = createToken({\n  name: 'MultiplicationOp',\n  pattern: Lexer.NA\n});\nexport var TimesOp = createToken({\n  name: 'TimesOp',\n  pattern: /\\*/,\n  categories: MultiplicationOp\n});\nexport var DivOp = createToken({\n  name: 'DivOp',\n  pattern: /\\//,\n  categories: MultiplicationOp\n});\nexport var PowerOp = createToken({\n  name: 'PowerOp',\n  pattern: /\\^/\n});\nexport var PercentOp = createToken({\n  name: 'PercentOp',\n  pattern: /%/\n});\nexport var BooleanOp = createToken({\n  name: 'BooleanOp',\n  pattern: Lexer.NA\n});\nexport var EqualsOp = createToken({\n  name: 'EqualsOp',\n  pattern: /=/,\n  categories: BooleanOp\n});\nexport var NotEqualOp = createToken({\n  name: 'NotEqualOp',\n  pattern: /<>/,\n  categories: BooleanOp\n});\nexport var GreaterThanOp = createToken({\n  name: 'GreaterThanOp',\n  pattern: />/,\n  categories: BooleanOp\n});\nexport var LessThanOp = createToken({\n  name: 'LessThanOp',\n  pattern: /</,\n  categories: BooleanOp\n});\nexport var GreaterThanOrEqualOp = createToken({\n  name: 'GreaterThanOrEqualOp',\n  pattern: />=/,\n  categories: BooleanOp\n});\nexport var LessThanOrEqualOp = createToken({\n  name: 'LessThanOrEqualOp',\n  pattern: /<=/,\n  categories: BooleanOp\n});\nexport var ConcatenateOp = createToken({\n  name: 'ConcatenateOp',\n  pattern: /&/\n});\n/* addresses */\n\nexport var simpleSheetName = \"[A-Za-z0-9_\\xC0-\\u02AF]+\";\nexport var quotedSheetName = \"'(((?!').|'')*)'\";\nexport var sheetNameRegexp = \"(\".concat(simpleSheetName, \"|\").concat(quotedSheetName, \")!\");\nexport var CellReference = createToken({\n  name: 'CellReference',\n  pattern: new RegExp(\"(\".concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[A-Za-z]+\\\\\").concat(ABSOLUTE_OPERATOR, \"?[0-9]+\"))\n});\nexport var ColumnRange = createToken({\n  name: 'ColumnRange',\n  pattern: new RegExp(\"(\".concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[A-Za-z]+\").concat(RANGE_OPERATOR, \"(\").concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[A-Za-z]+\"))\n});\nexport var RowRange = createToken({\n  name: 'RowRange',\n  pattern: new RegExp(\"(\".concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[0-9]+\").concat(RANGE_OPERATOR, \"(\").concat(sheetNameRegexp, \")?\\\\\").concat(ABSOLUTE_OPERATOR, \"?[0-9]+\"))\n});\nexport var RangeSeparator = createToken({\n  name: 'RangeSeparator',\n  pattern: \"\".concat(RANGE_OPERATOR)\n});\n/* parenthesis */\n\nexport var LParen = createToken({\n  name: 'LParen',\n  pattern: /\\(/\n});\nexport var RParen = createToken({\n  name: 'RParen',\n  pattern: /\\)/\n});\n/* array parenthesis */\n\nexport var ArrayLParen = createToken({\n  name: 'ArrayLParen',\n  pattern: /{/\n});\nexport var ArrayRParen = createToken({\n  name: 'ArrayRParen',\n  pattern: /}/\n});\n/* procedures */\n\nexport var ProcedureName = createToken({\n  name: 'ProcedureName',\n  pattern: /([A-Za-z\\u00C0-\\u02AF][A-Za-z0-9\\u00C0-\\u02AF._]*)\\(/\n});\n/* named expressions */\n\nexport var NamedExpression = createToken({\n  name: 'NamedExpression',\n  pattern: /[A-Za-z\\u00C0-\\u02AF_][A-Za-z0-9\\u00C0-\\u02AF._]*/\n});\n/* string literal */\n\nexport var StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/\n});\n/* error literal */\n\nexport var ErrorLiteral = createToken({\n  name: 'ErrorLiteral',\n  pattern: /#[A-Za-z0-9\\/]+[?!]?/\n});\n/* skipping whitespaces */\n\nexport var WhiteSpace = createToken({\n  name: 'WhiteSpace',\n  pattern: /[ \\t\\n\\r]+/\n});\nexport var buildLexerConfig = function buildLexerConfig(config) {\n  var offsetProcedureNameLiteral = config.translationPackage.getFunctionTranslation('OFFSET');\n  var errorMapping = config.errorMapping;\n  var functionMapping = config.translationPackage.buildFunctionMapping();\n  var ArrayRowSeparator = createToken({\n    name: 'ArrayRowSep',\n    pattern: config.arrayRowSeparator\n  });\n  var ArrayColSeparator = createToken({\n    name: 'ArrayColSep',\n    pattern: config.arrayColumnSeparator\n  });\n  /* configurable tokens */\n\n  var ArgSeparator, inject;\n\n  if (config.functionArgSeparator === config.arrayColumnSeparator) {\n    ArgSeparator = ArrayColSeparator;\n    inject = [];\n  } else if (config.functionArgSeparator === config.arrayRowSeparator) {\n    ArgSeparator = ArrayRowSeparator;\n    inject = [];\n  } else {\n    ArgSeparator = createToken({\n      name: 'ArgSeparator',\n      pattern: config.functionArgSeparator\n    });\n    inject = [ArgSeparator];\n  }\n\n  var NumberLiteral = createToken({\n    name: 'NumberLiteral',\n    pattern: new RegExp(\"(([\".concat(config.decimalSeparator, \"]\\\\d+)|(\\\\d+([\").concat(config.decimalSeparator, \"]\\\\d*)?))(e[+-]?\\\\d+)?\"))\n  });\n  var OffsetProcedureName = createToken({\n    name: 'OffsetProcedureName',\n    pattern: new RegExp(offsetProcedureNameLiteral, 'i')\n  });\n  /* order is important, first pattern is used */\n\n  var allTokens = [WhiteSpace, PlusOp, MinusOp, TimesOp, DivOp, PowerOp, EqualsOp, NotEqualOp, PercentOp, GreaterThanOrEqualOp, LessThanOrEqualOp, GreaterThanOp, LessThanOp, LParen, RParen, ArrayLParen, ArrayRParen, OffsetProcedureName, ProcedureName, RangeSeparator].concat(_toConsumableArray(inject), [ColumnRange, RowRange, NumberLiteral, StringLiteral, ErrorLiteral, ConcatenateOp, BooleanOp, AdditionOp, MultiplicationOp, CellReference, NamedExpression, ArrayRowSeparator, ArrayColSeparator]);\n  return {\n    ArgSeparator: ArgSeparator,\n    NumberLiteral: NumberLiteral,\n    OffsetProcedureName: OffsetProcedureName,\n    ArrayRowSeparator: ArrayRowSeparator,\n    ArrayColSeparator: ArrayColSeparator,\n    allTokens: allTokens,\n    errorMapping: errorMapping,\n    functionMapping: functionMapping,\n    decimalSeparator: config.decimalSeparator,\n    maxColumns: config.maxColumns,\n    maxRows: config.maxRows\n  };\n};"]},"metadata":{},"sourceType":"module"}