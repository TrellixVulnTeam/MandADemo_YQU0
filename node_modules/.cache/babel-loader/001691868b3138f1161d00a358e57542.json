{"ast":null,"code":"import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset } from \"../../cst/cst\";\nimport { has, isUndefined, NOOP } from \"../../../utils/utils\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults } from \"../../cst/cst_visitor\";\nimport { getKeyForAltIndex } from \"../../grammar/keys\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * This trait is responsible for the CST building logic.\n */\n\nvar TreeBuilder = function () {\n  function TreeBuilder() {}\n\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.LAST_EXPLICIT_RULE_STACK = [];\n    this.CST_STACK = [];\n    this.outputCst = has(config, \"outputCst\") ? config.outputCst : DEFAULT_PARSER_CONFIG.outputCst;\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = NOOP;\n      this.cstFinallyStateUpdate = NOOP;\n      this.cstPostTerminal = NOOP;\n      this.cstPostNonTerminal = NOOP;\n      this.cstPostRule = NOOP;\n      this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;\n      this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;\n      this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;\n      this.manyInternal = this.manyInternalNoCst;\n      this.orInternal = this.orInternalNoCst;\n      this.optionInternal = this.optionInternalNoCst;\n      this.atLeastOneInternal = this.atLeastOneInternalNoCst;\n      this.manySepFirstInternal = this.manySepFirstInternalNoCst;\n      this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = NOOP;\n        this.setNodeLocationFromNode = NOOP;\n        this.cstPostRule = NOOP;\n        this.setInitialNodeLocation = NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\n   *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n    * @param cstNode\n   */\n\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }; // CST\n\n\n  TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {\n    var cstNode = {\n      name: nestedName,\n      fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] + nestedName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.LAST_EXPLICIT_RULE_STACK.pop();\n    this.CST_STACK.pop();\n  };\n\n  TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {\n    var lastCstNode = this.CST_STACK.pop(); // TODO: the naming is bad, this should go directly to the\n    //       (correct) cstLocation update method\n    //       e.g if we put other logic in postRule...\n\n    this.cstPostRule(lastCstNode);\n  };\n\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode or its nested children.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode or its nested children.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    // Avoid side effects due to back tracking\n    // TODO: This costs a 2-3% in performance, A flag on IParserConfig\n    //   could be used to get rid of this conditional, but not sure its worth the effort\n    //   and API complexity.\n    if (this.isBackTracking() !== true) {\n      var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n      addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult); // This is only used when **both** error recovery and CST Output are enabled.\n\n      this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, this.allRuleNames);\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n\n    return this.baseCstVisitorConstructor;\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n\n  TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {\n    var nestedName;\n\n    if (methodOpts.NAME !== undefined) {\n      nestedName = methodOpts.NAME;\n      this.nestedRuleInvocationStateUpdate(nestedName, laKey);\n      return nestedName;\n    } else {\n      return undefined;\n    }\n  };\n\n  TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {\n    var ruleIdx = this.getLastExplicitRuleShortName();\n    var shortName = getKeyForAltIndex(ruleIdx, methodKeyIdx, occurrence, altIdx);\n    var nestedName;\n\n    if (methodOpts.NAME !== undefined) {\n      nestedName = methodOpts.NAME;\n      this.nestedRuleInvocationStateUpdate(nestedName, shortName);\n      return {\n        shortName: shortName,\n        nestedName: nestedName\n      };\n    } else {\n      return undefined;\n    }\n  };\n\n  TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {\n    var cstStack = this.CST_STACK;\n    var nestedRuleCst = cstStack[cstStack.length - 1];\n    this.nestedRuleFinallyStateUpdate(); // this return a different result than the previous invocation because \"nestedRuleFinallyStateUpdate\" pops the cst stack\n\n    var parentCstNode = cstStack[cstStack.length - 1];\n    addNoneTerminalToCst(parentCstNode, nestedName, nestedRuleCst);\n    this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n    return this.RULE_STACK[lastExplictIndex];\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];\n    return this.RULE_STACK[lastExplicitIndex];\n  };\n\n  TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n    return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n\n  TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {\n    this.RULE_OCCURRENCE_STACK.push(1);\n    this.RULE_STACK.push(shortNameKey);\n    this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);\n  };\n\n  TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop(); // NOOP when cst is disabled\n\n    this.cstNestedFinallyStateUpdate();\n  };\n\n  return TreeBuilder;\n}();\n\nexport { TreeBuilder };","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js"],"names":["addNoneTerminalToCst","addTerminalToCst","setNodeLocationFull","setNodeLocationOnlyOffset","has","isUndefined","NOOP","createBaseSemanticVisitorConstructor","createBaseVisitorConstructorWithDefaults","getKeyForAltIndex","DEFAULT_PARSER_CONFIG","TreeBuilder","prototype","initTreeBuilder","config","LAST_EXPLICIT_RULE_STACK","CST_STACK","outputCst","nodeLocationTracking","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","cstPostRule","getLastExplicitRuleShortName","getLastExplicitRuleShortNameNoCst","getPreviousExplicitRuleShortName","getPreviousExplicitRuleShortNameNoCst","getLastExplicitRuleOccurrenceIndex","getLastExplicitRuleOccurrenceIndexNoCst","manyInternal","manyInternalNoCst","orInternal","orInternalNoCst","optionInternal","optionInternalNoCst","atLeastOneInternal","atLeastOneInternalNoCst","manySepFirstInternal","manySepFirstInternalNoCst","atLeastOneSepFirstInternal","atLeastOneSepFirstInternalNoCst","test","recoveryEnabled","setNodeLocationFromToken","setNodeLocationFromNode","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","Error","cstNode","location","startOffset","NaN","endOffset","LA","startLine","startColumn","endLine","endColumn","nextToken","cstNestedInvocationStateUpdate","nestedName","shortName","name","fullName","shortRuleNameToFull","children","push","fullRuleName","RULE_STACK","length","pop","cstNestedFinallyStateUpdate","lastCstNode","ruleCstNode","prevToken","loc","key","consumedToken","rootCst","ruleCstResult","ruleName","isBackTracking","preCstNode","getBaseCstVisitorConstructor","baseCstVisitorConstructor","newBaseCstVisitorConstructor","className","allRuleNames","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","nestedRuleBeforeClause","methodOpts","laKey","NAME","undefined","nestedRuleInvocationStateUpdate","nestedAltBeforeClause","occurrence","methodKeyIdx","altIdx","ruleIdx","nestedRuleFinallyClause","cstStack","nestedRuleCst","nestedRuleFinallyStateUpdate","parentCstNode","lastExplictIndex","ruleStack","lastExplicitIndex","RULE_OCCURRENCE_STACK","occurrenceStack","nestedRuleName","shortNameKey"],"mappings":"AAAA,SAASA,oBAAT,EAA+BC,gBAA/B,EAAiDC,mBAAjD,EAAsEC,yBAAtE,QAAuG,eAAvG;AACA,SAASC,GAAT,EAAcC,WAAd,EAA2BC,IAA3B,QAAuC,sBAAvC;AACA,SAASC,oCAAT,EAA+CC,wCAA/C,QAA+F,uBAA/F;AACA,SAASC,iBAAT,QAAkC,oBAAlC;AACA,SAASC,qBAAT,QAAsC,WAAtC;AACA;AACA;AACA;;AACA,IAAIC,WAAW,GAAkB,YAAY;AACzC,WAASA,WAAT,GAAuB,CACtB;;AACDA,EAAAA,WAAW,CAACC,SAAZ,CAAsBC,eAAtB,GAAwC,UAAUC,MAAV,EAAkB;AACtD,SAAKC,wBAAL,GAAgC,EAAhC;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,SAAL,GAAiBb,GAAG,CAACU,MAAD,EAAS,WAAT,CAAH,GACXA,MAAM,CAACG,SADI,GAEXP,qBAAqB,CAACO,SAF5B;AAGA,SAAKC,oBAAL,GAA4Bd,GAAG,CAACU,MAAD,EAAS,sBAAT,CAAH,GACtBA,MAAM,CAACI,oBADe,GAEtBR,qBAAqB,CAACQ,oBAF5B;;AAGA,QAAI,CAAC,KAAKD,SAAV,EAAqB;AACjB,WAAKE,wBAAL,GAAgCb,IAAhC;AACA,WAAKc,qBAAL,GAA6Bd,IAA7B;AACA,WAAKe,eAAL,GAAuBf,IAAvB;AACA,WAAKgB,kBAAL,GAA0BhB,IAA1B;AACA,WAAKiB,WAAL,GAAmBjB,IAAnB;AACA,WAAKkB,4BAAL,GAAoC,KAAKC,iCAAzC;AACA,WAAKC,gCAAL,GAAwC,KAAKC,qCAA7C;AACA,WAAKC,kCAAL,GAA0C,KAAKC,uCAA/C;AACA,WAAKC,YAAL,GAAoB,KAAKC,iBAAzB;AACA,WAAKC,UAAL,GAAkB,KAAKC,eAAvB;AACA,WAAKC,cAAL,GAAsB,KAAKC,mBAA3B;AACA,WAAKC,kBAAL,GAA0B,KAAKC,uBAA/B;AACA,WAAKC,oBAAL,GAA4B,KAAKC,yBAAjC;AACA,WAAKC,0BAAL,GAAkC,KAAKC,+BAAvC;AACH,KAfD,MAgBK;AACD,UAAI,QAAQC,IAAR,CAAa,KAAKxB,oBAAlB,CAAJ,EAA6C;AACzC,YAAI,KAAKyB,eAAT,EAA0B;AACtB,eAAKC,wBAAL,GAAgC1C,mBAAhC;AACA,eAAK2C,uBAAL,GAA+B3C,mBAA/B;AACA,eAAKqB,WAAL,GAAmBjB,IAAnB;AACA,eAAKwC,sBAAL,GAA8B,KAAKC,kCAAnC;AACH,SALD,MAMK;AACD,eAAKH,wBAAL,GAAgCtC,IAAhC;AACA,eAAKuC,uBAAL,GAA+BvC,IAA/B;AACA,eAAKiB,WAAL,GAAmB,KAAKyB,eAAxB;AACA,eAAKF,sBAAL,GAA8B,KAAKG,iCAAnC;AACH;AACJ,OAbD,MAcK,IAAI,cAAcP,IAAd,CAAmB,KAAKxB,oBAAxB,CAAJ,EAAmD;AACpD,YAAI,KAAKyB,eAAT,EAA0B;AACtB,eAAKC,wBAAL,GAAiCzC,yBAAjC;AACA,eAAK0C,uBAAL,GAAgC1C,yBAAhC;AACA,eAAKoB,WAAL,GAAmBjB,IAAnB;AACA,eAAKwC,sBAAL,GAA8B,KAAKI,wCAAnC;AACH,SALD,MAMK;AACD,eAAKN,wBAAL,GAAgCtC,IAAhC;AACA,eAAKuC,uBAAL,GAA+BvC,IAA/B;AACA,eAAKiB,WAAL,GAAmB,KAAK4B,qBAAxB;AACA,eAAKL,sBAAL,GAA8B,KAAKM,uCAAnC;AACH;AACJ,OAbI,MAcA,IAAI,QAAQV,IAAR,CAAa,KAAKxB,oBAAlB,CAAJ,EAA6C;AAC9C,aAAK0B,wBAAL,GAAgCtC,IAAhC;AACA,aAAKuC,uBAAL,GAA+BvC,IAA/B;AACA,aAAKiB,WAAL,GAAmBjB,IAAnB;AACA,aAAKwC,sBAAL,GAA8BxC,IAA9B;AACH,OALI,MAMA;AACD,cAAM+C,KAAK,CAAC,qDAAqDvC,MAAM,CAACI,oBAA5D,GAAmF,IAApF,CAAX;AACH;AACJ;AACJ,GAhED;;AAiEAP,EAAAA,WAAW,CAACC,SAAZ,CAAsBsC,wCAAtB,GAAiE,UAAUI,OAAV,EAAmB;AAChFA,IAAAA,OAAO,CAACC,QAAR,GAAmB;AACfC,MAAAA,WAAW,EAAEC,GADE;AAEfC,MAAAA,SAAS,EAAED;AAFI,KAAnB;AAIH,GALD;;AAMA9C,EAAAA,WAAW,CAACC,SAAZ,CAAsBwC,uCAAtB,GAAgE,UAAUE,OAAV,EAAmB;AAC/EA,IAAAA,OAAO,CAACC,QAAR,GAAmB;AACf;AACA;AACA;AACA;AACAC,MAAAA,WAAW,EAAE,KAAKG,EAAL,CAAQ,CAAR,EAAWH,WALT;AAMfE,MAAAA,SAAS,EAAED;AANI,KAAnB;AAQH,GATD;;AAUA9C,EAAAA,WAAW,CAACC,SAAZ,CAAsBmC,kCAAtB,GAA2D,UAAUO,OAAV,EAAmB;AAC1EA,IAAAA,OAAO,CAACC,QAAR,GAAmB;AACfC,MAAAA,WAAW,EAAEC,GADE;AAEfG,MAAAA,SAAS,EAAEH,GAFI;AAGfI,MAAAA,WAAW,EAAEJ,GAHE;AAIfC,MAAAA,SAAS,EAAED,GAJI;AAKfK,MAAAA,OAAO,EAAEL,GALM;AAMfM,MAAAA,SAAS,EAAEN;AANI,KAAnB;AAQH,GATD;AAUA;AACJ;AACA;AACA;;;AAEI9C,EAAAA,WAAW,CAACC,SAAZ,CAAsBqC,iCAAtB,GAA0D,UAAUK,OAAV,EAAmB;AACzE,QAAIU,SAAS,GAAG,KAAKL,EAAL,CAAQ,CAAR,CAAhB;AACAL,IAAAA,OAAO,CAACC,QAAR,GAAmB;AACfC,MAAAA,WAAW,EAAEQ,SAAS,CAACR,WADR;AAEfI,MAAAA,SAAS,EAAEI,SAAS,CAACJ,SAFN;AAGfC,MAAAA,WAAW,EAAEG,SAAS,CAACH,WAHR;AAIfH,MAAAA,SAAS,EAAED,GAJI;AAKfK,MAAAA,OAAO,EAAEL,GALM;AAMfM,MAAAA,SAAS,EAAEN;AANI,KAAnB;AAQH,GAVD,CAnGyC,CA8GzC;;;AACA9C,EAAAA,WAAW,CAACC,SAAZ,CAAsBqD,8BAAtB,GAAuD,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACpF,QAAIb,OAAO,GAAG;AACVc,MAAAA,IAAI,EAAEF,UADI;AAEVG,MAAAA,QAAQ,EAAE,KAAKC,mBAAL,CAAyB,KAAK9C,4BAAL,EAAzB,IACN0C,UAHM;AAIVK,MAAAA,QAAQ,EAAE;AAJA,KAAd;AAMA,SAAKzB,sBAAL,CAA4BQ,OAA5B;AACA,SAAKtC,SAAL,CAAewD,IAAf,CAAoBlB,OAApB;AACH,GATD;;AAUA3C,EAAAA,WAAW,CAACC,SAAZ,CAAsBO,wBAAtB,GAAiD,UAAUsD,YAAV,EAAwBN,SAAxB,EAAmC;AAChF,SAAKpD,wBAAL,CAA8ByD,IAA9B,CAAmC,KAAKE,UAAL,CAAgBC,MAAhB,GAAyB,CAA5D;AACA,QAAIrB,OAAO,GAAG;AACVc,MAAAA,IAAI,EAAEK,YADI;AAEVF,MAAAA,QAAQ,EAAE;AAFA,KAAd;AAIA,SAAKzB,sBAAL,CAA4BQ,OAA5B;AACA,SAAKtC,SAAL,CAAewD,IAAf,CAAoBlB,OAApB;AACH,GARD;;AASA3C,EAAAA,WAAW,CAACC,SAAZ,CAAsBQ,qBAAtB,GAA8C,YAAY;AACtD,SAAKL,wBAAL,CAA8B6D,GAA9B;AACA,SAAK5D,SAAL,CAAe4D,GAAf;AACH,GAHD;;AAIAjE,EAAAA,WAAW,CAACC,SAAZ,CAAsBiE,2BAAtB,GAAoD,YAAY;AAC5D,QAAIC,WAAW,GAAG,KAAK9D,SAAL,CAAe4D,GAAf,EAAlB,CAD4D,CAE5D;AACA;AACA;;AACA,SAAKrD,WAAL,CAAiBuD,WAAjB;AACH,GAND;;AAOAnE,EAAAA,WAAW,CAACC,SAAZ,CAAsBoC,eAAtB,GAAwC,UAAU+B,WAAV,EAAuB;AAC3D,QAAIC,SAAS,GAAG,KAAKrB,EAAL,CAAQ,CAAR,CAAhB;AACA,QAAIsB,GAAG,GAAGF,WAAW,CAACxB,QAAtB,CAF2D,CAG3D;AACA;;AACA,QAAI0B,GAAG,CAACzB,WAAJ,IAAmBwB,SAAS,CAACxB,WAA7B,KAA6C,IAAjD,EAAuD;AACnDyB,MAAAA,GAAG,CAACvB,SAAJ,GAAgBsB,SAAS,CAACtB,SAA1B;AACAuB,MAAAA,GAAG,CAACnB,OAAJ,GAAckB,SAAS,CAAClB,OAAxB;AACAmB,MAAAA,GAAG,CAAClB,SAAJ,GAAgBiB,SAAS,CAACjB,SAA1B;AACH,KAJD,CAKA;AALA,SAMK;AACDkB,MAAAA,GAAG,CAACzB,WAAJ,GAAkBC,GAAlB;AACAwB,MAAAA,GAAG,CAACrB,SAAJ,GAAgBH,GAAhB;AACAwB,MAAAA,GAAG,CAACpB,WAAJ,GAAkBJ,GAAlB;AACH;AACJ,GAhBD;;AAiBA9C,EAAAA,WAAW,CAACC,SAAZ,CAAsBuC,qBAAtB,GAA8C,UAAU4B,WAAV,EAAuB;AACjE,QAAIC,SAAS,GAAG,KAAKrB,EAAL,CAAQ,CAAR,CAAhB;AACA,QAAIsB,GAAG,GAAGF,WAAW,CAACxB,QAAtB,CAFiE,CAGjE;AACA;;AACA,QAAI0B,GAAG,CAACzB,WAAJ,IAAmBwB,SAAS,CAACxB,WAA7B,KAA6C,IAAjD,EAAuD;AACnDyB,MAAAA,GAAG,CAACvB,SAAJ,GAAgBsB,SAAS,CAACtB,SAA1B;AACH,KAFD,CAGA;AAHA,SAIK;AACDuB,MAAAA,GAAG,CAACzB,WAAJ,GAAkBC,GAAlB;AACH;AACJ,GAZD;;AAaA9C,EAAAA,WAAW,CAACC,SAAZ,CAAsBS,eAAtB,GAAwC,UAAU6D,GAAV,EAAeC,aAAf,EAA8B;AAClE,QAAIC,OAAO,GAAG,KAAKpE,SAAL,CAAe,KAAKA,SAAL,CAAe2D,MAAf,GAAwB,CAAvC,CAAd;AACA1E,IAAAA,gBAAgB,CAACmF,OAAD,EAAUD,aAAV,EAAyBD,GAAzB,CAAhB,CAFkE,CAGlE;;AACA,SAAKtC,wBAAL,CAA8BwC,OAAO,CAAC7B,QAAtC,EAAgD4B,aAAhD;AACH,GALD;;AAMAxE,EAAAA,WAAW,CAACC,SAAZ,CAAsBU,kBAAtB,GAA2C,UAAU+D,aAAV,EAAyBC,QAAzB,EAAmC;AAC1E;AACA;AACA;AACA;AACA,QAAI,KAAKC,cAAL,OAA0B,IAA9B,EAAoC;AAChC,UAAIC,UAAU,GAAG,KAAKxE,SAAL,CAAe,KAAKA,SAAL,CAAe2D,MAAf,GAAwB,CAAvC,CAAjB;AACA3E,MAAAA,oBAAoB,CAACwF,UAAD,EAAaF,QAAb,EAAuBD,aAAvB,CAApB,CAFgC,CAGhC;;AACA,WAAKxC,uBAAL,CAA6B2C,UAAU,CAACjC,QAAxC,EAAkD8B,aAAa,CAAC9B,QAAhE;AACH;AACJ,GAXD;;AAYA5C,EAAAA,WAAW,CAACC,SAAZ,CAAsB6E,4BAAtB,GAAqD,YAAY;AAC7D,QAAIpF,WAAW,CAAC,KAAKqF,yBAAN,CAAf,EAAiD;AAC7C,UAAIC,4BAA4B,GAAGpF,oCAAoC,CAAC,KAAKqF,SAAN,EAAiB,KAAKC,YAAtB,CAAvE;AACA,WAAKH,yBAAL,GAAiCC,4BAAjC;AACA,aAAOA,4BAAP;AACH;;AACD,WAAO,KAAKD,yBAAZ;AACH,GAPD;;AAQA/E,EAAAA,WAAW,CAACC,SAAZ,CAAsBkF,wCAAtB,GAAiE,YAAY;AACzE,QAAIzF,WAAW,CAAC,KAAK0F,qCAAN,CAAf,EAA6D;AACzD,UAAIC,cAAc,GAAGxF,wCAAwC,CAAC,KAAKoF,SAAN,EAAiB,KAAKC,YAAtB,EAAoC,KAAKJ,4BAAL,EAApC,CAA7D;AACA,WAAKM,qCAAL,GAA6CC,cAA7C;AACA,aAAOA,cAAP;AACH;;AACD,WAAO,KAAKD,qCAAZ;AACH,GAPD;;AAQApF,EAAAA,WAAW,CAACC,SAAZ,CAAsBqF,sBAAtB,GAA+C,UAAUC,UAAV,EAAsBC,KAAtB,EAA6B;AACxE,QAAIjC,UAAJ;;AACA,QAAIgC,UAAU,CAACE,IAAX,KAAoBC,SAAxB,EAAmC;AAC/BnC,MAAAA,UAAU,GAAGgC,UAAU,CAACE,IAAxB;AACA,WAAKE,+BAAL,CAAqCpC,UAArC,EAAiDiC,KAAjD;AACA,aAAOjC,UAAP;AACH,KAJD,MAKK;AACD,aAAOmC,SAAP;AACH;AACJ,GAVD;;AAWA1F,EAAAA,WAAW,CAACC,SAAZ,CAAsB2F,qBAAtB,GAA8C,UAAUL,UAAV,EAAsBM,UAAtB,EAAkCC,YAAlC,EAAgDC,MAAhD,EAAwD;AAClG,QAAIC,OAAO,GAAG,KAAKnF,4BAAL,EAAd;AACA,QAAI2C,SAAS,GAAG1D,iBAAiB,CAACkG,OAAD,EAAUF,YAAV,EAAwBD,UAAxB,EAAoCE,MAApC,CAAjC;AACA,QAAIxC,UAAJ;;AACA,QAAIgC,UAAU,CAACE,IAAX,KAAoBC,SAAxB,EAAmC;AAC/BnC,MAAAA,UAAU,GAAGgC,UAAU,CAACE,IAAxB;AACA,WAAKE,+BAAL,CAAqCpC,UAArC,EAAiDC,SAAjD;AACA,aAAO;AACHA,QAAAA,SAAS,EAAEA,SADR;AAEHD,QAAAA,UAAU,EAAEA;AAFT,OAAP;AAIH,KAPD,MAQK;AACD,aAAOmC,SAAP;AACH;AACJ,GAfD;;AAgBA1F,EAAAA,WAAW,CAACC,SAAZ,CAAsBgG,uBAAtB,GAAgD,UAAUT,KAAV,EAAiBjC,UAAjB,EAA6B;AACzE,QAAI2C,QAAQ,GAAG,KAAK7F,SAApB;AACA,QAAI8F,aAAa,GAAGD,QAAQ,CAACA,QAAQ,CAAClC,MAAT,GAAkB,CAAnB,CAA5B;AACA,SAAKoC,4BAAL,GAHyE,CAIzE;;AACA,QAAIC,aAAa,GAAGH,QAAQ,CAACA,QAAQ,CAAClC,MAAT,GAAkB,CAAnB,CAA5B;AACA3E,IAAAA,oBAAoB,CAACgH,aAAD,EAAgB9C,UAAhB,EAA4B4C,aAA5B,CAApB;AACA,SAAKjE,uBAAL,CAA6BmE,aAAa,CAACzD,QAA3C,EAAqDuD,aAAa,CAACvD,QAAnE;AACH,GARD;;AASA5C,EAAAA,WAAW,CAACC,SAAZ,CAAsBY,4BAAtB,GAAqD,YAAY;AAC7D,QAAIyF,gBAAgB,GAAG,KAAKlG,wBAAL,CAA8B,KAAKA,wBAAL,CAA8B4D,MAA9B,GAAuC,CAArE,CAAvB;AACA,WAAO,KAAKD,UAAL,CAAgBuC,gBAAhB,CAAP;AACH,GAHD;;AAIAtG,EAAAA,WAAW,CAACC,SAAZ,CAAsBa,iCAAtB,GAA0D,YAAY;AAClE,QAAIyF,SAAS,GAAG,KAAKxC,UAArB;AACA,WAAOwC,SAAS,CAACA,SAAS,CAACvC,MAAV,GAAmB,CAApB,CAAhB;AACH,GAHD;;AAIAhE,EAAAA,WAAW,CAACC,SAAZ,CAAsBc,gCAAtB,GAAyD,YAAY;AACjE,QAAIyF,iBAAiB,GAAG,KAAKpG,wBAAL,CAA8B,KAAKA,wBAAL,CAA8B4D,MAA9B,GAAuC,CAArE,CAAxB;AACA,WAAO,KAAKD,UAAL,CAAgByC,iBAAhB,CAAP;AACH,GAHD;;AAIAxG,EAAAA,WAAW,CAACC,SAAZ,CAAsBe,qCAAtB,GAA8D,YAAY;AACtE,QAAIuF,SAAS,GAAG,KAAKxC,UAArB;AACA,WAAOwC,SAAS,CAACA,SAAS,CAACvC,MAAV,GAAmB,CAApB,CAAhB;AACH,GAHD;;AAIAhE,EAAAA,WAAW,CAACC,SAAZ,CAAsBgB,kCAAtB,GAA2D,YAAY;AACnE,QAAIuF,iBAAiB,GAAG,KAAKpG,wBAAL,CAA8B,KAAKA,wBAAL,CAA8B4D,MAA9B,GAAuC,CAArE,CAAxB;AACA,WAAO,KAAKyC,qBAAL,CAA2BD,iBAA3B,CAAP;AACH,GAHD;;AAIAxG,EAAAA,WAAW,CAACC,SAAZ,CAAsBiB,uCAAtB,GAAgE,YAAY;AACxE,QAAIwF,eAAe,GAAG,KAAKD,qBAA3B;AACA,WAAOC,eAAe,CAACA,eAAe,CAAC1C,MAAhB,GAAyB,CAA1B,CAAtB;AACH,GAHD;;AAIAhE,EAAAA,WAAW,CAACC,SAAZ,CAAsB0F,+BAAtB,GAAwD,UAAUgB,cAAV,EAA0BC,YAA1B,EAAwC;AAC5F,SAAKH,qBAAL,CAA2B5C,IAA3B,CAAgC,CAAhC;AACA,SAAKE,UAAL,CAAgBF,IAAhB,CAAqB+C,YAArB;AACA,SAAKtD,8BAAL,CAAoCqD,cAApC,EAAoDC,YAApD;AACH,GAJD;;AAKA5G,EAAAA,WAAW,CAACC,SAAZ,CAAsBmG,4BAAtB,GAAqD,YAAY;AAC7D,SAAKrC,UAAL,CAAgBE,GAAhB;AACA,SAAKwC,qBAAL,CAA2BxC,GAA3B,GAF6D,CAG7D;;AACA,SAAKC,2BAAL;AACH,GALD;;AAMA,SAAOlE,WAAP;AACH,CArRgC,EAAjC;;AAsRA,SAASA,WAAT","sourcesContent":["import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset } from \"../../cst/cst\";\nimport { has, isUndefined, NOOP } from \"../../../utils/utils\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults } from \"../../cst/cst_visitor\";\nimport { getKeyForAltIndex } from \"../../grammar/keys\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */ (function () {\n    function TreeBuilder() {\n    }\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\n        this.LAST_EXPLICIT_RULE_STACK = [];\n        this.CST_STACK = [];\n        this.outputCst = has(config, \"outputCst\")\n            ? config.outputCst\n            : DEFAULT_PARSER_CONFIG.outputCst;\n        this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking\n            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = NOOP;\n            this.cstFinallyStateUpdate = NOOP;\n            this.cstPostTerminal = NOOP;\n            this.cstPostNonTerminal = NOOP;\n            this.cstPostRule = NOOP;\n            this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;\n            this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;\n            this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;\n            this.manyInternal = this.manyInternalNoCst;\n            this.orInternal = this.orInternalNoCst;\n            this.optionInternal = this.optionInternalNoCst;\n            this.atLeastOneInternal = this.atLeastOneInternalNoCst;\n            this.manySepFirstInternal = this.manySepFirstInternalNoCst;\n            this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationFull;\n                    this.setNodeLocationFromNode = setNodeLocationFull;\n                    this.cstPostRule = NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = NOOP;\n                    this.setNodeLocationFromNode = NOOP;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = (setNodeLocationOnlyOffset);\n                    this.setNodeLocationFromNode = (setNodeLocationOnlyOffset);\n                    this.cstPostRule = NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = NOOP;\n                    this.setNodeLocationFromNode = NOOP;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = NOOP;\n                this.setNodeLocationFromNode = NOOP;\n                this.cstPostRule = NOOP;\n                this.setInitialNodeLocation = NOOP;\n            }\n            else {\n                throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n            }\n        }\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n        var nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    // CST\n    TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {\n        var cstNode = {\n            name: nestedName,\n            fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] +\n                nestedName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n        this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);\n        var cstNode = {\n            name: fullRuleName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n        this.LAST_EXPLICIT_RULE_STACK.pop();\n        this.CST_STACK.pop();\n    };\n    TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {\n        var lastCstNode = this.CST_STACK.pop();\n        // TODO: the naming is bad, this should go directly to the\n        //       (correct) cstLocation update method\n        //       e.g if we put other logic in postRule...\n        this.cstPostRule(lastCstNode);\n    };\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode or its nested children.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode or its nested children.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    };\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n        // Avoid side effects due to back tracking\n        // TODO: This costs a 2-3% in performance, A flag on IParserConfig\n        //   could be used to get rid of this conditional, but not sure its worth the effort\n        //   and API complexity.\n        if (this.isBackTracking() !== true) {\n            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n            addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n            // This is only used when **both** error recovery and CST Output are enabled.\n            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n        }\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n        if (isUndefined(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, this.allRuleNames);\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n        if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    };\n    TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {\n        var nestedName;\n        if (methodOpts.NAME !== undefined) {\n            nestedName = methodOpts.NAME;\n            this.nestedRuleInvocationStateUpdate(nestedName, laKey);\n            return nestedName;\n        }\n        else {\n            return undefined;\n        }\n    };\n    TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {\n        var ruleIdx = this.getLastExplicitRuleShortName();\n        var shortName = getKeyForAltIndex(ruleIdx, methodKeyIdx, occurrence, altIdx);\n        var nestedName;\n        if (methodOpts.NAME !== undefined) {\n            nestedName = methodOpts.NAME;\n            this.nestedRuleInvocationStateUpdate(nestedName, shortName);\n            return {\n                shortName: shortName,\n                nestedName: nestedName\n            };\n        }\n        else {\n            return undefined;\n        }\n    };\n    TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {\n        var cstStack = this.CST_STACK;\n        var nestedRuleCst = cstStack[cstStack.length - 1];\n        this.nestedRuleFinallyStateUpdate();\n        // this return a different result than the previous invocation because \"nestedRuleFinallyStateUpdate\" pops the cst stack\n        var parentCstNode = cstStack[cstStack.length - 1];\n        addNoneTerminalToCst(parentCstNode, nestedName, nestedRuleCst);\n        this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n        var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n        return this.RULE_STACK[lastExplictIndex];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];\n        return this.RULE_STACK[lastExplicitIndex];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n        return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    };\n    TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {\n        this.RULE_OCCURRENCE_STACK.push(1);\n        this.RULE_STACK.push(shortNameKey);\n        this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);\n    };\n    TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstNestedFinallyStateUpdate();\n    };\n    return TreeBuilder;\n}());\nexport { TreeBuilder };\n//# sourceMappingURL=tree_builder.js.map"]},"metadata":{},"sourceType":"module"}