{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { EmbeddedActionsParser, EMPTY_ALT, Lexer, tokenMatcher } from 'chevrotain';\nimport { CellError, ErrorType, simpleCellAddress } from '../Cell';\nimport { ErrorMessage } from '../error-message';\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from './addressRepresentationConverters';\nimport { AstNodeType, buildCellErrorAst, buildCellRangeAst, buildCellReferenceAst, buildColumnRangeAst, buildConcatenateOpAst, buildDivOpAst, buildEmptyArgAst, buildEqualsOpAst, buildErrorWithRawInputAst, buildGreaterThanOpAst, buildGreaterThanOrEqualOpAst, buildLessThanOpAst, buildLessThanOrEqualOpAst, buildMinusOpAst, buildMinusUnaryOpAst, buildNamedExpressionAst, buildNotEqualOpAst, buildNumberAst, buildParenthesisAst, buildParsingErrorAst, buildPercentOpAst, buildPlusOpAst, buildPlusUnaryOpAst, buildPowerOpAst, buildProcedureAst, buildRowRangeAst, buildStringAst, buildTimesOpAst, parsingError as _parsingError, ParsingErrorType, RangeSheetReferenceType } from './Ast';\nimport { CellAddress, CellReferenceType } from './CellAddress';\nimport { AdditionOp, BooleanOp, CellReference, ColumnRange, ConcatenateOp, DivOp, EqualsOp, ErrorLiteral, GreaterThanOp, GreaterThanOrEqualOp, LessThanOp, LessThanOrEqualOp, LParen, MinusOp, MultiplicationOp, NamedExpression, NotEqualOp, PercentOp, PlusOp, PowerOp, ProcedureName, RangeSeparator, RowRange, RParen, StringLiteral, TimesOp, WhiteSpace } from './LexerConfig';\n/**\n * LL(k) formula parser described using Chevrotain DSL\n *\n * It is equivalent to the grammar below:\n *\n * F -> '=' E <br/>\n * B -> K < B | K >= B ... | K <br/>\n * K -> E & K | E <br/>\n * E -> M + E | M - E | M <br/>\n * M -> W * M | W / M | W <br/>\n * W -> C * W | C <br/>\n * C -> N | R | O | A | P | num <br/>\n * N -> '(' E ')' <br/>\n * R -> A:OFFSET(..) | A:A <br/>\n * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>\n * A -> A1 | $A1 | A$1 | $A$1 <br/>\n * P -> SUM(..) <br/>\n */\n\nexport var FormulaParser = /*#__PURE__*/function (_EmbeddedActionsParse) {\n  _inherits(FormulaParser, _EmbeddedActionsParse);\n\n  var _super = _createSuper(FormulaParser);\n\n  function FormulaParser(lexerConfig, sheetMapping) {\n    var _this;\n\n    _classCallCheck(this, FormulaParser);\n\n    _this = _super.call(this, lexerConfig.allTokens, {\n      outputCst: false,\n      maxLookahead: 7\n    });\n    /**\n     * Entry rule\n     */\n\n    _this.formula = _this.RULE('formula', function () {\n      _this.CONSUME(EqualsOp);\n\n      return _this.SUBRULE(_this.booleanExpression);\n    });\n    /**\n     * Rule for boolean expression (e.g. 1 <= A1)\n     */\n\n    _this.booleanExpression = _this.RULE('booleanExpression', function () {\n      var lhs = _this.SUBRULE(_this.concatenateExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(BooleanOp);\n\n        var rhs = _this.SUBRULE2(_this.concatenateExpression);\n\n        if (tokenMatcher(op, EqualsOp)) {\n          lhs = buildEqualsOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, NotEqualOp)) {\n          lhs = buildNotEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOp)) {\n          lhs = buildGreaterThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOp)) {\n          lhs = buildLessThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOrEqualOp)) {\n          lhs = buildGreaterThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOrEqualOp)) {\n          lhs = buildLessThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    _this.booleanExpressionOrEmpty = _this.RULE('booleanExpressionOrEmpty', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.booleanExpression);\n        }\n      }, {\n        ALT: EMPTY_ALT(buildEmptyArgAst())\n      }]);\n    });\n    /**\n     * Rule for concatenation operator expression (e.g. \"=\" & A1)\n     */\n\n    _this.concatenateExpression = _this.RULE('concatenateExpression', function () {\n      var lhs = _this.SUBRULE(_this.additionExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(ConcatenateOp);\n\n        var rhs = _this.SUBRULE2(_this.additionExpression);\n\n        lhs = buildConcatenateOpAst(lhs, rhs, op.leadingWhitespace);\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for addition category operators (e.g. 1 + A1, 1 - A1)\n     */\n\n    _this.additionExpression = _this.RULE('additionExpression', function () {\n      var lhs = _this.SUBRULE(_this.multiplicationExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(AdditionOp);\n\n        var rhs = _this.SUBRULE2(_this.multiplicationExpression);\n\n        if (tokenMatcher(op, PlusOp)) {\n          lhs = buildPlusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, MinusOp)) {\n          lhs = buildMinusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for multiplication category operators (e.g. 1 * A1, 1 / A1)\n     */\n\n    _this.multiplicationExpression = _this.RULE('multiplicationExpression', function () {\n      var lhs = _this.SUBRULE(_this.powerExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(MultiplicationOp);\n\n        var rhs = _this.SUBRULE2(_this.powerExpression);\n\n        if (tokenMatcher(op, TimesOp)) {\n          lhs = buildTimesOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, DivOp)) {\n          lhs = buildDivOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for power expression\n     */\n\n    _this.powerExpression = _this.RULE('powerExpression', function () {\n      var lhs = _this.SUBRULE(_this.atomicExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(PowerOp);\n\n        var rhs = _this.SUBRULE2(_this.atomicExpression);\n\n        if (tokenMatcher(op, PowerOp)) {\n          lhs = buildPowerOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for atomic expressions, which is positive atomic expression or negation of it\n     */\n\n    _this.atomicExpression = _this.RULE('atomicExpression', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          var op = _this.CONSUME(AdditionOp);\n\n          var value = _this.SUBRULE(_this.atomicExpression);\n\n          if (tokenMatcher(op, PlusOp)) {\n            return buildPlusUnaryOpAst(value, op.leadingWhitespace);\n          } else if (tokenMatcher(op, MinusOp)) {\n            return buildMinusUnaryOpAst(value, op.leadingWhitespace);\n          } else {\n            _this.customParsingError = _parsingError(ParsingErrorType.ParserError, 'Mismatched token type');\n            return _this.customParsingError;\n          }\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE2(_this.rightUnaryOpAtomicExpression);\n        }\n      }]);\n    });\n    _this.rightUnaryOpAtomicExpression = _this.RULE('rightUnaryOpAtomicExpression', function () {\n      var positiveAtomicExpression = _this.SUBRULE(_this.positiveAtomicExpression);\n\n      var percentage = _this.OPTION(function () {\n        return _this.CONSUME(PercentOp);\n      });\n\n      if (percentage) {\n        return buildPercentOpAst(positiveAtomicExpression, percentage.leadingWhitespace);\n      }\n\n      return positiveAtomicExpression;\n    });\n    /**\n     * Rule for positive atomic expressions\n     */\n\n    _this.positiveAtomicExpression = _this.RULE('positiveAtomicExpression', function () {\n      return _this.OR(_this.atomicExpCache || (_this.atomicExpCache = [{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.parenthesisExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.cellRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.columnRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.rowRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.offsetExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.cellReference);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.procedureExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.namedExpressionExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          var number = _this.CONSUME(_this.lexerConfig.NumberLiteral);\n\n          return buildNumberAst(_this.numericStringToNumber(number.image), number.leadingWhitespace);\n        }\n      }, {\n        ALT: function ALT() {\n          var str = _this.CONSUME(StringLiteral);\n\n          return buildStringAst(str);\n        }\n      }, {\n        ALT: function ALT() {\n          var token = _this.CONSUME(ErrorLiteral);\n\n          var errString = token.image.toUpperCase();\n          var errorType = _this.lexerConfig.errorMapping[errString];\n\n          if (errorType) {\n            return buildCellErrorAst(new CellError(errorType), token.leadingWhitespace);\n          } else {\n            return _this.parsingError(ParsingErrorType.ParserError, 'Unknown error literal');\n          }\n        }\n      }]));\n    });\n    /**\n     * Rule for procedure expressions: SUM(1,A1)\n     */\n\n    _this.procedureExpression = _this.RULE('procedureExpression', function () {\n      var _a;\n\n      var procedureNameToken = _this.CONSUME(ProcedureName);\n\n      var procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);\n      var canonicalProcedureName = (_a = _this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n      var args = [];\n\n      var argument = _this.SUBRULE(_this.booleanExpressionOrEmpty);\n\n      _this.MANY(function () {\n        var _a;\n\n        var separator = _this.CONSUME(_this.lexerConfig.ArgSeparator);\n\n        if (argument.type === AstNodeType.EMPTY) {\n          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;\n        }\n\n        args.push(argument);\n        argument = _this.SUBRULE2(_this.booleanExpressionOrEmpty);\n      });\n\n      args.push(argument);\n\n      if (args.length === 1 && args[0].type === AstNodeType.EMPTY) {\n        args.length = 0;\n      }\n\n      var rParenToken = _this.CONSUME(RParen);\n\n      return buildProcedureAst(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    _this.namedExpressionExpression = _this.RULE('namedExpressionExpression', function () {\n      var name = _this.CONSUME(NamedExpression);\n\n      return buildNamedExpressionAst(name.image, name.leadingWhitespace);\n    });\n    /**\n     * Rule for expressions that start with OFFSET() function\n     *\n     * OFFSET() function can occur as cell reference or part of cell range.\n     * In order to preserve LL(k) properties, expressions that starts with OFFSET() functions needs to have separate rule.\n     *\n     * Proper {@link Ast} node type is built depending on the presence of {@link RangeSeparator}\n     */\n\n    _this.offsetExpression = _this.RULE('offsetExpression', function () {\n      var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n      var end;\n\n      _this.OPTION(function () {\n        _this.CONSUME(RangeSeparator);\n\n        if (offsetProcedure.type === AstNodeType.CELL_RANGE) {\n          end = _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n        } else {\n          end = _this.SUBRULE(_this.endOfRangeWithOffsetStartExpression, {\n            ARGS: [offsetProcedure]\n          });\n        }\n      });\n\n      if (end !== undefined) {\n        return end;\n      }\n\n      return offsetProcedure;\n    });\n    /**\n     * Rule for OFFSET() function expression\n     */\n\n    _this.offsetProcedureExpression = _this.RULE('offsetProcedureExpression', function () {\n      var args = [];\n\n      _this.CONSUME(_this.lexerConfig.OffsetProcedureName);\n\n      _this.CONSUME(LParen);\n\n      _this.MANY_SEP({\n        SEP: _this.lexerConfig.ArgSeparator,\n        DEF: function DEF() {\n          args.push(_this.SUBRULE(_this.booleanExpression));\n        }\n      });\n\n      _this.CONSUME(RParen);\n\n      return _this.handleOffsetHeuristic(args);\n    });\n    /**\n     * Rule for cell ranges (e.g. A1:B$3, A1:OFFSET())\n     */\n\n    _this.cellRangeExpression = _this.RULE('cellRangeExpression', function () {\n      var start = _this.CONSUME(CellReference);\n\n      _this.CONSUME2(RangeSeparator);\n\n      return _this.SUBRULE(_this.endOfRangeExpression, {\n        ARGS: [start]\n      });\n    });\n    /*\n    * Rule for column range, e.g. A:B, Sheet1!A:B, Sheet1!A:Sheet1!B\n    * */\n\n    _this.columnRangeExpression = _this.RULE('columnRangeExpression', function () {\n      var range = _this.CONSUME(ColumnRange);\n\n      var _range$image$split = range.image.split(':'),\n          _range$image$split2 = _slicedToArray(_range$image$split, 2),\n          startImage = _range$image$split2[0],\n          endImage = _range$image$split2[1];\n\n      var start = _this.ACTION(function () {\n        return columnAddressFromString(_this.sheetMapping, startImage, _this.formulaAddress);\n      });\n\n      var end = _this.ACTION(function () {\n        return columnAddressFromString(_this.sheetMapping, endImage, _this.formulaAddress);\n      });\n\n      if (start === undefined || end === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n\n      if (start.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns) || end.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n\n      if (start.sheet === null && end.sheet !== null) {\n        return _this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = _this.rangeSheetReferenceType(start.sheet, end.sheet);\n\n      if (start.sheet !== null && end.sheet === null) {\n        end = end.withAbsoluteSheet(start.sheet);\n      }\n\n      return buildColumnRangeAst(start, end, sheetReferenceType, range.leadingWhitespace);\n    });\n    /*\n    * Rule for row range, e.g. 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2\n    * */\n\n    _this.rowRangeExpression = _this.RULE('rowRangeExpression', function () {\n      var range = _this.CONSUME(RowRange);\n\n      var _range$image$split3 = range.image.split(':'),\n          _range$image$split4 = _slicedToArray(_range$image$split3, 2),\n          startImage = _range$image$split4[0],\n          endImage = _range$image$split4[1];\n\n      var start = _this.ACTION(function () {\n        return rowAddressFromString(_this.sheetMapping, startImage, _this.formulaAddress);\n      });\n\n      var end = _this.ACTION(function () {\n        return rowAddressFromString(_this.sheetMapping, endImage, _this.formulaAddress);\n      });\n\n      if (start === undefined || end === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n\n      if (start.exceedsSheetSizeLimits(_this.lexerConfig.maxRows) || end.exceedsSheetSizeLimits(_this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n\n      if (start.sheet === null && end.sheet !== null) {\n        return _this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = _this.rangeSheetReferenceType(start.sheet, end.sheet);\n\n      if (start.sheet !== null && end.sheet === null) {\n        end = end.withAbsoluteSheet(start.sheet);\n      }\n\n      return buildRowRangeAst(start, end, sheetReferenceType, range.leadingWhitespace);\n    });\n    /**\n     * Rule for cell reference expression (e.g. A1, $A1, A$1, $A$1, $Sheet42!A$17)\n     */\n\n    _this.cellReference = _this.RULE('cellReference', function () {\n      var cell = _this.CONSUME(CellReference);\n\n      var address = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, cell.image, _this.formulaAddress);\n      });\n\n      if (address === undefined) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.REF), cell.leadingWhitespace);\n      } else if (address.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.NAME), cell.leadingWhitespace);\n      } else {\n        return buildCellReferenceAst(address, cell.leadingWhitespace);\n      }\n    });\n    /**\n     * Rule for end of range expression\n     *\n     * End of range may be a cell reference or OFFSET() function call\n     */\n\n    _this.endOfRangeExpression = _this.RULE('endOfRangeExpression', function (start) {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.endRangeReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: function ALT() {\n          var _a;\n\n          var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n          var startAddress = _this.ACTION(function () {\n            return cellAddressFromString(_this.sheetMapping, start.image, _this.formulaAddress);\n          });\n\n          if (startAddress === undefined) {\n            return buildCellErrorAst(new CellError(ErrorType.REF));\n          }\n\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            var end = offsetProcedure.reference;\n            var sheetReferenceType = RangeSheetReferenceType.RELATIVE;\n\n            if (startAddress.sheet !== null) {\n              sheetReferenceType = RangeSheetReferenceType.START_ABSOLUTE;\n              end = end.withAbsoluteSheet(startAddress.sheet);\n            }\n\n            return buildCellRangeAst(startAddress, end, sheetReferenceType, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n          } else {\n            return _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for end of range expression\n     *\n     * End of range may be a cell reference or OFFSET() function call\n     */\n\n    _this.endOfRangeWithOffsetStartExpression = _this.RULE('endOfRangeWithOffsetStartExpression', function (start) {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.endRangeWithOffsetStartReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: function ALT() {\n          var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            var end = offsetProcedure.reference;\n            var sheetReferenceType = RangeSheetReferenceType.RELATIVE;\n\n            if (start.reference.sheet !== null) {\n              sheetReferenceType = RangeSheetReferenceType.START_ABSOLUTE;\n              end = end.withAbsoluteSheet(start.reference.sheet);\n            }\n\n            return buildCellRangeAst(start.reference, end, sheetReferenceType, start.leadingWhitespace);\n          } else {\n            return _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for end range reference expression with additional checks considering range start\n     */\n\n    _this.endRangeReference = _this.RULE('endRangeReference', function (start) {\n      var _a;\n\n      var end = _this.CONSUME(CellReference);\n\n      var startAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, start.image, _this.formulaAddress);\n      });\n\n      var endAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, end.image, _this.formulaAddress);\n      });\n\n      if (startAddress === undefined || endAddress === undefined) {\n        return _this.ACTION(function () {\n          return buildErrorWithRawInputAst(\"\".concat(start.image, \":\").concat(end.image), new CellError(ErrorType.REF), start.leadingWhitespace);\n        });\n      } else if (startAddress.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows)) {\n        return _this.ACTION(function () {\n          return buildErrorWithRawInputAst(\"\".concat(start.image, \":\").concat(end.image), new CellError(ErrorType.NAME), start.leadingWhitespace);\n        });\n      }\n\n      return _this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n    });\n    /**\n     * Rule for end range reference expression starting with offset procedure with additional checks considering range start\n     */\n\n    _this.endRangeWithOffsetStartReference = _this.RULE('endRangeWithOffsetStartReference', function (start) {\n      var end = _this.CONSUME(CellReference);\n\n      var endAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, end.image, _this.formulaAddress);\n      });\n\n      if (endAddress === undefined) {\n        return _this.ACTION(function () {\n          return buildCellErrorAst(new CellError(ErrorType.REF));\n        });\n      }\n\n      return _this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);\n    });\n    /**\n     * Rule for parenthesis expression\n     */\n\n    _this.parenthesisExpression = _this.RULE('parenthesisExpression', function () {\n      var lParenToken = _this.CONSUME(LParen);\n\n      var expression = _this.SUBRULE(_this.booleanExpression);\n\n      var rParenToken = _this.CONSUME(RParen);\n\n      return buildParenthesisAst(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n\n    _this.numericStringToNumber = function (input) {\n      var normalized = input.replace(_this.lexerConfig.decimalSeparator, '.');\n      return Number(normalized);\n    };\n\n    _this.lexerConfig = lexerConfig;\n    _this.sheetMapping = sheetMapping;\n    _this.formulaAddress = simpleCellAddress(0, 0, 0);\n\n    _this.performSelfAnalysis();\n\n    return _this;\n  }\n  /**\n   * Parses tokenized formula and builds abstract syntax tree\n   *\n   * @param tokens - tokenized formula\n   * @param formulaAddress - address of the cell in which formula is located\n   */\n\n\n  _createClass(FormulaParser, [{\n    key: \"parseFromTokens\",\n    value: function parseFromTokens(tokens, formulaAddress) {\n      this.input = tokens;\n      var ast = this.formulaWithContext(formulaAddress);\n      var errors = [];\n\n      if (this.customParsingError) {\n        errors.push(this.customParsingError);\n      }\n\n      errors = errors.concat(this.errors.map(function (e) {\n        return {\n          type: ParsingErrorType.ParserError,\n          message: e.message\n        };\n      }));\n\n      if (errors.length > 0) {\n        ast = buildParsingErrorAst();\n      }\n\n      return {\n        ast: ast,\n        errors: errors\n      };\n    }\n    /**\n     * Entry rule wrapper that sets formula address\n     *\n     * @param address - address of the cell in which formula is located\n     */\n\n  }, {\n    key: \"formulaWithContext\",\n    value: function formulaWithContext(address) {\n      this.formulaAddress = address;\n      return this.formula();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(FormulaParser.prototype), \"reset\", this).call(this);\n\n      this.customParsingError = undefined;\n    }\n  }, {\n    key: \"buildCellRange\",\n    value: function buildCellRange(startAddress, endAddress, leadingWhitespace) {\n      if (startAddress.sheet === null && endAddress.sheet !== null) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = this.rangeSheetReferenceType(startAddress.sheet, endAddress.sheet);\n\n      if (startAddress.sheet !== null && endAddress.sheet === null) {\n        endAddress = endAddress.withAbsoluteSheet(startAddress.sheet);\n      }\n\n      return buildCellRangeAst(startAddress, endAddress, sheetReferenceType, leadingWhitespace);\n    }\n    /**\n     * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments\n     *\n     * @param args - OFFSET function arguments\n     */\n\n  }, {\n    key: \"handleOffsetHeuristic\",\n    value: function handleOffsetHeuristic(args) {\n      var cellArg = args[0];\n\n      if (cellArg.type !== AstNodeType.CELL_REFERENCE) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');\n      }\n\n      var rowsArg = args[1];\n      var rowShift;\n\n      if (rowsArg.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {\n        rowShift = rowsArg.value;\n      } else if (rowsArg.type === AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n        rowShift = rowsArg.value.value;\n      } else if (rowsArg.type === AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n        rowShift = -rowsArg.value.value;\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');\n      }\n\n      var columnsArg = args[2];\n      var colShift;\n\n      if (columnsArg.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {\n        colShift = columnsArg.value;\n      } else if (columnsArg.type === AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n        colShift = columnsArg.value.value;\n      } else if (columnsArg.type === AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n        colShift = -columnsArg.value.value;\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');\n      }\n\n      var heightArg = args[3];\n      var height;\n\n      if (heightArg === undefined) {\n        height = 1;\n      } else if (heightArg.type === AstNodeType.NUMBER) {\n        height = heightArg.value;\n\n        if (height < 1) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');\n        } else if (!Number.isInteger(height)) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');\n        }\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');\n      }\n\n      var widthArg = args[4];\n      var width;\n\n      if (widthArg === undefined) {\n        width = 1;\n      } else if (widthArg.type === AstNodeType.NUMBER) {\n        width = widthArg.value;\n\n        if (width < 1) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');\n        } else if (!Number.isInteger(width)) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');\n        }\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');\n      }\n\n      var topLeftCorner = new CellAddress(null, cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);\n      var absoluteCol = topLeftCorner.col;\n      var absoluteRow = topLeftCorner.row;\n\n      if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n        absoluteRow = absoluteRow + this.formulaAddress.row;\n      }\n\n      if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        absoluteCol = absoluteCol + this.formulaAddress.col;\n      }\n\n      if (absoluteCol < 0 || absoluteRow < 0) {\n        return buildCellErrorAst(new CellError(ErrorType.REF, ErrorMessage.OutOfSheet));\n      }\n\n      if (width === 1 && height === 1) {\n        return buildCellReferenceAst(topLeftCorner);\n      } else {\n        var bottomRightCorner = new CellAddress(null, topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);\n        return buildCellRangeAst(topLeftCorner, bottomRightCorner, RangeSheetReferenceType.RELATIVE);\n      }\n    }\n  }, {\n    key: \"parsingError\",\n    value: function parsingError(type, message) {\n      this.customParsingError = _parsingError(type, message);\n      return buildParsingErrorAst();\n    }\n  }, {\n    key: \"rangeSheetReferenceType\",\n    value: function rangeSheetReferenceType(start, end) {\n      if (start === null) {\n        return RangeSheetReferenceType.RELATIVE;\n      } else if (end === null) {\n        return RangeSheetReferenceType.START_ABSOLUTE;\n      } else {\n        return RangeSheetReferenceType.BOTH_ABSOLUTE;\n      }\n    }\n  }]);\n\n  return FormulaParser;\n}(EmbeddedActionsParser);\nexport var FormulaLexer = /*#__PURE__*/function () {\n  function FormulaLexer(lexerConfig) {\n    _classCallCheck(this, FormulaLexer);\n\n    this.lexerConfig = lexerConfig;\n    this.lexer = new Lexer(lexerConfig.allTokens, {\n      ensureOptimizations: true\n    });\n  }\n  /**\n   * Returns Lexer tokens from formula string\n   *\n   * @param text - string representation of a formula\n   */\n\n\n  _createClass(FormulaLexer, [{\n    key: \"tokenizeFormula\",\n    value: function tokenizeFormula(text) {\n      var lexingResult = this.lexer.tokenize(text);\n      var tokens = lexingResult.tokens;\n      tokens = this.trimTrailingWhitespaces(tokens);\n      tokens = this.skipWhitespacesInsideRanges(tokens);\n      tokens = this.skipWhitespacesBeforeArgSeparators(tokens);\n      lexingResult.tokens = tokens;\n      return lexingResult;\n    }\n  }, {\n    key: \"skipWhitespacesInsideRanges\",\n    value: function skipWhitespacesInsideRanges(tokens) {\n      return this.filterTokensByNeighbors(tokens, function (previous, current, next) {\n        return (tokenMatcher(previous, CellReference) || tokenMatcher(previous, RangeSeparator)) && tokenMatcher(current, WhiteSpace) && (tokenMatcher(next, CellReference) || tokenMatcher(next, RangeSeparator));\n      });\n    }\n  }, {\n    key: \"skipWhitespacesBeforeArgSeparators\",\n    value: function skipWhitespacesBeforeArgSeparators(tokens) {\n      var _this2 = this;\n\n      return this.filterTokensByNeighbors(tokens, function (previous, current, next) {\n        return !tokenMatcher(previous, _this2.lexerConfig.ArgSeparator) && tokenMatcher(current, WhiteSpace) && tokenMatcher(next, _this2.lexerConfig.ArgSeparator);\n      });\n    }\n  }, {\n    key: \"filterTokensByNeighbors\",\n    value: function filterTokensByNeighbors(tokens, shouldBeSkipped) {\n      if (tokens.length < 3) {\n        return tokens;\n      }\n\n      var i = 0;\n      var filteredTokens = [tokens[i++]];\n\n      while (i < tokens.length - 1) {\n        if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {\n          filteredTokens.push(tokens[i]);\n        }\n\n        ++i;\n      }\n\n      filteredTokens.push(tokens[i]);\n      return filteredTokens;\n    }\n  }, {\n    key: \"trimTrailingWhitespaces\",\n    value: function trimTrailingWhitespaces(tokens) {\n      if (tokens.length > 0 && tokenMatcher(tokens[tokens.length - 1], WhiteSpace)) {\n        tokens.pop();\n      }\n\n      return tokens;\n    }\n  }]);\n\n  return FormulaLexer;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/FormulaParser.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","object","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","arguments","apply","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","EmbeddedActionsParser","EMPTY_ALT","Lexer","tokenMatcher","CellError","ErrorType","simpleCellAddress","ErrorMessage","cellAddressFromString","columnAddressFromString","rowAddressFromString","AstNodeType","buildCellErrorAst","buildCellRangeAst","buildCellReferenceAst","buildColumnRangeAst","buildConcatenateOpAst","buildDivOpAst","buildEmptyArgAst","buildEqualsOpAst","buildErrorWithRawInputAst","buildGreaterThanOpAst","buildGreaterThanOrEqualOpAst","buildLessThanOpAst","buildLessThanOrEqualOpAst","buildMinusOpAst","buildMinusUnaryOpAst","buildNamedExpressionAst","buildNotEqualOpAst","buildNumberAst","buildParenthesisAst","buildParsingErrorAst","buildPercentOpAst","buildPlusOpAst","buildPlusUnaryOpAst","buildPowerOpAst","buildProcedureAst","buildRowRangeAst","buildStringAst","buildTimesOpAst","parsingError","_parsingError","ParsingErrorType","RangeSheetReferenceType","CellAddress","CellReferenceType","AdditionOp","BooleanOp","CellReference","ColumnRange","ConcatenateOp","DivOp","EqualsOp","ErrorLiteral","GreaterThanOp","GreaterThanOrEqualOp","LessThanOp","LessThanOrEqualOp","LParen","MinusOp","MultiplicationOp","NamedExpression","NotEqualOp","PercentOp","PlusOp","PowerOp","ProcedureName","RangeSeparator","RowRange","RParen","StringLiteral","TimesOp","WhiteSpace","FormulaParser","_EmbeddedActionsParse","_super","lexerConfig","sheetMapping","_this","allTokens","outputCst","maxLookahead","formula","RULE","CONSUME","SUBRULE","booleanExpression","lhs","concatenateExpression","MANY","op","rhs","SUBRULE2","leadingWhitespace","ACTION","Error","booleanExpressionOrEmpty","OR","ALT","additionExpression","multiplicationExpression","powerExpression","atomicExpression","customParsingError","ParserError","rightUnaryOpAtomicExpression","positiveAtomicExpression","percentage","OPTION","atomicExpCache","parenthesisExpression","cellRangeExpression","columnRangeExpression","rowRangeExpression","offsetExpression","cellReference","procedureExpression","namedExpressionExpression","number","NumberLiteral","numericStringToNumber","image","str","token","errString","toUpperCase","errorType","errorMapping","_a","procedureNameToken","procedureName","canonicalProcedureName","functionMapping","args","argument","separator","ArgSeparator","type","EMPTY","rParenToken","offsetProcedure","offsetProcedureExpression","end","CELL_RANGE","RangeOffsetNotAllowed","endOfRangeWithOffsetStartExpression","ARGS","undefined","OffsetProcedureName","MANY_SEP","SEP","DEF","handleOffsetHeuristic","start","CONSUME2","endOfRangeExpression","range","_range$image$split","split","_range$image$split2","startImage","endImage","formulaAddress","REF","exceedsSheetSizeLimits","maxColumns","NAME","sheet","sheetReferenceType","rangeSheetReferenceType","withAbsoluteSheet","_range$image$split3","_range$image$split4","maxRows","cell","address","endRangeReference","startAddress","CELL_REFERENCE","reference","RELATIVE","START_ABSOLUTE","endRangeWithOffsetStartReference","endAddress","concat","buildCellRange","lParenToken","expression","input","normalized","replace","decimalSeparator","Number","performSelfAnalysis","parseFromTokens","tokens","ast","formulaWithContext","errors","map","message","reset","cellArg","StaticOffsetError","rowsArg","rowShift","NUMBER","isInteger","PLUS_UNARY_OP","MINUS_UNARY_OP","columnsArg","colShift","heightArg","height","widthArg","width","topLeftCorner","col","row","absoluteCol","absoluteRow","CELL_REFERENCE_RELATIVE","CELL_REFERENCE_ABSOLUTE_COL","CELL_REFERENCE_ABSOLUTE_ROW","OutOfSheet","bottomRightCorner","BOTH_ABSOLUTE","FormulaLexer","lexer","ensureOptimizations","tokenizeFormula","text","lexingResult","tokenize","trimTrailingWhitespaces","skipWhitespacesInsideRanges","skipWhitespacesBeforeArgSeparators","filterTokensByNeighbors","previous","current","_this2","shouldBeSkipped","filteredTokens","pop"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { EmbeddedActionsParser, EMPTY_ALT, Lexer, tokenMatcher } from 'chevrotain';\nimport { CellError, ErrorType, simpleCellAddress } from '../Cell';\nimport { ErrorMessage } from '../error-message';\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from './addressRepresentationConverters';\nimport { AstNodeType, buildCellErrorAst, buildCellRangeAst, buildCellReferenceAst, buildColumnRangeAst, buildConcatenateOpAst, buildDivOpAst, buildEmptyArgAst, buildEqualsOpAst, buildErrorWithRawInputAst, buildGreaterThanOpAst, buildGreaterThanOrEqualOpAst, buildLessThanOpAst, buildLessThanOrEqualOpAst, buildMinusOpAst, buildMinusUnaryOpAst, buildNamedExpressionAst, buildNotEqualOpAst, buildNumberAst, buildParenthesisAst, buildParsingErrorAst, buildPercentOpAst, buildPlusOpAst, buildPlusUnaryOpAst, buildPowerOpAst, buildProcedureAst, buildRowRangeAst, buildStringAst, buildTimesOpAst, parsingError as _parsingError, ParsingErrorType, RangeSheetReferenceType } from './Ast';\nimport { CellAddress, CellReferenceType } from './CellAddress';\nimport { AdditionOp, BooleanOp, CellReference, ColumnRange, ConcatenateOp, DivOp, EqualsOp, ErrorLiteral, GreaterThanOp, GreaterThanOrEqualOp, LessThanOp, LessThanOrEqualOp, LParen, MinusOp, MultiplicationOp, NamedExpression, NotEqualOp, PercentOp, PlusOp, PowerOp, ProcedureName, RangeSeparator, RowRange, RParen, StringLiteral, TimesOp, WhiteSpace } from './LexerConfig';\n/**\n * LL(k) formula parser described using Chevrotain DSL\n *\n * It is equivalent to the grammar below:\n *\n * F -> '=' E <br/>\n * B -> K < B | K >= B ... | K <br/>\n * K -> E & K | E <br/>\n * E -> M + E | M - E | M <br/>\n * M -> W * M | W / M | W <br/>\n * W -> C * W | C <br/>\n * C -> N | R | O | A | P | num <br/>\n * N -> '(' E ')' <br/>\n * R -> A:OFFSET(..) | A:A <br/>\n * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>\n * A -> A1 | $A1 | A$1 | $A$1 <br/>\n * P -> SUM(..) <br/>\n */\n\nexport var FormulaParser = /*#__PURE__*/function (_EmbeddedActionsParse) {\n  _inherits(FormulaParser, _EmbeddedActionsParse);\n\n  var _super = _createSuper(FormulaParser);\n\n  function FormulaParser(lexerConfig, sheetMapping) {\n    var _this;\n\n    _classCallCheck(this, FormulaParser);\n\n    _this = _super.call(this, lexerConfig.allTokens, {\n      outputCst: false,\n      maxLookahead: 7\n    });\n    /**\n     * Entry rule\n     */\n\n    _this.formula = _this.RULE('formula', function () {\n      _this.CONSUME(EqualsOp);\n\n      return _this.SUBRULE(_this.booleanExpression);\n    });\n    /**\n     * Rule for boolean expression (e.g. 1 <= A1)\n     */\n\n    _this.booleanExpression = _this.RULE('booleanExpression', function () {\n      var lhs = _this.SUBRULE(_this.concatenateExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(BooleanOp);\n\n        var rhs = _this.SUBRULE2(_this.concatenateExpression);\n\n        if (tokenMatcher(op, EqualsOp)) {\n          lhs = buildEqualsOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, NotEqualOp)) {\n          lhs = buildNotEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOp)) {\n          lhs = buildGreaterThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOp)) {\n          lhs = buildLessThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOrEqualOp)) {\n          lhs = buildGreaterThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOrEqualOp)) {\n          lhs = buildLessThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    _this.booleanExpressionOrEmpty = _this.RULE('booleanExpressionOrEmpty', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.booleanExpression);\n        }\n      }, {\n        ALT: EMPTY_ALT(buildEmptyArgAst())\n      }]);\n    });\n    /**\n     * Rule for concatenation operator expression (e.g. \"=\" & A1)\n     */\n\n    _this.concatenateExpression = _this.RULE('concatenateExpression', function () {\n      var lhs = _this.SUBRULE(_this.additionExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(ConcatenateOp);\n\n        var rhs = _this.SUBRULE2(_this.additionExpression);\n\n        lhs = buildConcatenateOpAst(lhs, rhs, op.leadingWhitespace);\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for addition category operators (e.g. 1 + A1, 1 - A1)\n     */\n\n    _this.additionExpression = _this.RULE('additionExpression', function () {\n      var lhs = _this.SUBRULE(_this.multiplicationExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(AdditionOp);\n\n        var rhs = _this.SUBRULE2(_this.multiplicationExpression);\n\n        if (tokenMatcher(op, PlusOp)) {\n          lhs = buildPlusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, MinusOp)) {\n          lhs = buildMinusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for multiplication category operators (e.g. 1 * A1, 1 / A1)\n     */\n\n    _this.multiplicationExpression = _this.RULE('multiplicationExpression', function () {\n      var lhs = _this.SUBRULE(_this.powerExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(MultiplicationOp);\n\n        var rhs = _this.SUBRULE2(_this.powerExpression);\n\n        if (tokenMatcher(op, TimesOp)) {\n          lhs = buildTimesOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, DivOp)) {\n          lhs = buildDivOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for power expression\n     */\n\n    _this.powerExpression = _this.RULE('powerExpression', function () {\n      var lhs = _this.SUBRULE(_this.atomicExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(PowerOp);\n\n        var rhs = _this.SUBRULE2(_this.atomicExpression);\n\n        if (tokenMatcher(op, PowerOp)) {\n          lhs = buildPowerOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for atomic expressions, which is positive atomic expression or negation of it\n     */\n\n    _this.atomicExpression = _this.RULE('atomicExpression', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          var op = _this.CONSUME(AdditionOp);\n\n          var value = _this.SUBRULE(_this.atomicExpression);\n\n          if (tokenMatcher(op, PlusOp)) {\n            return buildPlusUnaryOpAst(value, op.leadingWhitespace);\n          } else if (tokenMatcher(op, MinusOp)) {\n            return buildMinusUnaryOpAst(value, op.leadingWhitespace);\n          } else {\n            _this.customParsingError = _parsingError(ParsingErrorType.ParserError, 'Mismatched token type');\n            return _this.customParsingError;\n          }\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE2(_this.rightUnaryOpAtomicExpression);\n        }\n      }]);\n    });\n    _this.rightUnaryOpAtomicExpression = _this.RULE('rightUnaryOpAtomicExpression', function () {\n      var positiveAtomicExpression = _this.SUBRULE(_this.positiveAtomicExpression);\n\n      var percentage = _this.OPTION(function () {\n        return _this.CONSUME(PercentOp);\n      });\n\n      if (percentage) {\n        return buildPercentOpAst(positiveAtomicExpression, percentage.leadingWhitespace);\n      }\n\n      return positiveAtomicExpression;\n    });\n    /**\n     * Rule for positive atomic expressions\n     */\n\n    _this.positiveAtomicExpression = _this.RULE('positiveAtomicExpression', function () {\n      return _this.OR(_this.atomicExpCache || (_this.atomicExpCache = [{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.parenthesisExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.cellRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.columnRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.rowRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.offsetExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.cellReference);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.procedureExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.namedExpressionExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          var number = _this.CONSUME(_this.lexerConfig.NumberLiteral);\n\n          return buildNumberAst(_this.numericStringToNumber(number.image), number.leadingWhitespace);\n        }\n      }, {\n        ALT: function ALT() {\n          var str = _this.CONSUME(StringLiteral);\n\n          return buildStringAst(str);\n        }\n      }, {\n        ALT: function ALT() {\n          var token = _this.CONSUME(ErrorLiteral);\n\n          var errString = token.image.toUpperCase();\n          var errorType = _this.lexerConfig.errorMapping[errString];\n\n          if (errorType) {\n            return buildCellErrorAst(new CellError(errorType), token.leadingWhitespace);\n          } else {\n            return _this.parsingError(ParsingErrorType.ParserError, 'Unknown error literal');\n          }\n        }\n      }]));\n    });\n    /**\n     * Rule for procedure expressions: SUM(1,A1)\n     */\n\n    _this.procedureExpression = _this.RULE('procedureExpression', function () {\n      var _a;\n\n      var procedureNameToken = _this.CONSUME(ProcedureName);\n\n      var procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);\n      var canonicalProcedureName = (_a = _this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n      var args = [];\n\n      var argument = _this.SUBRULE(_this.booleanExpressionOrEmpty);\n\n      _this.MANY(function () {\n        var _a;\n\n        var separator = _this.CONSUME(_this.lexerConfig.ArgSeparator);\n\n        if (argument.type === AstNodeType.EMPTY) {\n          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;\n        }\n\n        args.push(argument);\n        argument = _this.SUBRULE2(_this.booleanExpressionOrEmpty);\n      });\n\n      args.push(argument);\n\n      if (args.length === 1 && args[0].type === AstNodeType.EMPTY) {\n        args.length = 0;\n      }\n\n      var rParenToken = _this.CONSUME(RParen);\n\n      return buildProcedureAst(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    _this.namedExpressionExpression = _this.RULE('namedExpressionExpression', function () {\n      var name = _this.CONSUME(NamedExpression);\n\n      return buildNamedExpressionAst(name.image, name.leadingWhitespace);\n    });\n    /**\n     * Rule for expressions that start with OFFSET() function\n     *\n     * OFFSET() function can occur as cell reference or part of cell range.\n     * In order to preserve LL(k) properties, expressions that starts with OFFSET() functions needs to have separate rule.\n     *\n     * Proper {@link Ast} node type is built depending on the presence of {@link RangeSeparator}\n     */\n\n    _this.offsetExpression = _this.RULE('offsetExpression', function () {\n      var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n      var end;\n\n      _this.OPTION(function () {\n        _this.CONSUME(RangeSeparator);\n\n        if (offsetProcedure.type === AstNodeType.CELL_RANGE) {\n          end = _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n        } else {\n          end = _this.SUBRULE(_this.endOfRangeWithOffsetStartExpression, {\n            ARGS: [offsetProcedure]\n          });\n        }\n      });\n\n      if (end !== undefined) {\n        return end;\n      }\n\n      return offsetProcedure;\n    });\n    /**\n     * Rule for OFFSET() function expression\n     */\n\n    _this.offsetProcedureExpression = _this.RULE('offsetProcedureExpression', function () {\n      var args = [];\n\n      _this.CONSUME(_this.lexerConfig.OffsetProcedureName);\n\n      _this.CONSUME(LParen);\n\n      _this.MANY_SEP({\n        SEP: _this.lexerConfig.ArgSeparator,\n        DEF: function DEF() {\n          args.push(_this.SUBRULE(_this.booleanExpression));\n        }\n      });\n\n      _this.CONSUME(RParen);\n\n      return _this.handleOffsetHeuristic(args);\n    });\n    /**\n     * Rule for cell ranges (e.g. A1:B$3, A1:OFFSET())\n     */\n\n    _this.cellRangeExpression = _this.RULE('cellRangeExpression', function () {\n      var start = _this.CONSUME(CellReference);\n\n      _this.CONSUME2(RangeSeparator);\n\n      return _this.SUBRULE(_this.endOfRangeExpression, {\n        ARGS: [start]\n      });\n    });\n    /*\n    * Rule for column range, e.g. A:B, Sheet1!A:B, Sheet1!A:Sheet1!B\n    * */\n\n    _this.columnRangeExpression = _this.RULE('columnRangeExpression', function () {\n      var range = _this.CONSUME(ColumnRange);\n\n      var _range$image$split = range.image.split(':'),\n          _range$image$split2 = _slicedToArray(_range$image$split, 2),\n          startImage = _range$image$split2[0],\n          endImage = _range$image$split2[1];\n\n      var start = _this.ACTION(function () {\n        return columnAddressFromString(_this.sheetMapping, startImage, _this.formulaAddress);\n      });\n\n      var end = _this.ACTION(function () {\n        return columnAddressFromString(_this.sheetMapping, endImage, _this.formulaAddress);\n      });\n\n      if (start === undefined || end === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n\n      if (start.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns) || end.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n\n      if (start.sheet === null && end.sheet !== null) {\n        return _this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = _this.rangeSheetReferenceType(start.sheet, end.sheet);\n\n      if (start.sheet !== null && end.sheet === null) {\n        end = end.withAbsoluteSheet(start.sheet);\n      }\n\n      return buildColumnRangeAst(start, end, sheetReferenceType, range.leadingWhitespace);\n    });\n    /*\n    * Rule for row range, e.g. 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2\n    * */\n\n    _this.rowRangeExpression = _this.RULE('rowRangeExpression', function () {\n      var range = _this.CONSUME(RowRange);\n\n      var _range$image$split3 = range.image.split(':'),\n          _range$image$split4 = _slicedToArray(_range$image$split3, 2),\n          startImage = _range$image$split4[0],\n          endImage = _range$image$split4[1];\n\n      var start = _this.ACTION(function () {\n        return rowAddressFromString(_this.sheetMapping, startImage, _this.formulaAddress);\n      });\n\n      var end = _this.ACTION(function () {\n        return rowAddressFromString(_this.sheetMapping, endImage, _this.formulaAddress);\n      });\n\n      if (start === undefined || end === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n\n      if (start.exceedsSheetSizeLimits(_this.lexerConfig.maxRows) || end.exceedsSheetSizeLimits(_this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n\n      if (start.sheet === null && end.sheet !== null) {\n        return _this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = _this.rangeSheetReferenceType(start.sheet, end.sheet);\n\n      if (start.sheet !== null && end.sheet === null) {\n        end = end.withAbsoluteSheet(start.sheet);\n      }\n\n      return buildRowRangeAst(start, end, sheetReferenceType, range.leadingWhitespace);\n    });\n    /**\n     * Rule for cell reference expression (e.g. A1, $A1, A$1, $A$1, $Sheet42!A$17)\n     */\n\n    _this.cellReference = _this.RULE('cellReference', function () {\n      var cell = _this.CONSUME(CellReference);\n\n      var address = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, cell.image, _this.formulaAddress);\n      });\n\n      if (address === undefined) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.REF), cell.leadingWhitespace);\n      } else if (address.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.NAME), cell.leadingWhitespace);\n      } else {\n        return buildCellReferenceAst(address, cell.leadingWhitespace);\n      }\n    });\n    /**\n     * Rule for end of range expression\n     *\n     * End of range may be a cell reference or OFFSET() function call\n     */\n\n    _this.endOfRangeExpression = _this.RULE('endOfRangeExpression', function (start) {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.endRangeReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: function ALT() {\n          var _a;\n\n          var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n          var startAddress = _this.ACTION(function () {\n            return cellAddressFromString(_this.sheetMapping, start.image, _this.formulaAddress);\n          });\n\n          if (startAddress === undefined) {\n            return buildCellErrorAst(new CellError(ErrorType.REF));\n          }\n\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            var end = offsetProcedure.reference;\n            var sheetReferenceType = RangeSheetReferenceType.RELATIVE;\n\n            if (startAddress.sheet !== null) {\n              sheetReferenceType = RangeSheetReferenceType.START_ABSOLUTE;\n              end = end.withAbsoluteSheet(startAddress.sheet);\n            }\n\n            return buildCellRangeAst(startAddress, end, sheetReferenceType, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n          } else {\n            return _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for end of range expression\n     *\n     * End of range may be a cell reference or OFFSET() function call\n     */\n\n    _this.endOfRangeWithOffsetStartExpression = _this.RULE('endOfRangeWithOffsetStartExpression', function (start) {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.endRangeWithOffsetStartReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: function ALT() {\n          var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            var end = offsetProcedure.reference;\n            var sheetReferenceType = RangeSheetReferenceType.RELATIVE;\n\n            if (start.reference.sheet !== null) {\n              sheetReferenceType = RangeSheetReferenceType.START_ABSOLUTE;\n              end = end.withAbsoluteSheet(start.reference.sheet);\n            }\n\n            return buildCellRangeAst(start.reference, end, sheetReferenceType, start.leadingWhitespace);\n          } else {\n            return _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for end range reference expression with additional checks considering range start\n     */\n\n    _this.endRangeReference = _this.RULE('endRangeReference', function (start) {\n      var _a;\n\n      var end = _this.CONSUME(CellReference);\n\n      var startAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, start.image, _this.formulaAddress);\n      });\n\n      var endAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, end.image, _this.formulaAddress);\n      });\n\n      if (startAddress === undefined || endAddress === undefined) {\n        return _this.ACTION(function () {\n          return buildErrorWithRawInputAst(\"\".concat(start.image, \":\").concat(end.image), new CellError(ErrorType.REF), start.leadingWhitespace);\n        });\n      } else if (startAddress.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows)) {\n        return _this.ACTION(function () {\n          return buildErrorWithRawInputAst(\"\".concat(start.image, \":\").concat(end.image), new CellError(ErrorType.NAME), start.leadingWhitespace);\n        });\n      }\n\n      return _this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n    });\n    /**\n     * Rule for end range reference expression starting with offset procedure with additional checks considering range start\n     */\n\n    _this.endRangeWithOffsetStartReference = _this.RULE('endRangeWithOffsetStartReference', function (start) {\n      var end = _this.CONSUME(CellReference);\n\n      var endAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, end.image, _this.formulaAddress);\n      });\n\n      if (endAddress === undefined) {\n        return _this.ACTION(function () {\n          return buildCellErrorAst(new CellError(ErrorType.REF));\n        });\n      }\n\n      return _this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);\n    });\n    /**\n     * Rule for parenthesis expression\n     */\n\n    _this.parenthesisExpression = _this.RULE('parenthesisExpression', function () {\n      var lParenToken = _this.CONSUME(LParen);\n\n      var expression = _this.SUBRULE(_this.booleanExpression);\n\n      var rParenToken = _this.CONSUME(RParen);\n\n      return buildParenthesisAst(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n\n    _this.numericStringToNumber = function (input) {\n      var normalized = input.replace(_this.lexerConfig.decimalSeparator, '.');\n      return Number(normalized);\n    };\n\n    _this.lexerConfig = lexerConfig;\n    _this.sheetMapping = sheetMapping;\n    _this.formulaAddress = simpleCellAddress(0, 0, 0);\n\n    _this.performSelfAnalysis();\n\n    return _this;\n  }\n  /**\n   * Parses tokenized formula and builds abstract syntax tree\n   *\n   * @param tokens - tokenized formula\n   * @param formulaAddress - address of the cell in which formula is located\n   */\n\n\n  _createClass(FormulaParser, [{\n    key: \"parseFromTokens\",\n    value: function parseFromTokens(tokens, formulaAddress) {\n      this.input = tokens;\n      var ast = this.formulaWithContext(formulaAddress);\n      var errors = [];\n\n      if (this.customParsingError) {\n        errors.push(this.customParsingError);\n      }\n\n      errors = errors.concat(this.errors.map(function (e) {\n        return {\n          type: ParsingErrorType.ParserError,\n          message: e.message\n        };\n      }));\n\n      if (errors.length > 0) {\n        ast = buildParsingErrorAst();\n      }\n\n      return {\n        ast: ast,\n        errors: errors\n      };\n    }\n    /**\n     * Entry rule wrapper that sets formula address\n     *\n     * @param address - address of the cell in which formula is located\n     */\n\n  }, {\n    key: \"formulaWithContext\",\n    value: function formulaWithContext(address) {\n      this.formulaAddress = address;\n      return this.formula();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(FormulaParser.prototype), \"reset\", this).call(this);\n\n      this.customParsingError = undefined;\n    }\n  }, {\n    key: \"buildCellRange\",\n    value: function buildCellRange(startAddress, endAddress, leadingWhitespace) {\n      if (startAddress.sheet === null && endAddress.sheet !== null) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = this.rangeSheetReferenceType(startAddress.sheet, endAddress.sheet);\n\n      if (startAddress.sheet !== null && endAddress.sheet === null) {\n        endAddress = endAddress.withAbsoluteSheet(startAddress.sheet);\n      }\n\n      return buildCellRangeAst(startAddress, endAddress, sheetReferenceType, leadingWhitespace);\n    }\n    /**\n     * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments\n     *\n     * @param args - OFFSET function arguments\n     */\n\n  }, {\n    key: \"handleOffsetHeuristic\",\n    value: function handleOffsetHeuristic(args) {\n      var cellArg = args[0];\n\n      if (cellArg.type !== AstNodeType.CELL_REFERENCE) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');\n      }\n\n      var rowsArg = args[1];\n      var rowShift;\n\n      if (rowsArg.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {\n        rowShift = rowsArg.value;\n      } else if (rowsArg.type === AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n        rowShift = rowsArg.value.value;\n      } else if (rowsArg.type === AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n        rowShift = -rowsArg.value.value;\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');\n      }\n\n      var columnsArg = args[2];\n      var colShift;\n\n      if (columnsArg.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {\n        colShift = columnsArg.value;\n      } else if (columnsArg.type === AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n        colShift = columnsArg.value.value;\n      } else if (columnsArg.type === AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n        colShift = -columnsArg.value.value;\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');\n      }\n\n      var heightArg = args[3];\n      var height;\n\n      if (heightArg === undefined) {\n        height = 1;\n      } else if (heightArg.type === AstNodeType.NUMBER) {\n        height = heightArg.value;\n\n        if (height < 1) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');\n        } else if (!Number.isInteger(height)) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');\n        }\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');\n      }\n\n      var widthArg = args[4];\n      var width;\n\n      if (widthArg === undefined) {\n        width = 1;\n      } else if (widthArg.type === AstNodeType.NUMBER) {\n        width = widthArg.value;\n\n        if (width < 1) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');\n        } else if (!Number.isInteger(width)) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');\n        }\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');\n      }\n\n      var topLeftCorner = new CellAddress(null, cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);\n      var absoluteCol = topLeftCorner.col;\n      var absoluteRow = topLeftCorner.row;\n\n      if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n        absoluteRow = absoluteRow + this.formulaAddress.row;\n      }\n\n      if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        absoluteCol = absoluteCol + this.formulaAddress.col;\n      }\n\n      if (absoluteCol < 0 || absoluteRow < 0) {\n        return buildCellErrorAst(new CellError(ErrorType.REF, ErrorMessage.OutOfSheet));\n      }\n\n      if (width === 1 && height === 1) {\n        return buildCellReferenceAst(topLeftCorner);\n      } else {\n        var bottomRightCorner = new CellAddress(null, topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);\n        return buildCellRangeAst(topLeftCorner, bottomRightCorner, RangeSheetReferenceType.RELATIVE);\n      }\n    }\n  }, {\n    key: \"parsingError\",\n    value: function parsingError(type, message) {\n      this.customParsingError = _parsingError(type, message);\n      return buildParsingErrorAst();\n    }\n  }, {\n    key: \"rangeSheetReferenceType\",\n    value: function rangeSheetReferenceType(start, end) {\n      if (start === null) {\n        return RangeSheetReferenceType.RELATIVE;\n      } else if (end === null) {\n        return RangeSheetReferenceType.START_ABSOLUTE;\n      } else {\n        return RangeSheetReferenceType.BOTH_ABSOLUTE;\n      }\n    }\n  }]);\n\n  return FormulaParser;\n}(EmbeddedActionsParser);\nexport var FormulaLexer = /*#__PURE__*/function () {\n  function FormulaLexer(lexerConfig) {\n    _classCallCheck(this, FormulaLexer);\n\n    this.lexerConfig = lexerConfig;\n    this.lexer = new Lexer(lexerConfig.allTokens, {\n      ensureOptimizations: true\n    });\n  }\n  /**\n   * Returns Lexer tokens from formula string\n   *\n   * @param text - string representation of a formula\n   */\n\n\n  _createClass(FormulaLexer, [{\n    key: \"tokenizeFormula\",\n    value: function tokenizeFormula(text) {\n      var lexingResult = this.lexer.tokenize(text);\n      var tokens = lexingResult.tokens;\n      tokens = this.trimTrailingWhitespaces(tokens);\n      tokens = this.skipWhitespacesInsideRanges(tokens);\n      tokens = this.skipWhitespacesBeforeArgSeparators(tokens);\n      lexingResult.tokens = tokens;\n      return lexingResult;\n    }\n  }, {\n    key: \"skipWhitespacesInsideRanges\",\n    value: function skipWhitespacesInsideRanges(tokens) {\n      return this.filterTokensByNeighbors(tokens, function (previous, current, next) {\n        return (tokenMatcher(previous, CellReference) || tokenMatcher(previous, RangeSeparator)) && tokenMatcher(current, WhiteSpace) && (tokenMatcher(next, CellReference) || tokenMatcher(next, RangeSeparator));\n      });\n    }\n  }, {\n    key: \"skipWhitespacesBeforeArgSeparators\",\n    value: function skipWhitespacesBeforeArgSeparators(tokens) {\n      var _this2 = this;\n\n      return this.filterTokensByNeighbors(tokens, function (previous, current, next) {\n        return !tokenMatcher(previous, _this2.lexerConfig.ArgSeparator) && tokenMatcher(current, WhiteSpace) && tokenMatcher(next, _this2.lexerConfig.ArgSeparator);\n      });\n    }\n  }, {\n    key: \"filterTokensByNeighbors\",\n    value: function filterTokensByNeighbors(tokens, shouldBeSkipped) {\n      if (tokens.length < 3) {\n        return tokens;\n      }\n\n      var i = 0;\n      var filteredTokens = [tokens[i++]];\n\n      while (i < tokens.length - 1) {\n        if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {\n          filteredTokens.push(tokens[i]);\n        }\n\n        ++i;\n      }\n\n      filteredTokens.push(tokens[i]);\n      return filteredTokens;\n    }\n  }, {\n    key: \"trimTrailingWhitespaces\",\n    value: function trimTrailingWhitespaces(tokens) {\n      if (tokens.length > 0 && tokenMatcher(tokens[tokens.length - 1], WhiteSpace)) {\n        tokens.pop();\n      }\n\n      return tokens;\n    }\n  }]);\n\n  return FormulaLexer;\n}();"]},"metadata":{},"sourceType":"module"}