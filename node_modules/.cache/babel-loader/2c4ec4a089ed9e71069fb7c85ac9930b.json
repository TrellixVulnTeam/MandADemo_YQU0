{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { ErrorMessage } from './error-message';\nimport { EmptyValue, getFormatOfExtendedNumber, getTypeOfExtendedNumber, isExtendedNumber, NumberType } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './interpreter/SimpleRangeValue';\n/**\n * Possible errors returned by our interpreter.\n */\n\nexport var ErrorType;\n\n(function (ErrorType) {\n  /** Division by zero. */\n  ErrorType[\"DIV_BY_ZERO\"] = \"DIV_BY_ZERO\";\n  /** Unknown function name. */\n\n  ErrorType[\"NAME\"] = \"NAME\";\n  ErrorType[\"VALUE\"] = \"VALUE\";\n  ErrorType[\"NUM\"] = \"NUM\";\n  ErrorType[\"NA\"] = \"NA\";\n  /** Cyclic dependency. */\n\n  ErrorType[\"CYCLE\"] = \"CYCLE\";\n  /** Wrong address reference. */\n\n  ErrorType[\"REF\"] = \"REF\";\n  /** Array spill error. */\n\n  ErrorType[\"SPILL\"] = \"SPILL\";\n  /** Invalid/missing licence error. */\n\n  ErrorType[\"LIC\"] = \"LIC\";\n  /** Generic error */\n\n  ErrorType[\"ERROR\"] = \"ERROR\";\n})(ErrorType || (ErrorType = {}));\n\nexport var CellType;\n\n(function (CellType) {\n  CellType[\"FORMULA\"] = \"FORMULA\";\n  CellType[\"VALUE\"] = \"VALUE\";\n  CellType[\"ARRAY\"] = \"ARRAY\";\n  CellType[\"EMPTY\"] = \"EMPTY\";\n  CellType[\"ARRAYFORMULA\"] = \"ARRAYFORMULA\";\n})(CellType || (CellType = {}));\n\nexport var getCellType = function getCellType(vertex, address) {\n  if (vertex instanceof ArrayVertex) {\n    if (vertex.isLeftCorner(address)) {\n      return CellType.ARRAYFORMULA;\n    } else {\n      return CellType.ARRAY;\n    }\n  }\n\n  if (vertex instanceof FormulaCellVertex || vertex instanceof ParsingErrorVertex) {\n    return CellType.FORMULA;\n  }\n\n  if (vertex instanceof ValueCellVertex) {\n    return CellType.VALUE;\n  }\n\n  return CellType.EMPTY;\n};\nexport var CellValueNoNumber;\n\n(function (CellValueNoNumber) {\n  CellValueNoNumber[\"EMPTY\"] = \"EMPTY\";\n  CellValueNoNumber[\"NUMBER\"] = \"NUMBER\";\n  CellValueNoNumber[\"STRING\"] = \"STRING\";\n  CellValueNoNumber[\"BOOLEAN\"] = \"BOOLEAN\";\n  CellValueNoNumber[\"ERROR\"] = \"ERROR\";\n})(CellValueNoNumber || (CellValueNoNumber = {}));\n\nexport var CellValueJustNumber;\n\n(function (CellValueJustNumber) {\n  CellValueJustNumber[\"NUMBER\"] = \"NUMBER\";\n})(CellValueJustNumber || (CellValueJustNumber = {}));\n\nexport var CellValueType = Object.assign(Object.assign({}, CellValueNoNumber), CellValueJustNumber);\nexport var CellValueDetailedType = Object.assign(Object.assign({}, CellValueNoNumber), NumberType);\nexport var CellValueTypeOrd = function CellValueTypeOrd(arg) {\n  switch (arg) {\n    case CellValueType.EMPTY:\n      return 0;\n\n    case CellValueType.NUMBER:\n      return 1;\n\n    case CellValueType.STRING:\n      return 2;\n\n    case CellValueType.BOOLEAN:\n      return 3;\n\n    case CellValueType.ERROR:\n      return 4;\n  }\n\n  throw new Error('Cell value not computed');\n};\nexport var getCellValueType = function getCellValueType(cellValue) {\n  if (cellValue === EmptyValue) {\n    return CellValueType.EMPTY;\n  }\n\n  if (cellValue instanceof CellError || cellValue instanceof SimpleRangeValue) {\n    return CellValueType.ERROR;\n  }\n\n  if (typeof cellValue === 'string') {\n    return CellValueType.STRING;\n  } else if (isExtendedNumber(cellValue)) {\n    return CellValueType.NUMBER;\n  } else if (typeof cellValue === 'boolean') {\n    return CellValueType.BOOLEAN;\n  }\n\n  throw new Error('Cell value not computed');\n};\nexport var getCellValueDetailedType = function getCellValueDetailedType(cellValue) {\n  if (isExtendedNumber(cellValue)) {\n    return getTypeOfExtendedNumber(cellValue);\n  } else {\n    return getCellValueType(cellValue);\n  }\n};\nexport var getCellValueFormat = function getCellValueFormat(cellValue) {\n  if (isExtendedNumber(cellValue)) {\n    return getFormatOfExtendedNumber(cellValue);\n  } else {\n    return undefined;\n  }\n};\nexport var CellError = /*#__PURE__*/function () {\n  function CellError(type, message, root) {\n    _classCallCheck(this, CellError);\n\n    this.type = type;\n    this.message = message;\n    this.root = root;\n  }\n\n  _createClass(CellError, [{\n    key: \"attachRootVertex\",\n    value: function attachRootVertex(vertex) {\n      if (this.root === undefined) {\n        return new CellError(this.type, this.message, vertex);\n      } else {\n        return this;\n      }\n    }\n  }], [{\n    key: \"parsingError\",\n    value: function parsingError() {\n      return new CellError(ErrorType.ERROR, ErrorMessage.ParseError);\n    }\n  }]);\n\n  return CellError;\n}();\nexport var simpleRowAddress = function simpleRowAddress(sheet, row) {\n  return {\n    sheet: sheet,\n    row: row\n  };\n};\nexport var invalidSimpleRowAddress = function invalidSimpleRowAddress(address) {\n  return address.row < 0;\n};\nexport var simpleColumnAddress = function simpleColumnAddress(sheet, col) {\n  return {\n    sheet: sheet,\n    col: col\n  };\n};\nexport var invalidSimpleColumnAddress = function invalidSimpleColumnAddress(address) {\n  return address.col < 0;\n};\nexport var simpleCellAddress = function simpleCellAddress(sheet, col, row) {\n  return {\n    sheet: sheet,\n    col: col,\n    row: row\n  };\n};\nexport var invalidSimpleCellAddress = function invalidSimpleCellAddress(address) {\n  return address.col < 0 || address.row < 0;\n};\nexport var movedSimpleCellAddress = function movedSimpleCellAddress(address, toSheet, toRight, toBottom) {\n  return simpleCellAddress(toSheet, address.col + toRight, address.row + toBottom);\n};\nexport var addressKey = function addressKey(address) {\n  return \"\".concat(address.sheet, \",\").concat(address.row, \",\").concat(address.col);\n};\nexport function isSimpleCellAddress(obj) {\n  if (obj && (_typeof(obj) === 'object' || typeof obj === 'function')) {\n    return 'col' in obj && typeof obj.col === 'number' && 'row' in obj && typeof obj.row === 'number' && 'sheet' in obj && typeof obj.sheet === 'number';\n  } else {\n    return false;\n  }\n}\nexport var absoluteSheetReference = function absoluteSheetReference(address, baseAddress) {\n  var _a;\n\n  return (_a = address.sheet) !== null && _a !== void 0 ? _a : baseAddress.sheet;\n};\nexport var equalSimpleCellAddress = function equalSimpleCellAddress(left, right) {\n  return left.sheet === right.sheet && left.col === right.col && left.row === right.row;\n};","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/Cell.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","ArrayVertex","FormulaCellVertex","ParsingErrorVertex","ValueCellVertex","ErrorMessage","EmptyValue","getFormatOfExtendedNumber","getTypeOfExtendedNumber","isExtendedNumber","NumberType","SimpleRangeValue","ErrorType","CellType","getCellType","vertex","address","isLeftCorner","ARRAYFORMULA","ARRAY","FORMULA","VALUE","EMPTY","CellValueNoNumber","CellValueJustNumber","CellValueType","assign","CellValueDetailedType","CellValueTypeOrd","arg","NUMBER","STRING","BOOLEAN","ERROR","Error","getCellValueType","cellValue","CellError","getCellValueDetailedType","getCellValueFormat","undefined","type","message","root","value","attachRootVertex","parsingError","ParseError","simpleRowAddress","sheet","row","invalidSimpleRowAddress","simpleColumnAddress","col","invalidSimpleColumnAddress","simpleCellAddress","invalidSimpleCellAddress","movedSimpleCellAddress","toSheet","toRight","toBottom","addressKey","concat","isSimpleCellAddress","absoluteSheetReference","baseAddress","_a","equalSimpleCellAddress","left","right"],"mappings":"AAAA,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE;;AAA2B,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;AAAEH,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAO,OAAOA,GAAd;AAAoB,KAAtD;AAAyD,GAApI,MAA0I;AAAED,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAOA,GAAG,IAAI,OAAOC,MAAP,KAAkB,UAAzB,IAAuCD,GAAG,CAACG,WAAJ,KAAoBF,MAA3D,IAAqED,GAAG,KAAKC,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAOJ,GAAzH;AAA+H,KAAjK;AAAoK;;AAAC,SAAOD,OAAO,CAACC,GAAD,CAAd;AAAsB;;AAE1X,SAASK,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACH,SAAb,EAAwBkB,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;;AAYvN;AACA;AACA;AACA;AACA,SAASiB,WAAT,EAAsBC,iBAAtB,EAAyCC,kBAAzC,EAA6DC,eAA7D,QAAoF,mBAApF;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA,SAASC,UAAT,EAAqBC,yBAArB,EAAgDC,uBAAhD,EAAyEC,gBAAzE,EAA2FC,UAA3F,QAA6G,gCAA7G;AACA,SAASC,gBAAT,QAAiC,gCAAjC;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,SAAJ;;AAEP,CAAC,UAAUA,SAAV,EAAqB;AACpB;AACAA,EAAAA,SAAS,CAAC,aAAD,CAAT,GAA2B,aAA3B;AACA;;AAEAA,EAAAA,SAAS,CAAC,MAAD,CAAT,GAAoB,MAApB;AACAA,EAAAA,SAAS,CAAC,OAAD,CAAT,GAAqB,OAArB;AACAA,EAAAA,SAAS,CAAC,KAAD,CAAT,GAAmB,KAAnB;AACAA,EAAAA,SAAS,CAAC,IAAD,CAAT,GAAkB,IAAlB;AACA;;AAEAA,EAAAA,SAAS,CAAC,OAAD,CAAT,GAAqB,OAArB;AACA;;AAEAA,EAAAA,SAAS,CAAC,KAAD,CAAT,GAAmB,KAAnB;AACA;;AAEAA,EAAAA,SAAS,CAAC,OAAD,CAAT,GAAqB,OAArB;AACA;;AAEAA,EAAAA,SAAS,CAAC,KAAD,CAAT,GAAmB,KAAnB;AACA;;AAEAA,EAAAA,SAAS,CAAC,OAAD,CAAT,GAAqB,OAArB;AACD,CAxBD,EAwBGA,SAAS,KAAKA,SAAS,GAAG,EAAjB,CAxBZ;;AA0BA,OAAO,IAAIC,QAAJ;;AAEP,CAAC,UAAUA,QAAV,EAAoB;AACnBA,EAAAA,QAAQ,CAAC,SAAD,CAAR,GAAsB,SAAtB;AACAA,EAAAA,QAAQ,CAAC,OAAD,CAAR,GAAoB,OAApB;AACAA,EAAAA,QAAQ,CAAC,OAAD,CAAR,GAAoB,OAApB;AACAA,EAAAA,QAAQ,CAAC,OAAD,CAAR,GAAoB,OAApB;AACAA,EAAAA,QAAQ,CAAC,cAAD,CAAR,GAA2B,cAA3B;AACD,CAND,EAMGA,QAAQ,KAAKA,QAAQ,GAAG,EAAhB,CANX;;AAQA,OAAO,IAAIC,WAAW,GAAG,SAASA,WAAT,CAAqBC,MAArB,EAA6BC,OAA7B,EAAsC;AAC7D,MAAID,MAAM,YAAYd,WAAtB,EAAmC;AACjC,QAAIc,MAAM,CAACE,YAAP,CAAoBD,OAApB,CAAJ,EAAkC;AAChC,aAAOH,QAAQ,CAACK,YAAhB;AACD,KAFD,MAEO;AACL,aAAOL,QAAQ,CAACM,KAAhB;AACD;AACF;;AAED,MAAIJ,MAAM,YAAYb,iBAAlB,IAAuCa,MAAM,YAAYZ,kBAA7D,EAAiF;AAC/E,WAAOU,QAAQ,CAACO,OAAhB;AACD;;AAED,MAAIL,MAAM,YAAYX,eAAtB,EAAuC;AACrC,WAAOS,QAAQ,CAACQ,KAAhB;AACD;;AAED,SAAOR,QAAQ,CAACS,KAAhB;AACD,CAlBM;AAmBP,OAAO,IAAIC,iBAAJ;;AAEP,CAAC,UAAUA,iBAAV,EAA6B;AAC5BA,EAAAA,iBAAiB,CAAC,OAAD,CAAjB,GAA6B,OAA7B;AACAA,EAAAA,iBAAiB,CAAC,QAAD,CAAjB,GAA8B,QAA9B;AACAA,EAAAA,iBAAiB,CAAC,QAAD,CAAjB,GAA8B,QAA9B;AACAA,EAAAA,iBAAiB,CAAC,SAAD,CAAjB,GAA+B,SAA/B;AACAA,EAAAA,iBAAiB,CAAC,OAAD,CAAjB,GAA6B,OAA7B;AACD,CAND,EAMGA,iBAAiB,KAAKA,iBAAiB,GAAG,EAAzB,CANpB;;AAQA,OAAO,IAAIC,mBAAJ;;AAEP,CAAC,UAAUA,mBAAV,EAA+B;AAC9BA,EAAAA,mBAAmB,CAAC,QAAD,CAAnB,GAAgC,QAAhC;AACD,CAFD,EAEGA,mBAAmB,KAAKA,mBAAmB,GAAG,EAA3B,CAFtB;;AAIA,OAAO,IAAIC,aAAa,GAAG9B,MAAM,CAAC+B,MAAP,CAAc/B,MAAM,CAAC+B,MAAP,CAAc,EAAd,EAAkBH,iBAAlB,CAAd,EAAoDC,mBAApD,CAApB;AACP,OAAO,IAAIG,qBAAqB,GAAGhC,MAAM,CAAC+B,MAAP,CAAc/B,MAAM,CAAC+B,MAAP,CAAc,EAAd,EAAkBH,iBAAlB,CAAd,EAAoDb,UAApD,CAA5B;AACP,OAAO,IAAIkB,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,GAA1B,EAA+B;AAC3D,UAAQA,GAAR;AACE,SAAKJ,aAAa,CAACH,KAAnB;AACE,aAAO,CAAP;;AAEF,SAAKG,aAAa,CAACK,MAAnB;AACE,aAAO,CAAP;;AAEF,SAAKL,aAAa,CAACM,MAAnB;AACE,aAAO,CAAP;;AAEF,SAAKN,aAAa,CAACO,OAAnB;AACE,aAAO,CAAP;;AAEF,SAAKP,aAAa,CAACQ,KAAnB;AACE,aAAO,CAAP;AAdJ;;AAiBA,QAAM,IAAIC,KAAJ,CAAU,yBAAV,CAAN;AACD,CAnBM;AAoBP,OAAO,IAAIC,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,SAA1B,EAAqC;AACjE,MAAIA,SAAS,KAAK9B,UAAlB,EAA8B;AAC5B,WAAOmB,aAAa,CAACH,KAArB;AACD;;AAED,MAAIc,SAAS,YAAYC,SAArB,IAAkCD,SAAS,YAAYzB,gBAA3D,EAA6E;AAC3E,WAAOc,aAAa,CAACQ,KAArB;AACD;;AAED,MAAI,OAAOG,SAAP,KAAqB,QAAzB,EAAmC;AACjC,WAAOX,aAAa,CAACM,MAArB;AACD,GAFD,MAEO,IAAItB,gBAAgB,CAAC2B,SAAD,CAApB,EAAiC;AACtC,WAAOX,aAAa,CAACK,MAArB;AACD,GAFM,MAEA,IAAI,OAAOM,SAAP,KAAqB,SAAzB,EAAoC;AACzC,WAAOX,aAAa,CAACO,OAArB;AACD;;AAED,QAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACD,CAlBM;AAmBP,OAAO,IAAII,wBAAwB,GAAG,SAASA,wBAAT,CAAkCF,SAAlC,EAA6C;AACjF,MAAI3B,gBAAgB,CAAC2B,SAAD,CAApB,EAAiC;AAC/B,WAAO5B,uBAAuB,CAAC4B,SAAD,CAA9B;AACD,GAFD,MAEO;AACL,WAAOD,gBAAgB,CAACC,SAAD,CAAvB;AACD;AACF,CANM;AAOP,OAAO,IAAIG,kBAAkB,GAAG,SAASA,kBAAT,CAA4BH,SAA5B,EAAuC;AACrE,MAAI3B,gBAAgB,CAAC2B,SAAD,CAApB,EAAiC;AAC/B,WAAO7B,yBAAyB,CAAC6B,SAAD,CAAhC;AACD,GAFD,MAEO;AACL,WAAOI,SAAP;AACD;AACF,CANM;AAOP,OAAO,IAAIH,SAAS,GAAG,aAAa,YAAY;AAC9C,WAASA,SAAT,CAAmBI,IAAnB,EAAyBC,OAAzB,EAAkCC,IAAlC,EAAwC;AACtC7D,IAAAA,eAAe,CAAC,IAAD,EAAOuD,SAAP,CAAf;;AAEA,SAAKI,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACD;;AAED7C,EAAAA,YAAY,CAACuC,SAAD,EAAY,CAAC;AACvBxC,IAAAA,GAAG,EAAE,kBADkB;AAEvB+C,IAAAA,KAAK,EAAE,SAASC,gBAAT,CAA0B9B,MAA1B,EAAkC;AACvC,UAAI,KAAK4B,IAAL,KAAcH,SAAlB,EAA6B;AAC3B,eAAO,IAAIH,SAAJ,CAAc,KAAKI,IAAnB,EAAyB,KAAKC,OAA9B,EAAuC3B,MAAvC,CAAP;AACD,OAFD,MAEO;AACL,eAAO,IAAP;AACD;AACF;AARsB,GAAD,CAAZ,EASR,CAAC;AACHlB,IAAAA,GAAG,EAAE,cADF;AAEH+C,IAAAA,KAAK,EAAE,SAASE,YAAT,GAAwB;AAC7B,aAAO,IAAIT,SAAJ,CAAczB,SAAS,CAACqB,KAAxB,EAA+B5B,YAAY,CAAC0C,UAA5C,CAAP;AACD;AAJE,GAAD,CATQ,CAAZ;;AAgBA,SAAOV,SAAP;AACD,CA1BmC,EAA7B;AA2BP,OAAO,IAAIW,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,GAAjC,EAAsC;AAClE,SAAO;AACLD,IAAAA,KAAK,EAAEA,KADF;AAELC,IAAAA,GAAG,EAAEA;AAFA,GAAP;AAID,CALM;AAMP,OAAO,IAAIC,uBAAuB,GAAG,SAASA,uBAAT,CAAiCnC,OAAjC,EAA0C;AAC7E,SAAOA,OAAO,CAACkC,GAAR,GAAc,CAArB;AACD,CAFM;AAGP,OAAO,IAAIE,mBAAmB,GAAG,SAASA,mBAAT,CAA6BH,KAA7B,EAAoCI,GAApC,EAAyC;AACxE,SAAO;AACLJ,IAAAA,KAAK,EAAEA,KADF;AAELI,IAAAA,GAAG,EAAEA;AAFA,GAAP;AAID,CALM;AAMP,OAAO,IAAIC,0BAA0B,GAAG,SAASA,0BAAT,CAAoCtC,OAApC,EAA6C;AACnF,SAAOA,OAAO,CAACqC,GAAR,GAAc,CAArB;AACD,CAFM;AAGP,OAAO,IAAIE,iBAAiB,GAAG,SAASA,iBAAT,CAA2BN,KAA3B,EAAkCI,GAAlC,EAAuCH,GAAvC,EAA4C;AACzE,SAAO;AACLD,IAAAA,KAAK,EAAEA,KADF;AAELI,IAAAA,GAAG,EAAEA,GAFA;AAGLH,IAAAA,GAAG,EAAEA;AAHA,GAAP;AAKD,CANM;AAOP,OAAO,IAAIM,wBAAwB,GAAG,SAASA,wBAAT,CAAkCxC,OAAlC,EAA2C;AAC/E,SAAOA,OAAO,CAACqC,GAAR,GAAc,CAAd,IAAmBrC,OAAO,CAACkC,GAAR,GAAc,CAAxC;AACD,CAFM;AAGP,OAAO,IAAIO,sBAAsB,GAAG,SAASA,sBAAT,CAAgCzC,OAAhC,EAAyC0C,OAAzC,EAAkDC,OAAlD,EAA2DC,QAA3D,EAAqE;AACvG,SAAOL,iBAAiB,CAACG,OAAD,EAAU1C,OAAO,CAACqC,GAAR,GAAcM,OAAxB,EAAiC3C,OAAO,CAACkC,GAAR,GAAcU,QAA/C,CAAxB;AACD,CAFM;AAGP,OAAO,IAAIC,UAAU,GAAG,SAASA,UAAT,CAAoB7C,OAApB,EAA6B;AACnD,SAAO,GAAG8C,MAAH,CAAU9C,OAAO,CAACiC,KAAlB,EAAyB,GAAzB,EAA8Ba,MAA9B,CAAqC9C,OAAO,CAACkC,GAA7C,EAAkD,GAAlD,EAAuDY,MAAvD,CAA8D9C,OAAO,CAACqC,GAAtE,CAAP;AACD,CAFM;AAGP,OAAO,SAASU,mBAAT,CAA6BtF,GAA7B,EAAkC;AACvC,MAAIA,GAAG,KAAKD,OAAO,CAACC,GAAD,CAAP,KAAiB,QAAjB,IAA6B,OAAOA,GAAP,KAAe,UAAjD,CAAP,EAAqE;AACnE,WAAO,SAASA,GAAT,IAAgB,OAAOA,GAAG,CAAC4E,GAAX,KAAmB,QAAnC,IAA+C,SAAS5E,GAAxD,IAA+D,OAAOA,GAAG,CAACyE,GAAX,KAAmB,QAAlF,IAA8F,WAAWzE,GAAzG,IAAgH,OAAOA,GAAG,CAACwE,KAAX,KAAqB,QAA5I;AACD,GAFD,MAEO;AACL,WAAO,KAAP;AACD;AACF;AACD,OAAO,IAAIe,sBAAsB,GAAG,SAASA,sBAAT,CAAgChD,OAAhC,EAAyCiD,WAAzC,EAAsD;AACxF,MAAIC,EAAJ;;AAEA,SAAO,CAACA,EAAE,GAAGlD,OAAO,CAACiC,KAAd,MAAyB,IAAzB,IAAiCiB,EAAE,KAAK,KAAK,CAA7C,GAAiDA,EAAjD,GAAsDD,WAAW,CAAChB,KAAzE;AACD,CAJM;AAKP,OAAO,IAAIkB,sBAAsB,GAAG,SAASA,sBAAT,CAAgCC,IAAhC,EAAsCC,KAAtC,EAA6C;AAC/E,SAAOD,IAAI,CAACnB,KAAL,KAAeoB,KAAK,CAACpB,KAArB,IAA8BmB,IAAI,CAACf,GAAL,KAAagB,KAAK,CAAChB,GAAjD,IAAwDe,IAAI,CAAClB,GAAL,KAAamB,KAAK,CAACnB,GAAlF;AACD,CAFM","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { ErrorMessage } from './error-message';\nimport { EmptyValue, getFormatOfExtendedNumber, getTypeOfExtendedNumber, isExtendedNumber, NumberType } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './interpreter/SimpleRangeValue';\n/**\n * Possible errors returned by our interpreter.\n */\n\nexport var ErrorType;\n\n(function (ErrorType) {\n  /** Division by zero. */\n  ErrorType[\"DIV_BY_ZERO\"] = \"DIV_BY_ZERO\";\n  /** Unknown function name. */\n\n  ErrorType[\"NAME\"] = \"NAME\";\n  ErrorType[\"VALUE\"] = \"VALUE\";\n  ErrorType[\"NUM\"] = \"NUM\";\n  ErrorType[\"NA\"] = \"NA\";\n  /** Cyclic dependency. */\n\n  ErrorType[\"CYCLE\"] = \"CYCLE\";\n  /** Wrong address reference. */\n\n  ErrorType[\"REF\"] = \"REF\";\n  /** Array spill error. */\n\n  ErrorType[\"SPILL\"] = \"SPILL\";\n  /** Invalid/missing licence error. */\n\n  ErrorType[\"LIC\"] = \"LIC\";\n  /** Generic error */\n\n  ErrorType[\"ERROR\"] = \"ERROR\";\n})(ErrorType || (ErrorType = {}));\n\nexport var CellType;\n\n(function (CellType) {\n  CellType[\"FORMULA\"] = \"FORMULA\";\n  CellType[\"VALUE\"] = \"VALUE\";\n  CellType[\"ARRAY\"] = \"ARRAY\";\n  CellType[\"EMPTY\"] = \"EMPTY\";\n  CellType[\"ARRAYFORMULA\"] = \"ARRAYFORMULA\";\n})(CellType || (CellType = {}));\n\nexport var getCellType = function getCellType(vertex, address) {\n  if (vertex instanceof ArrayVertex) {\n    if (vertex.isLeftCorner(address)) {\n      return CellType.ARRAYFORMULA;\n    } else {\n      return CellType.ARRAY;\n    }\n  }\n\n  if (vertex instanceof FormulaCellVertex || vertex instanceof ParsingErrorVertex) {\n    return CellType.FORMULA;\n  }\n\n  if (vertex instanceof ValueCellVertex) {\n    return CellType.VALUE;\n  }\n\n  return CellType.EMPTY;\n};\nexport var CellValueNoNumber;\n\n(function (CellValueNoNumber) {\n  CellValueNoNumber[\"EMPTY\"] = \"EMPTY\";\n  CellValueNoNumber[\"NUMBER\"] = \"NUMBER\";\n  CellValueNoNumber[\"STRING\"] = \"STRING\";\n  CellValueNoNumber[\"BOOLEAN\"] = \"BOOLEAN\";\n  CellValueNoNumber[\"ERROR\"] = \"ERROR\";\n})(CellValueNoNumber || (CellValueNoNumber = {}));\n\nexport var CellValueJustNumber;\n\n(function (CellValueJustNumber) {\n  CellValueJustNumber[\"NUMBER\"] = \"NUMBER\";\n})(CellValueJustNumber || (CellValueJustNumber = {}));\n\nexport var CellValueType = Object.assign(Object.assign({}, CellValueNoNumber), CellValueJustNumber);\nexport var CellValueDetailedType = Object.assign(Object.assign({}, CellValueNoNumber), NumberType);\nexport var CellValueTypeOrd = function CellValueTypeOrd(arg) {\n  switch (arg) {\n    case CellValueType.EMPTY:\n      return 0;\n\n    case CellValueType.NUMBER:\n      return 1;\n\n    case CellValueType.STRING:\n      return 2;\n\n    case CellValueType.BOOLEAN:\n      return 3;\n\n    case CellValueType.ERROR:\n      return 4;\n  }\n\n  throw new Error('Cell value not computed');\n};\nexport var getCellValueType = function getCellValueType(cellValue) {\n  if (cellValue === EmptyValue) {\n    return CellValueType.EMPTY;\n  }\n\n  if (cellValue instanceof CellError || cellValue instanceof SimpleRangeValue) {\n    return CellValueType.ERROR;\n  }\n\n  if (typeof cellValue === 'string') {\n    return CellValueType.STRING;\n  } else if (isExtendedNumber(cellValue)) {\n    return CellValueType.NUMBER;\n  } else if (typeof cellValue === 'boolean') {\n    return CellValueType.BOOLEAN;\n  }\n\n  throw new Error('Cell value not computed');\n};\nexport var getCellValueDetailedType = function getCellValueDetailedType(cellValue) {\n  if (isExtendedNumber(cellValue)) {\n    return getTypeOfExtendedNumber(cellValue);\n  } else {\n    return getCellValueType(cellValue);\n  }\n};\nexport var getCellValueFormat = function getCellValueFormat(cellValue) {\n  if (isExtendedNumber(cellValue)) {\n    return getFormatOfExtendedNumber(cellValue);\n  } else {\n    return undefined;\n  }\n};\nexport var CellError = /*#__PURE__*/function () {\n  function CellError(type, message, root) {\n    _classCallCheck(this, CellError);\n\n    this.type = type;\n    this.message = message;\n    this.root = root;\n  }\n\n  _createClass(CellError, [{\n    key: \"attachRootVertex\",\n    value: function attachRootVertex(vertex) {\n      if (this.root === undefined) {\n        return new CellError(this.type, this.message, vertex);\n      } else {\n        return this;\n      }\n    }\n  }], [{\n    key: \"parsingError\",\n    value: function parsingError() {\n      return new CellError(ErrorType.ERROR, ErrorMessage.ParseError);\n    }\n  }]);\n\n  return CellError;\n}();\nexport var simpleRowAddress = function simpleRowAddress(sheet, row) {\n  return {\n    sheet: sheet,\n    row: row\n  };\n};\nexport var invalidSimpleRowAddress = function invalidSimpleRowAddress(address) {\n  return address.row < 0;\n};\nexport var simpleColumnAddress = function simpleColumnAddress(sheet, col) {\n  return {\n    sheet: sheet,\n    col: col\n  };\n};\nexport var invalidSimpleColumnAddress = function invalidSimpleColumnAddress(address) {\n  return address.col < 0;\n};\nexport var simpleCellAddress = function simpleCellAddress(sheet, col, row) {\n  return {\n    sheet: sheet,\n    col: col,\n    row: row\n  };\n};\nexport var invalidSimpleCellAddress = function invalidSimpleCellAddress(address) {\n  return address.col < 0 || address.row < 0;\n};\nexport var movedSimpleCellAddress = function movedSimpleCellAddress(address, toSheet, toRight, toBottom) {\n  return simpleCellAddress(toSheet, address.col + toRight, address.row + toBottom);\n};\nexport var addressKey = function addressKey(address) {\n  return \"\".concat(address.sheet, \",\").concat(address.row, \",\").concat(address.col);\n};\nexport function isSimpleCellAddress(obj) {\n  if (obj && (_typeof(obj) === 'object' || typeof obj === 'function')) {\n    return 'col' in obj && typeof obj.col === 'number' && 'row' in obj && typeof obj.row === 'number' && 'sheet' in obj && typeof obj.sheet === 'number';\n  } else {\n    return false;\n  }\n}\nexport var absoluteSheetReference = function absoluteSheetReference(address, baseAddress) {\n  var _a;\n\n  return (_a = address.sheet) !== null && _a !== void 0 ? _a : baseAddress.sheet;\n};\nexport var equalSimpleCellAddress = function equalSimpleCellAddress(left, right) {\n  return left.sheet === right.sheet && left.col === right.col && left.row === right.row;\n};"]},"metadata":{},"sourceType":"module"}