{"ast":null,"code":"import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n} // Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\n\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport var tokenShortNameIdx = 1;\nexport var tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes); // add required tokenType and categoryMatches properties\n\n  assignTokenDefaultProps(tokenTypesAndParents); // fill up the categoryMatches\n\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  forEach(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nexport function expandCategories(tokenTypes) {\n  var result = cloneArr(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n\n  while (searching) {\n    categories = compact(flatten(map(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = difference(categories, result);\n    result = result.concat(newCategories);\n\n    if (isEmpty(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n\n  return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = tokenShortNameIdx++;\n    } // CATEGORIES? : TokenType | TokenType[]\n\n\n    if (hasCategoriesProperty(currTokType) && !isArray(currTokType.CATEGORIES) // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    forEach(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n  forEach(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  forEach(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode); // avoids infinite loops due to cyclic categories.\n\n    if (!contains(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nexport function hasShortKeyProperty(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n  return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n  return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n  return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/scan/tokens.js"],"names":["cloneArr","compact","contains","difference","flatten","forEach","has","isArray","isEmpty","map","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","tokenTypeIdx","isParent","categoryMatchesMap","tokenStructuredMatcherNoCategories","token","tokType","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypes","tokenTypesAndParents","expandCategories","assignTokenDefaultProps","assignCategoriesMapProp","assignCategoriesTokensProp","categoryMatches","length","result","categories","searching","currTokType","CATEGORIES","newCategories","concat","hasShortKeyProperty","hasCategoriesProperty","hasExtendingTokensTypesProperty","hasExtendingTokensTypesMapProperty","val","key","push","singleAssignCategoriesToksMap","path","nextNode","pathNode","nextCategory","newPath","isTokenType"],"mappings":"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","sourcesContent":["import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    var instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport var tokenShortNameIdx = 1;\nexport var tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    var tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    forEach(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexport function expandCategories(tokenTypes) {\n    var result = cloneArr(tokenTypes);\n    var categories = tokenTypes;\n    var searching = true;\n    while (searching) {\n        categories = compact(flatten(map(categories, function (currTokType) { return currTokType.CATEGORIES; })));\n        var newCategories = difference(categories, result);\n        result = result.concat(newCategories);\n        if (isEmpty(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !isArray(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        forEach(currTokType.categoryMatchesMap, function (val, key) {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    forEach(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!contains(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexport function hasShortKeyProperty(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n    return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\n//# sourceMappingURL=tokens.js.map"]},"metadata":{},"sourceType":"module"}