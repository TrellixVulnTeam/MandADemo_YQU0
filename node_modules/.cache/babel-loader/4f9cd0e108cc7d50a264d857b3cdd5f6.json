{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { absolutizeDependencies, filterDependenciesOutOfScope } from './absolutizeDependencies';\nimport { ArraySize } from './ArraySize';\nimport { equalSimpleCellAddress, invalidSimpleCellAddress, simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { ClipboardCellType } from './ClipboardOperations';\nimport { ContentChanges } from './ContentChanges';\nimport { ArrayVertex, EmptyCellVertex, FormulaCellVertex, ParsingErrorVertex, SparseStrategy, ValueCellVertex } from './DependencyGraph';\nimport { FormulaVertex } from './DependencyGraph/FormulaCellVertex';\nimport { AddColumnsTransformer } from './dependencyTransformers/AddColumnsTransformer';\nimport { AddRowsTransformer } from './dependencyTransformers/AddRowsTransformer';\nimport { CleanOutOfScopeDependenciesTransformer } from './dependencyTransformers/CleanOutOfScopeDependenciesTransformer';\nimport { MoveCellsTransformer } from './dependencyTransformers/MoveCellsTransformer';\nimport { RemoveColumnsTransformer } from './dependencyTransformers/RemoveColumnsTransformer';\nimport { RemoveRowsTransformer } from './dependencyTransformers/RemoveRowsTransformer';\nimport { RemoveSheetTransformer } from './dependencyTransformers/RemoveSheetTransformer';\nimport { InvalidArgumentsError, NamedExpressionDoesNotExistError, NoRelativeAddressesAllowedError, SheetSizeLimitExceededError, SourceLocationHasArrayError, TargetLocationHasArrayError } from './errors';\nimport { EmptyValue, getRawValue } from './interpreter/InterpreterValue';\nimport { doesContainRelativeReferences } from './NamedExpressions';\nimport { NamedExpressionDependency } from './parser';\nimport { findBoundaries } from './Sheet';\nimport { ColumnsSpan, RowsSpan } from './Span';\nimport { StatType } from './statistics';\nexport var RemoveRowsCommand = /*#__PURE__*/function () {\n  function RemoveRowsCommand(sheet, indexes) {\n    _classCallCheck(this, RemoveRowsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(RemoveRowsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeRemovedIndexes(this.indexes);\n    }\n  }, {\n    key: \"rowsSpans\",\n    value: function rowsSpans() {\n      var _this = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return RowsSpan.fromNumberOfRows(_this.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return RemoveRowsCommand;\n}();\nexport var AddRowsCommand = /*#__PURE__*/function () {\n  function AddRowsCommand(sheet, indexes) {\n    _classCallCheck(this, AddRowsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(AddRowsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeAddedIndexes(this.indexes);\n    }\n  }, {\n    key: \"rowsSpans\",\n    value: function rowsSpans() {\n      var _this2 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return RowsSpan.fromNumberOfRows(_this2.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return AddRowsCommand;\n}();\nexport var AddColumnsCommand = /*#__PURE__*/function () {\n  function AddColumnsCommand(sheet, indexes) {\n    _classCallCheck(this, AddColumnsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(AddColumnsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeAddedIndexes(this.indexes);\n    }\n  }, {\n    key: \"columnsSpans\",\n    value: function columnsSpans() {\n      var _this3 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return ColumnsSpan.fromNumberOfColumns(_this3.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return AddColumnsCommand;\n}();\nexport var RemoveColumnsCommand = /*#__PURE__*/function () {\n  function RemoveColumnsCommand(sheet, indexes) {\n    _classCallCheck(this, RemoveColumnsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(RemoveColumnsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeRemovedIndexes(this.indexes);\n    }\n  }, {\n    key: \"columnsSpans\",\n    value: function columnsSpans() {\n      var _this4 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return ColumnsSpan.fromNumberOfColumns(_this4.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return RemoveColumnsCommand;\n}();\nexport var Operations = /*#__PURE__*/function () {\n  function Operations(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor) {\n    _classCallCheck(this, Operations);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.cellContentParser = cellContentParser;\n    this.parser = parser;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.arraySizePredictor = arraySizePredictor;\n    this.changes = ContentChanges.empty();\n    this.allocateNamedExpressionAddressSpace();\n    this.maxColumns = config.maxColumns;\n    this.maxRows = config.maxRows;\n  }\n\n  _createClass(Operations, [{\n    key: \"removeRows\",\n    value: function removeRows(cmd) {\n      var rowsRemovals = [];\n\n      var _iterator = _createForOfIteratorHelper(cmd.rowsSpans()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rowsToRemove = _step.value;\n          var rowsRemoval = this.doRemoveRows(rowsToRemove);\n\n          if (rowsRemoval) {\n            rowsRemovals.push(rowsRemoval);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return rowsRemovals;\n    }\n  }, {\n    key: \"addRows\",\n    value: function addRows(cmd) {\n      var _iterator2 = _createForOfIteratorHelper(cmd.rowsSpans()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var addedRows = _step2.value;\n          this.doAddRows(addedRows);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(cmd) {\n      var _iterator3 = _createForOfIteratorHelper(cmd.columnsSpans()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var addedColumns = _step3.value;\n          this.doAddColumns(addedColumns);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(cmd) {\n      var columnsRemovals = [];\n\n      var _iterator4 = _createForOfIteratorHelper(cmd.columnsSpans()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var columnsToRemove = _step4.value;\n          var columnsRemoval = this.doRemoveColumns(columnsToRemove);\n\n          if (columnsRemoval) {\n            columnsRemovals.push(columnsRemoval);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return columnsRemovals;\n    }\n  }, {\n    key: \"removeSheet\",\n    value: function removeSheet(sheetId) {\n      var _this5 = this;\n\n      this.dependencyGraph.removeSheet(sheetId);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveSheetTransformer(sheetId);\n        transformation.performEagerTransformations(_this5.dependencyGraph, _this5.parser);\n        version = _this5.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.sheetMapping.removeSheet(sheetId);\n      this.columnSearch.removeSheet(sheetId);\n      var scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(function (namedexpression) {\n        return _this5.removeNamedExpression(namedexpression.normalizeExpressionName(), sheetId);\n      });\n      return {\n        version: version,\n        scopedNamedExpressions: scopedNamedExpressions\n      };\n    }\n  }, {\n    key: \"removeSheetByName\",\n    value: function removeSheetByName(sheetName) {\n      var sheetId = this.sheetMapping.fetch(sheetName);\n      return this.removeSheet(sheetId);\n    }\n  }, {\n    key: \"clearSheet\",\n    value: function clearSheet(sheetId) {\n      this.dependencyGraph.clearSheet(sheetId);\n      this.columnSearch.removeSheet(sheetId);\n    }\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(name) {\n      var sheetId = this.sheetMapping.addSheet(name);\n      var sheet = [];\n      this.dependencyGraph.addressMapping.autoAddSheet(sheetId, sheet, findBoundaries(sheet));\n      return this.sheetMapping.fetchDisplayName(sheetId);\n    }\n  }, {\n    key: \"renameSheet\",\n    value: function renameSheet(sheetId, newName) {\n      return this.sheetMapping.renameSheet(sheetId, newName);\n    }\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(sheet, startRow, numberOfRows, targetRow) {\n      var rowsToAdd = RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);\n      this.lazilyTransformingAstService.beginCombinedMode(sheet);\n      this.doAddRows(rowsToAdd);\n\n      if (targetRow < startRow) {\n        startRow += numberOfRows;\n      }\n\n      var startAddress = simpleCellAddress(sheet, 0, startRow);\n      var targetAddress = simpleCellAddress(sheet, 0, targetRow);\n      this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);\n      var rowsToRemove = RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);\n      this.doRemoveRows(rowsToRemove);\n      return this.lazilyTransformingAstService.commitCombinedMode();\n    }\n  }, {\n    key: \"moveColumns\",\n    value: function moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n      var columnsToAdd = ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);\n      this.lazilyTransformingAstService.beginCombinedMode(sheet);\n      this.doAddColumns(columnsToAdd);\n\n      if (targetColumn < startColumn) {\n        startColumn += numberOfColumns;\n      }\n\n      var startAddress = simpleCellAddress(sheet, startColumn, 0);\n      var targetAddress = simpleCellAddress(sheet, targetColumn, 0);\n      this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);\n      var columnsToRemove = ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);\n      this.doRemoveColumns(columnsToRemove);\n      return this.lazilyTransformingAstService.commitCombinedMode();\n    }\n  }, {\n    key: \"moveCells\",\n    value: function moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      var _this6 = this;\n\n      this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n      var sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n      var toRight = destinationLeftCorner.col - sourceLeftCorner.col;\n      var toBottom = destinationLeftCorner.row - sourceLeftCorner.row;\n      var toSheet = destinationLeftCorner.sheet;\n      var currentDataAtTarget = this.getRangeClipboardCells(targetRange);\n      var valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);\n      this.columnSearch.removeValues(valuesToRemove);\n      var valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);\n      this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);\n        transformation.performEagerTransformations(_this6.dependencyGraph, _this6.parser);\n        version = _this6.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);\n      var addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);\n      return {\n        version: version,\n        overwrittenCellsData: currentDataAtTarget,\n        addedGlobalNamedExpressions: addedGlobalNamedExpressions\n      };\n    }\n  }, {\n    key: \"setRowOrder\",\n    value: function setRowOrder(sheetId, rowMapping) {\n      var _this7 = this;\n\n      var buffer = [];\n      var oldContent = [];\n\n      var _iterator5 = _createForOfIteratorHelper(rowMapping),\n          _step5;\n\n      try {\n        var _loop = function _loop() {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              source = _step5$value[0],\n              target = _step5$value[1];\n\n          if (source !== target) {\n            var rowRange = AbsoluteCellRange.spanFrom({\n              sheet: sheetId,\n              col: 0,\n              row: source\n            }, Infinity, 1);\n\n            var row = _this7.getRangeClipboardCells(rowRange);\n\n            oldContent = oldContent.concat(row);\n            buffer.push(row.map(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                  _ref2$ = _ref2[0],\n                  sheet = _ref2$.sheet,\n                  col = _ref2$.col,\n                  cell = _ref2[1];\n\n              return [{\n                sheet: sheet,\n                col: col,\n                row: target\n              }, cell];\n            }));\n          }\n        };\n\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      buffer.forEach(function (row) {\n        return _this7.restoreClipboardCells(sheetId, row.values());\n      });\n      return oldContent;\n    }\n  }, {\n    key: \"setColumnOrder\",\n    value: function setColumnOrder(sheetId, columnMapping) {\n      var _this8 = this;\n\n      var buffer = [];\n      var oldContent = [];\n\n      var _iterator6 = _createForOfIteratorHelper(columnMapping),\n          _step6;\n\n      try {\n        var _loop2 = function _loop2() {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              source = _step6$value[0],\n              target = _step6$value[1];\n\n          if (source !== target) {\n            var rowRange = AbsoluteCellRange.spanFrom({\n              sheet: sheetId,\n              col: source,\n              row: 0\n            }, 1, Infinity);\n\n            var column = _this8.getRangeClipboardCells(rowRange);\n\n            oldContent = oldContent.concat(column);\n            buffer.push(column.map(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                  _ref4$ = _ref4[0],\n                  sheet = _ref4$.sheet,\n                  col = _ref4$.col,\n                  row = _ref4$.row,\n                  cell = _ref4[1];\n\n              return [{\n                sheet: sheet,\n                col: target,\n                row: row\n              }, cell];\n            }));\n          }\n        };\n\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      buffer.forEach(function (column) {\n        return _this8.restoreClipboardCells(sheetId, column.values());\n      });\n      return oldContent;\n    }\n  }, {\n    key: \"addNamedExpression\",\n    value: function addNamedExpression(expressionName, expression, sheetId, options) {\n      var namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);\n      this.storeNamedExpressionInCell(namedExpression.address, expression);\n      this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);\n    }\n  }, {\n    key: \"restoreNamedExpression\",\n    value: function restoreNamedExpression(namedExpression, content, sheetId) {\n      var expressionName = namedExpression.displayName;\n      this.restoreCell(namedExpression.address, content);\n      var restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);\n      this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);\n    }\n  }, {\n    key: \"changeNamedExpressionExpression\",\n    value: function changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {\n      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (!namedExpression) {\n        throw new NamedExpressionDoesNotExistError(expressionName);\n      }\n\n      var oldNamedExpression = namedExpression.copy();\n      namedExpression.options = options;\n      var content = this.getClipboardCell(namedExpression.address);\n      this.storeNamedExpressionInCell(namedExpression.address, newExpression);\n      return [oldNamedExpression, content];\n    }\n  }, {\n    key: \"removeNamedExpression\",\n    value: function removeNamedExpression(expressionName, sheetId) {\n      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (!namedExpression) {\n        throw new NamedExpressionDoesNotExistError(expressionName);\n      }\n\n      this.namedExpressions.remove(namedExpression.displayName, sheetId);\n      var content = this.getClipboardCell(namedExpression.address);\n\n      if (sheetId !== undefined) {\n        var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n        this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);\n      } else {\n        this.dependencyGraph.setCellEmpty(namedExpression.address);\n      }\n\n      return [namedExpression, content];\n    }\n  }, {\n    key: \"ensureItIsPossibleToMoveCells\",\n    value: function ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      if (invalidSimpleCellAddress(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || invalidSimpleCellAddress(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {\n        throw new InvalidArgumentsError('a valid range of cells to move.');\n      }\n\n      var sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n\n      if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {\n        throw new SheetSizeLimitExceededError();\n      }\n\n      if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n        throw new SourceLocationHasArrayError();\n      }\n\n      if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {\n        throw new TargetLocationHasArrayError();\n      }\n    }\n  }, {\n    key: \"restoreClipboardCells\",\n    value: function restoreClipboardCells(sourceSheetId, cells) {\n      var addedNamedExpressions = [];\n\n      var _iterator7 = _createForOfIteratorHelper(cells),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              address = _step7$value[0],\n              clipboardCell = _step7$value[1];\n\n          this.restoreCell(address, clipboardCell);\n\n          if (clipboardCell.type === ClipboardCellType.FORMULA) {\n            var _this$parser$fetchCac = this.parser.fetchCachedResult(clipboardCell.hash),\n                dependencies = _this$parser$fetchCac.dependencies;\n\n            addedNamedExpressions.push.apply(addedNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies)));\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return addedNamedExpressions;\n    }\n  }, {\n    key: \"restoreCell\",\n    value: function restoreCell(address, clipboardCell) {\n      switch (clipboardCell.type) {\n        case ClipboardCellType.VALUE:\n          {\n            this.setValueToCell(clipboardCell, address);\n            break;\n          }\n\n        case ClipboardCellType.FORMULA:\n          {\n            this.setFormulaToCellFromCache(clipboardCell.hash, address);\n            break;\n          }\n\n        case ClipboardCellType.EMPTY:\n          {\n            this.setCellEmpty(address);\n            break;\n          }\n\n        case ClipboardCellType.PARSING_ERROR:\n          {\n            this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);\n            break;\n          }\n      }\n    }\n    /**\n     * Removes multiple rows from sheet. </br>\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * @param sheet - sheet id from which rows will be removed\n     * @param rowStart - number of the first row to be deleted\n     * @param rowEnd - number of the last row to be deleted\n     * */\n\n  }, {\n    key: \"doRemoveRows\",\n    value: function doRemoveRows(rowsToRemove) {\n      var _this9 = this;\n\n      if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {\n        return;\n      }\n\n      var removedCells = [];\n\n      var _iterator8 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 1),\n              address = _step8$value[0];\n\n          removedCells.push({\n            address: address,\n            cellType: this.getClipboardCell(address)\n          });\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      var _this$dependencyGraph = this.dependencyGraph.removeRows(rowsToRemove),\n          affectedArrays = _this$dependencyGraph.affectedArrays,\n          contentChanges = _this$dependencyGraph.contentChanges;\n\n      this.columnSearch.applyChanges(contentChanges.getChanges());\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveRowsTransformer(rowsToRemove);\n        transformation.performEagerTransformations(_this9.dependencyGraph, _this9.parser);\n        version = _this9.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.rewriteAffectedArrays(affectedArrays);\n      return {\n        version: version,\n        removedCells: removedCells,\n        rowFrom: rowsToRemove.rowStart,\n        rowCount: rowsToRemove.numberOfRows\n      };\n    }\n    /**\n     * Removes multiple columns from sheet. </br>\n     * Does nothing if columns are outside of effective sheet size.\n     *\n     * @param sheet - sheet id from which columns will be removed\n     * @param columnStart - number of the first column to be deleted\n     * @param columnEnd - number of the last row to be deleted\n     */\n\n  }, {\n    key: \"doRemoveColumns\",\n    value: function doRemoveColumns(columnsToRemove) {\n      var _this10 = this;\n\n      if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {\n        return;\n      }\n\n      var removedCells = [];\n\n      var _iterator9 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step9$value = _slicedToArray(_step9.value, 1),\n              address = _step9$value[0];\n\n          removedCells.push({\n            address: address,\n            cellType: this.getClipboardCell(address)\n          });\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      var _this$dependencyGraph2 = this.dependencyGraph.removeColumns(columnsToRemove),\n          affectedArrays = _this$dependencyGraph2.affectedArrays,\n          contentChanges = _this$dependencyGraph2.contentChanges;\n\n      this.columnSearch.applyChanges(contentChanges.getChanges());\n      this.columnSearch.removeColumns(columnsToRemove);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveColumnsTransformer(columnsToRemove);\n        transformation.performEagerTransformations(_this10.dependencyGraph, _this10.parser);\n        version = _this10.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.rewriteAffectedArrays(affectedArrays);\n      return {\n        version: version,\n        removedCells: removedCells,\n        columnFrom: columnsToRemove.columnStart,\n        columnCount: columnsToRemove.numberOfColumns\n      };\n    }\n    /**\n     * Add multiple rows to sheet. </br>\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * @param sheet - sheet id in which rows will be added\n     * @param row - row number above which the rows will be added\n     * @param numberOfRowsToAdd - number of rows to add\n     */\n\n  }, {\n    key: \"doAddRows\",\n    value: function doAddRows(addedRows) {\n      var _this11 = this;\n\n      if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {\n        return;\n      }\n\n      var _this$dependencyGraph3 = this.dependencyGraph.addRows(addedRows),\n          affectedArrays = _this$dependencyGraph3.affectedArrays;\n\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new AddRowsTransformer(addedRows);\n        transformation.performEagerTransformations(_this11.dependencyGraph, _this11.parser);\n\n        _this11.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.rewriteAffectedArrays(affectedArrays);\n    }\n  }, {\n    key: \"rewriteAffectedArrays\",\n    value: function rewriteAffectedArrays(affectedArrays) {\n      var _iterator10 = _createForOfIteratorHelper(affectedArrays.values()),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var arrayVertex = _step10.value;\n\n          if (arrayVertex.array.size.isRef) {\n            continue;\n          }\n\n          var ast = arrayVertex.getFormula(this.lazilyTransformingAstService);\n          var address = arrayVertex.getAddress(this.lazilyTransformingAstService);\n          var hash = this.parser.computeHashFromAst(ast);\n          this.setFormulaToCellFromCache(hash, address);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n    /**\n     * Add multiple columns to sheet </br>\n     * Does nothing if columns are outside of effective sheet size\n     *\n     * @param sheet - sheet id in which columns will be added\n     * @param column - column number above which the columns will be added\n     * @param numberOfColumns - number of columns to add\n     */\n\n  }, {\n    key: \"doAddColumns\",\n    value: function doAddColumns(addedColumns) {\n      var _this12 = this;\n\n      if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {\n        return;\n      }\n\n      var _this$dependencyGraph4 = this.dependencyGraph.addColumns(addedColumns),\n          affectedArrays = _this$dependencyGraph4.affectedArrays,\n          contentChanges = _this$dependencyGraph4.contentChanges;\n\n      this.columnSearch.addColumns(addedColumns);\n      this.columnSearch.applyChanges(contentChanges.getChanges());\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new AddColumnsTransformer(addedColumns);\n        transformation.performEagerTransformations(_this12.dependencyGraph, _this12.parser);\n\n        _this12.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.rewriteAffectedArrays(affectedArrays);\n    }\n  }, {\n    key: \"getOldContent\",\n    value: function getOldContent(address) {\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n        return [address, {\n          type: ClipboardCellType.EMPTY\n        }];\n      } else if (vertex instanceof ValueCellVertex) {\n        return [address, Object.assign({\n          type: ClipboardCellType.VALUE\n        }, vertex.getValues())];\n      } else if (vertex instanceof FormulaVertex) {\n        return [vertex.getAddress(this.lazilyTransformingAstService), {\n          type: ClipboardCellType.FORMULA,\n          hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n        }];\n      } else if (vertex instanceof ParsingErrorVertex) {\n        return [address, {\n          type: ClipboardCellType.PARSING_ERROR,\n          rawInput: vertex.rawInput,\n          errors: vertex.errors\n        }];\n      }\n\n      throw Error('Trying to copy unsupported type');\n    }\n  }, {\n    key: \"getClipboardCell\",\n    value: function getClipboardCell(address) {\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n        return {\n          type: ClipboardCellType.EMPTY\n        };\n      } else if (vertex instanceof ValueCellVertex) {\n        return Object.assign({\n          type: ClipboardCellType.VALUE\n        }, vertex.getValues());\n      } else if (vertex instanceof ArrayVertex) {\n        var val = vertex.getArrayCellValue(address);\n\n        if (val === EmptyValue) {\n          return {\n            type: ClipboardCellType.EMPTY\n          };\n        }\n\n        return {\n          type: ClipboardCellType.VALUE,\n          parsedValue: val,\n          rawValue: vertex.getArrayCellRawValue(address)\n        };\n      } else if (vertex instanceof FormulaCellVertex) {\n        return {\n          type: ClipboardCellType.FORMULA,\n          hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n        };\n      } else if (vertex instanceof ParsingErrorVertex) {\n        return {\n          type: ClipboardCellType.PARSING_ERROR,\n          rawInput: vertex.rawInput,\n          errors: vertex.errors\n        };\n      }\n\n      throw Error('Trying to copy unsupported type');\n    }\n  }, {\n    key: \"getSheetClipboardCells\",\n    value: function getSheetClipboardCells(sheet) {\n      var sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n      var sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n      var arr = new Array(sheetHeight);\n\n      for (var i = 0; i < sheetHeight; i++) {\n        arr[i] = new Array(sheetWidth);\n\n        for (var j = 0; j < sheetWidth; j++) {\n          var address = simpleCellAddress(sheet, j, i);\n          arr[i][j] = this.getClipboardCell(address);\n        }\n      }\n\n      return arr;\n    }\n  }, {\n    key: \"getRangeClipboardCells\",\n    value: function getRangeClipboardCells(range) {\n      var result = [];\n\n      var _iterator11 = _createForOfIteratorHelper(range.addresses(this.dependencyGraph)),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var address = _step11.value;\n          result.push([address, this.getClipboardCell(address)]);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"setCellContent\",\n    value: function setCellContent(address, newCellContent) {\n      var parsedCellContent = this.cellContentParser.parse(newCellContent);\n      var oldContent = this.getOldContent(address);\n\n      if (parsedCellContent instanceof CellContent.Formula) {\n        var parserResult = this.parser.parse(parsedCellContent.formula, address);\n        var ast = parserResult.ast,\n            errors = parserResult.errors;\n\n        if (errors.length > 0) {\n          this.setParsingErrorToCell(parsedCellContent.formula, errors, address);\n        } else {\n          var size = this.arraySizePredictor.checkArraySize(ast, address);\n          this.setFormulaToCell(address, size, parserResult);\n        }\n      } else if (parsedCellContent instanceof CellContent.Empty) {\n        this.setCellEmpty(address);\n      } else {\n        this.setValueToCell({\n          parsedValue: parsedCellContent.value,\n          rawValue: newCellContent\n        }, address);\n      }\n\n      return oldContent;\n    }\n  }, {\n    key: \"setSheetContent\",\n    value: function setSheetContent(sheetId, newSheetContent) {\n      this.clearSheet(sheetId);\n\n      for (var i = 0; i < newSheetContent.length; i++) {\n        for (var j = 0; j < newSheetContent[i].length; j++) {\n          var address = simpleCellAddress(sheetId, j, i);\n          this.setCellContent(address, newSheetContent[i][j]);\n        }\n      }\n    }\n  }, {\n    key: \"setParsingErrorToCell\",\n    value: function setParsingErrorToCell(rawInput, errors, address) {\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      var vertex = new ParsingErrorVertex(errors, rawInput);\n      var arrayChanges = this.dependencyGraph.setParsingErrorToCell(address, vertex);\n      this.columnSearch.remove(getRawValue(oldValue), address);\n      this.columnSearch.applyChanges(arrayChanges.getChanges());\n      this.changes.addAll(arrayChanges);\n      this.changes.addChange(vertex.getCellValue(), address);\n    }\n  }, {\n    key: \"setFormulaToCell\",\n    value: function setFormulaToCell(address, size, _ref5) {\n      var ast = _ref5.ast,\n          hasVolatileFunction = _ref5.hasVolatileFunction,\n          hasStructuralChangeFunction = _ref5.hasStructuralChangeFunction,\n          dependencies = _ref5.dependencies;\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      var arrayChanges = this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), size, hasVolatileFunction, hasStructuralChangeFunction);\n      this.columnSearch.remove(getRawValue(oldValue), address);\n      this.columnSearch.applyChanges(arrayChanges.getChanges());\n      this.changes.addAll(arrayChanges);\n    }\n  }, {\n    key: \"setValueToCell\",\n    value: function setValueToCell(value, address) {\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      var arrayChanges = this.dependencyGraph.setValueToCell(address, value);\n      this.columnSearch.change(getRawValue(oldValue), getRawValue(value.parsedValue), address);\n      this.columnSearch.applyChanges(arrayChanges.getChanges().filter(function (change) {\n        return !equalSimpleCellAddress(change.address, address);\n      }));\n      this.changes.addAll(arrayChanges);\n      this.changes.addChange(value.parsedValue, address);\n    }\n  }, {\n    key: \"setCellEmpty\",\n    value: function setCellEmpty(address) {\n      if (this.dependencyGraph.isArrayInternalCell(address)) {\n        return;\n      }\n\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      var arrayChanges = this.dependencyGraph.setCellEmpty(address);\n      this.columnSearch.remove(getRawValue(oldValue), address);\n      this.columnSearch.applyChanges(arrayChanges.getChanges());\n      this.changes.addAll(arrayChanges);\n      this.changes.addChange(EmptyValue, address);\n    }\n  }, {\n    key: \"setFormulaToCellFromCache\",\n    value: function setFormulaToCellFromCache(formulaHash, address) {\n      var _this$parser$fetchCac2 = this.parser.fetchCachedResult(formulaHash),\n          ast = _this$parser$fetchCac2.ast,\n          hasVolatileFunction = _this$parser$fetchCac2.hasVolatileFunction,\n          hasStructuralChangeFunction = _this$parser$fetchCac2.hasStructuralChangeFunction,\n          dependencies = _this$parser$fetchCac2.dependencies;\n\n      var absoluteDependencies = absolutizeDependencies(dependencies, address);\n\n      var _CleanOutOfScopeDepen = new CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address),\n          _CleanOutOfScopeDepen2 = _slicedToArray(_CleanOutOfScopeDepen, 1),\n          cleanedAst = _CleanOutOfScopeDepen2[0];\n\n      this.parser.rememberNewAst(cleanedAst);\n      var cleanedDependencies = filterDependenciesOutOfScope(absoluteDependencies);\n      var size = this.arraySizePredictor.checkArraySize(ast, address);\n      this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, size, hasVolatileFunction, hasStructuralChangeFunction);\n    }\n    /**\n     * Returns true if row number is outside of given sheet.\n     *\n     * @param row - row number\n     * @param sheet - sheet id number\n     */\n\n  }, {\n    key: \"rowEffectivelyNotInSheet\",\n    value: function rowEffectivelyNotInSheet(row, sheet) {\n      var height = this.dependencyGraph.addressMapping.getHeight(sheet);\n      return row >= height;\n    }\n  }, {\n    key: \"getAndClearContentChanges\",\n    value: function getAndClearContentChanges() {\n      var changes = this.changes;\n      this.changes = ContentChanges.empty();\n      return changes;\n    }\n  }, {\n    key: \"forceApplyPostponedTransformations\",\n    value: function forceApplyPostponedTransformations() {\n      this.dependencyGraph.forceApplyPostponedTransformations();\n    }\n  }, {\n    key: \"sheetMapping\",\n    get: function get() {\n      return this.dependencyGraph.sheetMapping;\n    }\n    /**\n     * Returns true if row number is outside of given sheet.\n     *\n     * @param column - row number\n     * @param sheet - sheet id number\n     */\n\n  }, {\n    key: \"columnEffectivelyNotInSheet\",\n    value: function columnEffectivelyNotInSheet(column, sheet) {\n      var width = this.dependencyGraph.addressMapping.getWidth(sheet);\n      return column >= width;\n    }\n  }, {\n    key: \"adjustNamedExpressionEdges\",\n    value: function adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {\n      if (sheetId === undefined) {\n        return;\n      }\n\n      var localVertex = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);\n      var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n      var globalVertex = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);\n\n      var _iterator12 = _createForOfIteratorHelper(this.dependencyGraph.graph.adjacentNodes(globalVertex)),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var adjacentNode = _step12.value;\n\n          if (adjacentNode instanceof FormulaCellVertex && adjacentNode.getAddress(this.lazilyTransformingAstService).sheet === sheetId) {\n            var ast = adjacentNode.getFormula(this.lazilyTransformingAstService);\n            var formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);\n\n            var _this$parser$fetchCac3 = this.parser.fetchCachedResultForAst(ast),\n                dependencies = _this$parser$fetchCac3.dependencies;\n\n            var _iterator13 = _createForOfIteratorHelper(absolutizeDependencies(dependencies, formulaAddress)),\n                _step13;\n\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var dependency = _step13.value;\n\n                if (dependency instanceof NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {\n                  this.dependencyGraph.graph.removeEdge(globalVertex, adjacentNode);\n                  this.dependencyGraph.graph.addEdge(localVertex, adjacentNode);\n                }\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }, {\n    key: \"storeNamedExpressionInCell\",\n    value: function storeNamedExpressionInCell(address, expression) {\n      var parsedCellContent = this.cellContentParser.parse(expression);\n\n      if (parsedCellContent instanceof CellContent.Formula) {\n        var parsingResult = this.parser.parse(parsedCellContent.formula, simpleCellAddress(-1, 0, 0));\n\n        if (doesContainRelativeReferences(parsingResult.ast)) {\n          throw new NoRelativeAddressesAllowedError();\n        }\n\n        var ast = parsingResult.ast,\n            hasVolatileFunction = parsingResult.hasVolatileFunction,\n            hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,\n            dependencies = parsingResult.dependencies;\n        this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n      } else if (parsedCellContent instanceof CellContent.Empty) {\n        this.setCellEmpty(address);\n      } else {\n        this.setValueToCell({\n          parsedValue: parsedCellContent.value,\n          rawValue: expression\n        }, address);\n      }\n    }\n  }, {\n    key: \"updateNamedExpressionsForMovedCells\",\n    value: function updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {\n        return [];\n      }\n\n      var addedGlobalNamedExpressions = [];\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n\n      var _iterator14 = _createForOfIteratorHelper(targetRange.addresses(this.dependencyGraph)),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var formulaAddress = _step14.value;\n          var vertex = this.addressMapping.fetchCell(formulaAddress);\n\n          if (vertex instanceof FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {\n            var ast = vertex.getFormula(this.lazilyTransformingAstService);\n\n            var _this$parser$fetchCac4 = this.parser.fetchCachedResultForAst(ast),\n                dependencies = _this$parser$fetchCac4.dependencies;\n\n            addedGlobalNamedExpressions.push.apply(addedGlobalNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies)));\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      return addedGlobalNamedExpressions;\n    }\n  }, {\n    key: \"updateNamedExpressionsForTargetAddress\",\n    value: function updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {\n      if (sourceSheet === targetAddress.sheet) {\n        return [];\n      }\n\n      var addedGlobalNamedExpressions = [];\n      var vertex = this.addressMapping.fetchCell(targetAddress);\n\n      var _iterator15 = _createForOfIteratorHelper(absolutizeDependencies(dependencies, targetAddress)),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var namedExpressionDependency = _step15.value;\n\n          if (!(namedExpressionDependency instanceof NamedExpressionDependency)) {\n            continue;\n          }\n\n          var expressionName = namedExpressionDependency.name;\n          var sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet);\n          var namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);\n          var targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet) : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);\n\n          if (targetScopeExpressionVertex !== sourceVertex) {\n            this.dependencyGraph.graph.softRemoveEdge(sourceVertex, vertex);\n            this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);\n          }\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      return addedGlobalNamedExpressions;\n    }\n  }, {\n    key: \"allocateNamedExpressionAddressSpace\",\n    value: function allocateNamedExpressionAddressSpace() {\n      this.dependencyGraph.addressMapping.addSheet(-1, new SparseStrategy(0, 0));\n    }\n  }, {\n    key: \"copyOrFetchGlobalNamedExpressionVertex\",\n    value: function copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {\n      var expression = this.namedExpressions.namedExpressionForScope(expressionName);\n\n      if (expression === undefined) {\n        expression = this.namedExpressions.addNamedExpression(expressionName);\n        addedNamedExpressions.push(expression.normalizeExpressionName());\n\n        if (sourceVertex instanceof FormulaCellVertex) {\n          var parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));\n          var ast = parsingResult.ast,\n              hasVolatileFunction = parsingResult.hasVolatileFunction,\n              hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,\n              dependencies = parsingResult.dependencies;\n          this.dependencyGraph.setFormulaToCell(expression.address, ast, absolutizeDependencies(dependencies, expression.address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n        } else if (sourceVertex instanceof EmptyCellVertex) {\n          this.setCellEmpty(expression.address);\n        } else if (sourceVertex instanceof ValueCellVertex) {\n          this.setValueToCell(sourceVertex.getValues(), expression.address);\n        }\n      }\n\n      return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address);\n    }\n  }, {\n    key: \"addressMapping\",\n    get: function get() {\n      return this.dependencyGraph.addressMapping;\n    }\n  }]);\n\n  return Operations;\n}();\nexport function normalizeRemovedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n\n  var sorted = _toConsumableArray(indexes).sort(function (_ref6, _ref7) {\n    var _ref8 = _slicedToArray(_ref6, 1),\n        a = _ref8[0];\n\n    var _ref9 = _slicedToArray(_ref7, 1),\n        b = _ref9[0];\n\n    return a - b;\n  });\n  /* merge overlapping and adjacent indexes */\n\n\n  var merged = sorted.reduce(function (acc, _ref10) {\n    var _ref11 = _slicedToArray(_ref10, 2),\n        startIndex = _ref11[0],\n        amount = _ref11[1];\n\n    var previous = acc[acc.length - 1];\n    var lastIndex = previous[0] + previous[1];\n\n    if (startIndex <= lastIndex) {\n      previous[1] += Math.max(0, amount - (lastIndex - startIndex));\n    } else {\n      acc.push([startIndex, amount]);\n    }\n\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n\n  var shift = 0;\n\n  for (var i = 0; i < merged.length; ++i) {\n    merged[i][0] -= shift;\n    shift += merged[i][1];\n  }\n\n  return merged;\n}\nexport function normalizeAddedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n\n  var sorted = _toConsumableArray(indexes).sort(function (_ref12, _ref13) {\n    var _ref14 = _slicedToArray(_ref12, 1),\n        a = _ref14[0];\n\n    var _ref15 = _slicedToArray(_ref13, 1),\n        b = _ref15[0];\n\n    return a - b;\n  });\n  /* merge indexes with same start */\n\n\n  var merged = sorted.reduce(function (acc, _ref16) {\n    var _ref17 = _slicedToArray(_ref16, 2),\n        startIndex = _ref17[0],\n        amount = _ref17[1];\n\n    var previous = acc[acc.length - 1];\n\n    if (startIndex === previous[0]) {\n      previous[1] = Math.max(previous[1], amount);\n    } else {\n      acc.push([startIndex, amount]);\n    }\n\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n\n  var shift = 0;\n\n  for (var i = 0; i < merged.length; ++i) {\n    merged[i][0] += shift;\n    shift += merged[i][1];\n  }\n\n  return merged;\n}\n\nfunction isPositiveInteger(x) {\n  return Number.isInteger(x) && x > 0;\n}\n\nfunction isRowOrColumnRange(leftCorner, width, height) {\n  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/Operations.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","_i","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","_createForOfIteratorHelper","o","allowArrayLike","it","F","s","n","e","_e2","f","normalCompletion","didErr","step","_e3","return","minLen","Object","prototype","toString","slice","constructor","name","test","len","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","AbsoluteCellRange","absolutizeDependencies","filterDependenciesOutOfScope","ArraySize","equalSimpleCellAddress","invalidSimpleCellAddress","simpleCellAddress","CellContent","ClipboardCellType","ContentChanges","ArrayVertex","EmptyCellVertex","FormulaCellVertex","ParsingErrorVertex","SparseStrategy","ValueCellVertex","FormulaVertex","AddColumnsTransformer","AddRowsTransformer","CleanOutOfScopeDependenciesTransformer","MoveCellsTransformer","RemoveColumnsTransformer","RemoveRowsTransformer","RemoveSheetTransformer","InvalidArgumentsError","NamedExpressionDoesNotExistError","NoRelativeAddressesAllowedError","SheetSizeLimitExceededError","SourceLocationHasArrayError","TargetLocationHasArrayError","EmptyValue","getRawValue","doesContainRelativeReferences","NamedExpressionDependency","findBoundaries","ColumnsSpan","RowsSpan","StatType","RemoveRowsCommand","sheet","indexes","normalizedIndexes","normalizeRemovedIndexes","rowsSpans","_this","map","normalizedIndex","fromNumberOfRows","AddRowsCommand","normalizeAddedIndexes","_this2","AddColumnsCommand","columnsSpans","_this3","fromNumberOfColumns","RemoveColumnsCommand","_this4","Operations","config","dependencyGraph","columnSearch","cellContentParser","parser","stats","lazilyTransformingAstService","namedExpressions","arraySizePredictor","changes","empty","allocateNamedExpressionAddressSpace","maxColumns","maxRows","removeRows","cmd","rowsRemovals","_iterator","_step","rowsToRemove","rowsRemoval","doRemoveRows","addRows","_iterator2","_step2","addedRows","doAddRows","addColumns","_iterator3","_step3","addedColumns","doAddColumns","removeColumns","columnsRemovals","_iterator4","_step4","columnsToRemove","columnsRemoval","doRemoveColumns","removeSheet","sheetId","_this5","version","measure","TRANSFORM_ASTS","transformation","performEagerTransformations","addTransformation","sheetMapping","scopedNamedExpressions","getAllNamedExpressionsForScope","namedexpression","removeNamedExpression","normalizeExpressionName","removeSheetByName","sheetName","fetch","clearSheet","addSheet","addressMapping","autoAddSheet","fetchDisplayName","renameSheet","newName","moveRows","startRow","numberOfRows","targetRow","rowsToAdd","beginCombinedMode","startAddress","targetAddress","moveCells","Number","POSITIVE_INFINITY","commitCombinedMode","moveColumns","startColumn","numberOfColumns","targetColumn","columnsToAdd","sourceLeftCorner","width","height","destinationLeftCorner","_this6","ensureItIsPossibleToMoveCells","sourceRange","spanFrom","targetRange","toRight","col","toBottom","row","toSheet","currentDataAtTarget","getRangeClipboardCells","valuesToRemove","rawValuesFromRange","removeValues","valuesToMove","moveValues","addedGlobalNamedExpressions","updateNamedExpressionsForMovedCells","overwrittenCellsData","setRowOrder","rowMapping","_this7","buffer","oldContent","_iterator5","_step5","_loop","_step5$value","source","rowRange","Infinity","concat","_ref","_ref2","_ref2$","cell","forEach","restoreClipboardCells","values","setColumnOrder","columnMapping","_this8","_iterator6","_step6","_loop2","_step6$value","column","_ref3","_ref4","_ref4$","addNamedExpression","expressionName","expression","options","namedExpression","storeNamedExpressionInCell","address","adjustNamedExpressionEdges","restoreNamedExpression","content","displayName","restoreCell","restoredNamedExpression","changeNamedExpressionExpression","newExpression","namedExpressionForScope","oldNamedExpression","copy","getClipboardCell","remove","undefined","globalNamedExpression","workbookNamedExpressionOrPlaceholder","exchangeNode","setCellEmpty","isPositiveInteger","isRowOrColumnRange","hasSheetWithId","exceedsSheetSizeLimits","arrayMapping","isFormulaArrayInRange","sourceSheetId","cells","addedNamedExpressions","_iterator7","_step7","_step7$value","clipboardCell","type","FORMULA","_this$parser$fetchCac","fetchCachedResult","hash","dependencies","apply","updateNamedExpressionsForTargetAddress","VALUE","setValueToCell","setFormulaToCellFromCache","EMPTY","PARSING_ERROR","setParsingErrorToCell","rawInput","errors","_this9","rowEffectivelyNotInSheet","rowStart","removedCells","_iterator8","entriesFromRowsSpan","_step8","_step8$value","cellType","_this$dependencyGraph","affectedArrays","contentChanges","applyChanges","getChanges","rewriteAffectedArrays","rowFrom","rowCount","_this10","columnEffectivelyNotInSheet","columnStart","_iterator9","entriesFromColumnsSpan","_step9","_step9$value","_this$dependencyGraph2","columnFrom","columnCount","_this11","_this$dependencyGraph3","_iterator10","_step10","arrayVertex","array","size","isRef","ast","getFormula","getAddress","computeHashFromAst","_this12","_this$dependencyGraph4","getOldContent","vertex","getCell","assign","getValues","Error","val","getArrayCellValue","parsedValue","rawValue","getArrayCellRawValue","getSheetClipboardCells","sheetHeight","getSheetHeight","sheetWidth","getSheetWidth","j","range","result","_iterator11","addresses","_step11","setCellContent","newCellContent","parsedCellContent","parse","Formula","parserResult","formula","checkArraySize","setFormulaToCell","Empty","setSheetContent","newSheetContent","oldValue","getCellValue","arrayChanges","addAll","addChange","_ref5","hasVolatileFunction","hasStructuralChangeFunction","change","filter","isArrayInternalCell","formulaHash","_this$parser$fetchCac2","absoluteDependencies","_CleanOutOfScopeDepen","transformSingleAst","_CleanOutOfScopeDepen2","cleanedAst","rememberNewAst","cleanedDependencies","getHeight","getAndClearContentChanges","forceApplyPostponedTransformations","get","getWidth","localVertex","fetchCellOrCreateEmpty","globalVertex","_iterator12","graph","adjacentNodes","_step12","adjacentNode","formulaAddress","_this$parser$fetchCac3","fetchCachedResultForAst","_iterator13","_step13","dependency","toLowerCase","removeEdge","addEdge","parsingResult","scalar","_iterator14","_step14","fetchCell","_this$parser$fetchCac4","sourceSheet","_iterator15","_step15","namedExpressionDependency","sourceVertex","fetchNamedExpressionVertex","namedExpressionInTargetScope","isExpressionInScope","targetScopeExpressionVertex","copyOrFetchGlobalNamedExpressionVertex","softRemoveEdge","sorted","sort","_ref6","_ref7","_ref8","a","_ref9","b","merged","reduce","acc","_ref10","_ref11","startIndex","amount","previous","lastIndex","Math","max","shift","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","x","isInteger","leftCorner"],"mappings":"AAAA,SAASA,kBAAT,CAA4BC,GAA5B,EAAiC;AAAE,SAAOC,kBAAkB,CAACD,GAAD,CAAlB,IAA2BE,gBAAgB,CAACF,GAAD,CAA3C,IAAoDG,2BAA2B,CAACH,GAAD,CAA/E,IAAwFI,kBAAkB,EAAjH;AAAsH;;AAEzJ,SAASA,kBAAT,GAA8B;AAAE,QAAM,IAAIC,SAAJ,CAAc,sIAAd,CAAN;AAA8J;;AAE9L,SAASH,gBAAT,CAA0BI,IAA1B,EAAgC;AAAE,MAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCD,IAAI,CAACC,MAAM,CAACC,QAAR,CAAJ,IAAyB,IAA1D,IAAkEF,IAAI,CAAC,YAAD,CAAJ,IAAsB,IAA5F,EAAkG,OAAOG,KAAK,CAACC,IAAN,CAAWJ,IAAX,CAAP;AAA0B;;AAE9J,SAASL,kBAAT,CAA4BD,GAA5B,EAAiC;AAAE,MAAIS,KAAK,CAACE,OAAN,CAAcX,GAAd,CAAJ,EAAwB,OAAOY,iBAAiB,CAACZ,GAAD,CAAxB;AAAgC;;AAE3F,SAASa,cAAT,CAAwBb,GAAxB,EAA6Bc,CAA7B,EAAgC;AAAE,SAAOC,eAAe,CAACf,GAAD,CAAf,IAAwBgB,qBAAqB,CAAChB,GAAD,EAAMc,CAAN,CAA7C,IAAyDX,2BAA2B,CAACH,GAAD,EAAMc,CAAN,CAApF,IAAgGG,gBAAgB,EAAvH;AAA4H;;AAE9J,SAASA,gBAAT,GAA4B;AAAE,QAAM,IAAIZ,SAAJ,CAAc,2IAAd,CAAN;AAAmK;;AAEjM,SAASW,qBAAT,CAA+BhB,GAA/B,EAAoCc,CAApC,EAAuC;AAAE,MAAII,EAAE,GAAGlB,GAAG,IAAI,IAAP,GAAc,IAAd,GAAqB,OAAOO,MAAP,KAAkB,WAAlB,IAAiCP,GAAG,CAACO,MAAM,CAACC,QAAR,CAApC,IAAyDR,GAAG,CAAC,YAAD,CAA1F;;AAA0G,MAAIkB,EAAE,IAAI,IAAV,EAAgB;AAAQ,MAAIC,IAAI,GAAG,EAAX;AAAe,MAAIC,EAAE,GAAG,IAAT;AAAe,MAAIC,EAAE,GAAG,KAAT;;AAAgB,MAAIC,EAAJ,EAAQC,EAAR;;AAAY,MAAI;AAAE,SAAKL,EAAE,GAAGA,EAAE,CAACM,IAAH,CAAQxB,GAAR,CAAV,EAAwB,EAAEoB,EAAE,GAAG,CAACE,EAAE,GAAGJ,EAAE,CAACO,IAAH,EAAN,EAAiBC,IAAxB,CAAxB,EAAuDN,EAAE,GAAG,IAA5D,EAAkE;AAAED,MAAAA,IAAI,CAACQ,IAAL,CAAUL,EAAE,CAACM,KAAb;;AAAqB,UAAId,CAAC,IAAIK,IAAI,CAACU,MAAL,KAAgBf,CAAzB,EAA4B;AAAQ;AAAE,GAArI,CAAsI,OAAOgB,GAAP,EAAY;AAAET,IAAAA,EAAE,GAAG,IAAL;AAAWE,IAAAA,EAAE,GAAGO,GAAL;AAAW,GAA1K,SAAmL;AAAE,QAAI;AAAE,UAAI,CAACV,EAAD,IAAOF,EAAE,CAAC,QAAD,CAAF,IAAgB,IAA3B,EAAiCA,EAAE,CAAC,QAAD,CAAF;AAAiB,KAAxD,SAAiE;AAAE,UAAIG,EAAJ,EAAQ,MAAME,EAAN;AAAW;AAAE;;AAAC,SAAOJ,IAAP;AAAc;;AAEjgB,SAASJ,eAAT,CAAyBf,GAAzB,EAA8B;AAAE,MAAIS,KAAK,CAACE,OAAN,CAAcX,GAAd,CAAJ,EAAwB,OAAOA,GAAP;AAAa;;AAErE,SAAS+B,0BAAT,CAAoCC,CAApC,EAAuCC,cAAvC,EAAuD;AAAE,MAAIC,EAAE,GAAG,OAAO3B,MAAP,KAAkB,WAAlB,IAAiCyB,CAAC,CAACzB,MAAM,CAACC,QAAR,CAAlC,IAAuDwB,CAAC,CAAC,YAAD,CAAjE;;AAAiF,MAAI,CAACE,EAAL,EAAS;AAAE,QAAIzB,KAAK,CAACE,OAAN,CAAcqB,CAAd,MAAqBE,EAAE,GAAG/B,2BAA2B,CAAC6B,CAAD,CAArD,KAA6DC,cAAc,IAAID,CAAlB,IAAuB,OAAOA,CAAC,CAACH,MAAT,KAAoB,QAA5G,EAAsH;AAAE,UAAIK,EAAJ,EAAQF,CAAC,GAAGE,EAAJ;AAAQ,UAAIpB,CAAC,GAAG,CAAR;;AAAW,UAAIqB,CAAC,GAAG,SAASA,CAAT,GAAa,CAAE,CAAvB;;AAAyB,aAAO;AAAEC,QAAAA,CAAC,EAAED,CAAL;AAAQE,QAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,cAAIvB,CAAC,IAAIkB,CAAC,CAACH,MAAX,EAAmB,OAAO;AAAEH,YAAAA,IAAI,EAAE;AAAR,WAAP;AAAuB,iBAAO;AAAEA,YAAAA,IAAI,EAAE,KAAR;AAAeE,YAAAA,KAAK,EAAEI,CAAC,CAAClB,CAAC,EAAF;AAAvB,WAAP;AAAwC,SAA5G;AAA8GwB,QAAAA,CAAC,EAAE,SAASA,CAAT,CAAWC,GAAX,EAAgB;AAAE,gBAAMA,GAAN;AAAY,SAA/I;AAAiJC,QAAAA,CAAC,EAAEL;AAApJ,OAAP;AAAiK;;AAAC,UAAM,IAAI9B,SAAJ,CAAc,uIAAd,CAAN;AAA+J;;AAAC,MAAIoC,gBAAgB,GAAG,IAAvB;AAAA,MAA6BC,MAAM,GAAG,KAAtC;AAAA,MAA6CZ,GAA7C;AAAkD,SAAO;AAAEM,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAEF,MAAAA,EAAE,GAAGA,EAAE,CAACV,IAAH,CAAQQ,CAAR,CAAL;AAAkB,KAAtC;AAAwCK,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,UAAIM,IAAI,GAAGT,EAAE,CAACT,IAAH,EAAX;AAAsBgB,MAAAA,gBAAgB,GAAGE,IAAI,CAACjB,IAAxB;AAA8B,aAAOiB,IAAP;AAAc,KAA5H;AAA8HL,IAAAA,CAAC,EAAE,SAASA,CAAT,CAAWM,GAAX,EAAgB;AAAEF,MAAAA,MAAM,GAAG,IAAT;AAAeZ,MAAAA,GAAG,GAAGc,GAAN;AAAY,KAA9K;AAAgLJ,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,UAAI;AAAE,YAAI,CAACC,gBAAD,IAAqBP,EAAE,CAACW,MAAH,IAAa,IAAtC,EAA4CX,EAAE,CAACW,MAAH;AAAc,OAAhE,SAAyE;AAAE,YAAIH,MAAJ,EAAY,MAAMZ,GAAN;AAAY;AAAE;AAAvS,GAAP;AAAmT;;AAEx+B,SAAS3B,2BAAT,CAAqC6B,CAArC,EAAwCc,MAAxC,EAAgD;AAAE,MAAI,CAACd,CAAL,EAAQ;AAAQ,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOpB,iBAAiB,CAACoB,CAAD,EAAIc,MAAJ,CAAxB;AAAqC,MAAIT,CAAC,GAAGU,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BzB,IAA1B,CAA+BQ,CAA/B,EAAkCkB,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;AAAwD,MAAIb,CAAC,KAAK,QAAN,IAAkBL,CAAC,CAACmB,WAAxB,EAAqCd,CAAC,GAAGL,CAAC,CAACmB,WAAF,CAAcC,IAAlB;AAAwB,MAAIf,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAO5B,KAAK,CAACC,IAAN,CAAWsB,CAAX,CAAP;AAAsB,MAAIK,CAAC,KAAK,WAAN,IAAqB,2CAA2CgB,IAA3C,CAAgDhB,CAAhD,CAAzB,EAA6E,OAAOzB,iBAAiB,CAACoB,CAAD,EAAIc,MAAJ,CAAxB;AAAsC;;AAEha,SAASlC,iBAAT,CAA2BZ,GAA3B,EAAgCsD,GAAhC,EAAqC;AAAE,MAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGtD,GAAG,CAAC6B,MAA7B,EAAqCyB,GAAG,GAAGtD,GAAG,CAAC6B,MAAV;;AAAkB,OAAK,IAAIf,CAAC,GAAG,CAAR,EAAWyC,IAAI,GAAG,IAAI9C,KAAJ,CAAU6C,GAAV,CAAvB,EAAuCxC,CAAC,GAAGwC,GAA3C,EAAgDxC,CAAC,EAAjD,EAAqD;AAAEyC,IAAAA,IAAI,CAACzC,CAAD,CAAJ,GAAUd,GAAG,CAACc,CAAD,CAAb;AAAmB;;AAAC,SAAOyC,IAAP;AAAc;;AAqBvL,SAASC,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIrD,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASsD,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAI/C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+C,KAAK,CAAChC,MAA1B,EAAkCf,CAAC,EAAnC,EAAuC;AAAE,QAAIgD,UAAU,GAAGD,KAAK,CAAC/C,CAAD,CAAtB;AAA2BgD,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BlB,IAAAA,MAAM,CAACmB,cAAP,CAAsBN,MAAtB,EAA8BE,UAAU,CAACK,GAAzC,EAA8CL,UAA9C;AAA4D;AAAE;;AAE7T,SAASM,YAAT,CAAsBV,WAAtB,EAAmCW,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBV,iBAAiB,CAACD,WAAW,CAACV,SAAb,EAAwBqB,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBX,iBAAiB,CAACD,WAAD,EAAcY,WAAd,CAAjB;AAA6C,SAAOZ,WAAP;AAAqB;AAEvN;AACA;AACA;AACA;;;AACA,SAASa,iBAAT,QAAkC,qBAAlC;AACA,SAASC,sBAAT,EAAiCC,4BAAjC,QAAqE,0BAArE;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,sBAAT,EAAiCC,wBAAjC,EAA2DC,iBAA3D,QAAoF,QAApF;AACA,SAASC,WAAT,QAA4B,qBAA5B;AACA,SAASC,iBAAT,QAAkC,uBAAlC;AACA,SAASC,cAAT,QAA+B,kBAA/B;AACA,SAASC,WAAT,EAAsBC,eAAtB,EAAuCC,iBAAvC,EAA0DC,kBAA1D,EAA8EC,cAA9E,EAA8FC,eAA9F,QAAqH,mBAArH;AACA,SAASC,aAAT,QAA8B,qCAA9B;AACA,SAASC,qBAAT,QAAsC,gDAAtC;AACA,SAASC,kBAAT,QAAmC,6CAAnC;AACA,SAASC,sCAAT,QAAuD,iEAAvD;AACA,SAASC,oBAAT,QAAqC,+CAArC;AACA,SAASC,wBAAT,QAAyC,mDAAzC;AACA,SAASC,qBAAT,QAAsC,gDAAtC;AACA,SAASC,sBAAT,QAAuC,iDAAvC;AACA,SAASC,qBAAT,EAAgCC,gCAAhC,EAAkEC,+BAAlE,EAAmGC,2BAAnG,EAAgIC,2BAAhI,EAA6JC,2BAA7J,QAAgM,UAAhM;AACA,SAASC,UAAT,EAAqBC,WAArB,QAAwC,gCAAxC;AACA,SAASC,6BAAT,QAA8C,oBAA9C;AACA,SAASC,yBAAT,QAA0C,UAA1C;AACA,SAASC,cAAT,QAA+B,SAA/B;AACA,SAASC,WAAT,EAAsBC,QAAtB,QAAsC,QAAtC;AACA,SAASC,QAAT,QAAyB,cAAzB;AACA,OAAO,IAAIC,iBAAiB,GAAG,aAAa,YAAY;AACtD,WAASA,iBAAT,CAA2BC,KAA3B,EAAkCC,OAAlC,EAA2C;AACzCvD,IAAAA,eAAe,CAAC,IAAD,EAAOqD,iBAAP,CAAf;;AAEA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAED3C,EAAAA,YAAY,CAACyC,iBAAD,EAAoB,CAAC;AAC/B1C,IAAAA,GAAG,EAAE,mBAD0B;AAE/BvC,IAAAA,KAAK,EAAE,SAASoF,iBAAT,GAA6B;AAClC,aAAOC,uBAAuB,CAAC,KAAKF,OAAN,CAA9B;AACD;AAJ8B,GAAD,EAK7B;AACD5C,IAAAA,GAAG,EAAE,WADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASsF,SAAT,GAAqB;AAC1B,UAAIC,KAAK,GAAG,IAAZ;;AAEA,aAAO,KAAKH,iBAAL,GAAyBI,GAAzB,CAA6B,UAAUC,eAAV,EAA2B;AAC7D,eAAOV,QAAQ,CAACW,gBAAT,CAA0BH,KAAK,CAACL,KAAhC,EAAuCO,eAAe,CAAC,CAAD,CAAtD,EAA2DA,eAAe,CAAC,CAAD,CAA1E,CAAP;AACD,OAFM,CAAP;AAGD;AARA,GAL6B,CAApB,CAAZ;;AAgBA,SAAOR,iBAAP;AACD,CAzB2C,EAArC;AA0BP,OAAO,IAAIU,cAAc,GAAG,aAAa,YAAY;AACnD,WAASA,cAAT,CAAwBT,KAAxB,EAA+BC,OAA/B,EAAwC;AACtCvD,IAAAA,eAAe,CAAC,IAAD,EAAO+D,cAAP,CAAf;;AAEA,SAAKT,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAED3C,EAAAA,YAAY,CAACmD,cAAD,EAAiB,CAAC;AAC5BpD,IAAAA,GAAG,EAAE,mBADuB;AAE5BvC,IAAAA,KAAK,EAAE,SAASoF,iBAAT,GAA6B;AAClC,aAAOQ,qBAAqB,CAAC,KAAKT,OAAN,CAA5B;AACD;AAJ2B,GAAD,EAK1B;AACD5C,IAAAA,GAAG,EAAE,WADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASsF,SAAT,GAAqB;AAC1B,UAAIO,MAAM,GAAG,IAAb;;AAEA,aAAO,KAAKT,iBAAL,GAAyBI,GAAzB,CAA6B,UAAUC,eAAV,EAA2B;AAC7D,eAAOV,QAAQ,CAACW,gBAAT,CAA0BG,MAAM,CAACX,KAAjC,EAAwCO,eAAe,CAAC,CAAD,CAAvD,EAA4DA,eAAe,CAAC,CAAD,CAA3E,CAAP;AACD,OAFM,CAAP;AAGD;AARA,GAL0B,CAAjB,CAAZ;;AAgBA,SAAOE,cAAP;AACD,CAzBwC,EAAlC;AA0BP,OAAO,IAAIG,iBAAiB,GAAG,aAAa,YAAY;AACtD,WAASA,iBAAT,CAA2BZ,KAA3B,EAAkCC,OAAlC,EAA2C;AACzCvD,IAAAA,eAAe,CAAC,IAAD,EAAOkE,iBAAP,CAAf;;AAEA,SAAKZ,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAED3C,EAAAA,YAAY,CAACsD,iBAAD,EAAoB,CAAC;AAC/BvD,IAAAA,GAAG,EAAE,mBAD0B;AAE/BvC,IAAAA,KAAK,EAAE,SAASoF,iBAAT,GAA6B;AAClC,aAAOQ,qBAAqB,CAAC,KAAKT,OAAN,CAA5B;AACD;AAJ8B,GAAD,EAK7B;AACD5C,IAAAA,GAAG,EAAE,cADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS+F,YAAT,GAAwB;AAC7B,UAAIC,MAAM,GAAG,IAAb;;AAEA,aAAO,KAAKZ,iBAAL,GAAyBI,GAAzB,CAA6B,UAAUC,eAAV,EAA2B;AAC7D,eAAOX,WAAW,CAACmB,mBAAZ,CAAgCD,MAAM,CAACd,KAAvC,EAA8CO,eAAe,CAAC,CAAD,CAA7D,EAAkEA,eAAe,CAAC,CAAD,CAAjF,CAAP;AACD,OAFM,CAAP;AAGD;AARA,GAL6B,CAApB,CAAZ;;AAgBA,SAAOK,iBAAP;AACD,CAzB2C,EAArC;AA0BP,OAAO,IAAII,oBAAoB,GAAG,aAAa,YAAY;AACzD,WAASA,oBAAT,CAA8BhB,KAA9B,EAAqCC,OAArC,EAA8C;AAC5CvD,IAAAA,eAAe,CAAC,IAAD,EAAOsE,oBAAP,CAAf;;AAEA,SAAKhB,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAED3C,EAAAA,YAAY,CAAC0D,oBAAD,EAAuB,CAAC;AAClC3D,IAAAA,GAAG,EAAE,mBAD6B;AAElCvC,IAAAA,KAAK,EAAE,SAASoF,iBAAT,GAA6B;AAClC,aAAOC,uBAAuB,CAAC,KAAKF,OAAN,CAA9B;AACD;AAJiC,GAAD,EAKhC;AACD5C,IAAAA,GAAG,EAAE,cADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS+F,YAAT,GAAwB;AAC7B,UAAII,MAAM,GAAG,IAAb;;AAEA,aAAO,KAAKf,iBAAL,GAAyBI,GAAzB,CAA6B,UAAUC,eAAV,EAA2B;AAC7D,eAAOX,WAAW,CAACmB,mBAAZ,CAAgCE,MAAM,CAACjB,KAAvC,EAA8CO,eAAe,CAAC,CAAD,CAA7D,EAAkEA,eAAe,CAAC,CAAD,CAAjF,CAAP;AACD,OAFM,CAAP;AAGD;AARA,GALgC,CAAvB,CAAZ;;AAgBA,SAAOS,oBAAP;AACD,CAzB8C,EAAxC;AA0BP,OAAO,IAAIE,UAAU,GAAG,aAAa,YAAY;AAC/C,WAASA,UAAT,CAAoBC,MAApB,EAA4BC,eAA5B,EAA6CC,YAA7C,EAA2DC,iBAA3D,EAA8EC,MAA9E,EAAsFC,KAAtF,EAA6FC,4BAA7F,EAA2HC,gBAA3H,EAA6IC,kBAA7I,EAAiK;AAC/JjF,IAAAA,eAAe,CAAC,IAAD,EAAOwE,UAAP,CAAf;;AAEA,SAAKE,eAAL,GAAuBA,eAAvB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,4BAAL,GAAoCA,4BAApC;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,OAAL,GAAe1D,cAAc,CAAC2D,KAAf,EAAf;AACA,SAAKC,mCAAL;AACA,SAAKC,UAAL,GAAkBZ,MAAM,CAACY,UAAzB;AACA,SAAKC,OAAL,GAAeb,MAAM,CAACa,OAAtB;AACD;;AAED1E,EAAAA,YAAY,CAAC4D,UAAD,EAAa,CAAC;AACxB7D,IAAAA,GAAG,EAAE,YADmB;AAExBvC,IAAAA,KAAK,EAAE,SAASmH,UAAT,CAAoBC,GAApB,EAAyB;AAC9B,UAAIC,YAAY,GAAG,EAAnB;;AAEA,UAAIC,SAAS,GAAGnH,0BAA0B,CAACiH,GAAG,CAAC9B,SAAJ,EAAD,CAA1C;AAAA,UACIiC,KADJ;;AAGA,UAAI;AACF,aAAKD,SAAS,CAAC9G,CAAV,EAAL,EAAoB,CAAC,CAAC+G,KAAK,GAAGD,SAAS,CAAC7G,CAAV,EAAT,EAAwBX,IAA7C,GAAoD;AAClD,cAAI0H,YAAY,GAAGD,KAAK,CAACvH,KAAzB;AACA,cAAIyH,WAAW,GAAG,KAAKC,YAAL,CAAkBF,YAAlB,CAAlB;;AAEA,cAAIC,WAAJ,EAAiB;AACfJ,YAAAA,YAAY,CAACtH,IAAb,CAAkB0H,WAAlB;AACD;AACF;AACF,OATD,CASE,OAAOvH,GAAP,EAAY;AACZoH,QAAAA,SAAS,CAAC5G,CAAV,CAAYR,GAAZ;AACD,OAXD,SAWU;AACRoH,QAAAA,SAAS,CAAC1G,CAAV;AACD;;AAED,aAAOyG,YAAP;AACD;AAxBuB,GAAD,EAyBtB;AACD9E,IAAAA,GAAG,EAAE,SADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS2H,OAAT,CAAiBP,GAAjB,EAAsB;AAC3B,UAAIQ,UAAU,GAAGzH,0BAA0B,CAACiH,GAAG,CAAC9B,SAAJ,EAAD,CAA3C;AAAA,UACIuC,MADJ;;AAGA,UAAI;AACF,aAAKD,UAAU,CAACpH,CAAX,EAAL,EAAqB,CAAC,CAACqH,MAAM,GAAGD,UAAU,CAACnH,CAAX,EAAV,EAA0BX,IAAhD,GAAuD;AACrD,cAAIgI,SAAS,GAAGD,MAAM,CAAC7H,KAAvB;AACA,eAAK+H,SAAL,CAAeD,SAAf;AACD;AACF,OALD,CAKE,OAAO5H,GAAP,EAAY;AACZ0H,QAAAA,UAAU,CAAClH,CAAX,CAAaR,GAAb;AACD,OAPD,SAOU;AACR0H,QAAAA,UAAU,CAAChH,CAAX;AACD;AACF;AAhBA,GAzBsB,EA0CtB;AACD2B,IAAAA,GAAG,EAAE,YADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASgI,UAAT,CAAoBZ,GAApB,EAAyB;AAC9B,UAAIa,UAAU,GAAG9H,0BAA0B,CAACiH,GAAG,CAACrB,YAAJ,EAAD,CAA3C;AAAA,UACImC,MADJ;;AAGA,UAAI;AACF,aAAKD,UAAU,CAACzH,CAAX,EAAL,EAAqB,CAAC,CAAC0H,MAAM,GAAGD,UAAU,CAACxH,CAAX,EAAV,EAA0BX,IAAhD,GAAuD;AACrD,cAAIqI,YAAY,GAAGD,MAAM,CAAClI,KAA1B;AACA,eAAKoI,YAAL,CAAkBD,YAAlB;AACD;AACF,OALD,CAKE,OAAOjI,GAAP,EAAY;AACZ+H,QAAAA,UAAU,CAACvH,CAAX,CAAaR,GAAb;AACD,OAPD,SAOU;AACR+H,QAAAA,UAAU,CAACrH,CAAX;AACD;AACF;AAhBA,GA1CsB,EA2DtB;AACD2B,IAAAA,GAAG,EAAE,eADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASqI,aAAT,CAAuBjB,GAAvB,EAA4B;AACjC,UAAIkB,eAAe,GAAG,EAAtB;;AAEA,UAAIC,UAAU,GAAGpI,0BAA0B,CAACiH,GAAG,CAACrB,YAAJ,EAAD,CAA3C;AAAA,UACIyC,MADJ;;AAGA,UAAI;AACF,aAAKD,UAAU,CAAC/H,CAAX,EAAL,EAAqB,CAAC,CAACgI,MAAM,GAAGD,UAAU,CAAC9H,CAAX,EAAV,EAA0BX,IAAhD,GAAuD;AACrD,cAAI2I,eAAe,GAAGD,MAAM,CAACxI,KAA7B;AACA,cAAI0I,cAAc,GAAG,KAAKC,eAAL,CAAqBF,eAArB,CAArB;;AAEA,cAAIC,cAAJ,EAAoB;AAClBJ,YAAAA,eAAe,CAACvI,IAAhB,CAAqB2I,cAArB;AACD;AACF;AACF,OATD,CASE,OAAOxI,GAAP,EAAY;AACZqI,QAAAA,UAAU,CAAC7H,CAAX,CAAaR,GAAb;AACD,OAXD,SAWU;AACRqI,QAAAA,UAAU,CAAC3H,CAAX;AACD;;AAED,aAAO0H,eAAP;AACD;AAxBA,GA3DsB,EAoFtB;AACD/F,IAAAA,GAAG,EAAE,aADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS4I,WAAT,CAAqBC,OAArB,EAA8B;AACnC,UAAIC,MAAM,GAAG,IAAb;;AAEA,WAAKxC,eAAL,CAAqBsC,WAArB,CAAiCC,OAAjC;AACA,UAAIE,OAAJ;AACA,WAAKrC,KAAL,CAAWsC,OAAX,CAAmBhE,QAAQ,CAACiE,cAA5B,EAA4C,YAAY;AACtD,YAAIC,cAAc,GAAG,IAAIhF,sBAAJ,CAA2B2E,OAA3B,CAArB;AACAK,QAAAA,cAAc,CAACC,2BAAf,CAA2CL,MAAM,CAACxC,eAAlD,EAAmEwC,MAAM,CAACrC,MAA1E;AACAsC,QAAAA,OAAO,GAAGD,MAAM,CAACnC,4BAAP,CAAoCyC,iBAApC,CAAsDF,cAAtD,CAAV;AACD,OAJD;AAKA,WAAKG,YAAL,CAAkBT,WAAlB,CAA8BC,OAA9B;AACA,WAAKtC,YAAL,CAAkBqC,WAAlB,CAA8BC,OAA9B;AACA,UAAIS,sBAAsB,GAAG,KAAK1C,gBAAL,CAAsB2C,8BAAtB,CAAqDV,OAArD,EAA8DrD,GAA9D,CAAkE,UAAUgE,eAAV,EAA2B;AACxH,eAAOV,MAAM,CAACW,qBAAP,CAA6BD,eAAe,CAACE,uBAAhB,EAA7B,EAAwEb,OAAxE,CAAP;AACD,OAF4B,CAA7B;AAGA,aAAO;AACLE,QAAAA,OAAO,EAAEA,OADJ;AAELO,QAAAA,sBAAsB,EAAEA;AAFnB,OAAP;AAID;AArBA,GApFsB,EA0GtB;AACD/G,IAAAA,GAAG,EAAE,mBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS2J,iBAAT,CAA2BC,SAA3B,EAAsC;AAC3C,UAAIf,OAAO,GAAG,KAAKQ,YAAL,CAAkBQ,KAAlB,CAAwBD,SAAxB,CAAd;AACA,aAAO,KAAKhB,WAAL,CAAiBC,OAAjB,CAAP;AACD;AALA,GA1GsB,EAgHtB;AACDtG,IAAAA,GAAG,EAAE,YADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS8J,UAAT,CAAoBjB,OAApB,EAA6B;AAClC,WAAKvC,eAAL,CAAqBwD,UAArB,CAAgCjB,OAAhC;AACA,WAAKtC,YAAL,CAAkBqC,WAAlB,CAA8BC,OAA9B;AACD;AALA,GAhHsB,EAsHtB;AACDtG,IAAAA,GAAG,EAAE,UADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS+J,QAAT,CAAkBvI,IAAlB,EAAwB;AAC7B,UAAIqH,OAAO,GAAG,KAAKQ,YAAL,CAAkBU,QAAlB,CAA2BvI,IAA3B,CAAd;AACA,UAAI0D,KAAK,GAAG,EAAZ;AACA,WAAKoB,eAAL,CAAqB0D,cAArB,CAAoCC,YAApC,CAAiDpB,OAAjD,EAA0D3D,KAA1D,EAAiEL,cAAc,CAACK,KAAD,CAA/E;AACA,aAAO,KAAKmE,YAAL,CAAkBa,gBAAlB,CAAmCrB,OAAnC,CAAP;AACD;AAPA,GAtHsB,EA8HtB;AACDtG,IAAAA,GAAG,EAAE,aADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASmK,WAAT,CAAqBtB,OAArB,EAA8BuB,OAA9B,EAAuC;AAC5C,aAAO,KAAKf,YAAL,CAAkBc,WAAlB,CAA8BtB,OAA9B,EAAuCuB,OAAvC,CAAP;AACD;AAJA,GA9HsB,EAmItB;AACD7H,IAAAA,GAAG,EAAE,UADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASqK,QAAT,CAAkBnF,KAAlB,EAAyBoF,QAAzB,EAAmCC,YAAnC,EAAiDC,SAAjD,EAA4D;AACjE,UAAIC,SAAS,GAAG1F,QAAQ,CAACW,gBAAT,CAA0BR,KAA1B,EAAiCsF,SAAjC,EAA4CD,YAA5C,CAAhB;AACA,WAAK5D,4BAAL,CAAkC+D,iBAAlC,CAAoDxF,KAApD;AACA,WAAK6C,SAAL,CAAe0C,SAAf;;AAEA,UAAID,SAAS,GAAGF,QAAhB,EAA0B;AACxBA,QAAAA,QAAQ,IAAIC,YAAZ;AACD;;AAED,UAAII,YAAY,GAAG1H,iBAAiB,CAACiC,KAAD,EAAQ,CAAR,EAAWoF,QAAX,CAApC;AACA,UAAIM,aAAa,GAAG3H,iBAAiB,CAACiC,KAAD,EAAQ,CAAR,EAAWsF,SAAX,CAArC;AACA,WAAKK,SAAL,CAAeF,YAAf,EAA6BG,MAAM,CAACC,iBAApC,EAAuDR,YAAvD,EAAqEK,aAArE;AACA,UAAIpD,YAAY,GAAGzC,QAAQ,CAACW,gBAAT,CAA0BR,KAA1B,EAAiCoF,QAAjC,EAA2CC,YAA3C,CAAnB;AACA,WAAK7C,YAAL,CAAkBF,YAAlB;AACA,aAAO,KAAKb,4BAAL,CAAkCqE,kBAAlC,EAAP;AACD;AAjBA,GAnIsB,EAqJtB;AACDzI,IAAAA,GAAG,EAAE,aADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASiL,WAAT,CAAqB/F,KAArB,EAA4BgG,WAA5B,EAAyCC,eAAzC,EAA0DC,YAA1D,EAAwE;AAC7E,UAAIC,YAAY,GAAGvG,WAAW,CAACmB,mBAAZ,CAAgCf,KAAhC,EAAuCkG,YAAvC,EAAqDD,eAArD,CAAnB;AACA,WAAKxE,4BAAL,CAAkC+D,iBAAlC,CAAoDxF,KAApD;AACA,WAAKkD,YAAL,CAAkBiD,YAAlB;;AAEA,UAAID,YAAY,GAAGF,WAAnB,EAAgC;AAC9BA,QAAAA,WAAW,IAAIC,eAAf;AACD;;AAED,UAAIR,YAAY,GAAG1H,iBAAiB,CAACiC,KAAD,EAAQgG,WAAR,EAAqB,CAArB,CAApC;AACA,UAAIN,aAAa,GAAG3H,iBAAiB,CAACiC,KAAD,EAAQkG,YAAR,EAAsB,CAAtB,CAArC;AACA,WAAKP,SAAL,CAAeF,YAAf,EAA6BQ,eAA7B,EAA8CL,MAAM,CAACC,iBAArD,EAAwEH,aAAxE;AACA,UAAInC,eAAe,GAAG3D,WAAW,CAACmB,mBAAZ,CAAgCf,KAAhC,EAAuCgG,WAAvC,EAAoDC,eAApD,CAAtB;AACA,WAAKxC,eAAL,CAAqBF,eAArB;AACA,aAAO,KAAK9B,4BAAL,CAAkCqE,kBAAlC,EAAP;AACD;AAjBA,GArJsB,EAuKtB;AACDzI,IAAAA,GAAG,EAAE,WADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS6K,SAAT,CAAmBS,gBAAnB,EAAqCC,KAArC,EAA4CC,MAA5C,EAAoDC,qBAApD,EAA2E;AAChF,UAAIC,MAAM,GAAG,IAAb;;AAEA,WAAKC,6BAAL,CAAmCL,gBAAnC,EAAqDC,KAArD,EAA4DC,MAA5D,EAAoEC,qBAApE;AACA,UAAIG,WAAW,GAAGjJ,iBAAiB,CAACkJ,QAAlB,CAA2BP,gBAA3B,EAA6CC,KAA7C,EAAoDC,MAApD,CAAlB;AACA,UAAIM,WAAW,GAAGnJ,iBAAiB,CAACkJ,QAAlB,CAA2BJ,qBAA3B,EAAkDF,KAAlD,EAAyDC,MAAzD,CAAlB;AACA,UAAIO,OAAO,GAAGN,qBAAqB,CAACO,GAAtB,GAA4BV,gBAAgB,CAACU,GAA3D;AACA,UAAIC,QAAQ,GAAGR,qBAAqB,CAACS,GAAtB,GAA4BZ,gBAAgB,CAACY,GAA5D;AACA,UAAIC,OAAO,GAAGV,qBAAqB,CAACvG,KAApC;AACA,UAAIkH,mBAAmB,GAAG,KAAKC,sBAAL,CAA4BP,WAA5B,CAA1B;AACA,UAAIQ,cAAc,GAAG,KAAKhG,eAAL,CAAqBiG,kBAArB,CAAwCT,WAAxC,CAArB;AACA,WAAKvF,YAAL,CAAkBiG,YAAlB,CAA+BF,cAA/B;AACA,UAAIG,YAAY,GAAG,KAAKnG,eAAL,CAAqBiG,kBAArB,CAAwCX,WAAxC,CAAnB;AACA,WAAKrF,YAAL,CAAkBmG,UAAlB,CAA6BD,YAA7B,EAA2CV,OAA3C,EAAoDE,QAApD,EAA8DE,OAA9D;AACA,UAAIpD,OAAJ;AACA,WAAKrC,KAAL,CAAWsC,OAAX,CAAmBhE,QAAQ,CAACiE,cAA5B,EAA4C,YAAY;AACtD,YAAIC,cAAc,GAAG,IAAInF,oBAAJ,CAAyB6H,WAAzB,EAAsCG,OAAtC,EAA+CE,QAA/C,EAAyDE,OAAzD,CAArB;AACAjD,QAAAA,cAAc,CAACC,2BAAf,CAA2CuC,MAAM,CAACpF,eAAlD,EAAmEoF,MAAM,CAACjF,MAA1E;AACAsC,QAAAA,OAAO,GAAG2C,MAAM,CAAC/E,4BAAP,CAAoCyC,iBAApC,CAAsDF,cAAtD,CAAV;AACD,OAJD;AAKA,WAAK5C,eAAL,CAAqBuE,SAArB,CAA+Be,WAA/B,EAA4CG,OAA5C,EAAqDE,QAArD,EAA+DE,OAA/D;AACA,UAAIQ,2BAA2B,GAAG,KAAKC,mCAAL,CAAyCtB,gBAAzC,EAA2DC,KAA3D,EAAkEC,MAAlE,EAA0EC,qBAA1E,CAAlC;AACA,aAAO;AACL1C,QAAAA,OAAO,EAAEA,OADJ;AAEL8D,QAAAA,oBAAoB,EAAET,mBAFjB;AAGLO,QAAAA,2BAA2B,EAAEA;AAHxB,OAAP;AAKD;AA7BA,GAvKsB,EAqMtB;AACDpK,IAAAA,GAAG,EAAE,aADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS8M,WAAT,CAAqBjE,OAArB,EAA8BkE,UAA9B,EAA0C;AAC/C,UAAIC,MAAM,GAAG,IAAb;;AAEA,UAAIC,MAAM,GAAG,EAAb;AACA,UAAIC,UAAU,GAAG,EAAjB;;AAEA,UAAIC,UAAU,GAAGhN,0BAA0B,CAAC4M,UAAD,CAA3C;AAAA,UACIK,MADJ;;AAGA,UAAI;AACF,YAAIC,KAAK,GAAG,SAASA,KAAT,GAAiB;AAC3B,cAAIC,YAAY,GAAGrO,cAAc,CAACmO,MAAM,CAACpN,KAAR,EAAe,CAAf,CAAjC;AAAA,cACIuN,MAAM,GAAGD,YAAY,CAAC,CAAD,CADzB;AAAA,cAEItL,MAAM,GAAGsL,YAAY,CAAC,CAAD,CAFzB;;AAIA,cAAIC,MAAM,KAAKvL,MAAf,EAAuB;AACrB,gBAAIwL,QAAQ,GAAG7K,iBAAiB,CAACkJ,QAAlB,CAA2B;AACxC3G,cAAAA,KAAK,EAAE2D,OADiC;AAExCmD,cAAAA,GAAG,EAAE,CAFmC;AAGxCE,cAAAA,GAAG,EAAEqB;AAHmC,aAA3B,EAIZE,QAJY,EAIF,CAJE,CAAf;;AAMA,gBAAIvB,GAAG,GAAGc,MAAM,CAACX,sBAAP,CAA8BmB,QAA9B,CAAV;;AAEAN,YAAAA,UAAU,GAAGA,UAAU,CAACQ,MAAX,CAAkBxB,GAAlB,CAAb;AACAe,YAAAA,MAAM,CAAClN,IAAP,CAAYmM,GAAG,CAAC1G,GAAJ,CAAQ,UAAUmI,IAAV,EAAgB;AAClC,kBAAIC,KAAK,GAAG3O,cAAc,CAAC0O,IAAD,EAAO,CAAP,CAA1B;AAAA,kBACIE,MAAM,GAAGD,KAAK,CAAC,CAAD,CADlB;AAAA,kBAEI1I,KAAK,GAAG2I,MAAM,CAAC3I,KAFnB;AAAA,kBAGI8G,GAAG,GAAG6B,MAAM,CAAC7B,GAHjB;AAAA,kBAII8B,IAAI,GAAGF,KAAK,CAAC,CAAD,CAJhB;;AAMA,qBAAO,CAAC;AACN1I,gBAAAA,KAAK,EAAEA,KADD;AAEN8G,gBAAAA,GAAG,EAAEA,GAFC;AAGNE,gBAAAA,GAAG,EAAElK;AAHC,eAAD,EAIJ8L,IAJI,CAAP;AAKD,aAZW,CAAZ;AAaD;AACF,SA7BD;;AA+BA,aAAKX,UAAU,CAAC3M,CAAX,EAAL,EAAqB,CAAC,CAAC4M,MAAM,GAAGD,UAAU,CAAC1M,CAAX,EAAV,EAA0BX,IAAhD,GAAuD;AACrDuN,UAAAA,KAAK;AACN;AACF,OAnCD,CAmCE,OAAOnN,GAAP,EAAY;AACZiN,QAAAA,UAAU,CAACzM,CAAX,CAAaR,GAAb;AACD,OArCD,SAqCU;AACRiN,QAAAA,UAAU,CAACvM,CAAX;AACD;;AAEDqM,MAAAA,MAAM,CAACc,OAAP,CAAe,UAAU7B,GAAV,EAAe;AAC5B,eAAOc,MAAM,CAACgB,qBAAP,CAA6BnF,OAA7B,EAAsCqD,GAAG,CAAC+B,MAAJ,EAAtC,CAAP;AACD,OAFD;AAGA,aAAOf,UAAP;AACD;AAxDA,GArMsB,EA8PtB;AACD3K,IAAAA,GAAG,EAAE,gBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASkO,cAAT,CAAwBrF,OAAxB,EAAiCsF,aAAjC,EAAgD;AACrD,UAAIC,MAAM,GAAG,IAAb;;AAEA,UAAInB,MAAM,GAAG,EAAb;AACA,UAAIC,UAAU,GAAG,EAAjB;;AAEA,UAAImB,UAAU,GAAGlO,0BAA0B,CAACgO,aAAD,CAA3C;AAAA,UACIG,MADJ;;AAGA,UAAI;AACF,YAAIC,MAAM,GAAG,SAASA,MAAT,GAAkB;AAC7B,cAAIC,YAAY,GAAGvP,cAAc,CAACqP,MAAM,CAACtO,KAAR,EAAe,CAAf,CAAjC;AAAA,cACIuN,MAAM,GAAGiB,YAAY,CAAC,CAAD,CADzB;AAAA,cAEIxM,MAAM,GAAGwM,YAAY,CAAC,CAAD,CAFzB;;AAIA,cAAIjB,MAAM,KAAKvL,MAAf,EAAuB;AACrB,gBAAIwL,QAAQ,GAAG7K,iBAAiB,CAACkJ,QAAlB,CAA2B;AACxC3G,cAAAA,KAAK,EAAE2D,OADiC;AAExCmD,cAAAA,GAAG,EAAEuB,MAFmC;AAGxCrB,cAAAA,GAAG,EAAE;AAHmC,aAA3B,EAIZ,CAJY,EAITuB,QAJS,CAAf;;AAMA,gBAAIgB,MAAM,GAAGL,MAAM,CAAC/B,sBAAP,CAA8BmB,QAA9B,CAAb;;AAEAN,YAAAA,UAAU,GAAGA,UAAU,CAACQ,MAAX,CAAkBe,MAAlB,CAAb;AACAxB,YAAAA,MAAM,CAAClN,IAAP,CAAY0O,MAAM,CAACjJ,GAAP,CAAW,UAAUkJ,KAAV,EAAiB;AACtC,kBAAIC,KAAK,GAAG1P,cAAc,CAACyP,KAAD,EAAQ,CAAR,CAA1B;AAAA,kBACIE,MAAM,GAAGD,KAAK,CAAC,CAAD,CADlB;AAAA,kBAEIzJ,KAAK,GAAG0J,MAAM,CAAC1J,KAFnB;AAAA,kBAGI8G,GAAG,GAAG4C,MAAM,CAAC5C,GAHjB;AAAA,kBAIIE,GAAG,GAAG0C,MAAM,CAAC1C,GAJjB;AAAA,kBAKI4B,IAAI,GAAGa,KAAK,CAAC,CAAD,CALhB;;AAOA,qBAAO,CAAC;AACNzJ,gBAAAA,KAAK,EAAEA,KADD;AAEN8G,gBAAAA,GAAG,EAAEhK,MAFC;AAGNkK,gBAAAA,GAAG,EAAEA;AAHC,eAAD,EAIJ4B,IAJI,CAAP;AAKD,aAbW,CAAZ;AAcD;AACF,SA9BD;;AAgCA,aAAKO,UAAU,CAAC7N,CAAX,EAAL,EAAqB,CAAC,CAAC8N,MAAM,GAAGD,UAAU,CAAC5N,CAAX,EAAV,EAA0BX,IAAhD,GAAuD;AACrDyO,UAAAA,MAAM;AACP;AACF,OApCD,CAoCE,OAAOrO,GAAP,EAAY;AACZmO,QAAAA,UAAU,CAAC3N,CAAX,CAAaR,GAAb;AACD,OAtCD,SAsCU;AACRmO,QAAAA,UAAU,CAACzN,CAAX;AACD;;AAEDqM,MAAAA,MAAM,CAACc,OAAP,CAAe,UAAUU,MAAV,EAAkB;AAC/B,eAAOL,MAAM,CAACJ,qBAAP,CAA6BnF,OAA7B,EAAsC4F,MAAM,CAACR,MAAP,EAAtC,CAAP;AACD,OAFD;AAGA,aAAOf,UAAP;AACD;AAzDA,GA9PsB,EAwTtB;AACD3K,IAAAA,GAAG,EAAE,oBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS6O,kBAAT,CAA4BC,cAA5B,EAA4CC,UAA5C,EAAwDlG,OAAxD,EAAiEmG,OAAjE,EAA0E;AAC/E,UAAIC,eAAe,GAAG,KAAKrI,gBAAL,CAAsBiI,kBAAtB,CAAyCC,cAAzC,EAAyDjG,OAAzD,EAAkEmG,OAAlE,CAAtB;AACA,WAAKE,0BAAL,CAAgCD,eAAe,CAACE,OAAhD,EAAyDJ,UAAzD;AACA,WAAKK,0BAAL,CAAgCH,eAAhC,EAAiDH,cAAjD,EAAiEjG,OAAjE;AACD;AANA,GAxTsB,EA+TtB;AACDtG,IAAAA,GAAG,EAAE,wBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASqP,sBAAT,CAAgCJ,eAAhC,EAAiDK,OAAjD,EAA0DzG,OAA1D,EAAmE;AACxE,UAAIiG,cAAc,GAAGG,eAAe,CAACM,WAArC;AACA,WAAKC,WAAL,CAAiBP,eAAe,CAACE,OAAjC,EAA0CG,OAA1C;AACA,UAAIG,uBAAuB,GAAG,KAAK7I,gBAAL,CAAsByI,sBAAtB,CAA6CJ,eAA7C,EAA8DpG,OAA9D,CAA9B;AACA,WAAKuG,0BAAL,CAAgCK,uBAAhC,EAAyDX,cAAzD,EAAyEjG,OAAzE;AACD;AAPA,GA/TsB,EAuUtB;AACDtG,IAAAA,GAAG,EAAE,iCADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS0P,+BAAT,CAAyCZ,cAAzC,EAAyDa,aAAzD,EAAwE9G,OAAxE,EAAiFmG,OAAjF,EAA0F;AAC/F,UAAIC,eAAe,GAAG,KAAKrI,gBAAL,CAAsBgJ,uBAAtB,CAA8Cd,cAA9C,EAA8DjG,OAA9D,CAAtB;;AAEA,UAAI,CAACoG,eAAL,EAAsB;AACpB,cAAM,IAAI7K,gCAAJ,CAAqC0K,cAArC,CAAN;AACD;;AAED,UAAIe,kBAAkB,GAAGZ,eAAe,CAACa,IAAhB,EAAzB;AACAb,MAAAA,eAAe,CAACD,OAAhB,GAA0BA,OAA1B;AACA,UAAIM,OAAO,GAAG,KAAKS,gBAAL,CAAsBd,eAAe,CAACE,OAAtC,CAAd;AACA,WAAKD,0BAAL,CAAgCD,eAAe,CAACE,OAAhD,EAAyDQ,aAAzD;AACA,aAAO,CAACE,kBAAD,EAAqBP,OAArB,CAAP;AACD;AAdA,GAvUsB,EAsVtB;AACD/M,IAAAA,GAAG,EAAE,uBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASyJ,qBAAT,CAA+BqF,cAA/B,EAA+CjG,OAA/C,EAAwD;AAC7D,UAAIoG,eAAe,GAAG,KAAKrI,gBAAL,CAAsBgJ,uBAAtB,CAA8Cd,cAA9C,EAA8DjG,OAA9D,CAAtB;;AAEA,UAAI,CAACoG,eAAL,EAAsB;AACpB,cAAM,IAAI7K,gCAAJ,CAAqC0K,cAArC,CAAN;AACD;;AAED,WAAKlI,gBAAL,CAAsBoJ,MAAtB,CAA6Bf,eAAe,CAACM,WAA7C,EAA0D1G,OAA1D;AACA,UAAIyG,OAAO,GAAG,KAAKS,gBAAL,CAAsBd,eAAe,CAACE,OAAtC,CAAd;;AAEA,UAAItG,OAAO,KAAKoH,SAAhB,EAA2B;AACzB,YAAIC,qBAAqB,GAAG,KAAKtJ,gBAAL,CAAsBuJ,oCAAtB,CAA2DrB,cAA3D,CAA5B;AACA,aAAKxI,eAAL,CAAqB8J,YAArB,CAAkCnB,eAAe,CAACE,OAAlD,EAA2De,qBAAqB,CAACf,OAAjF;AACD,OAHD,MAGO;AACL,aAAK7I,eAAL,CAAqB+J,YAArB,CAAkCpB,eAAe,CAACE,OAAlD;AACD;;AAED,aAAO,CAACF,eAAD,EAAkBK,OAAlB,CAAP;AACD;AApBA,GAtVsB,EA2WtB;AACD/M,IAAAA,GAAG,EAAE,+BADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS2L,6BAAT,CAAuCL,gBAAvC,EAAyDC,KAAzD,EAAgEC,MAAhE,EAAwEC,qBAAxE,EAA+F;AACpG,UAAIzI,wBAAwB,CAACsI,gBAAD,CAAxB,IAA8C,EAAEgF,iBAAiB,CAAC/E,KAAD,CAAjB,IAA4B+E,iBAAiB,CAAC9E,MAAD,CAA7C,IAAyD+E,kBAAkB,CAACjF,gBAAD,EAAmBC,KAAnB,EAA0BC,MAA1B,CAA7E,CAA9C,IAAiKxI,wBAAwB,CAACyI,qBAAD,CAAzL,IAAoN,CAAC,KAAKpC,YAAL,CAAkBmH,cAAlB,CAAiClF,gBAAgB,CAACpG,KAAlD,CAArN,IAAiR,CAAC,KAAKmE,YAAL,CAAkBmH,cAAlB,CAAiC/E,qBAAqB,CAACvG,KAAvD,CAAtR,EAAqV;AACnV,cAAM,IAAIf,qBAAJ,CAA0B,iCAA1B,CAAN;AACD;;AAED,UAAIyH,WAAW,GAAGjJ,iBAAiB,CAACkJ,QAAlB,CAA2BP,gBAA3B,EAA6CC,KAA7C,EAAoDC,MAApD,CAAlB;AACA,UAAIM,WAAW,GAAGnJ,iBAAiB,CAACkJ,QAAlB,CAA2BJ,qBAA3B,EAAkDF,KAAlD,EAAyDC,MAAzD,CAAlB;;AAEA,UAAIM,WAAW,CAAC2E,sBAAZ,CAAmC,KAAKxJ,UAAxC,EAAoD,KAAKC,OAAzD,CAAJ,EAAuE;AACrE,cAAM,IAAI5C,2BAAJ,EAAN;AACD;;AAED,UAAI,KAAKgC,eAAL,CAAqBoK,YAArB,CAAkCC,qBAAlC,CAAwD/E,WAAxD,CAAJ,EAA0E;AACxE,cAAM,IAAIrH,2BAAJ,EAAN;AACD;;AAED,UAAI,KAAK+B,eAAL,CAAqBoK,YAArB,CAAkCC,qBAAlC,CAAwD7E,WAAxD,CAAJ,EAA0E;AACxE,cAAM,IAAItH,2BAAJ,EAAN;AACD;AACF;AArBA,GA3WsB,EAiYtB;AACDjC,IAAAA,GAAG,EAAE,uBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASgO,qBAAT,CAA+B4C,aAA/B,EAA8CC,KAA9C,EAAqD;AAC1D,UAAIC,qBAAqB,GAAG,EAA5B;;AAEA,UAAIC,UAAU,GAAG5Q,0BAA0B,CAAC0Q,KAAD,CAA3C;AAAA,UACIG,MADJ;;AAGA,UAAI;AACF,aAAKD,UAAU,CAACvQ,CAAX,EAAL,EAAqB,CAAC,CAACwQ,MAAM,GAAGD,UAAU,CAACtQ,CAAX,EAAV,EAA0BX,IAAhD,GAAuD;AACrD,cAAImR,YAAY,GAAGhS,cAAc,CAAC+R,MAAM,CAAChR,KAAR,EAAe,CAAf,CAAjC;AAAA,cACImP,OAAO,GAAG8B,YAAY,CAAC,CAAD,CAD1B;AAAA,cAEIC,aAAa,GAAGD,YAAY,CAAC,CAAD,CAFhC;;AAIA,eAAKzB,WAAL,CAAiBL,OAAjB,EAA0B+B,aAA1B;;AAEA,cAAIA,aAAa,CAACC,IAAd,KAAuBhO,iBAAiB,CAACiO,OAA7C,EAAsD;AACpD,gBAAIC,qBAAqB,GAAG,KAAK5K,MAAL,CAAY6K,iBAAZ,CAA8BJ,aAAa,CAACK,IAA5C,CAA5B;AAAA,gBACIC,YAAY,GAAGH,qBAAqB,CAACG,YADzC;;AAGAV,YAAAA,qBAAqB,CAAC/Q,IAAtB,CAA2B0R,KAA3B,CAAiCX,qBAAjC,EAAwD3S,kBAAkB,CAAC,KAAKuT,sCAAL,CAA4Cd,aAA5C,EAA2DzB,OAA3D,EAAoEqC,YAApE,CAAD,CAA1E;AACD;AACF;AACF,OAfD,CAeE,OAAOtR,GAAP,EAAY;AACZ6Q,QAAAA,UAAU,CAACrQ,CAAX,CAAaR,GAAb;AACD,OAjBD,SAiBU;AACR6Q,QAAAA,UAAU,CAACnQ,CAAX;AACD;;AAED,aAAOkQ,qBAAP;AACD;AA9BA,GAjYsB,EAgatB;AACDvO,IAAAA,GAAG,EAAE,aADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASwP,WAAT,CAAqBL,OAArB,EAA8B+B,aAA9B,EAA6C;AAClD,cAAQA,aAAa,CAACC,IAAtB;AACE,aAAKhO,iBAAiB,CAACwO,KAAvB;AACE;AACE,iBAAKC,cAAL,CAAoBV,aAApB,EAAmC/B,OAAnC;AACA;AACD;;AAEH,aAAKhM,iBAAiB,CAACiO,OAAvB;AACE;AACE,iBAAKS,yBAAL,CAA+BX,aAAa,CAACK,IAA7C,EAAmDpC,OAAnD;AACA;AACD;;AAEH,aAAKhM,iBAAiB,CAAC2O,KAAvB;AACE;AACE,iBAAKzB,YAAL,CAAkBlB,OAAlB;AACA;AACD;;AAEH,aAAKhM,iBAAiB,CAAC4O,aAAvB;AACE;AACE,iBAAKC,qBAAL,CAA2Bd,aAAa,CAACe,QAAzC,EAAmDf,aAAa,CAACgB,MAAjE,EAAyE/C,OAAzE;AACA;AACD;AAvBL;AAyBD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AApCK,GAhasB,EAsctB;AACD5M,IAAAA,GAAG,EAAE,cADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS0H,YAAT,CAAsBF,YAAtB,EAAoC;AACzC,UAAI2K,MAAM,GAAG,IAAb;;AAEA,UAAI,KAAKC,wBAAL,CAA8B5K,YAAY,CAAC6K,QAA3C,EAAqD7K,YAAY,CAACtC,KAAlE,CAAJ,EAA8E;AAC5E;AACD;;AAED,UAAIoN,YAAY,GAAG,EAAnB;;AAEA,UAAIC,UAAU,GAAGpS,0BAA0B,CAAC,KAAKmG,eAAL,CAAqBkM,mBAArB,CAAyChL,YAAzC,CAAD,CAA3C;AAAA,UACIiL,MADJ;;AAGA,UAAI;AACF,aAAKF,UAAU,CAAC/R,CAAX,EAAL,EAAqB,CAAC,CAACiS,MAAM,GAAGF,UAAU,CAAC9R,CAAX,EAAV,EAA0BX,IAAhD,GAAuD;AACrD,cAAI4S,YAAY,GAAGzT,cAAc,CAACwT,MAAM,CAACzS,KAAR,EAAe,CAAf,CAAjC;AAAA,cACImP,OAAO,GAAGuD,YAAY,CAAC,CAAD,CAD1B;;AAGAJ,UAAAA,YAAY,CAACvS,IAAb,CAAkB;AAChBoP,YAAAA,OAAO,EAAEA,OADO;AAEhBwD,YAAAA,QAAQ,EAAE,KAAK5C,gBAAL,CAAsBZ,OAAtB;AAFM,WAAlB;AAID;AACF,OAVD,CAUE,OAAOjP,GAAP,EAAY;AACZqS,QAAAA,UAAU,CAAC7R,CAAX,CAAaR,GAAb;AACD,OAZD,SAYU;AACRqS,QAAAA,UAAU,CAAC3R,CAAX;AACD;;AAED,UAAIgS,qBAAqB,GAAG,KAAKtM,eAAL,CAAqBa,UAArB,CAAgCK,YAAhC,CAA5B;AAAA,UACIqL,cAAc,GAAGD,qBAAqB,CAACC,cAD3C;AAAA,UAEIC,cAAc,GAAGF,qBAAqB,CAACE,cAF3C;;AAIA,WAAKvM,YAAL,CAAkBwM,YAAlB,CAA+BD,cAAc,CAACE,UAAf,EAA/B;AACA,UAAIjK,OAAJ;AACA,WAAKrC,KAAL,CAAWsC,OAAX,CAAmBhE,QAAQ,CAACiE,cAA5B,EAA4C,YAAY;AACtD,YAAIC,cAAc,GAAG,IAAIjF,qBAAJ,CAA0BuD,YAA1B,CAArB;AACA0B,QAAAA,cAAc,CAACC,2BAAf,CAA2CgJ,MAAM,CAAC7L,eAAlD,EAAmE6L,MAAM,CAAC1L,MAA1E;AACAsC,QAAAA,OAAO,GAAGoJ,MAAM,CAACxL,4BAAP,CAAoCyC,iBAApC,CAAsDF,cAAtD,CAAV;AACD,OAJD;AAKA,WAAK+J,qBAAL,CAA2BJ,cAA3B;AACA,aAAO;AACL9J,QAAAA,OAAO,EAAEA,OADJ;AAELuJ,QAAAA,YAAY,EAAEA,YAFT;AAGLY,QAAAA,OAAO,EAAE1L,YAAY,CAAC6K,QAHjB;AAILc,QAAAA,QAAQ,EAAE3L,YAAY,CAAC+C;AAJlB,OAAP;AAMD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAxDK,GAtcsB,EAggBtB;AACDhI,IAAAA,GAAG,EAAE,iBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS2I,eAAT,CAAyBF,eAAzB,EAA0C;AAC/C,UAAI2K,OAAO,GAAG,IAAd;;AAEA,UAAI,KAAKC,2BAAL,CAAiC5K,eAAe,CAAC6K,WAAjD,EAA8D7K,eAAe,CAACvD,KAA9E,CAAJ,EAA0F;AACxF;AACD;;AAED,UAAIoN,YAAY,GAAG,EAAnB;;AAEA,UAAIiB,UAAU,GAAGpT,0BAA0B,CAAC,KAAKmG,eAAL,CAAqBkN,sBAArB,CAA4C/K,eAA5C,CAAD,CAA3C;AAAA,UACIgL,MADJ;;AAGA,UAAI;AACF,aAAKF,UAAU,CAAC/S,CAAX,EAAL,EAAqB,CAAC,CAACiT,MAAM,GAAGF,UAAU,CAAC9S,CAAX,EAAV,EAA0BX,IAAhD,GAAuD;AACrD,cAAI4T,YAAY,GAAGzU,cAAc,CAACwU,MAAM,CAACzT,KAAR,EAAe,CAAf,CAAjC;AAAA,cACImP,OAAO,GAAGuE,YAAY,CAAC,CAAD,CAD1B;;AAGApB,UAAAA,YAAY,CAACvS,IAAb,CAAkB;AAChBoP,YAAAA,OAAO,EAAEA,OADO;AAEhBwD,YAAAA,QAAQ,EAAE,KAAK5C,gBAAL,CAAsBZ,OAAtB;AAFM,WAAlB;AAID;AACF,OAVD,CAUE,OAAOjP,GAAP,EAAY;AACZqT,QAAAA,UAAU,CAAC7S,CAAX,CAAaR,GAAb;AACD,OAZD,SAYU;AACRqT,QAAAA,UAAU,CAAC3S,CAAX;AACD;;AAED,UAAI+S,sBAAsB,GAAG,KAAKrN,eAAL,CAAqB+B,aAArB,CAAmCI,eAAnC,CAA7B;AAAA,UACIoK,cAAc,GAAGc,sBAAsB,CAACd,cAD5C;AAAA,UAEIC,cAAc,GAAGa,sBAAsB,CAACb,cAF5C;;AAIA,WAAKvM,YAAL,CAAkBwM,YAAlB,CAA+BD,cAAc,CAACE,UAAf,EAA/B;AACA,WAAKzM,YAAL,CAAkB8B,aAAlB,CAAgCI,eAAhC;AACA,UAAIM,OAAJ;AACA,WAAKrC,KAAL,CAAWsC,OAAX,CAAmBhE,QAAQ,CAACiE,cAA5B,EAA4C,YAAY;AACtD,YAAIC,cAAc,GAAG,IAAIlF,wBAAJ,CAA6ByE,eAA7B,CAArB;AACAS,QAAAA,cAAc,CAACC,2BAAf,CAA2CiK,OAAO,CAAC9M,eAAnD,EAAoE8M,OAAO,CAAC3M,MAA5E;AACAsC,QAAAA,OAAO,GAAGqK,OAAO,CAACzM,4BAAR,CAAqCyC,iBAArC,CAAuDF,cAAvD,CAAV;AACD,OAJD;AAKA,WAAK+J,qBAAL,CAA2BJ,cAA3B;AACA,aAAO;AACL9J,QAAAA,OAAO,EAAEA,OADJ;AAELuJ,QAAAA,YAAY,EAAEA,YAFT;AAGLsB,QAAAA,UAAU,EAAEnL,eAAe,CAAC6K,WAHvB;AAILO,QAAAA,WAAW,EAAEpL,eAAe,CAAC0C;AAJxB,OAAP;AAMD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAzDK,GAhgBsB,EA2jBtB;AACD5I,IAAAA,GAAG,EAAE,WADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS+H,SAAT,CAAmBD,SAAnB,EAA8B;AACnC,UAAIgM,OAAO,GAAG,IAAd;;AAEA,UAAI,KAAK1B,wBAAL,CAA8BtK,SAAS,CAACuK,QAAxC,EAAkDvK,SAAS,CAAC5C,KAA5D,CAAJ,EAAwE;AACtE;AACD;;AAED,UAAI6O,sBAAsB,GAAG,KAAKzN,eAAL,CAAqBqB,OAArB,CAA6BG,SAA7B,CAA7B;AAAA,UACI+K,cAAc,GAAGkB,sBAAsB,CAAClB,cAD5C;;AAGA,WAAKnM,KAAL,CAAWsC,OAAX,CAAmBhE,QAAQ,CAACiE,cAA5B,EAA4C,YAAY;AACtD,YAAIC,cAAc,GAAG,IAAIrF,kBAAJ,CAAuBiE,SAAvB,CAArB;AACAoB,QAAAA,cAAc,CAACC,2BAAf,CAA2C2K,OAAO,CAACxN,eAAnD,EAAoEwN,OAAO,CAACrN,MAA5E;;AAEAqN,QAAAA,OAAO,CAACnN,4BAAR,CAAqCyC,iBAArC,CAAuDF,cAAvD;AACD,OALD;AAMA,WAAK+J,qBAAL,CAA2BJ,cAA3B;AACD;AAnBA,GA3jBsB,EA+kBtB;AACDtQ,IAAAA,GAAG,EAAE,uBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASiT,qBAAT,CAA+BJ,cAA/B,EAA+C;AACpD,UAAImB,WAAW,GAAG7T,0BAA0B,CAAC0S,cAAc,CAAC5E,MAAf,EAAD,CAA5C;AAAA,UACIgG,OADJ;;AAGA,UAAI;AACF,aAAKD,WAAW,CAACxT,CAAZ,EAAL,EAAsB,CAAC,CAACyT,OAAO,GAAGD,WAAW,CAACvT,CAAZ,EAAX,EAA4BX,IAAnD,GAA0D;AACxD,cAAIoU,WAAW,GAAGD,OAAO,CAACjU,KAA1B;;AAEA,cAAIkU,WAAW,CAACC,KAAZ,CAAkBC,IAAlB,CAAuBC,KAA3B,EAAkC;AAChC;AACD;;AAED,cAAIC,GAAG,GAAGJ,WAAW,CAACK,UAAZ,CAAuB,KAAK5N,4BAA5B,CAAV;AACA,cAAIwI,OAAO,GAAG+E,WAAW,CAACM,UAAZ,CAAuB,KAAK7N,4BAA5B,CAAd;AACA,cAAI4K,IAAI,GAAG,KAAK9K,MAAL,CAAYgO,kBAAZ,CAA+BH,GAA/B,CAAX;AACA,eAAKzC,yBAAL,CAA+BN,IAA/B,EAAqCpC,OAArC;AACD;AACF,OAbD,CAaE,OAAOjP,GAAP,EAAY;AACZ8T,QAAAA,WAAW,CAACtT,CAAZ,CAAcR,GAAd;AACD,OAfD,SAeU;AACR8T,QAAAA,WAAW,CAACpT,CAAZ;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAhCK,GA/kBsB,EAinBtB;AACD2B,IAAAA,GAAG,EAAE,cADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASoI,YAAT,CAAsBD,YAAtB,EAAoC;AACzC,UAAIuM,OAAO,GAAG,IAAd;;AAEA,UAAI,KAAKrB,2BAAL,CAAiClL,YAAY,CAACmL,WAA9C,EAA2DnL,YAAY,CAACjD,KAAxE,CAAJ,EAAoF;AAClF;AACD;;AAED,UAAIyP,sBAAsB,GAAG,KAAKrO,eAAL,CAAqB0B,UAArB,CAAgCG,YAAhC,CAA7B;AAAA,UACI0K,cAAc,GAAG8B,sBAAsB,CAAC9B,cAD5C;AAAA,UAEIC,cAAc,GAAG6B,sBAAsB,CAAC7B,cAF5C;;AAIA,WAAKvM,YAAL,CAAkByB,UAAlB,CAA6BG,YAA7B;AACA,WAAK5B,YAAL,CAAkBwM,YAAlB,CAA+BD,cAAc,CAACE,UAAf,EAA/B;AACA,WAAKtM,KAAL,CAAWsC,OAAX,CAAmBhE,QAAQ,CAACiE,cAA5B,EAA4C,YAAY;AACtD,YAAIC,cAAc,GAAG,IAAItF,qBAAJ,CAA0BuE,YAA1B,CAArB;AACAe,QAAAA,cAAc,CAACC,2BAAf,CAA2CuL,OAAO,CAACpO,eAAnD,EAAoEoO,OAAO,CAACjO,MAA5E;;AAEAiO,QAAAA,OAAO,CAAC/N,4BAAR,CAAqCyC,iBAArC,CAAuDF,cAAvD;AACD,OALD;AAMA,WAAK+J,qBAAL,CAA2BJ,cAA3B;AACD;AAtBA,GAjnBsB,EAwoBtB;AACDtQ,IAAAA,GAAG,EAAE,eADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS4U,aAAT,CAAuBzF,OAAvB,EAAgC;AACrC,UAAI0F,MAAM,GAAG,KAAKvO,eAAL,CAAqBwO,OAArB,CAA6B3F,OAA7B,CAAb;;AAEA,UAAI0F,MAAM,KAAK5E,SAAX,IAAwB4E,MAAM,YAAYvR,eAA9C,EAA+D;AAC7D,eAAO,CAAC6L,OAAD,EAAU;AACfgC,UAAAA,IAAI,EAAEhO,iBAAiB,CAAC2O;AADT,SAAV,CAAP;AAGD,OAJD,MAIO,IAAI+C,MAAM,YAAYnR,eAAtB,EAAuC;AAC5C,eAAO,CAACyL,OAAD,EAAUhO,MAAM,CAAC4T,MAAP,CAAc;AAC7B5D,UAAAA,IAAI,EAAEhO,iBAAiB,CAACwO;AADK,SAAd,EAEdkD,MAAM,CAACG,SAAP,EAFc,CAAV,CAAP;AAGD,OAJM,MAIA,IAAIH,MAAM,YAAYlR,aAAtB,EAAqC;AAC1C,eAAO,CAACkR,MAAM,CAACL,UAAP,CAAkB,KAAK7N,4BAAvB,CAAD,EAAuD;AAC5DwK,UAAAA,IAAI,EAAEhO,iBAAiB,CAACiO,OADoC;AAE5DG,UAAAA,IAAI,EAAE,KAAK9K,MAAL,CAAYgO,kBAAZ,CAA+BI,MAAM,CAACN,UAAP,CAAkB,KAAK5N,4BAAvB,CAA/B;AAFsD,SAAvD,CAAP;AAID,OALM,MAKA,IAAIkO,MAAM,YAAYrR,kBAAtB,EAA0C;AAC/C,eAAO,CAAC2L,OAAD,EAAU;AACfgC,UAAAA,IAAI,EAAEhO,iBAAiB,CAAC4O,aADT;AAEfE,UAAAA,QAAQ,EAAE4C,MAAM,CAAC5C,QAFF;AAGfC,UAAAA,MAAM,EAAE2C,MAAM,CAAC3C;AAHA,SAAV,CAAP;AAKD;;AAED,YAAM+C,KAAK,CAAC,iCAAD,CAAX;AACD;AA3BA,GAxoBsB,EAoqBtB;AACD1S,IAAAA,GAAG,EAAE,kBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS+P,gBAAT,CAA0BZ,OAA1B,EAAmC;AACxC,UAAI0F,MAAM,GAAG,KAAKvO,eAAL,CAAqBwO,OAArB,CAA6B3F,OAA7B,CAAb;;AAEA,UAAI0F,MAAM,KAAK5E,SAAX,IAAwB4E,MAAM,YAAYvR,eAA9C,EAA+D;AAC7D,eAAO;AACL6N,UAAAA,IAAI,EAAEhO,iBAAiB,CAAC2O;AADnB,SAAP;AAGD,OAJD,MAIO,IAAI+C,MAAM,YAAYnR,eAAtB,EAAuC;AAC5C,eAAOvC,MAAM,CAAC4T,MAAP,CAAc;AACnB5D,UAAAA,IAAI,EAAEhO,iBAAiB,CAACwO;AADL,SAAd,EAEJkD,MAAM,CAACG,SAAP,EAFI,CAAP;AAGD,OAJM,MAIA,IAAIH,MAAM,YAAYxR,WAAtB,EAAmC;AACxC,YAAI6R,GAAG,GAAGL,MAAM,CAACM,iBAAP,CAAyBhG,OAAzB,CAAV;;AAEA,YAAI+F,GAAG,KAAKzQ,UAAZ,EAAwB;AACtB,iBAAO;AACL0M,YAAAA,IAAI,EAAEhO,iBAAiB,CAAC2O;AADnB,WAAP;AAGD;;AAED,eAAO;AACLX,UAAAA,IAAI,EAAEhO,iBAAiB,CAACwO,KADnB;AAELyD,UAAAA,WAAW,EAAEF,GAFR;AAGLG,UAAAA,QAAQ,EAAER,MAAM,CAACS,oBAAP,CAA4BnG,OAA5B;AAHL,SAAP;AAKD,OAdM,MAcA,IAAI0F,MAAM,YAAYtR,iBAAtB,EAAyC;AAC9C,eAAO;AACL4N,UAAAA,IAAI,EAAEhO,iBAAiB,CAACiO,OADnB;AAELG,UAAAA,IAAI,EAAE,KAAK9K,MAAL,CAAYgO,kBAAZ,CAA+BI,MAAM,CAACN,UAAP,CAAkB,KAAK5N,4BAAvB,CAA/B;AAFD,SAAP;AAID,OALM,MAKA,IAAIkO,MAAM,YAAYrR,kBAAtB,EAA0C;AAC/C,eAAO;AACL2N,UAAAA,IAAI,EAAEhO,iBAAiB,CAAC4O,aADnB;AAELE,UAAAA,QAAQ,EAAE4C,MAAM,CAAC5C,QAFZ;AAGLC,UAAAA,MAAM,EAAE2C,MAAM,CAAC3C;AAHV,SAAP;AAKD;;AAED,YAAM+C,KAAK,CAAC,iCAAD,CAAX;AACD;AAzCA,GApqBsB,EA8sBtB;AACD1S,IAAAA,GAAG,EAAE,wBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASuV,sBAAT,CAAgCrQ,KAAhC,EAAuC;AAC5C,UAAIsQ,WAAW,GAAG,KAAKlP,eAAL,CAAqBmP,cAArB,CAAoCvQ,KAApC,CAAlB;AACA,UAAIwQ,UAAU,GAAG,KAAKpP,eAAL,CAAqBqP,aAArB,CAAmCzQ,KAAnC,CAAjB;AACA,UAAI9G,GAAG,GAAG,IAAIS,KAAJ,CAAU2W,WAAV,CAAV;;AAEA,WAAK,IAAItW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsW,WAApB,EAAiCtW,CAAC,EAAlC,EAAsC;AACpCd,QAAAA,GAAG,CAACc,CAAD,CAAH,GAAS,IAAIL,KAAJ,CAAU6W,UAAV,CAAT;;AAEA,aAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,UAApB,EAAgCE,CAAC,EAAjC,EAAqC;AACnC,cAAIzG,OAAO,GAAGlM,iBAAiB,CAACiC,KAAD,EAAQ0Q,CAAR,EAAW1W,CAAX,CAA/B;AACAd,UAAAA,GAAG,CAACc,CAAD,CAAH,CAAO0W,CAAP,IAAY,KAAK7F,gBAAL,CAAsBZ,OAAtB,CAAZ;AACD;AACF;;AAED,aAAO/Q,GAAP;AACD;AAjBA,GA9sBsB,EAguBtB;AACDmE,IAAAA,GAAG,EAAE,wBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASqM,sBAAT,CAAgCwJ,KAAhC,EAAuC;AAC5C,UAAIC,MAAM,GAAG,EAAb;;AAEA,UAAIC,WAAW,GAAG5V,0BAA0B,CAAC0V,KAAK,CAACG,SAAN,CAAgB,KAAK1P,eAArB,CAAD,CAA5C;AAAA,UACI2P,OADJ;;AAGA,UAAI;AACF,aAAKF,WAAW,CAACvV,CAAZ,EAAL,EAAsB,CAAC,CAACyV,OAAO,GAAGF,WAAW,CAACtV,CAAZ,EAAX,EAA4BX,IAAnD,GAA0D;AACxD,cAAIqP,OAAO,GAAG8G,OAAO,CAACjW,KAAtB;AACA8V,UAAAA,MAAM,CAAC/V,IAAP,CAAY,CAACoP,OAAD,EAAU,KAAKY,gBAAL,CAAsBZ,OAAtB,CAAV,CAAZ;AACD;AACF,OALD,CAKE,OAAOjP,GAAP,EAAY;AACZ6V,QAAAA,WAAW,CAACrV,CAAZ,CAAcR,GAAd;AACD,OAPD,SAOU;AACR6V,QAAAA,WAAW,CAACnV,CAAZ;AACD;;AAED,aAAOkV,MAAP;AACD;AApBA,GAhuBsB,EAqvBtB;AACDvT,IAAAA,GAAG,EAAE,gBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASkW,cAAT,CAAwB/G,OAAxB,EAAiCgH,cAAjC,EAAiD;AACtD,UAAIC,iBAAiB,GAAG,KAAK5P,iBAAL,CAAuB6P,KAAvB,CAA6BF,cAA7B,CAAxB;AACA,UAAIjJ,UAAU,GAAG,KAAK0H,aAAL,CAAmBzF,OAAnB,CAAjB;;AAEA,UAAIiH,iBAAiB,YAAYlT,WAAW,CAACoT,OAA7C,EAAsD;AACpD,YAAIC,YAAY,GAAG,KAAK9P,MAAL,CAAY4P,KAAZ,CAAkBD,iBAAiB,CAACI,OAApC,EAA6CrH,OAA7C,CAAnB;AACA,YAAImF,GAAG,GAAGiC,YAAY,CAACjC,GAAvB;AAAA,YACIpC,MAAM,GAAGqE,YAAY,CAACrE,MAD1B;;AAGA,YAAIA,MAAM,CAACjS,MAAP,GAAgB,CAApB,EAAuB;AACrB,eAAK+R,qBAAL,CAA2BoE,iBAAiB,CAACI,OAA7C,EAAsDtE,MAAtD,EAA8D/C,OAA9D;AACD,SAFD,MAEO;AACL,cAAIiF,IAAI,GAAG,KAAKvN,kBAAL,CAAwB4P,cAAxB,CAAuCnC,GAAvC,EAA4CnF,OAA5C,CAAX;AACA,eAAKuH,gBAAL,CAAsBvH,OAAtB,EAA+BiF,IAA/B,EAAqCmC,YAArC;AACD;AACF,OAXD,MAWO,IAAIH,iBAAiB,YAAYlT,WAAW,CAACyT,KAA7C,EAAoD;AACzD,aAAKtG,YAAL,CAAkBlB,OAAlB;AACD,OAFM,MAEA;AACL,aAAKyC,cAAL,CAAoB;AAClBwD,UAAAA,WAAW,EAAEgB,iBAAiB,CAACpW,KADb;AAElBqV,UAAAA,QAAQ,EAAEc;AAFQ,SAApB,EAGGhH,OAHH;AAID;;AAED,aAAOjC,UAAP;AACD;AA3BA,GArvBsB,EAixBtB;AACD3K,IAAAA,GAAG,EAAE,iBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS4W,eAAT,CAAyB/N,OAAzB,EAAkCgO,eAAlC,EAAmD;AACxD,WAAK/M,UAAL,CAAgBjB,OAAhB;;AAEA,WAAK,IAAI3J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2X,eAAe,CAAC5W,MAApC,EAA4Cf,CAAC,EAA7C,EAAiD;AAC/C,aAAK,IAAI0W,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,eAAe,CAAC3X,CAAD,CAAf,CAAmBe,MAAvC,EAA+C2V,CAAC,EAAhD,EAAoD;AAClD,cAAIzG,OAAO,GAAGlM,iBAAiB,CAAC4F,OAAD,EAAU+M,CAAV,EAAa1W,CAAb,CAA/B;AACA,eAAKgX,cAAL,CAAoB/G,OAApB,EAA6B0H,eAAe,CAAC3X,CAAD,CAAf,CAAmB0W,CAAnB,CAA7B;AACD;AACF;AACF;AAXA,GAjxBsB,EA6xBtB;AACDrT,IAAAA,GAAG,EAAE,uBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASgS,qBAAT,CAA+BC,QAA/B,EAAyCC,MAAzC,EAAiD/C,OAAjD,EAA0D;AAC/D,UAAI2H,QAAQ,GAAG,KAAKxQ,eAAL,CAAqByQ,YAArB,CAAkC5H,OAAlC,CAAf;AACA,UAAI0F,MAAM,GAAG,IAAIrR,kBAAJ,CAAuB0O,MAAvB,EAA+BD,QAA/B,CAAb;AACA,UAAI+E,YAAY,GAAG,KAAK1Q,eAAL,CAAqB0L,qBAArB,CAA2C7C,OAA3C,EAAoD0F,MAApD,CAAnB;AACA,WAAKtO,YAAL,CAAkByJ,MAAlB,CAAyBtL,WAAW,CAACoS,QAAD,CAApC,EAAgD3H,OAAhD;AACA,WAAK5I,YAAL,CAAkBwM,YAAlB,CAA+BiE,YAAY,CAAChE,UAAb,EAA/B;AACA,WAAKlM,OAAL,CAAamQ,MAAb,CAAoBD,YAApB;AACA,WAAKlQ,OAAL,CAAaoQ,SAAb,CAAuBrC,MAAM,CAACkC,YAAP,EAAvB,EAA8C5H,OAA9C;AACD;AAVA,GA7xBsB,EAwyBtB;AACD5M,IAAAA,GAAG,EAAE,kBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS0W,gBAAT,CAA0BvH,OAA1B,EAAmCiF,IAAnC,EAAyC+C,KAAzC,EAAgD;AACrD,UAAI7C,GAAG,GAAG6C,KAAK,CAAC7C,GAAhB;AAAA,UACI8C,mBAAmB,GAAGD,KAAK,CAACC,mBADhC;AAAA,UAEIC,2BAA2B,GAAGF,KAAK,CAACE,2BAFxC;AAAA,UAGI7F,YAAY,GAAG2F,KAAK,CAAC3F,YAHzB;AAIA,UAAIsF,QAAQ,GAAG,KAAKxQ,eAAL,CAAqByQ,YAArB,CAAkC5H,OAAlC,CAAf;AACA,UAAI6H,YAAY,GAAG,KAAK1Q,eAAL,CAAqBoQ,gBAArB,CAAsCvH,OAAtC,EAA+CmF,GAA/C,EAAoD1R,sBAAsB,CAAC4O,YAAD,EAAerC,OAAf,CAA1E,EAAmGiF,IAAnG,EAAyGgD,mBAAzG,EAA8HC,2BAA9H,CAAnB;AACA,WAAK9Q,YAAL,CAAkByJ,MAAlB,CAAyBtL,WAAW,CAACoS,QAAD,CAApC,EAAgD3H,OAAhD;AACA,WAAK5I,YAAL,CAAkBwM,YAAlB,CAA+BiE,YAAY,CAAChE,UAAb,EAA/B;AACA,WAAKlM,OAAL,CAAamQ,MAAb,CAAoBD,YAApB;AACD;AAZA,GAxyBsB,EAqzBtB;AACDzU,IAAAA,GAAG,EAAE,gBADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS4R,cAAT,CAAwB5R,KAAxB,EAA+BmP,OAA/B,EAAwC;AAC7C,UAAI2H,QAAQ,GAAG,KAAKxQ,eAAL,CAAqByQ,YAArB,CAAkC5H,OAAlC,CAAf;AACA,UAAI6H,YAAY,GAAG,KAAK1Q,eAAL,CAAqBsL,cAArB,CAAoCzC,OAApC,EAA6CnP,KAA7C,CAAnB;AACA,WAAKuG,YAAL,CAAkB+Q,MAAlB,CAAyB5S,WAAW,CAACoS,QAAD,CAApC,EAAgDpS,WAAW,CAAC1E,KAAK,CAACoV,WAAP,CAA3D,EAAgFjG,OAAhF;AACA,WAAK5I,YAAL,CAAkBwM,YAAlB,CAA+BiE,YAAY,CAAChE,UAAb,GAA0BuE,MAA1B,CAAiC,UAAUD,MAAV,EAAkB;AAChF,eAAO,CAACvU,sBAAsB,CAACuU,MAAM,CAACnI,OAAR,EAAiBA,OAAjB,CAA9B;AACD,OAF8B,CAA/B;AAGA,WAAKrI,OAAL,CAAamQ,MAAb,CAAoBD,YAApB;AACA,WAAKlQ,OAAL,CAAaoQ,SAAb,CAAuBlX,KAAK,CAACoV,WAA7B,EAA0CjG,OAA1C;AACD;AAXA,GArzBsB,EAi0BtB;AACD5M,IAAAA,GAAG,EAAE,cADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASqQ,YAAT,CAAsBlB,OAAtB,EAA+B;AACpC,UAAI,KAAK7I,eAAL,CAAqBkR,mBAArB,CAAyCrI,OAAzC,CAAJ,EAAuD;AACrD;AACD;;AAED,UAAI2H,QAAQ,GAAG,KAAKxQ,eAAL,CAAqByQ,YAArB,CAAkC5H,OAAlC,CAAf;AACA,UAAI6H,YAAY,GAAG,KAAK1Q,eAAL,CAAqB+J,YAArB,CAAkClB,OAAlC,CAAnB;AACA,WAAK5I,YAAL,CAAkByJ,MAAlB,CAAyBtL,WAAW,CAACoS,QAAD,CAApC,EAAgD3H,OAAhD;AACA,WAAK5I,YAAL,CAAkBwM,YAAlB,CAA+BiE,YAAY,CAAChE,UAAb,EAA/B;AACA,WAAKlM,OAAL,CAAamQ,MAAb,CAAoBD,YAApB;AACA,WAAKlQ,OAAL,CAAaoQ,SAAb,CAAuBzS,UAAvB,EAAmC0K,OAAnC;AACD;AAbA,GAj0BsB,EA+0BtB;AACD5M,IAAAA,GAAG,EAAE,2BADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS6R,yBAAT,CAAmC4F,WAAnC,EAAgDtI,OAAhD,EAAyD;AAC9D,UAAIuI,sBAAsB,GAAG,KAAKjR,MAAL,CAAY6K,iBAAZ,CAA8BmG,WAA9B,CAA7B;AAAA,UACInD,GAAG,GAAGoD,sBAAsB,CAACpD,GADjC;AAAA,UAEI8C,mBAAmB,GAAGM,sBAAsB,CAACN,mBAFjD;AAAA,UAGIC,2BAA2B,GAAGK,sBAAsB,CAACL,2BAHzD;AAAA,UAII7F,YAAY,GAAGkG,sBAAsB,CAAClG,YAJ1C;;AAMA,UAAImG,oBAAoB,GAAG/U,sBAAsB,CAAC4O,YAAD,EAAerC,OAAf,CAAjD;;AAEA,UAAIyI,qBAAqB,GAAG,IAAI9T,sCAAJ,CAA2CqL,OAAO,CAACjK,KAAnD,EAA0D2S,kBAA1D,CAA6EvD,GAA7E,EAAkFnF,OAAlF,CAA5B;AAAA,UACI2I,sBAAsB,GAAG7Y,cAAc,CAAC2Y,qBAAD,EAAwB,CAAxB,CAD3C;AAAA,UAEIG,UAAU,GAAGD,sBAAsB,CAAC,CAAD,CAFvC;;AAIA,WAAKrR,MAAL,CAAYuR,cAAZ,CAA2BD,UAA3B;AACA,UAAIE,mBAAmB,GAAGpV,4BAA4B,CAAC8U,oBAAD,CAAtD;AACA,UAAIvD,IAAI,GAAG,KAAKvN,kBAAL,CAAwB4P,cAAxB,CAAuCnC,GAAvC,EAA4CnF,OAA5C,CAAX;AACA,WAAK7I,eAAL,CAAqBoQ,gBAArB,CAAsCvH,OAAtC,EAA+C4I,UAA/C,EAA2DE,mBAA3D,EAAgF7D,IAAhF,EAAsFgD,mBAAtF,EAA2GC,2BAA3G;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAzBK,GA/0BsB,EA02BtB;AACD9U,IAAAA,GAAG,EAAE,0BADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASoS,wBAAT,CAAkClG,GAAlC,EAAuChH,KAAvC,EAA8C;AACnD,UAAIsG,MAAM,GAAG,KAAKlF,eAAL,CAAqB0D,cAArB,CAAoCkO,SAApC,CAA8ChT,KAA9C,CAAb;AACA,aAAOgH,GAAG,IAAIV,MAAd;AACD;AALA,GA12BsB,EAg3BtB;AACDjJ,IAAAA,GAAG,EAAE,2BADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASmY,yBAAT,GAAqC;AAC1C,UAAIrR,OAAO,GAAG,KAAKA,OAAnB;AACA,WAAKA,OAAL,GAAe1D,cAAc,CAAC2D,KAAf,EAAf;AACA,aAAOD,OAAP;AACD;AANA,GAh3BsB,EAu3BtB;AACDvE,IAAAA,GAAG,EAAE,oCADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASoY,kCAAT,GAA8C;AACnD,WAAK9R,eAAL,CAAqB8R,kCAArB;AACD;AAJA,GAv3BsB,EA43BtB;AACD7V,IAAAA,GAAG,EAAE,cADJ;AAED8V,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAK/R,eAAL,CAAqB+C,YAA5B;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAVK,GA53BsB,EAw4BtB;AACD9G,IAAAA,GAAG,EAAE,6BADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASqT,2BAAT,CAAqC5E,MAArC,EAA6CvJ,KAA7C,EAAoD;AACzD,UAAIqG,KAAK,GAAG,KAAKjF,eAAL,CAAqB0D,cAArB,CAAoCsO,QAApC,CAA6CpT,KAA7C,CAAZ;AACA,aAAOuJ,MAAM,IAAIlD,KAAjB;AACD;AALA,GAx4BsB,EA84BtB;AACDhJ,IAAAA,GAAG,EAAE,4BADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASoP,0BAAT,CAAoCH,eAApC,EAAqDH,cAArD,EAAqEjG,OAArE,EAA8E;AACnF,UAAIA,OAAO,KAAKoH,SAAhB,EAA2B;AACzB;AACD;;AAED,UAAIsI,WAAW,GAAG,KAAKjS,eAAL,CAAqBkS,sBAArB,CAA4CvJ,eAAe,CAACE,OAA5D,CAAlB;AACA,UAAIe,qBAAqB,GAAG,KAAKtJ,gBAAL,CAAsBuJ,oCAAtB,CAA2DrB,cAA3D,CAA5B;AACA,UAAI2J,YAAY,GAAG,KAAKnS,eAAL,CAAqBkS,sBAArB,CAA4CtI,qBAAqB,CAACf,OAAlE,CAAnB;;AAEA,UAAIuJ,WAAW,GAAGvY,0BAA0B,CAAC,KAAKmG,eAAL,CAAqBqS,KAArB,CAA2BC,aAA3B,CAAyCH,YAAzC,CAAD,CAA5C;AAAA,UACII,OADJ;;AAGA,UAAI;AACF,aAAKH,WAAW,CAAClY,CAAZ,EAAL,EAAsB,CAAC,CAACqY,OAAO,GAAGH,WAAW,CAACjY,CAAZ,EAAX,EAA4BX,IAAnD,GAA0D;AACxD,cAAIgZ,YAAY,GAAGD,OAAO,CAAC7Y,KAA3B;;AAEA,cAAI8Y,YAAY,YAAYvV,iBAAxB,IAA6CuV,YAAY,CAACtE,UAAb,CAAwB,KAAK7N,4BAA7B,EAA2DzB,KAA3D,KAAqE2D,OAAtH,EAA+H;AAC7H,gBAAIyL,GAAG,GAAGwE,YAAY,CAACvE,UAAb,CAAwB,KAAK5N,4BAA7B,CAAV;AACA,gBAAIoS,cAAc,GAAGD,YAAY,CAACtE,UAAb,CAAwB,KAAK7N,4BAA7B,CAArB;;AAEA,gBAAIqS,sBAAsB,GAAG,KAAKvS,MAAL,CAAYwS,uBAAZ,CAAoC3E,GAApC,CAA7B;AAAA,gBACI9C,YAAY,GAAGwH,sBAAsB,CAACxH,YAD1C;;AAGA,gBAAI0H,WAAW,GAAG/Y,0BAA0B,CAACyC,sBAAsB,CAAC4O,YAAD,EAAeuH,cAAf,CAAvB,CAA5C;AAAA,gBACII,OADJ;;AAGA,gBAAI;AACF,mBAAKD,WAAW,CAAC1Y,CAAZ,EAAL,EAAsB,CAAC,CAAC2Y,OAAO,GAAGD,WAAW,CAACzY,CAAZ,EAAX,EAA4BX,IAAnD,GAA0D;AACxD,oBAAIsZ,UAAU,GAAGD,OAAO,CAACnZ,KAAzB;;AAEA,oBAAIoZ,UAAU,YAAYxU,yBAAtB,IAAmDwU,UAAU,CAAC5X,IAAX,CAAgB6X,WAAhB,OAAkCpK,eAAe,CAACM,WAAhB,CAA4B8J,WAA5B,EAAzF,EAAoI;AAClI,uBAAK/S,eAAL,CAAqBqS,KAArB,CAA2BW,UAA3B,CAAsCb,YAAtC,EAAoDK,YAApD;AACA,uBAAKxS,eAAL,CAAqBqS,KAArB,CAA2BY,OAA3B,CAAmChB,WAAnC,EAAgDO,YAAhD;AACD;AACF;AACF,aATD,CASE,OAAO5Y,GAAP,EAAY;AACZgZ,cAAAA,WAAW,CAACxY,CAAZ,CAAcR,GAAd;AACD,aAXD,SAWU;AACRgZ,cAAAA,WAAW,CAACtY,CAAZ;AACD;AACF;AACF;AACF,OA9BD,CA8BE,OAAOV,GAAP,EAAY;AACZwY,QAAAA,WAAW,CAAChY,CAAZ,CAAcR,GAAd;AACD,OAhCD,SAgCU;AACRwY,QAAAA,WAAW,CAAC9X,CAAZ;AACD;AACF;AAjDA,GA94BsB,EAg8BtB;AACD2B,IAAAA,GAAG,EAAE,4BADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASkP,0BAAT,CAAoCC,OAApC,EAA6CJ,UAA7C,EAAyD;AAC9D,UAAIqH,iBAAiB,GAAG,KAAK5P,iBAAL,CAAuB6P,KAAvB,CAA6BtH,UAA7B,CAAxB;;AAEA,UAAIqH,iBAAiB,YAAYlT,WAAW,CAACoT,OAA7C,EAAsD;AACpD,YAAIkD,aAAa,GAAG,KAAK/S,MAAL,CAAY4P,KAAZ,CAAkBD,iBAAiB,CAACI,OAApC,EAA6CvT,iBAAiB,CAAC,CAAC,CAAF,EAAK,CAAL,EAAQ,CAAR,CAA9D,CAApB;;AAEA,YAAI0B,6BAA6B,CAAC6U,aAAa,CAAClF,GAAf,CAAjC,EAAsD;AACpD,gBAAM,IAAIjQ,+BAAJ,EAAN;AACD;;AAED,YAAIiQ,GAAG,GAAGkF,aAAa,CAAClF,GAAxB;AAAA,YACI8C,mBAAmB,GAAGoC,aAAa,CAACpC,mBADxC;AAAA,YAEIC,2BAA2B,GAAGmC,aAAa,CAACnC,2BAFhD;AAAA,YAGI7F,YAAY,GAAGgI,aAAa,CAAChI,YAHjC;AAIA,aAAKlL,eAAL,CAAqBoQ,gBAArB,CAAsCvH,OAAtC,EAA+CmF,GAA/C,EAAoD1R,sBAAsB,CAAC4O,YAAD,EAAerC,OAAf,CAA1E,EAAmGrM,SAAS,CAAC2W,MAAV,EAAnG,EAAuHrC,mBAAvH,EAA4IC,2BAA5I;AACD,OAZD,MAYO,IAAIjB,iBAAiB,YAAYlT,WAAW,CAACyT,KAA7C,EAAoD;AACzD,aAAKtG,YAAL,CAAkBlB,OAAlB;AACD,OAFM,MAEA;AACL,aAAKyC,cAAL,CAAoB;AAClBwD,UAAAA,WAAW,EAAEgB,iBAAiB,CAACpW,KADb;AAElBqV,UAAAA,QAAQ,EAAEtG;AAFQ,SAApB,EAGGI,OAHH;AAID;AACF;AAzBA,GAh8BsB,EA09BtB;AACD5M,IAAAA,GAAG,EAAE,qCADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS4M,mCAAT,CAA6CtB,gBAA7C,EAA+DC,KAA/D,EAAsEC,MAAtE,EAA8EC,qBAA9E,EAAqG;AAC1G,UAAIH,gBAAgB,CAACpG,KAAjB,KAA2BuG,qBAAqB,CAACvG,KAArD,EAA4D;AAC1D,eAAO,EAAP;AACD;;AAED,UAAIyH,2BAA2B,GAAG,EAAlC;AACA,UAAIb,WAAW,GAAGnJ,iBAAiB,CAACkJ,QAAlB,CAA2BJ,qBAA3B,EAAkDF,KAAlD,EAAyDC,MAAzD,CAAlB;;AAEA,UAAIkO,WAAW,GAAGvZ,0BAA0B,CAAC2L,WAAW,CAACkK,SAAZ,CAAsB,KAAK1P,eAA3B,CAAD,CAA5C;AAAA,UACIqT,OADJ;;AAGA,UAAI;AACF,aAAKD,WAAW,CAAClZ,CAAZ,EAAL,EAAsB,CAAC,CAACmZ,OAAO,GAAGD,WAAW,CAACjZ,CAAZ,EAAX,EAA4BX,IAAnD,GAA0D;AACxD,cAAIiZ,cAAc,GAAGY,OAAO,CAAC3Z,KAA7B;AACA,cAAI6U,MAAM,GAAG,KAAK7K,cAAL,CAAoB4P,SAApB,CAA8Bb,cAA9B,CAAb;;AAEA,cAAIlE,MAAM,YAAYtR,iBAAlB,IAAuCwV,cAAc,CAAC7T,KAAf,KAAyBoG,gBAAgB,CAACpG,KAArF,EAA4F;AAC1F,gBAAIoP,GAAG,GAAGO,MAAM,CAACN,UAAP,CAAkB,KAAK5N,4BAAvB,CAAV;;AAEA,gBAAIkT,sBAAsB,GAAG,KAAKpT,MAAL,CAAYwS,uBAAZ,CAAoC3E,GAApC,CAA7B;AAAA,gBACI9C,YAAY,GAAGqI,sBAAsB,CAACrI,YAD1C;;AAGA7E,YAAAA,2BAA2B,CAAC5M,IAA5B,CAAiC0R,KAAjC,CAAuC9E,2BAAvC,EAAoExO,kBAAkB,CAAC,KAAKuT,sCAAL,CAA4CpG,gBAAgB,CAACpG,KAA7D,EAAoE6T,cAApE,EAAoFvH,YAApF,CAAD,CAAtF;AACD;AACF;AACF,OAdD,CAcE,OAAOtR,GAAP,EAAY;AACZwZ,QAAAA,WAAW,CAAChZ,CAAZ,CAAcR,GAAd;AACD,OAhBD,SAgBU;AACRwZ,QAAAA,WAAW,CAAC9Y,CAAZ;AACD;;AAED,aAAO+L,2BAAP;AACD;AAlCA,GA19BsB,EA6/BtB;AACDpK,IAAAA,GAAG,EAAE,wCADJ;AAEDvC,IAAAA,KAAK,EAAE,SAAS0R,sCAAT,CAAgDoI,WAAhD,EAA6DlP,aAA7D,EAA4E4G,YAA5E,EAA0F;AAC/F,UAAIsI,WAAW,KAAKlP,aAAa,CAAC1F,KAAlC,EAAyC;AACvC,eAAO,EAAP;AACD;;AAED,UAAIyH,2BAA2B,GAAG,EAAlC;AACA,UAAIkI,MAAM,GAAG,KAAK7K,cAAL,CAAoB4P,SAApB,CAA8BhP,aAA9B,CAAb;;AAEA,UAAImP,WAAW,GAAG5Z,0BAA0B,CAACyC,sBAAsB,CAAC4O,YAAD,EAAe5G,aAAf,CAAvB,CAA5C;AAAA,UACIoP,OADJ;;AAGA,UAAI;AACF,aAAKD,WAAW,CAACvZ,CAAZ,EAAL,EAAsB,CAAC,CAACwZ,OAAO,GAAGD,WAAW,CAACtZ,CAAZ,EAAX,EAA4BX,IAAnD,GAA0D;AACxD,cAAIma,yBAAyB,GAAGD,OAAO,CAACha,KAAxC;;AAEA,cAAI,EAAEia,yBAAyB,YAAYrV,yBAAvC,CAAJ,EAAuE;AACrE;AACD;;AAED,cAAIkK,cAAc,GAAGmL,yBAAyB,CAACzY,IAA/C;AACA,cAAI0Y,YAAY,GAAG,KAAK5T,eAAL,CAAqB6T,0BAArB,CAAgDrL,cAAhD,EAAgEgL,WAAhE,CAAnB;AACA,cAAIM,4BAA4B,GAAG,KAAKxT,gBAAL,CAAsByT,mBAAtB,CAA0CvL,cAA1C,EAA0DlE,aAAa,CAAC1F,KAAxE,CAAnC;AACA,cAAIoV,2BAA2B,GAAGF,4BAA4B,GAAG,KAAK9T,eAAL,CAAqB6T,0BAArB,CAAgDrL,cAAhD,EAAgElE,aAAa,CAAC1F,KAA9E,CAAH,GAA0F,KAAKqV,sCAAL,CAA4CzL,cAA5C,EAA4DoL,YAA5D,EAA0EvN,2BAA1E,CAAxJ;;AAEA,cAAI2N,2BAA2B,KAAKJ,YAApC,EAAkD;AAChD,iBAAK5T,eAAL,CAAqBqS,KAArB,CAA2B6B,cAA3B,CAA0CN,YAA1C,EAAwDrF,MAAxD;AACA,iBAAKvO,eAAL,CAAqBqS,KAArB,CAA2BY,OAA3B,CAAmCe,2BAAnC,EAAgEzF,MAAhE;AACD;AACF;AACF,OAlBD,CAkBE,OAAO3U,GAAP,EAAY;AACZ6Z,QAAAA,WAAW,CAACrZ,CAAZ,CAAcR,GAAd;AACD,OApBD,SAoBU;AACR6Z,QAAAA,WAAW,CAACnZ,CAAZ;AACD;;AAED,aAAO+L,2BAAP;AACD;AAtCA,GA7/BsB,EAoiCtB;AACDpK,IAAAA,GAAG,EAAE,qCADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASgH,mCAAT,GAA+C;AACpD,WAAKV,eAAL,CAAqB0D,cAArB,CAAoCD,QAApC,CAA6C,CAAC,CAA9C,EAAiD,IAAItG,cAAJ,CAAmB,CAAnB,EAAsB,CAAtB,CAAjD;AACD;AAJA,GApiCsB,EAyiCtB;AACDlB,IAAAA,GAAG,EAAE,wCADJ;AAEDvC,IAAAA,KAAK,EAAE,SAASua,sCAAT,CAAgDzL,cAAhD,EAAgEoL,YAAhE,EAA8EpJ,qBAA9E,EAAqG;AAC1G,UAAI/B,UAAU,GAAG,KAAKnI,gBAAL,CAAsBgJ,uBAAtB,CAA8Cd,cAA9C,CAAjB;;AAEA,UAAIC,UAAU,KAAKkB,SAAnB,EAA8B;AAC5BlB,QAAAA,UAAU,GAAG,KAAKnI,gBAAL,CAAsBiI,kBAAtB,CAAyCC,cAAzC,CAAb;AACAgC,QAAAA,qBAAqB,CAAC/Q,IAAtB,CAA2BgP,UAAU,CAACrF,uBAAX,EAA3B;;AAEA,YAAIwQ,YAAY,YAAY3W,iBAA5B,EAA+C;AAC7C,cAAIiW,aAAa,GAAG,KAAK/S,MAAL,CAAYwS,uBAAZ,CAAoCiB,YAAY,CAAC3F,UAAb,CAAwB,KAAK5N,4BAA7B,CAApC,CAApB;AACA,cAAI2N,GAAG,GAAGkF,aAAa,CAAClF,GAAxB;AAAA,cACI8C,mBAAmB,GAAGoC,aAAa,CAACpC,mBADxC;AAAA,cAEIC,2BAA2B,GAAGmC,aAAa,CAACnC,2BAFhD;AAAA,cAGI7F,YAAY,GAAGgI,aAAa,CAAChI,YAHjC;AAIA,eAAKlL,eAAL,CAAqBoQ,gBAArB,CAAsC3H,UAAU,CAACI,OAAjD,EAA0DmF,GAA1D,EAA+D1R,sBAAsB,CAAC4O,YAAD,EAAezC,UAAU,CAACI,OAA1B,CAArF,EAAyHrM,SAAS,CAAC2W,MAAV,EAAzH,EAA6IrC,mBAA7I,EAAkKC,2BAAlK;AACD,SAPD,MAOO,IAAI6C,YAAY,YAAY5W,eAA5B,EAA6C;AAClD,eAAK+M,YAAL,CAAkBtB,UAAU,CAACI,OAA7B;AACD,SAFM,MAEA,IAAI+K,YAAY,YAAYxW,eAA5B,EAA6C;AAClD,eAAKkO,cAAL,CAAoBsI,YAAY,CAAClF,SAAb,EAApB,EAA8CjG,UAAU,CAACI,OAAzD;AACD;AACF;;AAED,aAAO,KAAK7I,eAAL,CAAqBkS,sBAArB,CAA4CzJ,UAAU,CAACI,OAAvD,CAAP;AACD;AAxBA,GAziCsB,EAkkCtB;AACD5M,IAAAA,GAAG,EAAE,gBADJ;AAED8V,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAK/R,eAAL,CAAqB0D,cAA5B;AACD;AAJA,GAlkCsB,CAAb,CAAZ;;AAykCA,SAAO5D,UAAP;AACD,CA5lCoC,EAA9B;AA6lCP,OAAO,SAASf,uBAAT,CAAiCF,OAAjC,EAA0C;AAC/C,MAAIA,OAAO,CAAClF,MAAR,IAAkB,CAAtB,EAAyB;AACvB,WAAOkF,OAAP;AACD;;AAED,MAAIsV,MAAM,GAAGtc,kBAAkB,CAACgH,OAAD,CAAlB,CAA4BuV,IAA5B,CAAiC,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AACpE,QAAIC,KAAK,GAAG5b,cAAc,CAAC0b,KAAD,EAAQ,CAAR,CAA1B;AAAA,QACIG,CAAC,GAAGD,KAAK,CAAC,CAAD,CADb;;AAGA,QAAIE,KAAK,GAAG9b,cAAc,CAAC2b,KAAD,EAAQ,CAAR,CAA1B;AAAA,QACII,CAAC,GAAGD,KAAK,CAAC,CAAD,CADb;;AAGA,WAAOD,CAAC,GAAGE,CAAX;AACD,GARY,CAAb;AASA;;;AAGA,MAAIC,MAAM,GAAGR,MAAM,CAACS,MAAP,CAAc,UAAUC,GAAV,EAAeC,MAAf,EAAuB;AAChD,QAAIC,MAAM,GAAGpc,cAAc,CAACmc,MAAD,EAAS,CAAT,CAA3B;AAAA,QACIE,UAAU,GAAGD,MAAM,CAAC,CAAD,CADvB;AAAA,QAEIE,MAAM,GAAGF,MAAM,CAAC,CAAD,CAFnB;;AAIA,QAAIG,QAAQ,GAAGL,GAAG,CAACA,GAAG,CAAClb,MAAJ,GAAa,CAAd,CAAlB;AACA,QAAIwb,SAAS,GAAGD,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtC;;AAEA,QAAIF,UAAU,IAAIG,SAAlB,EAA6B;AAC3BD,MAAAA,QAAQ,CAAC,CAAD,CAAR,IAAeE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYJ,MAAM,IAAIE,SAAS,GAAGH,UAAhB,CAAlB,CAAf;AACD,KAFD,MAEO;AACLH,MAAAA,GAAG,CAACpb,IAAJ,CAAS,CAACub,UAAD,EAAaC,MAAb,CAAT;AACD;;AAED,WAAOJ,GAAP;AACD,GAfY,EAeV,CAACV,MAAM,CAAC,CAAD,CAAP,CAfU,CAAb;AAgBA;;AAEA,MAAImB,KAAK,GAAG,CAAZ;;AAEA,OAAK,IAAI1c,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+b,MAAM,CAAChb,MAA3B,EAAmC,EAAEf,CAArC,EAAwC;AACtC+b,IAAAA,MAAM,CAAC/b,CAAD,CAAN,CAAU,CAAV,KAAgB0c,KAAhB;AACAA,IAAAA,KAAK,IAAIX,MAAM,CAAC/b,CAAD,CAAN,CAAU,CAAV,CAAT;AACD;;AAED,SAAO+b,MAAP;AACD;AACD,OAAO,SAASrV,qBAAT,CAA+BT,OAA/B,EAAwC;AAC7C,MAAIA,OAAO,CAAClF,MAAR,IAAkB,CAAtB,EAAyB;AACvB,WAAOkF,OAAP;AACD;;AAED,MAAIsV,MAAM,GAAGtc,kBAAkB,CAACgH,OAAD,CAAlB,CAA4BuV,IAA5B,CAAiC,UAAUmB,MAAV,EAAkBC,MAAlB,EAA0B;AACtE,QAAIC,MAAM,GAAG9c,cAAc,CAAC4c,MAAD,EAAS,CAAT,CAA3B;AAAA,QACIf,CAAC,GAAGiB,MAAM,CAAC,CAAD,CADd;;AAGA,QAAIC,MAAM,GAAG/c,cAAc,CAAC6c,MAAD,EAAS,CAAT,CAA3B;AAAA,QACId,CAAC,GAAGgB,MAAM,CAAC,CAAD,CADd;;AAGA,WAAOlB,CAAC,GAAGE,CAAX;AACD,GARY,CAAb;AASA;;;AAGA,MAAIC,MAAM,GAAGR,MAAM,CAACS,MAAP,CAAc,UAAUC,GAAV,EAAec,MAAf,EAAuB;AAChD,QAAIC,MAAM,GAAGjd,cAAc,CAACgd,MAAD,EAAS,CAAT,CAA3B;AAAA,QACIX,UAAU,GAAGY,MAAM,CAAC,CAAD,CADvB;AAAA,QAEIX,MAAM,GAAGW,MAAM,CAAC,CAAD,CAFnB;;AAIA,QAAIV,QAAQ,GAAGL,GAAG,CAACA,GAAG,CAAClb,MAAJ,GAAa,CAAd,CAAlB;;AAEA,QAAIqb,UAAU,KAAKE,QAAQ,CAAC,CAAD,CAA3B,EAAgC;AAC9BA,MAAAA,QAAQ,CAAC,CAAD,CAAR,GAAcE,IAAI,CAACC,GAAL,CAASH,QAAQ,CAAC,CAAD,CAAjB,EAAsBD,MAAtB,CAAd;AACD,KAFD,MAEO;AACLJ,MAAAA,GAAG,CAACpb,IAAJ,CAAS,CAACub,UAAD,EAAaC,MAAb,CAAT;AACD;;AAED,WAAOJ,GAAP;AACD,GAdY,EAcV,CAACV,MAAM,CAAC,CAAD,CAAP,CAdU,CAAb;AAeA;;AAEA,MAAImB,KAAK,GAAG,CAAZ;;AAEA,OAAK,IAAI1c,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+b,MAAM,CAAChb,MAA3B,EAAmC,EAAEf,CAArC,EAAwC;AACtC+b,IAAAA,MAAM,CAAC/b,CAAD,CAAN,CAAU,CAAV,KAAgB0c,KAAhB;AACAA,IAAAA,KAAK,IAAIX,MAAM,CAAC/b,CAAD,CAAN,CAAU,CAAV,CAAT;AACD;;AAED,SAAO+b,MAAP;AACD;;AAED,SAAS3K,iBAAT,CAA2B6L,CAA3B,EAA8B;AAC5B,SAAOrR,MAAM,CAACsR,SAAP,CAAiBD,CAAjB,KAAuBA,CAAC,GAAG,CAAlC;AACD;;AAED,SAAS5L,kBAAT,CAA4B8L,UAA5B,EAAwC9Q,KAAxC,EAA+CC,MAA/C,EAAuD;AACrD,SAAO6Q,UAAU,CAACnQ,GAAX,KAAmB,CAAnB,IAAwBoE,iBAAiB,CAAC/E,KAAD,CAAzC,IAAoDC,MAAM,KAAKV,MAAM,CAACC,iBAAtE,IAA2FsR,UAAU,CAACrQ,GAAX,KAAmB,CAAnB,IAAwBsE,iBAAiB,CAAC9E,MAAD,CAAzC,IAAqDD,KAAK,KAAKT,MAAM,CAACC,iBAAxK;AACD","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { absolutizeDependencies, filterDependenciesOutOfScope } from './absolutizeDependencies';\nimport { ArraySize } from './ArraySize';\nimport { equalSimpleCellAddress, invalidSimpleCellAddress, simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { ClipboardCellType } from './ClipboardOperations';\nimport { ContentChanges } from './ContentChanges';\nimport { ArrayVertex, EmptyCellVertex, FormulaCellVertex, ParsingErrorVertex, SparseStrategy, ValueCellVertex } from './DependencyGraph';\nimport { FormulaVertex } from './DependencyGraph/FormulaCellVertex';\nimport { AddColumnsTransformer } from './dependencyTransformers/AddColumnsTransformer';\nimport { AddRowsTransformer } from './dependencyTransformers/AddRowsTransformer';\nimport { CleanOutOfScopeDependenciesTransformer } from './dependencyTransformers/CleanOutOfScopeDependenciesTransformer';\nimport { MoveCellsTransformer } from './dependencyTransformers/MoveCellsTransformer';\nimport { RemoveColumnsTransformer } from './dependencyTransformers/RemoveColumnsTransformer';\nimport { RemoveRowsTransformer } from './dependencyTransformers/RemoveRowsTransformer';\nimport { RemoveSheetTransformer } from './dependencyTransformers/RemoveSheetTransformer';\nimport { InvalidArgumentsError, NamedExpressionDoesNotExistError, NoRelativeAddressesAllowedError, SheetSizeLimitExceededError, SourceLocationHasArrayError, TargetLocationHasArrayError } from './errors';\nimport { EmptyValue, getRawValue } from './interpreter/InterpreterValue';\nimport { doesContainRelativeReferences } from './NamedExpressions';\nimport { NamedExpressionDependency } from './parser';\nimport { findBoundaries } from './Sheet';\nimport { ColumnsSpan, RowsSpan } from './Span';\nimport { StatType } from './statistics';\nexport var RemoveRowsCommand = /*#__PURE__*/function () {\n  function RemoveRowsCommand(sheet, indexes) {\n    _classCallCheck(this, RemoveRowsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(RemoveRowsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeRemovedIndexes(this.indexes);\n    }\n  }, {\n    key: \"rowsSpans\",\n    value: function rowsSpans() {\n      var _this = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return RowsSpan.fromNumberOfRows(_this.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return RemoveRowsCommand;\n}();\nexport var AddRowsCommand = /*#__PURE__*/function () {\n  function AddRowsCommand(sheet, indexes) {\n    _classCallCheck(this, AddRowsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(AddRowsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeAddedIndexes(this.indexes);\n    }\n  }, {\n    key: \"rowsSpans\",\n    value: function rowsSpans() {\n      var _this2 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return RowsSpan.fromNumberOfRows(_this2.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return AddRowsCommand;\n}();\nexport var AddColumnsCommand = /*#__PURE__*/function () {\n  function AddColumnsCommand(sheet, indexes) {\n    _classCallCheck(this, AddColumnsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(AddColumnsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeAddedIndexes(this.indexes);\n    }\n  }, {\n    key: \"columnsSpans\",\n    value: function columnsSpans() {\n      var _this3 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return ColumnsSpan.fromNumberOfColumns(_this3.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return AddColumnsCommand;\n}();\nexport var RemoveColumnsCommand = /*#__PURE__*/function () {\n  function RemoveColumnsCommand(sheet, indexes) {\n    _classCallCheck(this, RemoveColumnsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(RemoveColumnsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeRemovedIndexes(this.indexes);\n    }\n  }, {\n    key: \"columnsSpans\",\n    value: function columnsSpans() {\n      var _this4 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return ColumnsSpan.fromNumberOfColumns(_this4.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return RemoveColumnsCommand;\n}();\nexport var Operations = /*#__PURE__*/function () {\n  function Operations(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor) {\n    _classCallCheck(this, Operations);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.cellContentParser = cellContentParser;\n    this.parser = parser;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.arraySizePredictor = arraySizePredictor;\n    this.changes = ContentChanges.empty();\n    this.allocateNamedExpressionAddressSpace();\n    this.maxColumns = config.maxColumns;\n    this.maxRows = config.maxRows;\n  }\n\n  _createClass(Operations, [{\n    key: \"removeRows\",\n    value: function removeRows(cmd) {\n      var rowsRemovals = [];\n\n      var _iterator = _createForOfIteratorHelper(cmd.rowsSpans()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rowsToRemove = _step.value;\n          var rowsRemoval = this.doRemoveRows(rowsToRemove);\n\n          if (rowsRemoval) {\n            rowsRemovals.push(rowsRemoval);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return rowsRemovals;\n    }\n  }, {\n    key: \"addRows\",\n    value: function addRows(cmd) {\n      var _iterator2 = _createForOfIteratorHelper(cmd.rowsSpans()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var addedRows = _step2.value;\n          this.doAddRows(addedRows);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(cmd) {\n      var _iterator3 = _createForOfIteratorHelper(cmd.columnsSpans()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var addedColumns = _step3.value;\n          this.doAddColumns(addedColumns);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(cmd) {\n      var columnsRemovals = [];\n\n      var _iterator4 = _createForOfIteratorHelper(cmd.columnsSpans()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var columnsToRemove = _step4.value;\n          var columnsRemoval = this.doRemoveColumns(columnsToRemove);\n\n          if (columnsRemoval) {\n            columnsRemovals.push(columnsRemoval);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return columnsRemovals;\n    }\n  }, {\n    key: \"removeSheet\",\n    value: function removeSheet(sheetId) {\n      var _this5 = this;\n\n      this.dependencyGraph.removeSheet(sheetId);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveSheetTransformer(sheetId);\n        transformation.performEagerTransformations(_this5.dependencyGraph, _this5.parser);\n        version = _this5.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.sheetMapping.removeSheet(sheetId);\n      this.columnSearch.removeSheet(sheetId);\n      var scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(function (namedexpression) {\n        return _this5.removeNamedExpression(namedexpression.normalizeExpressionName(), sheetId);\n      });\n      return {\n        version: version,\n        scopedNamedExpressions: scopedNamedExpressions\n      };\n    }\n  }, {\n    key: \"removeSheetByName\",\n    value: function removeSheetByName(sheetName) {\n      var sheetId = this.sheetMapping.fetch(sheetName);\n      return this.removeSheet(sheetId);\n    }\n  }, {\n    key: \"clearSheet\",\n    value: function clearSheet(sheetId) {\n      this.dependencyGraph.clearSheet(sheetId);\n      this.columnSearch.removeSheet(sheetId);\n    }\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(name) {\n      var sheetId = this.sheetMapping.addSheet(name);\n      var sheet = [];\n      this.dependencyGraph.addressMapping.autoAddSheet(sheetId, sheet, findBoundaries(sheet));\n      return this.sheetMapping.fetchDisplayName(sheetId);\n    }\n  }, {\n    key: \"renameSheet\",\n    value: function renameSheet(sheetId, newName) {\n      return this.sheetMapping.renameSheet(sheetId, newName);\n    }\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(sheet, startRow, numberOfRows, targetRow) {\n      var rowsToAdd = RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);\n      this.lazilyTransformingAstService.beginCombinedMode(sheet);\n      this.doAddRows(rowsToAdd);\n\n      if (targetRow < startRow) {\n        startRow += numberOfRows;\n      }\n\n      var startAddress = simpleCellAddress(sheet, 0, startRow);\n      var targetAddress = simpleCellAddress(sheet, 0, targetRow);\n      this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);\n      var rowsToRemove = RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);\n      this.doRemoveRows(rowsToRemove);\n      return this.lazilyTransformingAstService.commitCombinedMode();\n    }\n  }, {\n    key: \"moveColumns\",\n    value: function moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n      var columnsToAdd = ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);\n      this.lazilyTransformingAstService.beginCombinedMode(sheet);\n      this.doAddColumns(columnsToAdd);\n\n      if (targetColumn < startColumn) {\n        startColumn += numberOfColumns;\n      }\n\n      var startAddress = simpleCellAddress(sheet, startColumn, 0);\n      var targetAddress = simpleCellAddress(sheet, targetColumn, 0);\n      this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);\n      var columnsToRemove = ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);\n      this.doRemoveColumns(columnsToRemove);\n      return this.lazilyTransformingAstService.commitCombinedMode();\n    }\n  }, {\n    key: \"moveCells\",\n    value: function moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      var _this6 = this;\n\n      this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n      var sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n      var toRight = destinationLeftCorner.col - sourceLeftCorner.col;\n      var toBottom = destinationLeftCorner.row - sourceLeftCorner.row;\n      var toSheet = destinationLeftCorner.sheet;\n      var currentDataAtTarget = this.getRangeClipboardCells(targetRange);\n      var valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);\n      this.columnSearch.removeValues(valuesToRemove);\n      var valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);\n      this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);\n        transformation.performEagerTransformations(_this6.dependencyGraph, _this6.parser);\n        version = _this6.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);\n      var addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);\n      return {\n        version: version,\n        overwrittenCellsData: currentDataAtTarget,\n        addedGlobalNamedExpressions: addedGlobalNamedExpressions\n      };\n    }\n  }, {\n    key: \"setRowOrder\",\n    value: function setRowOrder(sheetId, rowMapping) {\n      var _this7 = this;\n\n      var buffer = [];\n      var oldContent = [];\n\n      var _iterator5 = _createForOfIteratorHelper(rowMapping),\n          _step5;\n\n      try {\n        var _loop = function _loop() {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              source = _step5$value[0],\n              target = _step5$value[1];\n\n          if (source !== target) {\n            var rowRange = AbsoluteCellRange.spanFrom({\n              sheet: sheetId,\n              col: 0,\n              row: source\n            }, Infinity, 1);\n\n            var row = _this7.getRangeClipboardCells(rowRange);\n\n            oldContent = oldContent.concat(row);\n            buffer.push(row.map(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                  _ref2$ = _ref2[0],\n                  sheet = _ref2$.sheet,\n                  col = _ref2$.col,\n                  cell = _ref2[1];\n\n              return [{\n                sheet: sheet,\n                col: col,\n                row: target\n              }, cell];\n            }));\n          }\n        };\n\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      buffer.forEach(function (row) {\n        return _this7.restoreClipboardCells(sheetId, row.values());\n      });\n      return oldContent;\n    }\n  }, {\n    key: \"setColumnOrder\",\n    value: function setColumnOrder(sheetId, columnMapping) {\n      var _this8 = this;\n\n      var buffer = [];\n      var oldContent = [];\n\n      var _iterator6 = _createForOfIteratorHelper(columnMapping),\n          _step6;\n\n      try {\n        var _loop2 = function _loop2() {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              source = _step6$value[0],\n              target = _step6$value[1];\n\n          if (source !== target) {\n            var rowRange = AbsoluteCellRange.spanFrom({\n              sheet: sheetId,\n              col: source,\n              row: 0\n            }, 1, Infinity);\n\n            var column = _this8.getRangeClipboardCells(rowRange);\n\n            oldContent = oldContent.concat(column);\n            buffer.push(column.map(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                  _ref4$ = _ref4[0],\n                  sheet = _ref4$.sheet,\n                  col = _ref4$.col,\n                  row = _ref4$.row,\n                  cell = _ref4[1];\n\n              return [{\n                sheet: sheet,\n                col: target,\n                row: row\n              }, cell];\n            }));\n          }\n        };\n\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      buffer.forEach(function (column) {\n        return _this8.restoreClipboardCells(sheetId, column.values());\n      });\n      return oldContent;\n    }\n  }, {\n    key: \"addNamedExpression\",\n    value: function addNamedExpression(expressionName, expression, sheetId, options) {\n      var namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);\n      this.storeNamedExpressionInCell(namedExpression.address, expression);\n      this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);\n    }\n  }, {\n    key: \"restoreNamedExpression\",\n    value: function restoreNamedExpression(namedExpression, content, sheetId) {\n      var expressionName = namedExpression.displayName;\n      this.restoreCell(namedExpression.address, content);\n      var restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);\n      this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);\n    }\n  }, {\n    key: \"changeNamedExpressionExpression\",\n    value: function changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {\n      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (!namedExpression) {\n        throw new NamedExpressionDoesNotExistError(expressionName);\n      }\n\n      var oldNamedExpression = namedExpression.copy();\n      namedExpression.options = options;\n      var content = this.getClipboardCell(namedExpression.address);\n      this.storeNamedExpressionInCell(namedExpression.address, newExpression);\n      return [oldNamedExpression, content];\n    }\n  }, {\n    key: \"removeNamedExpression\",\n    value: function removeNamedExpression(expressionName, sheetId) {\n      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (!namedExpression) {\n        throw new NamedExpressionDoesNotExistError(expressionName);\n      }\n\n      this.namedExpressions.remove(namedExpression.displayName, sheetId);\n      var content = this.getClipboardCell(namedExpression.address);\n\n      if (sheetId !== undefined) {\n        var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n        this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);\n      } else {\n        this.dependencyGraph.setCellEmpty(namedExpression.address);\n      }\n\n      return [namedExpression, content];\n    }\n  }, {\n    key: \"ensureItIsPossibleToMoveCells\",\n    value: function ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      if (invalidSimpleCellAddress(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || invalidSimpleCellAddress(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {\n        throw new InvalidArgumentsError('a valid range of cells to move.');\n      }\n\n      var sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n\n      if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {\n        throw new SheetSizeLimitExceededError();\n      }\n\n      if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n        throw new SourceLocationHasArrayError();\n      }\n\n      if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {\n        throw new TargetLocationHasArrayError();\n      }\n    }\n  }, {\n    key: \"restoreClipboardCells\",\n    value: function restoreClipboardCells(sourceSheetId, cells) {\n      var addedNamedExpressions = [];\n\n      var _iterator7 = _createForOfIteratorHelper(cells),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              address = _step7$value[0],\n              clipboardCell = _step7$value[1];\n\n          this.restoreCell(address, clipboardCell);\n\n          if (clipboardCell.type === ClipboardCellType.FORMULA) {\n            var _this$parser$fetchCac = this.parser.fetchCachedResult(clipboardCell.hash),\n                dependencies = _this$parser$fetchCac.dependencies;\n\n            addedNamedExpressions.push.apply(addedNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies)));\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return addedNamedExpressions;\n    }\n  }, {\n    key: \"restoreCell\",\n    value: function restoreCell(address, clipboardCell) {\n      switch (clipboardCell.type) {\n        case ClipboardCellType.VALUE:\n          {\n            this.setValueToCell(clipboardCell, address);\n            break;\n          }\n\n        case ClipboardCellType.FORMULA:\n          {\n            this.setFormulaToCellFromCache(clipboardCell.hash, address);\n            break;\n          }\n\n        case ClipboardCellType.EMPTY:\n          {\n            this.setCellEmpty(address);\n            break;\n          }\n\n        case ClipboardCellType.PARSING_ERROR:\n          {\n            this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);\n            break;\n          }\n      }\n    }\n    /**\n     * Removes multiple rows from sheet. </br>\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * @param sheet - sheet id from which rows will be removed\n     * @param rowStart - number of the first row to be deleted\n     * @param rowEnd - number of the last row to be deleted\n     * */\n\n  }, {\n    key: \"doRemoveRows\",\n    value: function doRemoveRows(rowsToRemove) {\n      var _this9 = this;\n\n      if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {\n        return;\n      }\n\n      var removedCells = [];\n\n      var _iterator8 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 1),\n              address = _step8$value[0];\n\n          removedCells.push({\n            address: address,\n            cellType: this.getClipboardCell(address)\n          });\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      var _this$dependencyGraph = this.dependencyGraph.removeRows(rowsToRemove),\n          affectedArrays = _this$dependencyGraph.affectedArrays,\n          contentChanges = _this$dependencyGraph.contentChanges;\n\n      this.columnSearch.applyChanges(contentChanges.getChanges());\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveRowsTransformer(rowsToRemove);\n        transformation.performEagerTransformations(_this9.dependencyGraph, _this9.parser);\n        version = _this9.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.rewriteAffectedArrays(affectedArrays);\n      return {\n        version: version,\n        removedCells: removedCells,\n        rowFrom: rowsToRemove.rowStart,\n        rowCount: rowsToRemove.numberOfRows\n      };\n    }\n    /**\n     * Removes multiple columns from sheet. </br>\n     * Does nothing if columns are outside of effective sheet size.\n     *\n     * @param sheet - sheet id from which columns will be removed\n     * @param columnStart - number of the first column to be deleted\n     * @param columnEnd - number of the last row to be deleted\n     */\n\n  }, {\n    key: \"doRemoveColumns\",\n    value: function doRemoveColumns(columnsToRemove) {\n      var _this10 = this;\n\n      if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {\n        return;\n      }\n\n      var removedCells = [];\n\n      var _iterator9 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step9$value = _slicedToArray(_step9.value, 1),\n              address = _step9$value[0];\n\n          removedCells.push({\n            address: address,\n            cellType: this.getClipboardCell(address)\n          });\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      var _this$dependencyGraph2 = this.dependencyGraph.removeColumns(columnsToRemove),\n          affectedArrays = _this$dependencyGraph2.affectedArrays,\n          contentChanges = _this$dependencyGraph2.contentChanges;\n\n      this.columnSearch.applyChanges(contentChanges.getChanges());\n      this.columnSearch.removeColumns(columnsToRemove);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveColumnsTransformer(columnsToRemove);\n        transformation.performEagerTransformations(_this10.dependencyGraph, _this10.parser);\n        version = _this10.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.rewriteAffectedArrays(affectedArrays);\n      return {\n        version: version,\n        removedCells: removedCells,\n        columnFrom: columnsToRemove.columnStart,\n        columnCount: columnsToRemove.numberOfColumns\n      };\n    }\n    /**\n     * Add multiple rows to sheet. </br>\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * @param sheet - sheet id in which rows will be added\n     * @param row - row number above which the rows will be added\n     * @param numberOfRowsToAdd - number of rows to add\n     */\n\n  }, {\n    key: \"doAddRows\",\n    value: function doAddRows(addedRows) {\n      var _this11 = this;\n\n      if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {\n        return;\n      }\n\n      var _this$dependencyGraph3 = this.dependencyGraph.addRows(addedRows),\n          affectedArrays = _this$dependencyGraph3.affectedArrays;\n\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new AddRowsTransformer(addedRows);\n        transformation.performEagerTransformations(_this11.dependencyGraph, _this11.parser);\n\n        _this11.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.rewriteAffectedArrays(affectedArrays);\n    }\n  }, {\n    key: \"rewriteAffectedArrays\",\n    value: function rewriteAffectedArrays(affectedArrays) {\n      var _iterator10 = _createForOfIteratorHelper(affectedArrays.values()),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var arrayVertex = _step10.value;\n\n          if (arrayVertex.array.size.isRef) {\n            continue;\n          }\n\n          var ast = arrayVertex.getFormula(this.lazilyTransformingAstService);\n          var address = arrayVertex.getAddress(this.lazilyTransformingAstService);\n          var hash = this.parser.computeHashFromAst(ast);\n          this.setFormulaToCellFromCache(hash, address);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n    /**\n     * Add multiple columns to sheet </br>\n     * Does nothing if columns are outside of effective sheet size\n     *\n     * @param sheet - sheet id in which columns will be added\n     * @param column - column number above which the columns will be added\n     * @param numberOfColumns - number of columns to add\n     */\n\n  }, {\n    key: \"doAddColumns\",\n    value: function doAddColumns(addedColumns) {\n      var _this12 = this;\n\n      if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {\n        return;\n      }\n\n      var _this$dependencyGraph4 = this.dependencyGraph.addColumns(addedColumns),\n          affectedArrays = _this$dependencyGraph4.affectedArrays,\n          contentChanges = _this$dependencyGraph4.contentChanges;\n\n      this.columnSearch.addColumns(addedColumns);\n      this.columnSearch.applyChanges(contentChanges.getChanges());\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new AddColumnsTransformer(addedColumns);\n        transformation.performEagerTransformations(_this12.dependencyGraph, _this12.parser);\n\n        _this12.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.rewriteAffectedArrays(affectedArrays);\n    }\n  }, {\n    key: \"getOldContent\",\n    value: function getOldContent(address) {\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n        return [address, {\n          type: ClipboardCellType.EMPTY\n        }];\n      } else if (vertex instanceof ValueCellVertex) {\n        return [address, Object.assign({\n          type: ClipboardCellType.VALUE\n        }, vertex.getValues())];\n      } else if (vertex instanceof FormulaVertex) {\n        return [vertex.getAddress(this.lazilyTransformingAstService), {\n          type: ClipboardCellType.FORMULA,\n          hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n        }];\n      } else if (vertex instanceof ParsingErrorVertex) {\n        return [address, {\n          type: ClipboardCellType.PARSING_ERROR,\n          rawInput: vertex.rawInput,\n          errors: vertex.errors\n        }];\n      }\n\n      throw Error('Trying to copy unsupported type');\n    }\n  }, {\n    key: \"getClipboardCell\",\n    value: function getClipboardCell(address) {\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n        return {\n          type: ClipboardCellType.EMPTY\n        };\n      } else if (vertex instanceof ValueCellVertex) {\n        return Object.assign({\n          type: ClipboardCellType.VALUE\n        }, vertex.getValues());\n      } else if (vertex instanceof ArrayVertex) {\n        var val = vertex.getArrayCellValue(address);\n\n        if (val === EmptyValue) {\n          return {\n            type: ClipboardCellType.EMPTY\n          };\n        }\n\n        return {\n          type: ClipboardCellType.VALUE,\n          parsedValue: val,\n          rawValue: vertex.getArrayCellRawValue(address)\n        };\n      } else if (vertex instanceof FormulaCellVertex) {\n        return {\n          type: ClipboardCellType.FORMULA,\n          hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n        };\n      } else if (vertex instanceof ParsingErrorVertex) {\n        return {\n          type: ClipboardCellType.PARSING_ERROR,\n          rawInput: vertex.rawInput,\n          errors: vertex.errors\n        };\n      }\n\n      throw Error('Trying to copy unsupported type');\n    }\n  }, {\n    key: \"getSheetClipboardCells\",\n    value: function getSheetClipboardCells(sheet) {\n      var sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n      var sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n      var arr = new Array(sheetHeight);\n\n      for (var i = 0; i < sheetHeight; i++) {\n        arr[i] = new Array(sheetWidth);\n\n        for (var j = 0; j < sheetWidth; j++) {\n          var address = simpleCellAddress(sheet, j, i);\n          arr[i][j] = this.getClipboardCell(address);\n        }\n      }\n\n      return arr;\n    }\n  }, {\n    key: \"getRangeClipboardCells\",\n    value: function getRangeClipboardCells(range) {\n      var result = [];\n\n      var _iterator11 = _createForOfIteratorHelper(range.addresses(this.dependencyGraph)),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var address = _step11.value;\n          result.push([address, this.getClipboardCell(address)]);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"setCellContent\",\n    value: function setCellContent(address, newCellContent) {\n      var parsedCellContent = this.cellContentParser.parse(newCellContent);\n      var oldContent = this.getOldContent(address);\n\n      if (parsedCellContent instanceof CellContent.Formula) {\n        var parserResult = this.parser.parse(parsedCellContent.formula, address);\n        var ast = parserResult.ast,\n            errors = parserResult.errors;\n\n        if (errors.length > 0) {\n          this.setParsingErrorToCell(parsedCellContent.formula, errors, address);\n        } else {\n          var size = this.arraySizePredictor.checkArraySize(ast, address);\n          this.setFormulaToCell(address, size, parserResult);\n        }\n      } else if (parsedCellContent instanceof CellContent.Empty) {\n        this.setCellEmpty(address);\n      } else {\n        this.setValueToCell({\n          parsedValue: parsedCellContent.value,\n          rawValue: newCellContent\n        }, address);\n      }\n\n      return oldContent;\n    }\n  }, {\n    key: \"setSheetContent\",\n    value: function setSheetContent(sheetId, newSheetContent) {\n      this.clearSheet(sheetId);\n\n      for (var i = 0; i < newSheetContent.length; i++) {\n        for (var j = 0; j < newSheetContent[i].length; j++) {\n          var address = simpleCellAddress(sheetId, j, i);\n          this.setCellContent(address, newSheetContent[i][j]);\n        }\n      }\n    }\n  }, {\n    key: \"setParsingErrorToCell\",\n    value: function setParsingErrorToCell(rawInput, errors, address) {\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      var vertex = new ParsingErrorVertex(errors, rawInput);\n      var arrayChanges = this.dependencyGraph.setParsingErrorToCell(address, vertex);\n      this.columnSearch.remove(getRawValue(oldValue), address);\n      this.columnSearch.applyChanges(arrayChanges.getChanges());\n      this.changes.addAll(arrayChanges);\n      this.changes.addChange(vertex.getCellValue(), address);\n    }\n  }, {\n    key: \"setFormulaToCell\",\n    value: function setFormulaToCell(address, size, _ref5) {\n      var ast = _ref5.ast,\n          hasVolatileFunction = _ref5.hasVolatileFunction,\n          hasStructuralChangeFunction = _ref5.hasStructuralChangeFunction,\n          dependencies = _ref5.dependencies;\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      var arrayChanges = this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), size, hasVolatileFunction, hasStructuralChangeFunction);\n      this.columnSearch.remove(getRawValue(oldValue), address);\n      this.columnSearch.applyChanges(arrayChanges.getChanges());\n      this.changes.addAll(arrayChanges);\n    }\n  }, {\n    key: \"setValueToCell\",\n    value: function setValueToCell(value, address) {\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      var arrayChanges = this.dependencyGraph.setValueToCell(address, value);\n      this.columnSearch.change(getRawValue(oldValue), getRawValue(value.parsedValue), address);\n      this.columnSearch.applyChanges(arrayChanges.getChanges().filter(function (change) {\n        return !equalSimpleCellAddress(change.address, address);\n      }));\n      this.changes.addAll(arrayChanges);\n      this.changes.addChange(value.parsedValue, address);\n    }\n  }, {\n    key: \"setCellEmpty\",\n    value: function setCellEmpty(address) {\n      if (this.dependencyGraph.isArrayInternalCell(address)) {\n        return;\n      }\n\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      var arrayChanges = this.dependencyGraph.setCellEmpty(address);\n      this.columnSearch.remove(getRawValue(oldValue), address);\n      this.columnSearch.applyChanges(arrayChanges.getChanges());\n      this.changes.addAll(arrayChanges);\n      this.changes.addChange(EmptyValue, address);\n    }\n  }, {\n    key: \"setFormulaToCellFromCache\",\n    value: function setFormulaToCellFromCache(formulaHash, address) {\n      var _this$parser$fetchCac2 = this.parser.fetchCachedResult(formulaHash),\n          ast = _this$parser$fetchCac2.ast,\n          hasVolatileFunction = _this$parser$fetchCac2.hasVolatileFunction,\n          hasStructuralChangeFunction = _this$parser$fetchCac2.hasStructuralChangeFunction,\n          dependencies = _this$parser$fetchCac2.dependencies;\n\n      var absoluteDependencies = absolutizeDependencies(dependencies, address);\n\n      var _CleanOutOfScopeDepen = new CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address),\n          _CleanOutOfScopeDepen2 = _slicedToArray(_CleanOutOfScopeDepen, 1),\n          cleanedAst = _CleanOutOfScopeDepen2[0];\n\n      this.parser.rememberNewAst(cleanedAst);\n      var cleanedDependencies = filterDependenciesOutOfScope(absoluteDependencies);\n      var size = this.arraySizePredictor.checkArraySize(ast, address);\n      this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, size, hasVolatileFunction, hasStructuralChangeFunction);\n    }\n    /**\n     * Returns true if row number is outside of given sheet.\n     *\n     * @param row - row number\n     * @param sheet - sheet id number\n     */\n\n  }, {\n    key: \"rowEffectivelyNotInSheet\",\n    value: function rowEffectivelyNotInSheet(row, sheet) {\n      var height = this.dependencyGraph.addressMapping.getHeight(sheet);\n      return row >= height;\n    }\n  }, {\n    key: \"getAndClearContentChanges\",\n    value: function getAndClearContentChanges() {\n      var changes = this.changes;\n      this.changes = ContentChanges.empty();\n      return changes;\n    }\n  }, {\n    key: \"forceApplyPostponedTransformations\",\n    value: function forceApplyPostponedTransformations() {\n      this.dependencyGraph.forceApplyPostponedTransformations();\n    }\n  }, {\n    key: \"sheetMapping\",\n    get: function get() {\n      return this.dependencyGraph.sheetMapping;\n    }\n    /**\n     * Returns true if row number is outside of given sheet.\n     *\n     * @param column - row number\n     * @param sheet - sheet id number\n     */\n\n  }, {\n    key: \"columnEffectivelyNotInSheet\",\n    value: function columnEffectivelyNotInSheet(column, sheet) {\n      var width = this.dependencyGraph.addressMapping.getWidth(sheet);\n      return column >= width;\n    }\n  }, {\n    key: \"adjustNamedExpressionEdges\",\n    value: function adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {\n      if (sheetId === undefined) {\n        return;\n      }\n\n      var localVertex = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);\n      var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n      var globalVertex = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);\n\n      var _iterator12 = _createForOfIteratorHelper(this.dependencyGraph.graph.adjacentNodes(globalVertex)),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var adjacentNode = _step12.value;\n\n          if (adjacentNode instanceof FormulaCellVertex && adjacentNode.getAddress(this.lazilyTransformingAstService).sheet === sheetId) {\n            var ast = adjacentNode.getFormula(this.lazilyTransformingAstService);\n            var formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);\n\n            var _this$parser$fetchCac3 = this.parser.fetchCachedResultForAst(ast),\n                dependencies = _this$parser$fetchCac3.dependencies;\n\n            var _iterator13 = _createForOfIteratorHelper(absolutizeDependencies(dependencies, formulaAddress)),\n                _step13;\n\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var dependency = _step13.value;\n\n                if (dependency instanceof NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {\n                  this.dependencyGraph.graph.removeEdge(globalVertex, adjacentNode);\n                  this.dependencyGraph.graph.addEdge(localVertex, adjacentNode);\n                }\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }, {\n    key: \"storeNamedExpressionInCell\",\n    value: function storeNamedExpressionInCell(address, expression) {\n      var parsedCellContent = this.cellContentParser.parse(expression);\n\n      if (parsedCellContent instanceof CellContent.Formula) {\n        var parsingResult = this.parser.parse(parsedCellContent.formula, simpleCellAddress(-1, 0, 0));\n\n        if (doesContainRelativeReferences(parsingResult.ast)) {\n          throw new NoRelativeAddressesAllowedError();\n        }\n\n        var ast = parsingResult.ast,\n            hasVolatileFunction = parsingResult.hasVolatileFunction,\n            hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,\n            dependencies = parsingResult.dependencies;\n        this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n      } else if (parsedCellContent instanceof CellContent.Empty) {\n        this.setCellEmpty(address);\n      } else {\n        this.setValueToCell({\n          parsedValue: parsedCellContent.value,\n          rawValue: expression\n        }, address);\n      }\n    }\n  }, {\n    key: \"updateNamedExpressionsForMovedCells\",\n    value: function updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {\n        return [];\n      }\n\n      var addedGlobalNamedExpressions = [];\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n\n      var _iterator14 = _createForOfIteratorHelper(targetRange.addresses(this.dependencyGraph)),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var formulaAddress = _step14.value;\n          var vertex = this.addressMapping.fetchCell(formulaAddress);\n\n          if (vertex instanceof FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {\n            var ast = vertex.getFormula(this.lazilyTransformingAstService);\n\n            var _this$parser$fetchCac4 = this.parser.fetchCachedResultForAst(ast),\n                dependencies = _this$parser$fetchCac4.dependencies;\n\n            addedGlobalNamedExpressions.push.apply(addedGlobalNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies)));\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      return addedGlobalNamedExpressions;\n    }\n  }, {\n    key: \"updateNamedExpressionsForTargetAddress\",\n    value: function updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {\n      if (sourceSheet === targetAddress.sheet) {\n        return [];\n      }\n\n      var addedGlobalNamedExpressions = [];\n      var vertex = this.addressMapping.fetchCell(targetAddress);\n\n      var _iterator15 = _createForOfIteratorHelper(absolutizeDependencies(dependencies, targetAddress)),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var namedExpressionDependency = _step15.value;\n\n          if (!(namedExpressionDependency instanceof NamedExpressionDependency)) {\n            continue;\n          }\n\n          var expressionName = namedExpressionDependency.name;\n          var sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet);\n          var namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);\n          var targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet) : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);\n\n          if (targetScopeExpressionVertex !== sourceVertex) {\n            this.dependencyGraph.graph.softRemoveEdge(sourceVertex, vertex);\n            this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);\n          }\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      return addedGlobalNamedExpressions;\n    }\n  }, {\n    key: \"allocateNamedExpressionAddressSpace\",\n    value: function allocateNamedExpressionAddressSpace() {\n      this.dependencyGraph.addressMapping.addSheet(-1, new SparseStrategy(0, 0));\n    }\n  }, {\n    key: \"copyOrFetchGlobalNamedExpressionVertex\",\n    value: function copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {\n      var expression = this.namedExpressions.namedExpressionForScope(expressionName);\n\n      if (expression === undefined) {\n        expression = this.namedExpressions.addNamedExpression(expressionName);\n        addedNamedExpressions.push(expression.normalizeExpressionName());\n\n        if (sourceVertex instanceof FormulaCellVertex) {\n          var parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));\n          var ast = parsingResult.ast,\n              hasVolatileFunction = parsingResult.hasVolatileFunction,\n              hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,\n              dependencies = parsingResult.dependencies;\n          this.dependencyGraph.setFormulaToCell(expression.address, ast, absolutizeDependencies(dependencies, expression.address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n        } else if (sourceVertex instanceof EmptyCellVertex) {\n          this.setCellEmpty(expression.address);\n        } else if (sourceVertex instanceof ValueCellVertex) {\n          this.setValueToCell(sourceVertex.getValues(), expression.address);\n        }\n      }\n\n      return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address);\n    }\n  }, {\n    key: \"addressMapping\",\n    get: function get() {\n      return this.dependencyGraph.addressMapping;\n    }\n  }]);\n\n  return Operations;\n}();\nexport function normalizeRemovedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n\n  var sorted = _toConsumableArray(indexes).sort(function (_ref6, _ref7) {\n    var _ref8 = _slicedToArray(_ref6, 1),\n        a = _ref8[0];\n\n    var _ref9 = _slicedToArray(_ref7, 1),\n        b = _ref9[0];\n\n    return a - b;\n  });\n  /* merge overlapping and adjacent indexes */\n\n\n  var merged = sorted.reduce(function (acc, _ref10) {\n    var _ref11 = _slicedToArray(_ref10, 2),\n        startIndex = _ref11[0],\n        amount = _ref11[1];\n\n    var previous = acc[acc.length - 1];\n    var lastIndex = previous[0] + previous[1];\n\n    if (startIndex <= lastIndex) {\n      previous[1] += Math.max(0, amount - (lastIndex - startIndex));\n    } else {\n      acc.push([startIndex, amount]);\n    }\n\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n\n  var shift = 0;\n\n  for (var i = 0; i < merged.length; ++i) {\n    merged[i][0] -= shift;\n    shift += merged[i][1];\n  }\n\n  return merged;\n}\nexport function normalizeAddedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n\n  var sorted = _toConsumableArray(indexes).sort(function (_ref12, _ref13) {\n    var _ref14 = _slicedToArray(_ref12, 1),\n        a = _ref14[0];\n\n    var _ref15 = _slicedToArray(_ref13, 1),\n        b = _ref15[0];\n\n    return a - b;\n  });\n  /* merge indexes with same start */\n\n\n  var merged = sorted.reduce(function (acc, _ref16) {\n    var _ref17 = _slicedToArray(_ref16, 2),\n        startIndex = _ref17[0],\n        amount = _ref17[1];\n\n    var previous = acc[acc.length - 1];\n\n    if (startIndex === previous[0]) {\n      previous[1] = Math.max(previous[1], amount);\n    } else {\n      acc.push([startIndex, amount]);\n    }\n\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n\n  var shift = 0;\n\n  for (var i = 0; i < merged.length; ++i) {\n    merged[i][0] += shift;\n    shift += merged[i][1];\n  }\n\n  return merged;\n}\n\nfunction isPositiveInteger(x) {\n  return Number.isInteger(x) && x > 0;\n}\n\nfunction isRowOrColumnRange(leftCorner, width, height) {\n  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;\n}"]},"metadata":{},"sourceType":"module"}