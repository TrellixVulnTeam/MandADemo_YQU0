{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { absolutizeDependencies } from './absolutizeDependencies';\nimport { ArraySize } from './ArraySize';\nimport { simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { getRawValue } from './interpreter/InterpreterValue';\nimport { StatType } from './statistics';\n/**\n * Service building the graph and mappings.\n */\n\nexport var GraphBuilder = /*#__PURE__*/function () {\n  /**\n   * Configures the building service.\n   */\n  function GraphBuilder(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor) {\n    _classCallCheck(this, GraphBuilder);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.stats = stats;\n    this.arraySizePredictor = arraySizePredictor;\n    this.buildStrategy = new SimpleStrategy(dependencyGraph, columnSearch, parser, stats, cellContentParser, arraySizePredictor);\n  }\n  /**\n   * Builds graph.\n   */\n\n\n  _createClass(GraphBuilder, [{\n    key: \"buildGraph\",\n    value: function buildGraph(sheets, stats) {\n      var _this = this;\n\n      var dependencies = stats.measure(StatType.COLLECT_DEPENDENCIES, function () {\n        return _this.buildStrategy.run(sheets);\n      });\n      this.dependencyGraph.getAndClearContentChanges();\n      stats.measure(StatType.PROCESS_DEPENDENCIES, function () {\n        return _this.processDependencies(dependencies);\n      });\n    }\n  }, {\n    key: \"processDependencies\",\n    value: function processDependencies(dependencies) {\n      var _this2 = this;\n\n      dependencies.forEach(function (cellDependencies, endVertex) {\n        _this2.dependencyGraph.processCellDependencies(cellDependencies, endVertex);\n      });\n    }\n  }]);\n\n  return GraphBuilder;\n}();\nexport var SimpleStrategy = /*#__PURE__*/function () {\n  function SimpleStrategy(dependencyGraph, columnIndex, parser, stats, cellContentParser, arraySizePredictor) {\n    _classCallCheck(this, SimpleStrategy);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnIndex = columnIndex;\n    this.parser = parser;\n    this.stats = stats;\n    this.cellContentParser = cellContentParser;\n    this.arraySizePredictor = arraySizePredictor;\n  }\n\n  _createClass(SimpleStrategy, [{\n    key: \"run\",\n    value: function run(sheets) {\n      var _this3 = this;\n\n      var dependencies = new Map();\n\n      for (var sheetName in sheets) {\n        var sheetId = this.dependencyGraph.getSheetId(sheetName);\n        var sheet = sheets[sheetName];\n\n        for (var i = 0; i < sheet.length; ++i) {\n          var row = sheet[i];\n\n          var _loop = function _loop(j) {\n            var cellContent = row[j];\n            var address = simpleCellAddress(sheetId, j, i);\n\n            var parsedCellContent = _this3.cellContentParser.parse(cellContent);\n\n            if (parsedCellContent instanceof CellContent.Formula) {\n              var parseResult = _this3.stats.measure(StatType.PARSER, function () {\n                return _this3.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (parseResult.errors.length > 0) {\n                _this3.shrinkArrayIfNeeded(address);\n\n                var vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formula);\n\n                _this3.dependencyGraph.addVertex(address, vertex);\n              } else {\n                _this3.shrinkArrayIfNeeded(address);\n\n                var size = _this3.arraySizePredictor.checkArraySize(parseResult.ast, address);\n\n                if (size.isScalar()) {\n                  var _vertex = new FormulaCellVertex(parseResult.ast, address, 0);\n\n                  dependencies.set(_vertex, absolutizeDependencies(parseResult.dependencies, address));\n\n                  _this3.dependencyGraph.addVertex(address, _vertex);\n\n                  if (parseResult.hasVolatileFunction) {\n                    _this3.dependencyGraph.markAsVolatile(_vertex);\n                  }\n\n                  if (parseResult.hasStructuralChangeFunction) {\n                    _this3.dependencyGraph.markAsDependentOnStructureChange(_vertex);\n                  }\n                } else {\n                  var _vertex2 = new ArrayVertex(parseResult.ast, address, new ArraySize(size.width, size.height));\n\n                  dependencies.set(_vertex2, absolutizeDependencies(parseResult.dependencies, address));\n\n                  _this3.dependencyGraph.addArrayVertex(address, _vertex2);\n                }\n              }\n            } else if (parsedCellContent instanceof CellContent.Empty) {\n              /* we don't care about empty cells here */\n            } else {\n              _this3.shrinkArrayIfNeeded(address);\n\n              var _vertex3 = new ValueCellVertex(parsedCellContent.value, cellContent);\n\n              _this3.columnIndex.add(getRawValue(parsedCellContent.value), address);\n\n              _this3.dependencyGraph.addVertex(address, _vertex3);\n            }\n          };\n\n          for (var j = 0; j < row.length; ++j) {\n            _loop(j);\n          }\n        }\n      }\n\n      return dependencies;\n    }\n  }, {\n    key: \"shrinkArrayIfNeeded\",\n    value: function shrinkArrayIfNeeded(address) {\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex instanceof ArrayVertex) {\n        this.dependencyGraph.shrinkArrayToCorner(vertex);\n      }\n    }\n  }]);\n\n  return SimpleStrategy;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/GraphBuilder.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","absolutizeDependencies","ArraySize","simpleCellAddress","CellContent","ArrayVertex","FormulaCellVertex","ParsingErrorVertex","ValueCellVertex","getRawValue","StatType","GraphBuilder","dependencyGraph","columnSearch","parser","cellContentParser","stats","arraySizePredictor","buildStrategy","SimpleStrategy","value","buildGraph","sheets","_this","dependencies","measure","COLLECT_DEPENDENCIES","run","getAndClearContentChanges","PROCESS_DEPENDENCIES","processDependencies","_this2","forEach","cellDependencies","endVertex","processCellDependencies","columnIndex","_this3","Map","sheetName","sheetId","getSheetId","sheet","row","_loop","j","cellContent","address","parsedCellContent","parse","Formula","parseResult","PARSER","formula","errors","shrinkArrayIfNeeded","vertex","addVertex","size","checkArraySize","ast","isScalar","_vertex","set","hasVolatileFunction","markAsVolatile","hasStructuralChangeFunction","markAsDependentOnStructureChange","_vertex2","width","height","addArrayVertex","Empty","_vertex3","add","getCell","shrinkArrayToCorner"],"mappings":"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","sourcesContent":["import \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { absolutizeDependencies } from './absolutizeDependencies';\nimport { ArraySize } from './ArraySize';\nimport { simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { getRawValue } from './interpreter/InterpreterValue';\nimport { StatType } from './statistics';\n/**\n * Service building the graph and mappings.\n */\n\nexport var GraphBuilder = /*#__PURE__*/function () {\n  /**\n   * Configures the building service.\n   */\n  function GraphBuilder(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor) {\n    _classCallCheck(this, GraphBuilder);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.stats = stats;\n    this.arraySizePredictor = arraySizePredictor;\n    this.buildStrategy = new SimpleStrategy(dependencyGraph, columnSearch, parser, stats, cellContentParser, arraySizePredictor);\n  }\n  /**\n   * Builds graph.\n   */\n\n\n  _createClass(GraphBuilder, [{\n    key: \"buildGraph\",\n    value: function buildGraph(sheets, stats) {\n      var _this = this;\n\n      var dependencies = stats.measure(StatType.COLLECT_DEPENDENCIES, function () {\n        return _this.buildStrategy.run(sheets);\n      });\n      this.dependencyGraph.getAndClearContentChanges();\n      stats.measure(StatType.PROCESS_DEPENDENCIES, function () {\n        return _this.processDependencies(dependencies);\n      });\n    }\n  }, {\n    key: \"processDependencies\",\n    value: function processDependencies(dependencies) {\n      var _this2 = this;\n\n      dependencies.forEach(function (cellDependencies, endVertex) {\n        _this2.dependencyGraph.processCellDependencies(cellDependencies, endVertex);\n      });\n    }\n  }]);\n\n  return GraphBuilder;\n}();\nexport var SimpleStrategy = /*#__PURE__*/function () {\n  function SimpleStrategy(dependencyGraph, columnIndex, parser, stats, cellContentParser, arraySizePredictor) {\n    _classCallCheck(this, SimpleStrategy);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnIndex = columnIndex;\n    this.parser = parser;\n    this.stats = stats;\n    this.cellContentParser = cellContentParser;\n    this.arraySizePredictor = arraySizePredictor;\n  }\n\n  _createClass(SimpleStrategy, [{\n    key: \"run\",\n    value: function run(sheets) {\n      var _this3 = this;\n\n      var dependencies = new Map();\n\n      for (var sheetName in sheets) {\n        var sheetId = this.dependencyGraph.getSheetId(sheetName);\n        var sheet = sheets[sheetName];\n\n        for (var i = 0; i < sheet.length; ++i) {\n          var row = sheet[i];\n\n          var _loop = function _loop(j) {\n            var cellContent = row[j];\n            var address = simpleCellAddress(sheetId, j, i);\n\n            var parsedCellContent = _this3.cellContentParser.parse(cellContent);\n\n            if (parsedCellContent instanceof CellContent.Formula) {\n              var parseResult = _this3.stats.measure(StatType.PARSER, function () {\n                return _this3.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (parseResult.errors.length > 0) {\n                _this3.shrinkArrayIfNeeded(address);\n\n                var vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formula);\n\n                _this3.dependencyGraph.addVertex(address, vertex);\n              } else {\n                _this3.shrinkArrayIfNeeded(address);\n\n                var size = _this3.arraySizePredictor.checkArraySize(parseResult.ast, address);\n\n                if (size.isScalar()) {\n                  var _vertex = new FormulaCellVertex(parseResult.ast, address, 0);\n\n                  dependencies.set(_vertex, absolutizeDependencies(parseResult.dependencies, address));\n\n                  _this3.dependencyGraph.addVertex(address, _vertex);\n\n                  if (parseResult.hasVolatileFunction) {\n                    _this3.dependencyGraph.markAsVolatile(_vertex);\n                  }\n\n                  if (parseResult.hasStructuralChangeFunction) {\n                    _this3.dependencyGraph.markAsDependentOnStructureChange(_vertex);\n                  }\n                } else {\n                  var _vertex2 = new ArrayVertex(parseResult.ast, address, new ArraySize(size.width, size.height));\n\n                  dependencies.set(_vertex2, absolutizeDependencies(parseResult.dependencies, address));\n\n                  _this3.dependencyGraph.addArrayVertex(address, _vertex2);\n                }\n              }\n            } else if (parsedCellContent instanceof CellContent.Empty) {\n              /* we don't care about empty cells here */\n            } else {\n              _this3.shrinkArrayIfNeeded(address);\n\n              var _vertex3 = new ValueCellVertex(parsedCellContent.value, cellContent);\n\n              _this3.columnIndex.add(getRawValue(parsedCellContent.value), address);\n\n              _this3.dependencyGraph.addVertex(address, _vertex3);\n            }\n          };\n\n          for (var j = 0; j < row.length; ++j) {\n            _loop(j);\n          }\n        }\n      }\n\n      return dependencies;\n    }\n  }, {\n    key: \"shrinkArrayIfNeeded\",\n    value: function shrinkArrayIfNeeded(address) {\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex instanceof ArrayVertex) {\n        this.dependencyGraph.shrinkArrayToCorner(vertex);\n      }\n    }\n  }]);\n\n  return SimpleStrategy;\n}();"]},"metadata":{},"sourceType":"module"}