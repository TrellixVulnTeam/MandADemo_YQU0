{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { CellError, ErrorType, simpleCellAddress } from './Cell';\nimport { DetailedCellError } from './CellValue';\nimport { ErrorMessage } from './error-message';\nimport { EmptyValue, getRawValue, isExtendedNumber } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './interpreter/SimpleRangeValue';\nimport { NamedExpressions } from './NamedExpressions';\nimport { simpleCellAddressToString } from './parser/addressRepresentationConverters';\n/**\n * A list of cells which values changed after the operation, their absolute addresses and new values.\n */\n\nexport var ExportedCellChange = /*#__PURE__*/function () {\n  function ExportedCellChange(address, newValue) {\n    _classCallCheck(this, ExportedCellChange);\n\n    this.address = address;\n    this.newValue = newValue;\n  }\n\n  _createClass(ExportedCellChange, [{\n    key: \"col\",\n    get: function get() {\n      return this.address.col;\n    }\n  }, {\n    key: \"row\",\n    get: function get() {\n      return this.address.row;\n    }\n  }, {\n    key: \"sheet\",\n    get: function get() {\n      return this.address.sheet;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.newValue;\n    }\n  }]);\n\n  return ExportedCellChange;\n}();\nexport var ExportedNamedExpressionChange = function ExportedNamedExpressionChange(name, newValue) {\n  _classCallCheck(this, ExportedNamedExpressionChange);\n\n  this.name = name;\n  this.newValue = newValue;\n};\nexport var Exporter = /*#__PURE__*/function () {\n  function Exporter(config, namedExpressions, sheetIndexMapping) {\n    _classCallCheck(this, Exporter);\n\n    this.config = config;\n    this.namedExpressions = namedExpressions;\n    this.sheetIndexMapping = sheetIndexMapping;\n  }\n\n  _createClass(Exporter, [{\n    key: \"exportChange\",\n    value: function exportChange(change) {\n      if (change.sheet === NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {\n        var namedExpression = this.namedExpressions.namedExpressionInAddress(change.row);\n\n        if (!namedExpression) {\n          throw 'Missing named expression';\n        }\n\n        return new ExportedNamedExpressionChange(namedExpression.displayName, this.exportValue(change.value));\n      } else {\n        return new ExportedCellChange(simpleCellAddress(change.sheet, change.col, change.row), this.exportValue(change.value));\n      }\n    }\n  }, {\n    key: \"exportValue\",\n    value: function exportValue(value) {\n      if (value instanceof SimpleRangeValue) {\n        return this.detailedError(new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected));\n      } else if (this.config.smartRounding && isExtendedNumber(value)) {\n        return this.cellValueRounding(getRawValue(value));\n      } else if (value instanceof CellError) {\n        return this.detailedError(value);\n      } else if (value === EmptyValue) {\n        return null;\n      } else {\n        return getRawValue(value);\n      }\n    }\n  }, {\n    key: \"detailedError\",\n    value: function detailedError(error) {\n      var _a;\n\n      var address = undefined;\n      var originAddress = error.address;\n\n      if (originAddress !== undefined) {\n        if (originAddress.sheet === NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {\n          address = (_a = this.namedExpressions.namedExpressionInAddress(originAddress.row)) === null || _a === void 0 ? void 0 : _a.displayName;\n        } else {\n          address = simpleCellAddressToString(this.sheetIndexMapping, originAddress, -1);\n        }\n      }\n\n      return new DetailedCellError(error, this.config.translationPackage.getErrorTranslation(error.type), address);\n    }\n  }, {\n    key: \"cellValueRounding\",\n    value: function cellValueRounding(value) {\n      if (value === 0) {\n        return value;\n      }\n\n      var magnitudeMultiplierExponent = Math.floor(Math.log10(Math.abs(value)));\n      var placesMultiplier = Math.pow(10, this.config.precisionRounding - magnitudeMultiplierExponent);\n\n      if (value < 0) {\n        return -Math.round(-value * placesMultiplier) / placesMultiplier;\n      } else {\n        return Math.round(value * placesMultiplier) / placesMultiplier;\n      }\n    }\n  }]);\n\n  return Exporter;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/Exporter.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellError","ErrorType","simpleCellAddress","DetailedCellError","ErrorMessage","EmptyValue","getRawValue","isExtendedNumber","SimpleRangeValue","NamedExpressions","simpleCellAddressToString","ExportedCellChange","address","newValue","get","col","row","sheet","ExportedNamedExpressionChange","name","Exporter","config","namedExpressions","sheetIndexMapping","value","exportChange","change","SHEET_FOR_WORKBOOK_EXPRESSIONS","namedExpression","namedExpressionInAddress","displayName","exportValue","detailedError","VALUE","ScalarExpected","smartRounding","cellValueRounding","error","_a","undefined","originAddress","translationPackage","getErrorTranslation","type","magnitudeMultiplierExponent","Math","floor","log10","abs","placesMultiplier","pow","precisionRounding","round"],"mappings":"AAGA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;AAEvN;AACA;AACA;AACA;;;AACA,SAASkB,SAAT,EAAoBC,SAApB,EAA+BC,iBAA/B,QAAwD,QAAxD;AACA,SAASC,iBAAT,QAAkC,aAAlC;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA,SAASC,UAAT,EAAqBC,WAArB,EAAkCC,gBAAlC,QAA0D,gCAA1D;AACA,SAASC,gBAAT,QAAiC,gCAAjC;AACA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,yBAAT,QAA0C,0CAA1C;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,kBAAkB,GAAG,aAAa,YAAY;AACvD,WAASA,kBAAT,CAA4BC,OAA5B,EAAqCC,QAArC,EAA+C;AAC7CjC,IAAAA,eAAe,CAAC,IAAD,EAAO+B,kBAAP,CAAf;;AAEA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACD;;AAEDjB,EAAAA,YAAY,CAACe,kBAAD,EAAqB,CAAC;AAChChB,IAAAA,GAAG,EAAE,KAD2B;AAEhCmB,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKF,OAAL,CAAaG,GAApB;AACD;AAJ+B,GAAD,EAK9B;AACDpB,IAAAA,GAAG,EAAE,KADJ;AAEDmB,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKF,OAAL,CAAaI,GAApB;AACD;AAJA,GAL8B,EAU9B;AACDrB,IAAAA,GAAG,EAAE,OADJ;AAEDmB,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKF,OAAL,CAAaK,KAApB;AACD;AAJA,GAV8B,EAe9B;AACDtB,IAAAA,GAAG,EAAE,OADJ;AAEDmB,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKD,QAAZ;AACD;AAJA,GAf8B,CAArB,CAAZ;;AAsBA,SAAOF,kBAAP;AACD,CA/B4C,EAAtC;AAgCP,OAAO,IAAIO,6BAA6B,GAAG,SAASA,6BAAT,CAAuCC,IAAvC,EAA6CN,QAA7C,EAAuD;AAChGjC,EAAAA,eAAe,CAAC,IAAD,EAAOsC,6BAAP,CAAf;;AAEA,OAAKC,IAAL,GAAYA,IAAZ;AACA,OAAKN,QAAL,GAAgBA,QAAhB;AACD,CALM;AAMP,OAAO,IAAIO,QAAQ,GAAG,aAAa,YAAY;AAC7C,WAASA,QAAT,CAAkBC,MAAlB,EAA0BC,gBAA1B,EAA4CC,iBAA5C,EAA+D;AAC7D3C,IAAAA,eAAe,CAAC,IAAD,EAAOwC,QAAP,CAAf;;AAEA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACD;;AAED3B,EAAAA,YAAY,CAACwB,QAAD,EAAW,CAAC;AACtBzB,IAAAA,GAAG,EAAE,cADiB;AAEtB6B,IAAAA,KAAK,EAAE,SAASC,YAAT,CAAsBC,MAAtB,EAA8B;AACnC,UAAIA,MAAM,CAACT,KAAP,KAAiBR,gBAAgB,CAACkB,8BAAtC,EAAsE;AACpE,YAAIC,eAAe,GAAG,KAAKN,gBAAL,CAAsBO,wBAAtB,CAA+CH,MAAM,CAACV,GAAtD,CAAtB;;AAEA,YAAI,CAACY,eAAL,EAAsB;AACpB,gBAAM,0BAAN;AACD;;AAED,eAAO,IAAIV,6BAAJ,CAAkCU,eAAe,CAACE,WAAlD,EAA+D,KAAKC,WAAL,CAAiBL,MAAM,CAACF,KAAxB,CAA/D,CAAP;AACD,OARD,MAQO;AACL,eAAO,IAAIb,kBAAJ,CAAuBT,iBAAiB,CAACwB,MAAM,CAACT,KAAR,EAAeS,MAAM,CAACX,GAAtB,EAA2BW,MAAM,CAACV,GAAlC,CAAxC,EAAgF,KAAKe,WAAL,CAAiBL,MAAM,CAACF,KAAxB,CAAhF,CAAP;AACD;AACF;AAdqB,GAAD,EAepB;AACD7B,IAAAA,GAAG,EAAE,aADJ;AAED6B,IAAAA,KAAK,EAAE,SAASO,WAAT,CAAqBP,KAArB,EAA4B;AACjC,UAAIA,KAAK,YAAYhB,gBAArB,EAAuC;AACrC,eAAO,KAAKwB,aAAL,CAAmB,IAAIhC,SAAJ,CAAcC,SAAS,CAACgC,KAAxB,EAA+B7B,YAAY,CAAC8B,cAA5C,CAAnB,CAAP;AACD,OAFD,MAEO,IAAI,KAAKb,MAAL,CAAYc,aAAZ,IAA6B5B,gBAAgB,CAACiB,KAAD,CAAjD,EAA0D;AAC/D,eAAO,KAAKY,iBAAL,CAAuB9B,WAAW,CAACkB,KAAD,CAAlC,CAAP;AACD,OAFM,MAEA,IAAIA,KAAK,YAAYxB,SAArB,EAAgC;AACrC,eAAO,KAAKgC,aAAL,CAAmBR,KAAnB,CAAP;AACD,OAFM,MAEA,IAAIA,KAAK,KAAKnB,UAAd,EAA0B;AAC/B,eAAO,IAAP;AACD,OAFM,MAEA;AACL,eAAOC,WAAW,CAACkB,KAAD,CAAlB;AACD;AACF;AAdA,GAfoB,EA8BpB;AACD7B,IAAAA,GAAG,EAAE,eADJ;AAED6B,IAAAA,KAAK,EAAE,SAASQ,aAAT,CAAuBK,KAAvB,EAA8B;AACnC,UAAIC,EAAJ;;AAEA,UAAI1B,OAAO,GAAG2B,SAAd;AACA,UAAIC,aAAa,GAAGH,KAAK,CAACzB,OAA1B;;AAEA,UAAI4B,aAAa,KAAKD,SAAtB,EAAiC;AAC/B,YAAIC,aAAa,CAACvB,KAAd,KAAwBR,gBAAgB,CAACkB,8BAA7C,EAA6E;AAC3Ef,UAAAA,OAAO,GAAG,CAAC0B,EAAE,GAAG,KAAKhB,gBAAL,CAAsBO,wBAAtB,CAA+CW,aAAa,CAACxB,GAA7D,CAAN,MAA6E,IAA7E,IAAqFsB,EAAE,KAAK,KAAK,CAAjG,GAAqG,KAAK,CAA1G,GAA8GA,EAAE,CAACR,WAA3H;AACD,SAFD,MAEO;AACLlB,UAAAA,OAAO,GAAGF,yBAAyB,CAAC,KAAKa,iBAAN,EAAyBiB,aAAzB,EAAwC,CAAC,CAAzC,CAAnC;AACD;AACF;;AAED,aAAO,IAAIrC,iBAAJ,CAAsBkC,KAAtB,EAA6B,KAAKhB,MAAL,CAAYoB,kBAAZ,CAA+BC,mBAA/B,CAAmDL,KAAK,CAACM,IAAzD,CAA7B,EAA6F/B,OAA7F,CAAP;AACD;AAjBA,GA9BoB,EAgDpB;AACDjB,IAAAA,GAAG,EAAE,mBADJ;AAED6B,IAAAA,KAAK,EAAE,SAASY,iBAAT,CAA2BZ,KAA3B,EAAkC;AACvC,UAAIA,KAAK,KAAK,CAAd,EAAiB;AACf,eAAOA,KAAP;AACD;;AAED,UAAIoB,2BAA2B,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,KAAL,CAAWF,IAAI,CAACG,GAAL,CAASxB,KAAT,CAAX,CAAX,CAAlC;AACA,UAAIyB,gBAAgB,GAAGJ,IAAI,CAACK,GAAL,CAAS,EAAT,EAAa,KAAK7B,MAAL,CAAY8B,iBAAZ,GAAgCP,2BAA7C,CAAvB;;AAEA,UAAIpB,KAAK,GAAG,CAAZ,EAAe;AACb,eAAO,CAACqB,IAAI,CAACO,KAAL,CAAW,CAAC5B,KAAD,GAASyB,gBAApB,CAAD,GAAyCA,gBAAhD;AACD,OAFD,MAEO;AACL,eAAOJ,IAAI,CAACO,KAAL,CAAW5B,KAAK,GAAGyB,gBAAnB,IAAuCA,gBAA9C;AACD;AACF;AAfA,GAhDoB,CAAX,CAAZ;;AAkEA,SAAO7B,QAAP;AACD,CA5EkC,EAA5B","sourcesContent":["import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.math.log10.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { CellError, ErrorType, simpleCellAddress } from './Cell';\nimport { DetailedCellError } from './CellValue';\nimport { ErrorMessage } from './error-message';\nimport { EmptyValue, getRawValue, isExtendedNumber } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './interpreter/SimpleRangeValue';\nimport { NamedExpressions } from './NamedExpressions';\nimport { simpleCellAddressToString } from './parser/addressRepresentationConverters';\n/**\n * A list of cells which values changed after the operation, their absolute addresses and new values.\n */\n\nexport var ExportedCellChange = /*#__PURE__*/function () {\n  function ExportedCellChange(address, newValue) {\n    _classCallCheck(this, ExportedCellChange);\n\n    this.address = address;\n    this.newValue = newValue;\n  }\n\n  _createClass(ExportedCellChange, [{\n    key: \"col\",\n    get: function get() {\n      return this.address.col;\n    }\n  }, {\n    key: \"row\",\n    get: function get() {\n      return this.address.row;\n    }\n  }, {\n    key: \"sheet\",\n    get: function get() {\n      return this.address.sheet;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.newValue;\n    }\n  }]);\n\n  return ExportedCellChange;\n}();\nexport var ExportedNamedExpressionChange = function ExportedNamedExpressionChange(name, newValue) {\n  _classCallCheck(this, ExportedNamedExpressionChange);\n\n  this.name = name;\n  this.newValue = newValue;\n};\nexport var Exporter = /*#__PURE__*/function () {\n  function Exporter(config, namedExpressions, sheetIndexMapping) {\n    _classCallCheck(this, Exporter);\n\n    this.config = config;\n    this.namedExpressions = namedExpressions;\n    this.sheetIndexMapping = sheetIndexMapping;\n  }\n\n  _createClass(Exporter, [{\n    key: \"exportChange\",\n    value: function exportChange(change) {\n      if (change.sheet === NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {\n        var namedExpression = this.namedExpressions.namedExpressionInAddress(change.row);\n\n        if (!namedExpression) {\n          throw 'Missing named expression';\n        }\n\n        return new ExportedNamedExpressionChange(namedExpression.displayName, this.exportValue(change.value));\n      } else {\n        return new ExportedCellChange(simpleCellAddress(change.sheet, change.col, change.row), this.exportValue(change.value));\n      }\n    }\n  }, {\n    key: \"exportValue\",\n    value: function exportValue(value) {\n      if (value instanceof SimpleRangeValue) {\n        return this.detailedError(new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected));\n      } else if (this.config.smartRounding && isExtendedNumber(value)) {\n        return this.cellValueRounding(getRawValue(value));\n      } else if (value instanceof CellError) {\n        return this.detailedError(value);\n      } else if (value === EmptyValue) {\n        return null;\n      } else {\n        return getRawValue(value);\n      }\n    }\n  }, {\n    key: \"detailedError\",\n    value: function detailedError(error) {\n      var _a;\n\n      var address = undefined;\n      var originAddress = error.address;\n\n      if (originAddress !== undefined) {\n        if (originAddress.sheet === NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {\n          address = (_a = this.namedExpressions.namedExpressionInAddress(originAddress.row)) === null || _a === void 0 ? void 0 : _a.displayName;\n        } else {\n          address = simpleCellAddressToString(this.sheetIndexMapping, originAddress, -1);\n        }\n      }\n\n      return new DetailedCellError(error, this.config.translationPackage.getErrorTranslation(error.type), address);\n    }\n  }, {\n    key: \"cellValueRounding\",\n    value: function cellValueRounding(value) {\n      if (value === 0) {\n        return value;\n      }\n\n      var magnitudeMultiplierExponent = Math.floor(Math.log10(Math.abs(value)));\n      var placesMultiplier = Math.pow(10, this.config.precisionRounding - magnitudeMultiplierExponent);\n\n      if (value < 0) {\n        return -Math.round(-value * placesMultiplier) / placesMultiplier;\n      } else {\n        return Math.round(value * placesMultiplier) / placesMultiplier;\n      }\n    }\n  }]);\n\n  return Exporter;\n}();"]},"metadata":{},"sourceType":"module"}