{"ast":null,"code":"import { createTokenInstance, EOF } from \"../../../scan/tokens_public\";\nimport { cloneArr, contains, dropRight, find, flatten, has, isEmpty, map } from \"../../../utils/utils\";\nimport { MismatchedTokenException } from \"../../exceptions_public\";\nimport { IN } from \"../../constants\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\nexport var EOF_FOLLOW_KEY = {};\nexport var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport function InRuleRecoveryException(message) {\n  this.name = IN_RULE_RECOVERY_EXCEPTION;\n  this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\n\nvar Recoverable = function () {\n  function Recoverable() {}\n\n  Recoverable.prototype.initRecoverable = function (config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = has(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled; // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  };\n\n  Recoverable.prototype.getTokenToInsert = function (tokType) {\n    var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  };\n\n  Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n    return true;\n  };\n\n  Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    var _this = this; // TODO: can the resyncTokenType be cached?\n\n\n    var reSyncTokType = this.findReSyncTokenType();\n    var savedLexerState = this.exportLexerState();\n    var resyncedTokens = [];\n    var passedResyncPoint = false;\n    var nextTokenWithoutResync = this.LA(1);\n    var currToken = this.LA(1);\n\n    var generateErrorMessage = function () {\n      var previousToken = _this.LA(0); // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n\n\n      var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: _this.getCurrRuleFullName()\n      });\n\n      var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0)); // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n\n      error.resyncedTokens = dropRight(resyncedTokens);\n\n      _this.SAVE_ERROR(error);\n    };\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return; // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage(); // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n\n        grammarRule.apply(this, grammarRuleArgs);\n        return; // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    } // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n\n\n    this.importLexerState(savedLexerState);\n  };\n\n  Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false;\n    } // arguments to try and perform resync into the next iteration of the many are missing\n\n\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n      return false;\n    } // no need to recover, next token is what we expect...\n\n\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    } // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n\n\n    if (this.isBackTracking()) {\n      return false;\n    } // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n\n\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n\n    return true;\n  }; // Error Recovery functionality\n\n\n  Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n    var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    var follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  };\n\n  Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      var tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      var nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  };\n\n  Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  };\n\n  Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n    var _this = this;\n\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    } // must know the possible following tokens to perform single token insertion\n\n\n    if (isEmpty(follows)) {\n      return false;\n    }\n\n    var mismatchedTok = this.LA(1);\n    var isMisMatchedTokInFollows = find(follows, function (possibleFollowsTokType) {\n      return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== undefined;\n    return isMisMatchedTokInFollows;\n  };\n\n  Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n    var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  };\n\n  Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n    var followKey = this.getCurrFollowKey();\n    var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return contains(currentRuleReSyncSet, tokenTypeIdx);\n  };\n\n  Recoverable.prototype.findReSyncTokenType = function () {\n    var allPossibleReSyncTokTypes = this.flattenFollowSet(); // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n\n    var nextToken = this.LA(1);\n    var k = 2;\n\n    while (true) {\n      var nextTokenType = nextToken.tokenType;\n\n      if (contains(allPossibleReSyncTokTypes, nextTokenType)) {\n        return nextTokenType;\n      }\n\n      nextToken = this.LA(k);\n      k++;\n    }\n  };\n\n  Recoverable.prototype.getCurrFollowKey = function () {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  };\n\n  Recoverable.prototype.buildFullFollowKeyStack = function () {\n    var _this = this;\n\n    var explicitRuleStack = this.RULE_STACK;\n    var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n\n    if (!isEmpty(this.LAST_EXPLICIT_RULE_STACK)) {\n      explicitRuleStack = map(this.LAST_EXPLICIT_RULE_STACK, function (idx) {\n        return _this.RULE_STACK[idx];\n      });\n      explicitOccurrenceStack = map(this.LAST_EXPLICIT_RULE_STACK, function (idx) {\n        return _this.RULE_OCCURRENCE_STACK[idx];\n      });\n    } // TODO: only iterate over explicit rules here\n\n\n    return map(explicitRuleStack, function (ruleName, idx) {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n\n      return {\n        ruleName: _this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  };\n\n  Recoverable.prototype.flattenFollowSet = function () {\n    var _this = this;\n\n    var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n      return _this.getFollowSetFromFollowKey(currKey);\n    });\n    return flatten(followStack);\n  };\n\n  Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n\n    var followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  }; // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n\n\n  Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n\n    return resyncTokens;\n  };\n\n  Recoverable.prototype.reSyncTo = function (tokType) {\n    var resyncedTokens = [];\n    var nextTok = this.LA(1);\n\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    } // the last token is not part of the error.\n\n\n    return dropRight(resyncedTokens);\n  };\n\n  Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {// by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  };\n\n  Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n    var pathRuleStack = this.getHumanReadableRuleStack();\n    var pathOccurrenceStack = cloneArr(this.RULE_OCCURRENCE_STACK);\n    var grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  };\n\n  Recoverable.prototype.getHumanReadableRuleStack = function () {\n    var _this = this;\n\n    if (!isEmpty(this.LAST_EXPLICIT_RULE_STACK)) {\n      return map(this.LAST_EXPLICIT_RULE_STACK, function (currIdx) {\n        return _this.shortRuleNameToFullName(_this.RULE_STACK[currIdx]);\n      });\n    } else {\n      return map(this.RULE_STACK, function (currShortName) {\n        return _this.shortRuleNameToFullName(currShortName);\n      });\n    }\n  };\n\n  return Recoverable;\n}();\n\nexport { Recoverable };\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  var firstAfterRepInfo = this.firstAfterRepMap[key];\n\n  if (firstAfterRepInfo === undefined) {\n    var currRuleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[currRuleName];\n    var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n\n  var expectTokAfterLastMatch = firstAfterRepInfo.token;\n  var nextTokIdx = firstAfterRepInfo.occurrence;\n  var isEndOfRule = firstAfterRepInfo.isEndOfRule; // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js"],"names":["createTokenInstance","EOF","cloneArr","contains","dropRight","find","flatten","has","isEmpty","map","MismatchedTokenException","IN","DEFAULT_PARSER_CONFIG","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","message","name","prototype","Error","Recoverable","initRecoverable","config","firstAfterRepMap","resyncFollows","recoveryEnabled","attemptInRepetitionRecovery","getTokenToInsert","tokType","tokToInsert","NaN","isInsertedInRecovery","canTokenTypeBeInsertedInRecovery","tryInRepetitionRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","_this","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","resyncedTokens","passedResyncPoint","nextTokenWithoutResync","LA","currToken","generateErrorMessage","previousToken","msg","errorMessageProvider","buildMismatchTokenMessage","expected","actual","previous","ruleName","getCurrRuleFullName","error","SAVE_ERROR","tokenMatcher","call","apply","SKIP_TOKEN","addToResyncTokens","importLexerState","shouldInRepetitionRecoveryBeTried","expectTokAfterLastMatch","nextTokIdx","notStuck","undefined","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","follows","getNextPossibleTokenTypes","tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","mismatchedTok","isMisMatchedTokInFollows","possibleFollowsTokType","isNextTokenWhatIsExpected","isInCurrentRuleReSyncSet","tokenTypeIdx","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","nextToken","k","nextTokenType","tokenType","RULE_STACK","length","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","buildFullFollowKeyStack","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","LAST_EXPLICIT_RULE_STACK","idx","followStack","currKey","followName","token","resyncTokens","push","reSyncTo","prodFunc","args","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","pathRuleStack","getHumanReadableRuleStack","pathOccurrenceStack","ruleStack","occurrenceStack","lastTok","lastTokOccurrence","currIdx","currShortName","key","getKeyForAutomaticLookahead","firstAfterRepInfo","currRuleName","ruleGrammar","getGAstProductions","walker","startWalking","occurrence","isEndOfRule"],"mappings":"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","sourcesContent":["import { createTokenInstance, EOF } from \"../../../scan/tokens_public\";\nimport { cloneArr, contains, dropRight, find, flatten, has, isEmpty, map } from \"../../../utils/utils\";\nimport { MismatchedTokenException } from \"../../exceptions_public\";\nimport { IN } from \"../../constants\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\nexport var EOF_FOLLOW_KEY = {};\nexport var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport function InRuleRecoveryException(message) {\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n    this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */ (function () {\n    function Recoverable() {\n    }\n    Recoverable.prototype.initRecoverable = function (config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = has(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled\n            : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    };\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\n        var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    };\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        var _this = this;\n        // TODO: can the resyncTokenType be cached?\n        var reSyncTokType = this.findReSyncTokenType();\n        var savedLexerState = this.exportLexerState();\n        var resyncedTokens = [];\n        var passedResyncPoint = false;\n        var nextTokenWithoutResync = this.LA(1);\n        var currToken = this.LA(1);\n        var generateErrorMessage = function () {\n            var previousToken = _this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: _this.getCurrRuleFullName()\n            });\n            var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = dropRight(resyncedTokens);\n            _this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    };\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // arguments to try and perform resync into the next iteration of the many are missing\n        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    };\n    // Error Recovery functionality\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    };\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    };\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n        var _this = this;\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (isEmpty(follows)) {\n            return false;\n        }\n        var mismatchedTok = this.LA(1);\n        var isMisMatchedTokInFollows = find(follows, function (possibleFollowsTokType) {\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    };\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n        var followKey = this.getCurrFollowKey();\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return contains(currentRuleReSyncSet, tokenTypeIdx);\n    };\n    Recoverable.prototype.findReSyncTokenType = function () {\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        var nextToken = this.LA(1);\n        var k = 2;\n        while (true) {\n            var nextTokenType = nextToken.tokenType;\n            if (contains(allPossibleReSyncTokTypes, nextTokenType)) {\n                return nextTokenType;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    };\n    Recoverable.prototype.getCurrFollowKey = function () {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    };\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\n        var _this = this;\n        var explicitRuleStack = this.RULE_STACK;\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        if (!isEmpty(this.LAST_EXPLICIT_RULE_STACK)) {\n            explicitRuleStack = map(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_STACK[idx]; });\n            explicitOccurrenceStack = map(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_OCCURRENCE_STACK[idx]; });\n        }\n        // TODO: only iterate over explicit rules here\n        return map(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: _this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    };\n    Recoverable.prototype.flattenFollowSet = function () {\n        var _this = this;\n        var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this.getFollowSetFromFollowKey(currKey);\n        });\n        return flatten(followStack);\n    };\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n        }\n        var followName = followKey.ruleName +\n            followKey.idxInCallingRule +\n            IN +\n            followKey.inRule;\n        return this.resyncFollows[followName];\n    };\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n        if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    };\n    Recoverable.prototype.reSyncTo = function (tokType) {\n        var resyncedTokens = [];\n        var nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return dropRight(resyncedTokens);\n    };\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    };\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n        var pathRuleStack = this.getHumanReadableRuleStack();\n        var pathOccurrenceStack = cloneArr(this.RULE_OCCURRENCE_STACK);\n        var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    };\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\n        var _this = this;\n        if (!isEmpty(this.LAST_EXPLICIT_RULE_STACK)) {\n            return map(this.LAST_EXPLICIT_RULE_STACK, function (currIdx) {\n                return _this.shortRuleNameToFullName(_this.RULE_STACK[currIdx]);\n            });\n        }\n        else {\n            return map(this.RULE_STACK, function (currShortName) {\n                return _this.shortRuleNameToFullName(currShortName);\n            });\n        }\n    };\n    return Recoverable;\n}());\nexport { Recoverable };\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\n    var nextTokIdx = firstAfterRepInfo.occurrence;\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map"]},"metadata":{},"sourceType":"module"}