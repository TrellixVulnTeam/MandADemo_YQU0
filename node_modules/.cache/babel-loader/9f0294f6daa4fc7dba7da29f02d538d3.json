{"ast":null,"code":"import { forEach, map } from \"../utils/utils\";\nimport { RepetitionMandatory, Option, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, NonTerminal, Alternation, Flat, Repetition } from \"../parse/grammar/gast/gast_public\";\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\n\nvar NL = \"\\n\";\nexport function genUmdModule(options) {\n  return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\" + genClass(options) + \"\\n    \\nreturn {\\n    \" + options.name + \": \" + options.name + \" \\n}\\n}));\\n\";\n}\nexport function genWrapperFunction(options) {\n  return \"    \\n\" + genClass(options) + \"\\nreturn new \" + options.name + \"(tokenVocabulary, config)    \\n\";\n}\nexport function genClass(options) {\n  // TODO: how to pass the token vocabulary? Constructor? other?\n  var result = \"\\nfunction \" + options.name + \"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \" + genAllRules(options.rules) + \"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\" + options.name + \".prototype = Object.create(chevrotain.CstParser.prototype)\\n\" + options.name + \".prototype.constructor = \" + options.name + \"    \\n    \";\n  return result;\n}\nexport function genAllRules(rules) {\n  var rulesText = map(rules, function (currRule) {\n    return genRule(currRule, 1);\n  });\n  return rulesText.join(\"\\n\");\n}\nexport function genRule(prod, n) {\n  var result = indent(n, \"$.RULE(\\\"\" + prod.name + \"\\\", function() {\") + NL;\n  result += genDefinition(prod.definition, n + 1);\n  result += indent(n + 1, \"})\") + NL;\n  return result;\n}\nexport function genTerminal(prod, n) {\n  var name = prod.terminalType.name; // TODO: potential performance optimization, avoid tokenMap Dictionary access\n\n  return indent(n, \"$.CONSUME\" + prod.idx + \"(this.tokensMap.\" + name + \")\" + NL);\n}\nexport function genNonTerminal(prod, n) {\n  return indent(n, \"$.SUBRULE\" + prod.idx + \"($.\" + prod.nonTerminalName + \")\" + NL);\n}\nexport function genAlternation(prod, n) {\n  var result = indent(n, \"$.OR\" + prod.idx + \"([\") + NL;\n  var alts = map(prod.definition, function (altDef) {\n    return genSingleAlt(altDef, n + 1);\n  });\n  result += alts.join(\",\" + NL);\n  result += NL + indent(n, \"])\" + NL);\n  return result;\n}\nexport function genSingleAlt(prod, n) {\n  var result = indent(n, \"{\") + NL;\n\n  if (prod.name) {\n    result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\",\") + NL;\n  }\n\n  result += indent(n + 1, \"ALT: function() {\") + NL;\n  result += genDefinition(prod.definition, n + 1);\n  result += indent(n + 1, \"}\") + NL;\n  result += indent(n, \"}\");\n  return result;\n}\n\nfunction genProd(prod, n) {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return genNonTerminal(prod, n);\n  } else if (prod instanceof Option) {\n    return genDSLRule(\"OPTION\", prod, n);\n  } else if (prod instanceof RepetitionMandatory) {\n    return genDSLRule(\"AT_LEAST_ONE\", prod, n);\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n);\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return genDSLRule(\"MANY_SEP\", prod, n);\n  } else if (prod instanceof Repetition) {\n    return genDSLRule(\"MANY\", prod, n);\n  } else if (prod instanceof Alternation) {\n    return genAlternation(prod, n);\n  } else if (prod instanceof Terminal) {\n    return genTerminal(prod, n);\n  } else if (prod instanceof Flat) {\n    return genDefinition(prod.definition, n);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction genDSLRule(dslName, prod, n) {\n  var result = indent(n, \"$.\" + (dslName + prod.idx) + \"(\");\n\n  if (prod.name || prod.separator) {\n    result += \"{\" + NL;\n\n    if (prod.name) {\n      result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\"\") + \",\" + NL;\n    }\n\n    if (prod.separator) {\n      result += indent(n + 1, \"SEP: this.tokensMap.\" + prod.separator.name) + \",\" + NL;\n    }\n\n    result += \"DEF: \" + genDefFunction(prod.definition, n + 2) + NL;\n    result += indent(n, \"}\") + NL;\n  } else {\n    result += genDefFunction(prod.definition, n + 1);\n  }\n\n  result += indent(n, \")\") + NL;\n  return result;\n}\n\nfunction genDefFunction(definition, n) {\n  var def = \"function() {\" + NL;\n  def += genDefinition(definition, n);\n  def += indent(n, \"}\") + NL;\n  return def;\n}\n\nfunction genDefinition(def, n) {\n  var result = \"\";\n  forEach(def, function (prod) {\n    result += genProd(prod, n + 1);\n  });\n  return result;\n}\n\nfunction indent(howMuch, text) {\n  var spaces = Array(howMuch * 4 + 1).join(\" \");\n  return spaces + text;\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/generate/generate.js"],"names":["forEach","map","RepetitionMandatory","Option","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","NonTerminal","Alternation","Flat","Repetition","NL","genUmdModule","options","genClass","name","genWrapperFunction","result","genAllRules","rules","rulesText","currRule","genRule","join","prod","n","indent","genDefinition","definition","genTerminal","terminalType","idx","genNonTerminal","nonTerminalName","genAlternation","alts","altDef","genSingleAlt","genProd","genDSLRule","Error","dslName","separator","genDefFunction","def","howMuch","text","spaces","Array"],"mappings":"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","sourcesContent":["import { forEach, map } from \"../utils/utils\";\nimport { RepetitionMandatory, Option, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, NonTerminal, Alternation, Flat, Repetition } from \"../parse/grammar/gast/gast_public\";\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\nvar NL = \"\\n\";\nexport function genUmdModule(options) {\n    return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\" + genClass(options) + \"\\n    \\nreturn {\\n    \" + options.name + \": \" + options.name + \" \\n}\\n}));\\n\";\n}\nexport function genWrapperFunction(options) {\n    return \"    \\n\" + genClass(options) + \"\\nreturn new \" + options.name + \"(tokenVocabulary, config)    \\n\";\n}\nexport function genClass(options) {\n    // TODO: how to pass the token vocabulary? Constructor? other?\n    var result = \"\\nfunction \" + options.name + \"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \" + genAllRules(options.rules) + \"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\" + options.name + \".prototype = Object.create(chevrotain.CstParser.prototype)\\n\" + options.name + \".prototype.constructor = \" + options.name + \"    \\n    \";\n    return result;\n}\nexport function genAllRules(rules) {\n    var rulesText = map(rules, function (currRule) {\n        return genRule(currRule, 1);\n    });\n    return rulesText.join(\"\\n\");\n}\nexport function genRule(prod, n) {\n    var result = indent(n, \"$.RULE(\\\"\" + prod.name + \"\\\", function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"})\") + NL;\n    return result;\n}\nexport function genTerminal(prod, n) {\n    var name = prod.terminalType.name;\n    // TODO: potential performance optimization, avoid tokenMap Dictionary access\n    return indent(n, \"$.CONSUME\" + prod.idx + \"(this.tokensMap.\" + name + \")\" + NL);\n}\nexport function genNonTerminal(prod, n) {\n    return indent(n, \"$.SUBRULE\" + prod.idx + \"($.\" + prod.nonTerminalName + \")\" + NL);\n}\nexport function genAlternation(prod, n) {\n    var result = indent(n, \"$.OR\" + prod.idx + \"([\") + NL;\n    var alts = map(prod.definition, function (altDef) { return genSingleAlt(altDef, n + 1); });\n    result += alts.join(\",\" + NL);\n    result += NL + indent(n, \"])\" + NL);\n    return result;\n}\nexport function genSingleAlt(prod, n) {\n    var result = indent(n, \"{\") + NL;\n    if (prod.name) {\n        result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\",\") + NL;\n    }\n    result += indent(n + 1, \"ALT: function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"}\") + NL;\n    result += indent(n, \"}\");\n    return result;\n}\nfunction genProd(prod, n) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        return genNonTerminal(prod, n);\n    }\n    else if (prod instanceof Option) {\n        return genDSLRule(\"OPTION\", prod, n);\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return genDSLRule(\"AT_LEAST_ONE\", prod, n);\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n);\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return genDSLRule(\"MANY_SEP\", prod, n);\n    }\n    else if (prod instanceof Repetition) {\n        return genDSLRule(\"MANY\", prod, n);\n    }\n    else if (prod instanceof Alternation) {\n        return genAlternation(prod, n);\n    }\n    else if (prod instanceof Terminal) {\n        return genTerminal(prod, n);\n    }\n    else if (prod instanceof Flat) {\n        return genDefinition(prod.definition, n);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction genDSLRule(dslName, prod, n) {\n    var result = indent(n, \"$.\" + (dslName + prod.idx) + \"(\");\n    if (prod.name || prod.separator) {\n        result += \"{\" + NL;\n        if (prod.name) {\n            result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\"\") + \",\" + NL;\n        }\n        if (prod.separator) {\n            result +=\n                indent(n + 1, \"SEP: this.tokensMap.\" + prod.separator.name) +\n                    \",\" +\n                    NL;\n        }\n        result += \"DEF: \" + genDefFunction(prod.definition, n + 2) + NL;\n        result += indent(n, \"}\") + NL;\n    }\n    else {\n        result += genDefFunction(prod.definition, n + 1);\n    }\n    result += indent(n, \")\") + NL;\n    return result;\n}\nfunction genDefFunction(definition, n) {\n    var def = \"function() {\" + NL;\n    def += genDefinition(definition, n);\n    def += indent(n, \"}\") + NL;\n    return def;\n}\nfunction genDefinition(def, n) {\n    var result = \"\";\n    forEach(def, function (prod) {\n        result += genProd(prod, n + 1);\n    });\n    return result;\n}\nfunction indent(howMuch, text) {\n    var spaces = Array(howMuch * 4 + 1).join(\" \");\n    return spaces + text;\n}\n//# sourceMappingURL=generate.js.map"]},"metadata":{},"sourceType":"module"}