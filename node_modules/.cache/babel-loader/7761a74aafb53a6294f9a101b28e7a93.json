{"ast":null,"code":"import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns } from \"./lexer\";\nimport { cloneArr, cloneObj, forEach, IDENTITY, isArray, isEmpty, isUndefined, keys, last, map, merge, NOOP, PRINT_WARNING, reduce, reject, timer, toFastProperties } from \"../utils/utils\";\nimport { augmentTokenTypes } from \"./tokens\";\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser\";\nexport var LexerDefinitionErrorType;\n\n(function (LexerDefinitionErrorType) {\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\n\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\n\nvar Lexer = function () {\n  function Lexer(lexerDefinition, config) {\n    var _this = this;\n\n    if (config === void 0) {\n      config = DEFAULT_LEXER_CONFIG;\n    }\n\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.config = undefined;\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" + \"a boolean 2nd argument is no longer supported\");\n    } // todo: defaults func?\n\n\n    this.config = merge(DEFAULT_LEXER_CONFIG, config);\n    var traceInitVal = this.config.traceInitPerf;\n\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", function () {\n      var actualDefinition;\n      var hasOnlySingleMode = true;\n\n      _this.TRACE_INIT(\"Lexer Config handling\", function () {\n        if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          _this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n\n        _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n        _this.trackEndLines = /full/i.test(_this.config.positionTracking); // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: {}\n          };\n          actualDefinition.modes[DEFAULT_MODE] = cloneArr(lexerDefinition);\n          actualDefinition[DEFAULT_MODE] = DEFAULT_MODE;\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = cloneObj(lexerDefinition);\n        }\n      });\n\n      if (_this.config.skipValidations === false) {\n        _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n          _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n\n        _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n          _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n      } // for extra robustness to avoid throwing an none informative error message\n\n\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {}; // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n\n      forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n        actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) {\n          return isUndefined(currTokType);\n        });\n      });\n      var allModeNames = keys(actualDefinition.modes);\n      forEach(actualDefinition.modes, function (currModDef, currModName) {\n        _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n          _this.modes.push(currModName);\n\n          if (_this.config.skipValidations === false) {\n            _this.TRACE_INIT(\"validatePatterns\", function () {\n              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n            });\n          } // If definition errors were encountered, the analysis phase may fail unexpectedly/\n          // Considering a lexer with definition errors may never be used, there is no point\n          // to performing the analysis anyhow...\n\n\n          if (isEmpty(_this.lexerDefinitionErrors)) {\n            augmentTokenTypes(currModDef);\n            var currAnalyzeResult_1;\n\n            _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n              currAnalyzeResult_1 = analyzeTokenTypes(currModDef, {\n                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: _this.TRACE_INIT.bind(_this)\n              });\n            });\n\n            _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;\n            _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n            _this.emptyGroups = merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n            _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n            _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;\n          }\n        });\n      });\n      _this.defaultMode = actualDefinition.defaultMode;\n\n      if (!isEmpty(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {\n        var allErrMessages = map(_this.lexerDefinitionErrors, function (error) {\n          return error.message;\n        });\n        var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      } // Only print warning if there are no errors, This will avoid pl\n\n\n      forEach(_this.lexerDefinitionWarning, function (warningDescriptor) {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n\n      _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          _this.chopInput = IDENTITY;\n          _this.match = _this.matchWithTest;\n        } else {\n          _this.updateLastIndex = NOOP;\n          _this.match = _this.matchWithExec;\n        }\n\n        if (hasOnlySingleMode) {\n          _this.handleModes = NOOP;\n        }\n\n        if (_this.trackStartLines === false) {\n          _this.computeNewColumn = IDENTITY;\n        }\n\n        if (_this.trackEndLines === false) {\n          _this.updateTokenEndLineColumnLocation = NOOP;\n        }\n\n        if (/full/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createFullToken;\n        } else if (/onlyStart/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createOffsetOnlyToken;\n        } else {\n          throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n        }\n\n        if (_this.hasCustom) {\n          _this.addToken = _this.addTokenUsingPush;\n          _this.handlePayload = _this.handlePayloadWithCustom;\n        } else {\n          _this.addToken = _this.addTokenUsingMemberAccess;\n          _this.handlePayload = _this.handlePayloadNoCustom;\n        }\n      });\n\n      _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n        var unOptimizedModes = reduce(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n\n          return cannotBeOptimized;\n        }, []);\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" + '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' + \"\\t Or inspect the console log for details on how to resolve these issues.\");\n        }\n      });\n\n      _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n        clearRegExpParserCache();\n      });\n\n      _this.TRACE_INIT(\"toFastProperties\", function () {\n        toFastProperties(_this);\n      });\n    });\n  }\n\n  Lexer.prototype.tokenize = function (text, initialMode) {\n    if (initialMode === void 0) {\n      initialMode = this.defaultMode;\n    }\n\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n        return error.message;\n      });\n      var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n\n    var lexResult = this.tokenizeInternal(text, initialMode);\n    return lexResult;\n  }; // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n\n\n  Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n    var _this = this;\n\n    var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    var orgText = text;\n    var orgLength = orgText.length;\n    var offset = 0;\n    var matchedTokensIndex = 0; // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n\n    var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n    : Math.floor(text.length / 10);\n    var matchedTokens = new Array(guessedNumberOfTokens);\n    var errors = [];\n    var line = this.trackStartLines ? 1 : undefined;\n    var column = this.trackStartLines ? 1 : undefined;\n    var groups = cloneEmptyGroups(this.emptyGroups);\n    var trackLines = this.trackStartLines;\n    var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    var currModePatternsLength = 0;\n    var patternIdxToConfig = [];\n    var currCharCodeToPatternIdxToConfig = [];\n    var modeStack = [];\n    var emptyArray = [];\n    Object.freeze(emptyArray);\n    var getPossiblePatterns = undefined;\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n\n    function getPossiblePatternsOptimized(charCode) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n\n    var pop_mode = function (popToken) {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === undefined) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine !== undefined ? popToken.startLine : undefined,\n          column: popToken.startColumn !== undefined ? popToken.startColumn : undefined,\n          length: popToken.image.length,\n          message: msg_1\n        });\n      } else {\n        modeStack.pop();\n        var newMode = last(modeStack);\n        patternIdxToConfig = _this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    } // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n\n\n    push_mode.call(this, initialMode);\n    var currConfig;\n\n    while (offset < orgLength) {\n      matchedImage = null;\n      var nextCharCode = orgText.charCodeAt(offset);\n      var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      var chosenPatternsLength = chosenPatternIdxToConfig.length;\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        var currPattern = currConfig.pattern;\n        payload = null; // manually in-lined because > 600 chars won't be in-lined in V8\n\n        var singleCharCode = currConfig.short;\n\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n\n          if (match !== null) {\n            matchedImage = match[0];\n\n            if (match.payload !== undefined) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAltIdx = currConfig.longerAlt;\n\n          if (longerAltIdx !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            var longerAltConfig = patternIdxToConfig[longerAltIdx];\n            var longerAltPattern = longerAltConfig.pattern;\n            altPayload = null; // single Char can never be a longer alt so no need to test it.\n            // manually in-lined because > 600 chars won't be in-lined in V8\n\n            if (longerAltConfig.isCustom === true) {\n              match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n\n              if (match !== null) {\n                matchAltImage = match[0];\n\n                if (match.payload !== undefined) {\n                  altPayload = match.payload;\n                }\n              } else {\n                matchAltImage = null;\n              }\n            } else {\n              this.updateLastIndex(longerAltPattern, offset);\n              matchAltImage = this.match(longerAltPattern, text, offset);\n            }\n\n            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n              matchedImage = matchAltImage;\n              payload = altPayload;\n              currConfig = longerAltConfig;\n            }\n          }\n\n          break;\n        }\n      } // successful match\n\n\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx; // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload); // TODO: optimize NOOP in case there are no special groups?\n\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength; // TODO: with newlines the column may be assigned twice\n\n        column = this.computeNewColumn(column, imageLength);\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          var numOfLTsInMatch = 0;\n          var foundTerminator = void 0;\n          var lastLTEndOffset = void 0;\n          lineTerminatorPattern.lastIndex = 0;\n\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        } // will be NOOP if no modes present\n\n\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        var errorStartOffset = offset;\n        var errorLine = line;\n        var errorColumn = column;\n        var foundResyncPoint = false;\n\n        while (!foundResyncPoint && offset < orgLength) {\n          // drop chars until we succeed in matching something\n          droppedChar = orgText.charCodeAt(offset); // Identity Func (when sticky flag is enabled)\n\n          text = this.chopInput(text, 1);\n          offset++;\n\n          for (j = 0; j < currModePatternsLength; j++) {\n            var currConfig_1 = patternIdxToConfig[j];\n            var currPattern = currConfig_1.pattern; // manually in-lined because > 600 chars won't be in-lined in V8\n\n            var singleCharCode = currConfig_1.short;\n\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig_1.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset; // at this point we either re-synced or reached the end of the input text\n\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n      }\n    } // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n\n\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    };\n  };\n\n  Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      var pushMode = config.push;\n      pop_mode(newToken);\n\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  };\n\n  Lexer.prototype.chopInput = function (text, length) {\n    return text.substring(length);\n  };\n\n  Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  }; // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n\n\n  Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    var lastCharIsLT, fixForEndingInLT;\n\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT; // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      } // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n\n    }\n  };\n\n  Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  }; // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n\n  /* istanbul ignore next - place holder */\n\n\n  Lexer.prototype.createTokenInstance = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return null;\n  };\n\n  Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n\n  Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      startLine: startLine,\n      startColumn: startColumn,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n\n  Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine: startLine,\n      endLine: startLine,\n      startColumn: startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  }; // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n\n  /* istanbul ignore next - place holder */\n\n\n  Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n    return 666;\n  };\n\n  Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  };\n\n  Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  }; // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n\n  /* istanbul ignore next - place holder */\n\n\n  Lexer.prototype.handlePayload = function (token, payload) {};\n\n  Lexer.prototype.handlePayloadNoCustom = function (token, payload) {};\n\n  Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  };\n  /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n\n\n  Lexer.prototype.match = function (pattern, text, offset) {\n    return null;\n  };\n\n  Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n    var found = pattern.test(text);\n\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n\n    return null;\n  };\n\n  Lexer.prototype.matchWithExec = function (pattern, text) {\n    var regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : regExpArray;\n  }; // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n\n\n  Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(indent + \"--> <\" + phaseDesc + \">\");\n      }\n\n      var _a = timer(phaseImpl),\n          time = _a.time,\n          value = _a.value;\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n\n\n      var traceMethod = time > 10 ? console.warn : console.log;\n\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n      }\n\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  };\n\n  Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" + \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n  Lexer.NA = /NOT_APPLICABLE/;\n  return Lexer;\n}();\n\nexport { Lexer };","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/scan/lexer_public.js"],"names":["analyzeTokenTypes","charCodeToOptimizedIndex","cloneEmptyGroups","DEFAULT_MODE","LineTerminatorOptimizedTester","performRuntimeChecks","performWarningRuntimeChecks","SUPPORT_STICKY","validatePatterns","cloneArr","cloneObj","forEach","IDENTITY","isArray","isEmpty","isUndefined","keys","last","map","merge","NOOP","PRINT_WARNING","reduce","reject","timer","toFastProperties","augmentTokenTypes","defaultLexerErrorProvider","clearRegExpParserCache","LexerDefinitionErrorType","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","positionTracking","lineTerminatorsPattern","lineTerminatorCharacters","ensureOptimizations","safeMode","errorMessageProvider","traceInitPerf","skipValidations","Object","freeze","Lexer","lexerDefinition","config","_this","lexerDefinitionErrors","lexerDefinitionWarning","patternIdxToConfig","charCodeToPatternIdxToConfig","modes","emptyGroups","undefined","trackStartLines","trackEndLines","hasCustom","canModeBeOptimized","Error","traceInitVal","traceInitMaxIdent","Infinity","traceInitIndent","TRACE_INIT","actualDefinition","hasOnlySingleMode","test","concat","currModeValue","currModeName","currTokType","allModeNames","currModDef","currModName","push","currAnalyzeResult_1","tracer","bind","canBeOptimized","defaultMode","allErrMessages","error","message","allErrMessagesString","join","warningDescriptor","chopInput","match","matchWithTest","updateLastIndex","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","prototype","tokenize","text","initialMode","lexResult","tokenizeInternal","i","j","matchAltImage","longerAltIdx","matchedImage","payload","altPayload","imageLength","group","tokType","newToken","errLength","droppedChar","msg","orgText","orgLength","length","offset","matchedTokensIndex","guessedNumberOfTokens","Math","floor","matchedTokens","Array","errors","line","column","groups","trackLines","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","charCode","optimizedCharIdx","possiblePatterns","pop_mode","popToken","tokenType","PUSH_MODE","msg_1","buildUnableToPopLexerModeMessage","startOffset","startLine","startColumn","image","pop","newMode","modeCanBeOptimized","push_mode","call","currConfig","nextCharCode","charCodeAt","chosenPatternIdxToConfig","chosenPatternsLength","currPattern","pattern","singleCharCode","short","isCustom","exec","longerAlt","longerAltConfig","longerAltPattern","tokenTypeIdx","canLineTerminator","numOfLTsInMatch","foundTerminator","lastLTEndOffset","lastIndex","errorStartOffset","errorLine","errorColumn","foundResyncPoint","currConfig_1","buildUnexpectedCharactersMessage","tokens","pushMode","substring","regExp","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","args","_i","arguments","endOffset","tokenVector","index","tokenToAdd","token","found","regExpArray","phaseDesc","phaseImpl","indent","console","log","_a","time","value","traceMethod","warn","SKIPPED","NA"],"mappings":"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","sourcesContent":["import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns } from \"./lexer\";\nimport { cloneArr, cloneObj, forEach, IDENTITY, isArray, isEmpty, isUndefined, keys, last, map, merge, NOOP, PRINT_WARNING, reduce, reject, timer, toFastProperties } from \"../utils/utils\";\nimport { augmentTokenTypes } from \"./tokens\";\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser\";\nexport var LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */ (function () {\n    function Lexer(lexerDefinition, config) {\n        var _this = this;\n        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.config = undefined;\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = merge(DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n            var actualDefinition;\n            var hasOnlySingleMode = true;\n            _this.TRACE_INIT(\"Lexer Config handling\", function () {\n                if (_this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    _this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (_this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n                _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if (isArray(lexerDefinition)) {\n                    actualDefinition = { modes: {} };\n                    actualDefinition.modes[DEFAULT_MODE] = cloneArr(lexerDefinition);\n                    actualDefinition[DEFAULT_MODE] = DEFAULT_MODE;\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = cloneObj((lexerDefinition));\n                }\n            });\n            if (_this.config.skipValidations === false) {\n                _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n                _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n                actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) { return isUndefined(currTokType); });\n            });\n            var allModeNames = keys(actualDefinition.modes);\n            forEach(actualDefinition.modes, function (currModDef, currModName) {\n                _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n                    _this.modes.push(currModName);\n                    if (_this.config.skipValidations === false) {\n                        _this.TRACE_INIT(\"validatePatterns\", function () {\n                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if (isEmpty(_this.lexerDefinitionErrors)) {\n                        augmentTokenTypes(currModDef);\n                        var currAnalyzeResult_1;\n                        _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                            currAnalyzeResult_1 = analyzeTokenTypes(currModDef, {\n                                lineTerminatorCharacters: _this.config\n                                    .lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: _this.TRACE_INIT.bind(_this)\n                            });\n                        });\n                        _this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.patternIdxToConfig;\n                        _this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n                        _this.emptyGroups = merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n                        _this.hasCustom =\n                            currAnalyzeResult_1.hasCustom || _this.hasCustom;\n                        _this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult_1.canBeOptimized;\n                    }\n                });\n            });\n            _this.defaultMode = actualDefinition.defaultMode;\n            if (!isEmpty(_this.lexerDefinitionErrors) &&\n                !_this.config.deferDefinitionErrorsHandling) {\n                var allErrMessages = map(_this.lexerDefinitionErrors, function (error) {\n                    return error.message;\n                });\n                var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" +\n                    allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            forEach(_this.lexerDefinitionWarning, function (warningDescriptor) {\n                PRINT_WARNING(warningDescriptor.message);\n            });\n            _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (SUPPORT_STICKY) {\n                    _this.chopInput = IDENTITY;\n                    _this.match = _this.matchWithTest;\n                }\n                else {\n                    _this.updateLastIndex = NOOP;\n                    _this.match = _this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    _this.handleModes = NOOP;\n                }\n                if (_this.trackStartLines === false) {\n                    _this.computeNewColumn = IDENTITY;\n                }\n                if (_this.trackEndLines === false) {\n                    _this.updateTokenEndLineColumnLocation = NOOP;\n                }\n                if (/full/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createFullToken;\n                }\n                else if (/onlyStart/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n                }\n                if (_this.hasCustom) {\n                    _this.addToken = _this.addTokenUsingPush;\n                    _this.handlePayload = _this.handlePayloadWithCustom;\n                }\n                else {\n                    _this.addToken = _this.addTokenUsingMemberAccess;\n                    _this.handlePayload = _this.handlePayloadNoCustom;\n                }\n            });\n            _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n                var unOptimizedModes = reduce(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n                    throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n                clearRegExpParserCache();\n            });\n            _this.TRACE_INIT(\"toFastProperties\", function () {\n                toFastProperties(_this);\n            });\n        });\n    }\n    Lexer.prototype.tokenize = function (text, initialMode) {\n        if (initialMode === void 0) { initialMode = this.defaultMode; }\n        if (!isEmpty(this.lexerDefinitionErrors)) {\n            var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n                return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        var lexResult = this.tokenizeInternal(text, initialMode);\n        return lexResult;\n    };\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n        var _this = this;\n        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        var orgText = text;\n        var orgLength = orgText.length;\n        var offset = 0;\n        var matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        var guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        var matchedTokens = new Array(guessedNumberOfTokens);\n        var errors = [];\n        var line = this.trackStartLines ? 1 : undefined;\n        var column = this.trackStartLines ? 1 : undefined;\n        var groups = cloneEmptyGroups(this.emptyGroups);\n        var trackLines = this.trackStartLines;\n        var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        var currModePatternsLength = 0;\n        var patternIdxToConfig = [];\n        var currCharCodeToPatternIdxToConfig = [];\n        var modeStack = [];\n        var emptyArray = [];\n        Object.freeze(emptyArray);\n        var getPossiblePatterns = undefined;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        var pop_mode = function (popToken) {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine !== undefined\n                        ? popToken.startLine\n                        : undefined,\n                    column: popToken.startColumn !== undefined\n                        ? popToken.startColumn\n                        : undefined,\n                    length: popToken.image.length,\n                    message: msg_1\n                });\n            }\n            else {\n                modeStack.pop();\n                var newMode = last(modeStack);\n                patternIdxToConfig = _this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig = _this\n                    .charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] &&\n                    _this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig = this\n                .charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] &&\n                this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        var currConfig;\n        while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                var currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                var singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAltIdx = currConfig.longerAlt;\n                    if (longerAltIdx !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        var longerAltConfig = patternIdxToConfig[longerAltIdx];\n                        var longerAltPattern = longerAltConfig.pattern;\n                        altPayload = null;\n                        // single Char can never be a longer alt so no need to test it.\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        if (longerAltConfig.isCustom === true) {\n                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                            if (match !== null) {\n                                matchAltImage = match[0];\n                                if (match.payload !== undefined) {\n                                    altPayload = match.payload;\n                                }\n                            }\n                            else {\n                                matchAltImage = null;\n                            }\n                        }\n                        else {\n                            this.updateLastIndex(longerAltPattern, offset);\n                            matchAltImage = this.match(longerAltPattern, text, offset);\n                        }\n                        if (matchAltImage &&\n                            matchAltImage.length > matchedImage.length) {\n                            matchedImage = matchAltImage;\n                            payload = altPayload;\n                            currConfig = longerAltConfig;\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true &&\n                    currConfig.canLineTerminator === true) {\n                    var numOfLTsInMatch = 0;\n                    var foundTerminator = void 0;\n                    var lastLTEndOffset = void 0;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset =\n                                lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                var errorStartOffset = offset;\n                var errorLine = line;\n                var errorColumn = column;\n                var foundResyncPoint = false;\n                while (!foundResyncPoint && offset < orgLength) {\n                    // drop chars until we succeed in matching something\n                    droppedChar = orgText.charCodeAt(offset);\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        var currConfig_1 = patternIdxToConfig[j];\n                        var currPattern = currConfig_1.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        var singleCharCode = currConfig_1.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig_1.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg\n                });\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n        };\n    };\n    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    };\n    Lexer.prototype.chopInput = function (text, length) {\n        return text.substring(length);\n    };\n    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    };\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        var lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    };\n    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.createTokenInstance = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return null;\n    };\n    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n        return 666;\n    };\n    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    };\n    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    };\n    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.handlePayload = function (token, payload) { };\n    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };\n    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    };\n    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n    Lexer.prototype.match = function (pattern, text, offset) {\n        return null;\n    };\n    Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n        var found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    };\n    Lexer.prototype.matchWithExec = function (pattern, text) {\n        var regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : regExpArray;\n    };\n    // Duplicated from the parser's perf trace trait to allow future extraction\n    // of the lexer to a separate package.\n    Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(indent + \"--> <\" + phaseDesc + \">\");\n            }\n            var _a = timer(phaseImpl), time = _a.time, value = _a.value;\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    };\n    Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n        \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer.NA = /NOT_APPLICABLE/;\n    return Lexer;\n}());\nexport { Lexer };\n//# sourceMappingURL=lexer_public.js.map"]},"metadata":{},"sourceType":"module"}