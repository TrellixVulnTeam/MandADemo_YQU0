{"ast":null,"code":"import { EarlyExitException, isRecognitionException, NoViableAltException } from \"../../exceptions_public\";\nimport { cloneArr, defaults } from \"../../../utils/utils\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr } from \"../../grammar/lookahead\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * Trait responsible for runtime parsing errors.\n */\n\nvar ErrorHandler = function () {\n  function ErrorHandler() {}\n\n  ErrorHandler.prototype.initErrorHandler = function (config) {\n    this._errors = [];\n    this.errorMessageProvider = defaults(config.errorMessageProvider, DEFAULT_PARSER_CONFIG.errorMessageProvider);\n  };\n\n  ErrorHandler.prototype.SAVE_ERROR = function (error) {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: cloneArr(this.RULE_OCCURRENCE_STACK)\n      };\n\n      this._errors.push(error);\n\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  };\n\n  Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n    // TODO: extract these methods to ErrorHandler Trait?\n    get: function () {\n      return cloneArr(this._errors);\n    },\n    set: function (newErrors) {\n      this._errors = newErrors;\n    },\n    enumerable: true,\n    configurable: true\n  }); // TODO: consider caching the error message computed information\n\n  ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName];\n    var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    var insideProdPaths = lookAheadPathsPerAlternative[0];\n    var actualTokens = [];\n\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    var msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    });\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }; // TODO: consider caching the error message computed information\n\n\n  ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName]; // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n\n    var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n    var actualTokens = [];\n\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    var previousToken = this.LA(0);\n    var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n  };\n\n  return ErrorHandler;\n}();\n\nexport { ErrorHandler };","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js"],"names":["EarlyExitException","isRecognitionException","NoViableAltException","cloneArr","defaults","getLookaheadPathsForOptionalProd","getLookaheadPathsForOr","DEFAULT_PARSER_CONFIG","ErrorHandler","prototype","initErrorHandler","config","_errors","errorMessageProvider","SAVE_ERROR","error","context","ruleStack","getHumanReadableRuleStack","ruleOccurrenceStack","RULE_OCCURRENCE_STACK","push","Error","Object","defineProperty","get","set","newErrors","enumerable","configurable","raiseEarlyExitException","occurrence","prodType","userDefinedErrMsg","ruleName","getCurrRuleFullName","ruleGrammar","getGAstProductions","lookAheadPathsPerAlternative","maxLookahead","insideProdPaths","actualTokens","i","LA","msg","buildEarlyExitMessage","expectedIterationPaths","actual","previous","customUserDescription","raiseNoAltException","errMsgTypes","previousToken","errMsg","buildNoViableAltMessage","expectedPathsPerAlt"],"mappings":"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","sourcesContent":["import { EarlyExitException, isRecognitionException, NoViableAltException } from \"../../exceptions_public\";\nimport { cloneArr, defaults } from \"../../../utils/utils\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr } from \"../../grammar/lookahead\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar ErrorHandler = /** @class */ (function () {\n    function ErrorHandler() {\n    }\n    ErrorHandler.prototype.initErrorHandler = function (config) {\n        this._errors = [];\n        this.errorMessageProvider = defaults(config.errorMessageProvider, DEFAULT_PARSER_CONFIG.errorMessageProvider);\n    };\n    ErrorHandler.prototype.SAVE_ERROR = function (error) {\n        if (isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: cloneArr(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    };\n    Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n        // TODO: extract these methods to ErrorHandler Trait?\n        get: function () {\n            return cloneArr(this._errors);\n        },\n        set: function (newErrors) {\n            this._errors = newErrors;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        var insideProdPaths = lookAheadPathsPerAlternative[0];\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n        });\n        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n    };\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var previousToken = this.LA(0);\n        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n    };\n    return ErrorHandler;\n}());\nexport { ErrorHandler };\n//# sourceMappingURL=error_handler.js.map"]},"metadata":{},"sourceType":"module"}