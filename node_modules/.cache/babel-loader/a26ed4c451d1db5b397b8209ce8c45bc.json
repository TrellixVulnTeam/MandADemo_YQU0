{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { absolutizeDependencies } from './absolutizeDependencies';\nimport { CellError, simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { getRawValue } from './interpreter/InterpreterValue';\nimport { FormulaCellVertex, MatrixVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { GraphBuilderMatrixHeuristic } from './GraphBuilderMatrixHeuristic';\nimport { checkMatrixSize } from './Matrix';\nimport { StatType } from './statistics';\n/**\n * Service building the graph and mappings.\n */\n\nexport var GraphBuilder = /*#__PURE__*/function () {\n  /**\n   * Configures the building service.\n   *\n   * @param graph - graph instance in which we want to add vertices and edges\n   * @param addressMapping - mapping from addresses to vertices\n   * @param rangeMapping - mapping from ranges to range vertices\n   * @param stats - dependency tracking building performance\n   * @param config - configuration of the sheet\n   */\n  function GraphBuilder(dependencyGraph, columnSearch, parser, cellContentParser, config, stats) {\n    _classCallCheck(this, GraphBuilder);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.config = config;\n    this.stats = stats;\n\n    if (this.config.matrixDetection) {\n      this.buildStrategy = new MatrixDetectionStrategy(this.dependencyGraph, this.columnSearch, this.parser, this.stats, config.matrixDetectionThreshold, this.cellContentParser);\n    } else {\n      this.buildStrategy = new SimpleStrategy(this.dependencyGraph, this.columnSearch, this.parser, this.stats, this.cellContentParser);\n    }\n  }\n  /**\n   * Builds graph.\n   *\n   * @param sheet - two-dimensional array representation of sheet\n   */\n\n\n  _createClass(GraphBuilder, [{\n    key: \"buildGraph\",\n    value: function buildGraph(sheets) {\n      var dependencies = this.buildStrategy.run(sheets);\n      this.processDependencies(dependencies);\n    }\n  }, {\n    key: \"processDependencies\",\n    value: function processDependencies(dependencies) {\n      var _this = this;\n\n      dependencies.forEach(function (cellDependencies, endVertex) {\n        _this.dependencyGraph.processCellDependencies(cellDependencies, endVertex);\n      });\n    }\n  }]);\n\n  return GraphBuilder;\n}();\nexport var SimpleStrategy = /*#__PURE__*/function () {\n  function SimpleStrategy(dependencyGraph, columnIndex, parser, stats, cellContentParser) {\n    _classCallCheck(this, SimpleStrategy);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnIndex = columnIndex;\n    this.parser = parser;\n    this.stats = stats;\n    this.cellContentParser = cellContentParser;\n  }\n\n  _createClass(SimpleStrategy, [{\n    key: \"run\",\n    value: function run(sheets) {\n      var _this2 = this;\n\n      var dependencies = new Map();\n\n      for (var sheetName in sheets) {\n        var sheetId = this.dependencyGraph.getSheetId(sheetName);\n        var sheet = sheets[sheetName];\n\n        for (var i = 0; i < sheet.length; ++i) {\n          var row = sheet[i];\n\n          var _loop = function _loop(j) {\n            var cellContent = row[j];\n            var address = simpleCellAddress(sheetId, j, i);\n\n            var parsedCellContent = _this2.cellContentParser.parse(cellContent);\n\n            if (parsedCellContent instanceof CellContent.MatrixFormula) {\n              if (_this2.dependencyGraph.existsVertex(address)) {\n                return \"continue\";\n              }\n\n              var parseResult = _this2.stats.measure(StatType.PARSER, function () {\n                return _this2.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (parseResult.errors.length > 0) {\n                var vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formulaWithBraces());\n\n                _this2.dependencyGraph.addVertex(address, vertex);\n              } else {\n                var _vertex = buildMatrixVertex(parseResult.ast, address);\n\n                dependencies.set(_vertex, absolutizeDependencies(parseResult.dependencies, address));\n\n                _this2.dependencyGraph.addMatrixVertex(address, _vertex);\n              }\n            } else if (parsedCellContent instanceof CellContent.Formula) {\n              var _parseResult = _this2.stats.measure(StatType.PARSER, function () {\n                return _this2.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (_parseResult.errors.length > 0) {\n                var _vertex2 = new ParsingErrorVertex(_parseResult.errors, parsedCellContent.formula);\n\n                _this2.dependencyGraph.addVertex(address, _vertex2);\n              } else {\n                var _vertex3 = new FormulaCellVertex(_parseResult.ast, address, 0);\n\n                dependencies.set(_vertex3, absolutizeDependencies(_parseResult.dependencies, address));\n\n                _this2.dependencyGraph.addVertex(address, _vertex3);\n\n                if (_parseResult.hasVolatileFunction) {\n                  _this2.dependencyGraph.markAsVolatile(_vertex3);\n                }\n\n                if (_parseResult.hasStructuralChangeFunction) {\n                  _this2.dependencyGraph.markAsDependentOnStructureChange(_vertex3);\n                }\n              }\n            } else if (parsedCellContent instanceof CellContent.Empty) {\n              /* we don't care about empty cells here */\n            } else {\n              var _vertex4 = new ValueCellVertex(parsedCellContent.value, cellContent);\n\n              _this2.columnIndex.add(getRawValue(parsedCellContent.value), address);\n\n              _this2.dependencyGraph.addVertex(address, _vertex4);\n            }\n          };\n\n          for (var j = 0; j < row.length; ++j) {\n            var _ret = _loop(j);\n\n            if (_ret === \"continue\") continue;\n          }\n        }\n      }\n\n      return dependencies;\n    }\n  }]);\n\n  return SimpleStrategy;\n}();\nexport var MatrixDetectionStrategy = /*#__PURE__*/function () {\n  function MatrixDetectionStrategy(dependencyGraph, columnSearch, parser, stats, threshold, cellContentParser) {\n    _classCallCheck(this, MatrixDetectionStrategy);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.stats = stats;\n    this.threshold = threshold;\n    this.cellContentParser = cellContentParser;\n  }\n\n  _createClass(MatrixDetectionStrategy, [{\n    key: \"run\",\n    value: function run(sheets) {\n      var _this3 = this;\n\n      var dependencies = new Map();\n      var matrixHeuristic = new GraphBuilderMatrixHeuristic(this.dependencyGraph, this.columnSearch, this.threshold, this.cellContentParser);\n\n      for (var sheetName in sheets) {\n        var sheetId = this.dependencyGraph.getSheetId(sheetName);\n        var sheet = sheets[sheetName];\n        matrixHeuristic.addSheet(sheetId, {\n          width: this.dependencyGraph.getSheetWidth(sheetId),\n          height: this.dependencyGraph.getSheetHeight(sheetId)\n        });\n\n        for (var i = 0; i < sheet.length; ++i) {\n          var row = sheet[i];\n\n          var _loop2 = function _loop2(j) {\n            var cellContent = row[j];\n            var address = simpleCellAddress(sheetId, j, i);\n\n            var parsedCellContent = _this3.cellContentParser.parse(cellContent);\n\n            if (parsedCellContent instanceof CellContent.MatrixFormula) {\n              if (_this3.dependencyGraph.existsVertex(address)) {\n                return \"continue\";\n              }\n\n              var parseResult = _this3.stats.measure(StatType.PARSER, function () {\n                return _this3.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (parseResult.errors.length > 0) {\n                var vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formulaWithBraces());\n\n                _this3.dependencyGraph.addVertex(address, vertex);\n              } else {\n                var _vertex5 = buildMatrixVertex(parseResult.ast, address);\n\n                dependencies.set(_vertex5, absolutizeDependencies(parseResult.dependencies, address));\n\n                _this3.dependencyGraph.addMatrixVertex(address, _vertex5);\n              }\n            } else if (parsedCellContent instanceof CellContent.Formula) {\n              var _parseResult2 = _this3.stats.measure(StatType.PARSER, function () {\n                return _this3.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (_parseResult2.errors.length > 0) {\n                var _vertex6 = new ParsingErrorVertex(_parseResult2.errors, parsedCellContent.formula);\n\n                _this3.dependencyGraph.addVertex(address, _vertex6);\n              } else {\n                var _vertex7 = new FormulaCellVertex(_parseResult2.ast, address, 0);\n\n                dependencies.set(_vertex7, absolutizeDependencies(_parseResult2.dependencies, address));\n\n                _this3.dependencyGraph.addVertex(address, _vertex7);\n              }\n            } else if (parsedCellContent instanceof CellContent.Empty) {\n              /* we don't care about empty cells here */\n            } else if (parsedCellContent instanceof CellContent.Number) {\n              matrixHeuristic.add(address);\n            } else {\n              var _vertex8 = new ValueCellVertex(parsedCellContent.value, cellContent);\n\n              _this3.columnSearch.add(parsedCellContent.value, address);\n\n              _this3.dependencyGraph.addVertex(address, _vertex8);\n            }\n          };\n\n          for (var j = 0; j < row.length; ++j) {\n            var _ret2 = _loop2(j);\n\n            if (_ret2 === \"continue\") continue;\n          }\n        }\n      }\n\n      this.stats.start(StatType.MATRIX_DETECTION);\n      var notMatrices = matrixHeuristic.run(sheets);\n\n      for (var _i = notMatrices.length - 1; _i >= 0; --_i) {\n        var elem = notMatrices[_i];\n        elem.cells.reverse();\n\n        var _iterator = _createForOfIteratorHelper(elem.cells),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var address = _step.value;\n            var value = sheets[this.dependencyGraph.getSheetName(address.sheet)][address.row][address.col];\n            var vertex = new ValueCellVertex(Number(value), value);\n            this.columnSearch.add(Number(value), address);\n            this.dependencyGraph.addVertex(address, vertex);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      this.stats.end(StatType.MATRIX_DETECTION);\n      return dependencies;\n    }\n  }]);\n\n  return MatrixDetectionStrategy;\n}();\nexport function buildMatrixVertex(ast, formulaAddress) {\n  var size = checkMatrixSize(ast, formulaAddress);\n\n  if (size instanceof CellError) {\n    return new ValueCellVertex(size, undefined);\n  }\n\n  return new MatrixVertex(formulaAddress, size.width, size.height, ast);\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/GraphBuilder.js"],"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","return","minLen","_arrayLikeToArray","Object","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","absolutizeDependencies","CellError","simpleCellAddress","CellContent","getRawValue","FormulaCellVertex","MatrixVertex","ParsingErrorVertex","ValueCellVertex","GraphBuilderMatrixHeuristic","checkMatrixSize","StatType","GraphBuilder","dependencyGraph","columnSearch","parser","cellContentParser","config","stats","matrixDetection","buildStrategy","MatrixDetectionStrategy","matrixDetectionThreshold","SimpleStrategy","buildGraph","sheets","dependencies","run","processDependencies","_this","forEach","cellDependencies","endVertex","processCellDependencies","columnIndex","_this2","Map","sheetName","sheetId","getSheetId","sheet","row","_loop","j","cellContent","address","parsedCellContent","parse","MatrixFormula","existsVertex","parseResult","measure","PARSER","formula","errors","vertex","formulaWithBraces","addVertex","_vertex","buildMatrixVertex","ast","set","addMatrixVertex","Formula","_parseResult","_vertex2","_vertex3","hasVolatileFunction","markAsVolatile","hasStructuralChangeFunction","markAsDependentOnStructureChange","Empty","_vertex4","add","_ret","threshold","_this3","matrixHeuristic","addSheet","width","getSheetWidth","height","getSheetHeight","_loop2","_vertex5","_parseResult2","_vertex6","_vertex7","Number","_vertex8","_ret2","start","MATRIX_DETECTION","notMatrices","_i","elem","cells","reverse","_iterator","_step","getSheetName","col","end","formulaAddress","size","undefined"],"mappings":"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","sourcesContent":["function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { absolutizeDependencies } from './absolutizeDependencies';\nimport { CellError, simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { getRawValue } from './interpreter/InterpreterValue';\nimport { FormulaCellVertex, MatrixVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { GraphBuilderMatrixHeuristic } from './GraphBuilderMatrixHeuristic';\nimport { checkMatrixSize } from './Matrix';\nimport { StatType } from './statistics';\n/**\n * Service building the graph and mappings.\n */\n\nexport var GraphBuilder = /*#__PURE__*/function () {\n  /**\n   * Configures the building service.\n   *\n   * @param graph - graph instance in which we want to add vertices and edges\n   * @param addressMapping - mapping from addresses to vertices\n   * @param rangeMapping - mapping from ranges to range vertices\n   * @param stats - dependency tracking building performance\n   * @param config - configuration of the sheet\n   */\n  function GraphBuilder(dependencyGraph, columnSearch, parser, cellContentParser, config, stats) {\n    _classCallCheck(this, GraphBuilder);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.config = config;\n    this.stats = stats;\n\n    if (this.config.matrixDetection) {\n      this.buildStrategy = new MatrixDetectionStrategy(this.dependencyGraph, this.columnSearch, this.parser, this.stats, config.matrixDetectionThreshold, this.cellContentParser);\n    } else {\n      this.buildStrategy = new SimpleStrategy(this.dependencyGraph, this.columnSearch, this.parser, this.stats, this.cellContentParser);\n    }\n  }\n  /**\n   * Builds graph.\n   *\n   * @param sheet - two-dimensional array representation of sheet\n   */\n\n\n  _createClass(GraphBuilder, [{\n    key: \"buildGraph\",\n    value: function buildGraph(sheets) {\n      var dependencies = this.buildStrategy.run(sheets);\n      this.processDependencies(dependencies);\n    }\n  }, {\n    key: \"processDependencies\",\n    value: function processDependencies(dependencies) {\n      var _this = this;\n\n      dependencies.forEach(function (cellDependencies, endVertex) {\n        _this.dependencyGraph.processCellDependencies(cellDependencies, endVertex);\n      });\n    }\n  }]);\n\n  return GraphBuilder;\n}();\nexport var SimpleStrategy = /*#__PURE__*/function () {\n  function SimpleStrategy(dependencyGraph, columnIndex, parser, stats, cellContentParser) {\n    _classCallCheck(this, SimpleStrategy);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnIndex = columnIndex;\n    this.parser = parser;\n    this.stats = stats;\n    this.cellContentParser = cellContentParser;\n  }\n\n  _createClass(SimpleStrategy, [{\n    key: \"run\",\n    value: function run(sheets) {\n      var _this2 = this;\n\n      var dependencies = new Map();\n\n      for (var sheetName in sheets) {\n        var sheetId = this.dependencyGraph.getSheetId(sheetName);\n        var sheet = sheets[sheetName];\n\n        for (var i = 0; i < sheet.length; ++i) {\n          var row = sheet[i];\n\n          var _loop = function _loop(j) {\n            var cellContent = row[j];\n            var address = simpleCellAddress(sheetId, j, i);\n\n            var parsedCellContent = _this2.cellContentParser.parse(cellContent);\n\n            if (parsedCellContent instanceof CellContent.MatrixFormula) {\n              if (_this2.dependencyGraph.existsVertex(address)) {\n                return \"continue\";\n              }\n\n              var parseResult = _this2.stats.measure(StatType.PARSER, function () {\n                return _this2.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (parseResult.errors.length > 0) {\n                var vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formulaWithBraces());\n\n                _this2.dependencyGraph.addVertex(address, vertex);\n              } else {\n                var _vertex = buildMatrixVertex(parseResult.ast, address);\n\n                dependencies.set(_vertex, absolutizeDependencies(parseResult.dependencies, address));\n\n                _this2.dependencyGraph.addMatrixVertex(address, _vertex);\n              }\n            } else if (parsedCellContent instanceof CellContent.Formula) {\n              var _parseResult = _this2.stats.measure(StatType.PARSER, function () {\n                return _this2.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (_parseResult.errors.length > 0) {\n                var _vertex2 = new ParsingErrorVertex(_parseResult.errors, parsedCellContent.formula);\n\n                _this2.dependencyGraph.addVertex(address, _vertex2);\n              } else {\n                var _vertex3 = new FormulaCellVertex(_parseResult.ast, address, 0);\n\n                dependencies.set(_vertex3, absolutizeDependencies(_parseResult.dependencies, address));\n\n                _this2.dependencyGraph.addVertex(address, _vertex3);\n\n                if (_parseResult.hasVolatileFunction) {\n                  _this2.dependencyGraph.markAsVolatile(_vertex3);\n                }\n\n                if (_parseResult.hasStructuralChangeFunction) {\n                  _this2.dependencyGraph.markAsDependentOnStructureChange(_vertex3);\n                }\n              }\n            } else if (parsedCellContent instanceof CellContent.Empty) {\n              /* we don't care about empty cells here */\n            } else {\n              var _vertex4 = new ValueCellVertex(parsedCellContent.value, cellContent);\n\n              _this2.columnIndex.add(getRawValue(parsedCellContent.value), address);\n\n              _this2.dependencyGraph.addVertex(address, _vertex4);\n            }\n          };\n\n          for (var j = 0; j < row.length; ++j) {\n            var _ret = _loop(j);\n\n            if (_ret === \"continue\") continue;\n          }\n        }\n      }\n\n      return dependencies;\n    }\n  }]);\n\n  return SimpleStrategy;\n}();\nexport var MatrixDetectionStrategy = /*#__PURE__*/function () {\n  function MatrixDetectionStrategy(dependencyGraph, columnSearch, parser, stats, threshold, cellContentParser) {\n    _classCallCheck(this, MatrixDetectionStrategy);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.stats = stats;\n    this.threshold = threshold;\n    this.cellContentParser = cellContentParser;\n  }\n\n  _createClass(MatrixDetectionStrategy, [{\n    key: \"run\",\n    value: function run(sheets) {\n      var _this3 = this;\n\n      var dependencies = new Map();\n      var matrixHeuristic = new GraphBuilderMatrixHeuristic(this.dependencyGraph, this.columnSearch, this.threshold, this.cellContentParser);\n\n      for (var sheetName in sheets) {\n        var sheetId = this.dependencyGraph.getSheetId(sheetName);\n        var sheet = sheets[sheetName];\n        matrixHeuristic.addSheet(sheetId, {\n          width: this.dependencyGraph.getSheetWidth(sheetId),\n          height: this.dependencyGraph.getSheetHeight(sheetId)\n        });\n\n        for (var i = 0; i < sheet.length; ++i) {\n          var row = sheet[i];\n\n          var _loop2 = function _loop2(j) {\n            var cellContent = row[j];\n            var address = simpleCellAddress(sheetId, j, i);\n\n            var parsedCellContent = _this3.cellContentParser.parse(cellContent);\n\n            if (parsedCellContent instanceof CellContent.MatrixFormula) {\n              if (_this3.dependencyGraph.existsVertex(address)) {\n                return \"continue\";\n              }\n\n              var parseResult = _this3.stats.measure(StatType.PARSER, function () {\n                return _this3.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (parseResult.errors.length > 0) {\n                var vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formulaWithBraces());\n\n                _this3.dependencyGraph.addVertex(address, vertex);\n              } else {\n                var _vertex5 = buildMatrixVertex(parseResult.ast, address);\n\n                dependencies.set(_vertex5, absolutizeDependencies(parseResult.dependencies, address));\n\n                _this3.dependencyGraph.addMatrixVertex(address, _vertex5);\n              }\n            } else if (parsedCellContent instanceof CellContent.Formula) {\n              var _parseResult2 = _this3.stats.measure(StatType.PARSER, function () {\n                return _this3.parser.parse(parsedCellContent.formula, address);\n              });\n\n              if (_parseResult2.errors.length > 0) {\n                var _vertex6 = new ParsingErrorVertex(_parseResult2.errors, parsedCellContent.formula);\n\n                _this3.dependencyGraph.addVertex(address, _vertex6);\n              } else {\n                var _vertex7 = new FormulaCellVertex(_parseResult2.ast, address, 0);\n\n                dependencies.set(_vertex7, absolutizeDependencies(_parseResult2.dependencies, address));\n\n                _this3.dependencyGraph.addVertex(address, _vertex7);\n              }\n            } else if (parsedCellContent instanceof CellContent.Empty) {\n              /* we don't care about empty cells here */\n            } else if (parsedCellContent instanceof CellContent.Number) {\n              matrixHeuristic.add(address);\n            } else {\n              var _vertex8 = new ValueCellVertex(parsedCellContent.value, cellContent);\n\n              _this3.columnSearch.add(parsedCellContent.value, address);\n\n              _this3.dependencyGraph.addVertex(address, _vertex8);\n            }\n          };\n\n          for (var j = 0; j < row.length; ++j) {\n            var _ret2 = _loop2(j);\n\n            if (_ret2 === \"continue\") continue;\n          }\n        }\n      }\n\n      this.stats.start(StatType.MATRIX_DETECTION);\n      var notMatrices = matrixHeuristic.run(sheets);\n\n      for (var _i = notMatrices.length - 1; _i >= 0; --_i) {\n        var elem = notMatrices[_i];\n        elem.cells.reverse();\n\n        var _iterator = _createForOfIteratorHelper(elem.cells),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var address = _step.value;\n            var value = sheets[this.dependencyGraph.getSheetName(address.sheet)][address.row][address.col];\n            var vertex = new ValueCellVertex(Number(value), value);\n            this.columnSearch.add(Number(value), address);\n            this.dependencyGraph.addVertex(address, vertex);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      this.stats.end(StatType.MATRIX_DETECTION);\n      return dependencies;\n    }\n  }]);\n\n  return MatrixDetectionStrategy;\n}();\nexport function buildMatrixVertex(ast, formulaAddress) {\n  var size = checkMatrixSize(ast, formulaAddress);\n\n  if (size instanceof CellError) {\n    return new ValueCellVertex(size, undefined);\n  }\n\n  return new MatrixVertex(formulaAddress, size.width, size.height, ast);\n}"]},"metadata":{},"sourceType":"module"}