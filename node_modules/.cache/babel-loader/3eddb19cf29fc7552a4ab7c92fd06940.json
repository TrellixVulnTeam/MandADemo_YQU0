{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { map, reduce, every, isEmpty, flatten, forEach, has } from \"../../utils/utils\";\nimport { possiblePathsFrom } from \"./interpreter\";\nimport { RestWalker } from \"./rest\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../scan/tokens\";\nimport { Alternation, Flat, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport var PROD_TYPE;\n\n(function (PROD_TYPE) {\n  PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\n\nexport function getProdType(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof Option) {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition) {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof RepetitionMandatory) {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation) {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\n\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n  var numOfAlts = alts.length;\n  var areAllOneTokenLookahead = every(alts, function (currAlt) {\n    return every(currAlt, function (currPath) {\n      return currPath.length === 1;\n    });\n  }); // This version takes into account the predicates as well.\n\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (orAlts) {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      var predicates = map(orAlts, function (currAlt) {\n        return currAlt.GATE;\n      });\n\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        var currPredicate = predicates[t];\n\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          } // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n\n\n          return t;\n        } // none of the paths for the current alternative matched\n        // try the next alternative\n\n      } // none of the alternatives could be matched\n\n\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    var singleTokenAlts = map(alts, function (currAlt) {\n      return flatten(currAlt);\n    });\n    var choiceToAlt_1 = reduce(singleTokenAlts, function (result, currAlt, idx) {\n      forEach(currAlt, function (currTokType) {\n        if (!has(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n\n        forEach(currTokType.categoryMatches, function (currExtendingType) {\n          if (!has(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, []);\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n\n    return function () {\n      var nextToken = this.LA(1);\n      return choiceToAlt_1[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          } // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n\n\n          return t;\n        } // none of the paths for the current alternative matched\n        // try the next alternative\n\n      } // none of the alternatives could be matched\n\n\n      return undefined;\n    };\n  }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n  var areAllOneTokenLookahead = every(alt, function (currPath) {\n    return currPath.length === 1;\n  });\n  var numOfPaths = alt.length; // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    var singleTokensTypes = flatten(alt);\n\n    if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n      var expectedTokenType = singleTokensTypes[0];\n      var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n      return function () {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n      };\n    } else {\n      var choiceToAlt_2 = reduce(singleTokensTypes, function (result, currTokType, idx) {\n        result[currTokType.tokenTypeIdx] = true;\n        forEach(currTokType.categoryMatches, function (currExtendingType) {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function () {\n        var nextToken = this.LA(1);\n        return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function () {\n      nextPath: for (var j = 0; j < numOfPaths; j++) {\n        var currPath = alt[j];\n        var currPathLength = currPath.length;\n\n        for (var i = 0; i < currPathLength; i++) {\n          var nextToken = this.LA(i + 1);\n\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        } // found a full path that matches.\n\n\n        return true;\n      } // none of the paths matched\n\n\n      return false;\n    };\n  }\n}\n\nvar RestDefinitionFinderWalker = function (_super) {\n  __extends(RestDefinitionFinderWalker, _super);\n\n  function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n    var _this = _super.call(this) || this;\n\n    _this.topProd = topProd;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    return _this;\n  }\n\n  RestDefinitionFinderWalker.prototype.startWalking = function () {\n    this.walk(this.topProd);\n    return this.restDef;\n  };\n\n  RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    } // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n\n\n    return false;\n  };\n\n  RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n\n  return RestDefinitionFinderWalker;\n}(RestWalker);\n/**\n * Returns the definition of a target production in a top level level rule.\n */\n\n\nvar InsideDefinitionFinderVisitor = function (_super) {\n  __extends(InsideDefinitionFinderVisitor, _super);\n\n  function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n    var _this = _super.call(this) || this;\n\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    _this.targetRef = targetRef;\n    _this.result = [];\n    return _this;\n  }\n\n  InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  };\n\n  return InsideDefinitionFinderVisitor;\n}(GAstVisitor);\n\nfunction initializeArrayOfArrays(size) {\n  var result = new Array(size);\n\n  for (var i = 0; i < size; i++) {\n    result[i] = [];\n  }\n\n  return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\n\n\nfunction pathToHashKeys(path) {\n  var keys = [\"\"];\n\n  for (var i = 0; i < path.length; i++) {\n    var tokType = path[i];\n    var longerKeys = [];\n\n    for (var j = 0; j < keys.length; j++) {\n      var currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n\n      for (var t = 0; t < tokType.categoryMatches.length; t++) {\n        var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n\n    keys = longerKeys;\n  }\n\n  return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\n\n\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n\n    var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n\n    for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      var searchKey = searchPathKeys[searchIdx];\n\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  } // None of the SearchPathKeys were found in any of the other alternatives\n\n\n  return true;\n}\n\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n  var partialAlts = map(altsDefs, function (currAlt) {\n    return possiblePathsFrom([currAlt], 1);\n  });\n  var finalResult = initializeArrayOfArrays(partialAlts.length);\n  var altsHashes = map(partialAlts, function (currAltPaths) {\n    var dict = {};\n    forEach(currAltPaths, function (item) {\n      var keys = pathToHashKeys(item.partialPath);\n      forEach(keys, function (currKey) {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  var newData = partialAlts; // maxLookahead loop\n\n  for (var pathLength = 1; pathLength <= k; pathLength++) {\n    var currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n\n    var _loop_1 = function (altIdx) {\n      var currAltPathsAndSuffixes = currDataset[altIdx]; // paths in current alternative loop\n\n      for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        var prefixKeys = pathToHashKeys(currPathPrefix);\n        var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx); // End of the line for this path.\n\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          var currAltResult = finalResult[altIdx]; // TODO: Can we implement a containsPath using Maps/Dictionaries?\n\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix); // Update all new  keys for the current path.\n\n            for (var j = 0; j < prefixKeys.length; j++) {\n              var currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        } // Expand longer paths\n        else {\n          var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes); // Update keys for new known paths\n\n          forEach(newPartialPathsAndSuffixes, function (item) {\n            var prefixKeys = pathToHashKeys(item.partialPath);\n            forEach(prefixKeys, function (key) {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }; // alternatives loop\n\n\n    for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      _loop_1(altIdx);\n    }\n  }\n\n  return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  var insideDef = insideDefVisitor.result;\n  var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  var afterDef = afterDefWalker.startWalking();\n  var insideFlat = new Flat({\n    definition: insideDef\n  });\n  var afterFlat = new Flat({\n    definition: afterDef\n  });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n  compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n    var otherPath = alternative[i];\n\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n\n    for (var j = 0; j < otherPath.length; j++) {\n      var searchTok = searchPath[j];\n      var otherTok = otherPath[j];\n      var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && every(prefix, function (tokType, idx) {\n    var otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n  return every(lookAheadPaths, function (singleAltPaths) {\n    return every(singleAltPaths, function (singlePath) {\n      return every(singlePath, function (token) {\n        return isEmpty(token.categoryMatches);\n      });\n    });\n  });\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","map","reduce","every","isEmpty","flatten","forEach","has","possiblePathsFrom","RestWalker","tokenStructuredMatcher","tokenStructuredMatcherNoCategories","Alternation","Flat","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","GAstVisitor","PROD_TYPE","getProdType","prod","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","Error","buildLookaheadFuncForOr","occurrence","ruleGrammar","maxLookahead","hasPredicates","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","getLookaheadPathsForOr","tokenMatcher","areTokenCategoriesNotUsed","buildLookaheadFuncForOptionalProd","k","prodType","lookaheadBuilder","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","alts","numOfAlts","length","areAllOneTokenLookahead","currAlt","currPath","orAlts","predicates","GATE","t","currNumOfPaths","currPredicate","undefined","call","nextPath","j","currPathLength","i","nextToken","LA","singleTokenAlts","choiceToAlt_1","result","idx","currTokType","tokenTypeIdx","categoryMatches","currExtendingType","buildSingleAlternativeLookaheadFunction","alt","numOfPaths","singleTokensTypes","expectedTokenType","expectedTokenUniqueKey_1","choiceToAlt_2","RestDefinitionFinderWalker","_super","topProd","targetOccurrence","targetProdType","_this","startWalking","walk","restDef","checkIsTarget","node","expectedProdType","currRest","prevRest","concat","walkOption","optionProd","walkAtLeastOne","atLeastOneProd","walkAtLeastOneSep","atLeastOneSepProd","walkMany","manyProd","walkManySep","manySepProd","InsideDefinitionFinderVisitor","targetRef","expectedProdName","definition","visitOption","visitRepetition","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitAlternation","initializeArrayOfArrays","size","pathToHashKeys","path","keys","tokType","longerKeys","currShorterKey","push","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","searchKey","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","currAltPaths","dict","item","partialPath","currKey","newData","pathLength","currDataset","_loop_1","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","suffixDef","prefixKeys","isUnique","currAltResult","containsPath","newPartialPathsAndSuffixes","key","orProd","visitor","accept","insideDefVisitor","insideDef","afterDefWalker","afterDef","insideFlat","afterFlat","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","matchingTokens","categoryMatchesMap","isStrictPrefixOfPath","prefix","other","otherTokType","singleAltPaths","singlePath","token"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { map, reduce, every, isEmpty, flatten, forEach, has } from \"../../utils/utils\";\nimport { possiblePathsFrom } from \"./interpreter\";\nimport { RestWalker } from \"./rest\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../scan/tokens\";\nimport { Alternation, Flat, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option) {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof Repetition) {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof Alternation) {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    var numOfAlts = alts.length;\n    var areAllOneTokenLookahead = every(alts, function (currAlt) {\n        return every(currAlt, function (currPath) {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            var predicates = map(orAlts, function (currAlt) { return currAlt.GATE; });\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                var currPredicate = predicates[t];\n                if (currPredicate !== undefined &&\n                    currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        var singleTokenAlts = map(alts, function (currAlt) {\n            return flatten(currAlt);\n        });\n        var choiceToAlt_1 = reduce(singleTokenAlts, function (result, currAlt, idx) {\n            forEach(currAlt, function (currTokType) {\n                if (!has(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                forEach(currTokType.categoryMatches, function (currExtendingType) {\n                    if (!has(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, []);\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    var areAllOneTokenLookahead = every(alt, function (currPath) {\n        return currPath.length === 1;\n    });\n    var numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 &&\n            isEmpty(singleTokensTypes[0].categoryMatches)) {\n            var expectedTokenType = singleTokensTypes[0];\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n            };\n        }\n        else {\n            var choiceToAlt_2 = reduce(singleTokensTypes, function (result, currTokType, idx) {\n                result[currTokType.tokenTypeIdx] = true;\n                forEach(currTokType.categoryMatches, function (currExtendingType) {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                var nextToken = this.LA(1);\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\n                var currPath = alt[j];\n                var currPathLength = currPath.length;\n                for (var i = 0; i < currPathLength; i++) {\n                    var nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\n    __extends(RestDefinitionFinderWalker, _super);\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        return _this;\n    }\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.restDef;\n    };\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    };\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return RestDefinitionFinderWalker;\n}(RestWalker));\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\n    __extends(InsideDefinitionFinderVisitor, _super);\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this = _super.call(this) || this;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        _this.targetRef = targetRef;\n        _this.result = [];\n        return _this;\n    }\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    };\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    };\n    return InsideDefinitionFinderVisitor;\n}(GAstVisitor));\nfunction initializeArrayOfArrays(size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    var keys = [\"\"];\n    for (var i = 0; i < path.length; i++) {\n        var tokType = path[i];\n        var longerKeys = [];\n        for (var j = 0; j < keys.length; j++) {\n            var currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\n                var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            var searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    var partialAlts = map(altsDefs, function (currAlt) { return possiblePathsFrom([currAlt], 1); });\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\n    var altsHashes = map(partialAlts, function (currAltPaths) {\n        var dict = {};\n        forEach(currAltPaths, function (item) {\n            var keys = pathToHashKeys(item.partialPath);\n            forEach(keys, function (currKey) {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    var newData = partialAlts;\n    // maxLookahead loop\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop_1 = function (altIdx) {\n            var currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                var prefixKeys = pathToHashKeys(currPathPrefix);\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique ||\n                    isEmpty(suffixDef) ||\n                    currPathPrefix.length === k) {\n                    var currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (var j = 0; j < prefixKeys.length; j++) {\n                            var currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    forEach(newPartialPathsAndSuffixes, function (item) {\n                        var prefixKeys = pathToHashKeys(item.partialPath);\n                        forEach(prefixKeys, function (key) {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        };\n        // alternatives loop\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            _loop_1(altIdx);\n        }\n    }\n    return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    var insideDef = insideDefVisitor.result;\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    var afterDef = afterDefWalker.startWalking();\n    var insideFlat = new Flat({ definition: insideDef });\n    var afterFlat = new Flat({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n        var otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n            var searchTok = searchPath[j];\n            var otherTok = otherPath[j];\n            var matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !==\n                    undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        every(prefix, function (tokType, idx) {\n            var otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, function (singleAltPaths) {\n        return every(singleAltPaths, function (singlePath) {\n            return every(singlePath, function (token) { return isEmpty(token.categoryMatches); });\n        });\n    });\n}\n//# sourceMappingURL=lookahead.js.map"]},"metadata":{},"sourceType":"module"}