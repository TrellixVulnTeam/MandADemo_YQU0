{"ast":null,"code":"import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\n\nvar RestWalker = function () {\n  function RestWalker() {}\n\n  RestWalker.prototype.walk = function (prod, prevRest) {\n    var _this = this;\n\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n\n    forEach(prod.definition, function (subProd, index) {\n      var currRest = drop(prod.definition, index + 1);\n      /* istanbul ignore else */\n\n      if (subProd instanceof NonTerminal) {\n        _this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        _this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Flat) {\n        _this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        _this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        _this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        _this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        _this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        _this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  };\n\n  RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {};\n\n  RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {};\n\n  RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n    // ABCDEF => after the D the rest is EF\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  };\n\n  RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  };\n\n  RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    var fullAtLeastOneRest = [new Option({\n      definition: atLeastOneProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  };\n\n  RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  };\n\n  RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    var fullManyRest = [new Option({\n      definition: manyProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  };\n\n  RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  };\n\n  RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n    var _this = this; // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n\n\n    var fullOrRest = currRest.concat(prevRest); // walk all different alternatives\n\n    forEach(orProd.definition, function (alt) {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      var prodWrapper = new Flat({\n        definition: [alt]\n      });\n\n      _this.walk(prodWrapper, fullOrRest);\n    });\n  };\n\n  return RestWalker;\n}();\n\nexport { RestWalker };\n\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  var repSepRest = [new Option({\n    definition: [new Terminal({\n      terminalType: repSepProd.separator\n    })].concat(repSepProd.definition)\n  })];\n  var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js"],"names":["drop","forEach","Alternation","Flat","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","RestWalker","prototype","walk","prod","prevRest","_this","definition","subProd","index","currRest","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","Error","terminal","refProd","flatProd","fullOrRest","concat","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","repSepRest","terminalType","separator","fullRepSepRest"],"mappings":"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","sourcesContent":["import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */ (function () {\n    function RestWalker() {\n    }\n    RestWalker.prototype.walk = function (prod, prevRest) {\n        var _this = this;\n        if (prevRest === void 0) { prevRest = []; }\n        forEach(prod.definition, function (subProd, index) {\n            var currRest = drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof NonTerminal) {\n                _this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                _this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Flat) {\n                _this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                _this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                _this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                _this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                _this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                _this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    };\n    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };\n    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };\n    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    };\n    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    };\n    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        var fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    };\n    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    };\n    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        var fullManyRest = [\n            new Option({ definition: manyProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    };\n    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    };\n    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n        var _this = this;\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        var fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        forEach(orProd.definition, function (alt) {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            var prodWrapper = new Flat({ definition: [alt] });\n            _this.walk(prodWrapper, fullOrRest);\n        });\n    };\n    return RestWalker;\n}());\nexport { RestWalker };\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    var repSepRest = [\n        new Option({\n            definition: [\n                new Terminal({ terminalType: repSepProd.separator })\n            ].concat(repSepProd.definition)\n        })\n    ];\n    var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map"]},"metadata":{},"sourceType":"module"}