{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { simpleCellRange } from '../AbsoluteCellRange';\nimport { simpleCellAddress } from '../Cell';\nimport { CellAddress } from './CellAddress';\nimport { ColumnAddress } from './ColumnAddress';\nimport { ABSOLUTE_OPERATOR, RANGE_OPERATOR, sheetNameRegexp, simpleSheetName } from './LexerConfig';\nimport { RowAddress } from './RowAddress';\nvar addressRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\\").concat(ABSOLUTE_OPERATOR, \"?)([A-Za-z]+)(\\\\\").concat(ABSOLUTE_OPERATOR, \"?)([0-9]+)$\"));\nvar columnRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\\").concat(ABSOLUTE_OPERATOR, \"?)([A-Za-z]+)$\"));\nvar rowRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\\").concat(ABSOLUTE_OPERATOR, \"?)([0-9]+)$\"));\nvar simpleSheetNameRegex = new RegExp(\"^\".concat(simpleSheetName, \"$\"));\n/**\n * Computes R0C0 representation of cell address based on it's string representation and base address.\n *\n * @param sheetMapping - mapping function needed to change name of a sheet to index\n * @param stringAddress - string representation of cell address, e.g. 'C64'\n * @param baseAddress - base address for R0C0 conversion\n * @returns object representation of address\n */\n\nexport var cellAddressFromString = function cellAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = addressRegex.exec(stringAddress);\n  var col = columnLabelToIndex(result[6]);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = undefined;\n  }\n\n  var row = Number(result[8]) - 1;\n\n  if (result[5] === ABSOLUTE_OPERATOR && result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absolute(col, row, sheet);\n  } else if (result[5] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteCol(col, row - baseAddress.row, sheet);\n  } else if (result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteRow(col - baseAddress.col, row, sheet);\n  } else {\n    return CellAddress.relative(row - baseAddress.row, col - baseAddress.col, sheet);\n  }\n};\nexport var columnAddressFromString = function columnAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = columnRegex.exec(stringAddress);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = undefined;\n  }\n\n  var col = columnLabelToIndex(result[6]);\n\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return ColumnAddress.absolute(col, sheet);\n  } else {\n    return ColumnAddress.relative(col - baseAddress.col, sheet);\n  }\n};\nexport var rowAddressFromString = function rowAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = rowRegex.exec(stringAddress);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = undefined;\n  }\n\n  var row = Number(result[6]) - 1;\n\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return RowAddress.absolute(row, sheet);\n  } else {\n    return RowAddress.relative(row - baseAddress.row, sheet);\n  }\n};\n/**\n * Computes simple (absolute) address of a cell address based on its string representation.\n * If sheet name present in string representation but is not present in sheet mapping, returns undefined.\n * If sheet name is not present in string representation, returns {@param sheetContext} as sheet number\n *\n * @param sheetMapping - mapping function needed to change name of a sheet to index\n * @param stringAddress - string representation of cell address, e.g. 'C64'\n * @param sheetContext - sheet in context of which we should parse the address\n * @returns absolute representation of address, e.g. { sheet: 0, col: 1, row: 1 }\n */\n\nexport var simpleCellAddressFromString = function simpleCellAddressFromString(sheetMapping, stringAddress, sheetContext) {\n  var result = addressRegex.exec(stringAddress);\n  var col = columnLabelToIndex(result[6]);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = sheetContext;\n  }\n\n  var row = Number(result[8]) - 1;\n  return simpleCellAddress(sheet, col, row);\n};\nexport var simpleCellRangeFromString = function simpleCellRangeFromString(sheetMapping, stringAddress, sheetContext) {\n  var split = stringAddress.split(RANGE_OPERATOR);\n\n  if (split.length !== 2) {\n    return undefined;\n  }\n\n  var _split = _slicedToArray(split, 2),\n      startString = _split[0],\n      endString = _split[1];\n\n  var start = simpleCellAddressFromString(sheetMapping, startString, sheetContext);\n\n  if (start === undefined) {\n    return undefined;\n  }\n\n  var end = simpleCellAddressFromString(sheetMapping, endString, start.sheet);\n\n  if (end === undefined) {\n    return undefined;\n  }\n\n  if (start.sheet !== end.sheet) {\n    return undefined;\n  }\n\n  return simpleCellRange(start, end);\n};\n/**\n * Returns string representation of absolute address\n * If sheet index is not present in sheet mapping, returns undefined\n *\n * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name\n * @param address - object representation of absolute address\n * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name\n * */\n\nexport var simpleCellAddressToString = function simpleCellAddressToString(sheetIndexMapping, address, sheetIndex) {\n  var column = columnIndexToLabel(address.col);\n  var sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);\n\n  if (sheetName === undefined) {\n    return undefined;\n  }\n\n  if (sheetIndex !== address.sheet) {\n    return \"\".concat(sheetName, \"!\").concat(column).concat(address.row + 1);\n  } else {\n    return \"\".concat(column).concat(address.row + 1);\n  }\n};\nexport var simpleCellRangeToString = function simpleCellRangeToString(sheetIndexMapping, address, sheetIndex) {\n  var startString = simpleCellAddressToString(sheetIndexMapping, address.start, sheetIndex);\n  var endString = simpleCellAddressToString(sheetIndexMapping, address.end, address.start.sheet);\n\n  if (startString === undefined || endString === undefined) {\n    return undefined;\n  } else {\n    return \"\".concat(startString).concat(RANGE_OPERATOR).concat(endString);\n  }\n};\n/**\n* Convert column label to index\n*\n* @param columnStringRepresentation - column label (e.g. 'AAB')\n* @returns column index\n* */\n\nfunction columnLabelToIndex(columnStringRepresentation) {\n  if (columnStringRepresentation.length === 1) {\n    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;\n  } else {\n    return columnStringRepresentation.split('').reduce(function (currentColumn, nextLetter) {\n      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);\n    }, 0) - 1;\n  }\n}\n/**\n * Converts column index to label\n *\n * @param column - address to convert\n * @returns string representation, e.g. 'AAB'\n */\n\n\nexport function columnIndexToLabel(column) {\n  var result = '';\n\n  while (column >= 0) {\n    result = String.fromCharCode(column % 26 + 97) + result;\n    column = Math.floor(column / 26) - 1;\n  }\n\n  return result.toUpperCase();\n}\nexport function sheetIndexToString(sheetId, sheetMappingFn) {\n  var sheetName = sheetMappingFn(sheetId);\n\n  if (sheetName === undefined) {\n    return undefined;\n  }\n\n  if (simpleSheetNameRegex.test(sheetName)) {\n    return sheetName;\n  } else {\n    sheetName = sheetName.replace(/'/g, \"''\");\n    return \"'\".concat(sheetName, \"'\");\n  }\n}\n\nfunction extractSheetNumber(regexResult, sheetMapping) {\n  var _a;\n\n  var maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];\n\n  if (maybeSheetName) {\n    maybeSheetName = maybeSheetName.replace(/''/g, \"'\");\n    return sheetMapping(maybeSheetName);\n  } else {\n    return null;\n  }\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/addressRepresentationConverters.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","simpleCellRange","simpleCellAddress","CellAddress","ColumnAddress","ABSOLUTE_OPERATOR","RANGE_OPERATOR","sheetNameRegexp","simpleSheetName","RowAddress","addressRegex","RegExp","concat","columnRegex","rowRegex","simpleSheetNameRegex","cellAddressFromString","sheetMapping","stringAddress","baseAddress","result","exec","col","columnLabelToIndex","sheet","extractSheetNumber","undefined","row","Number","absolute","absoluteCol","absoluteRow","relative","columnAddressFromString","rowAddressFromString","simpleCellAddressFromString","sheetContext","simpleCellRangeFromString","split","_split","startString","endString","start","end","simpleCellAddressToString","sheetIndexMapping","address","sheetIndex","column","columnIndexToLabel","sheetName","sheetIndexToString","simpleCellRangeToString","columnStringRepresentation","toUpperCase","charCodeAt","reduce","currentColumn","nextLetter","String","fromCharCode","Math","floor","sheetId","sheetMappingFn","replace","regexResult","_a","maybeSheetName"],"mappings":"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","sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { simpleCellRange } from '../AbsoluteCellRange';\nimport { simpleCellAddress } from '../Cell';\nimport { CellAddress } from './CellAddress';\nimport { ColumnAddress } from './ColumnAddress';\nimport { ABSOLUTE_OPERATOR, RANGE_OPERATOR, sheetNameRegexp, simpleSheetName } from './LexerConfig';\nimport { RowAddress } from './RowAddress';\nvar addressRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\\").concat(ABSOLUTE_OPERATOR, \"?)([A-Za-z]+)(\\\\\").concat(ABSOLUTE_OPERATOR, \"?)([0-9]+)$\"));\nvar columnRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\\").concat(ABSOLUTE_OPERATOR, \"?)([A-Za-z]+)$\"));\nvar rowRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\\").concat(ABSOLUTE_OPERATOR, \"?)([0-9]+)$\"));\nvar simpleSheetNameRegex = new RegExp(\"^\".concat(simpleSheetName, \"$\"));\n/**\n * Computes R0C0 representation of cell address based on it's string representation and base address.\n *\n * @param sheetMapping - mapping function needed to change name of a sheet to index\n * @param stringAddress - string representation of cell address, e.g. 'C64'\n * @param baseAddress - base address for R0C0 conversion\n * @returns object representation of address\n */\n\nexport var cellAddressFromString = function cellAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = addressRegex.exec(stringAddress);\n  var col = columnLabelToIndex(result[6]);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = undefined;\n  }\n\n  var row = Number(result[8]) - 1;\n\n  if (result[5] === ABSOLUTE_OPERATOR && result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absolute(col, row, sheet);\n  } else if (result[5] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteCol(col, row - baseAddress.row, sheet);\n  } else if (result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteRow(col - baseAddress.col, row, sheet);\n  } else {\n    return CellAddress.relative(row - baseAddress.row, col - baseAddress.col, sheet);\n  }\n};\nexport var columnAddressFromString = function columnAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = columnRegex.exec(stringAddress);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = undefined;\n  }\n\n  var col = columnLabelToIndex(result[6]);\n\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return ColumnAddress.absolute(col, sheet);\n  } else {\n    return ColumnAddress.relative(col - baseAddress.col, sheet);\n  }\n};\nexport var rowAddressFromString = function rowAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = rowRegex.exec(stringAddress);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = undefined;\n  }\n\n  var row = Number(result[6]) - 1;\n\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return RowAddress.absolute(row, sheet);\n  } else {\n    return RowAddress.relative(row - baseAddress.row, sheet);\n  }\n};\n/**\n * Computes simple (absolute) address of a cell address based on its string representation.\n * If sheet name present in string representation but is not present in sheet mapping, returns undefined.\n * If sheet name is not present in string representation, returns {@param sheetContext} as sheet number\n *\n * @param sheetMapping - mapping function needed to change name of a sheet to index\n * @param stringAddress - string representation of cell address, e.g. 'C64'\n * @param sheetContext - sheet in context of which we should parse the address\n * @returns absolute representation of address, e.g. { sheet: 0, col: 1, row: 1 }\n */\n\nexport var simpleCellAddressFromString = function simpleCellAddressFromString(sheetMapping, stringAddress, sheetContext) {\n  var result = addressRegex.exec(stringAddress);\n  var col = columnLabelToIndex(result[6]);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = sheetContext;\n  }\n\n  var row = Number(result[8]) - 1;\n  return simpleCellAddress(sheet, col, row);\n};\nexport var simpleCellRangeFromString = function simpleCellRangeFromString(sheetMapping, stringAddress, sheetContext) {\n  var split = stringAddress.split(RANGE_OPERATOR);\n\n  if (split.length !== 2) {\n    return undefined;\n  }\n\n  var _split = _slicedToArray(split, 2),\n      startString = _split[0],\n      endString = _split[1];\n\n  var start = simpleCellAddressFromString(sheetMapping, startString, sheetContext);\n\n  if (start === undefined) {\n    return undefined;\n  }\n\n  var end = simpleCellAddressFromString(sheetMapping, endString, start.sheet);\n\n  if (end === undefined) {\n    return undefined;\n  }\n\n  if (start.sheet !== end.sheet) {\n    return undefined;\n  }\n\n  return simpleCellRange(start, end);\n};\n/**\n * Returns string representation of absolute address\n * If sheet index is not present in sheet mapping, returns undefined\n *\n * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name\n * @param address - object representation of absolute address\n * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name\n * */\n\nexport var simpleCellAddressToString = function simpleCellAddressToString(sheetIndexMapping, address, sheetIndex) {\n  var column = columnIndexToLabel(address.col);\n  var sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);\n\n  if (sheetName === undefined) {\n    return undefined;\n  }\n\n  if (sheetIndex !== address.sheet) {\n    return \"\".concat(sheetName, \"!\").concat(column).concat(address.row + 1);\n  } else {\n    return \"\".concat(column).concat(address.row + 1);\n  }\n};\nexport var simpleCellRangeToString = function simpleCellRangeToString(sheetIndexMapping, address, sheetIndex) {\n  var startString = simpleCellAddressToString(sheetIndexMapping, address.start, sheetIndex);\n  var endString = simpleCellAddressToString(sheetIndexMapping, address.end, address.start.sheet);\n\n  if (startString === undefined || endString === undefined) {\n    return undefined;\n  } else {\n    return \"\".concat(startString).concat(RANGE_OPERATOR).concat(endString);\n  }\n};\n/**\n* Convert column label to index\n*\n* @param columnStringRepresentation - column label (e.g. 'AAB')\n* @returns column index\n* */\n\nfunction columnLabelToIndex(columnStringRepresentation) {\n  if (columnStringRepresentation.length === 1) {\n    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;\n  } else {\n    return columnStringRepresentation.split('').reduce(function (currentColumn, nextLetter) {\n      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);\n    }, 0) - 1;\n  }\n}\n/**\n * Converts column index to label\n *\n * @param column - address to convert\n * @returns string representation, e.g. 'AAB'\n */\n\n\nexport function columnIndexToLabel(column) {\n  var result = '';\n\n  while (column >= 0) {\n    result = String.fromCharCode(column % 26 + 97) + result;\n    column = Math.floor(column / 26) - 1;\n  }\n\n  return result.toUpperCase();\n}\nexport function sheetIndexToString(sheetId, sheetMappingFn) {\n  var sheetName = sheetMappingFn(sheetId);\n\n  if (sheetName === undefined) {\n    return undefined;\n  }\n\n  if (simpleSheetNameRegex.test(sheetName)) {\n    return sheetName;\n  } else {\n    sheetName = sheetName.replace(/'/g, \"''\");\n    return \"'\".concat(sheetName, \"'\");\n  }\n}\n\nfunction extractSheetNumber(regexResult, sheetMapping) {\n  var _a;\n\n  var maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];\n\n  if (maybeSheetName) {\n    maybeSheetName = maybeSheetName.replace(/''/g, \"'\");\n    return sheetMapping(maybeSheetName);\n  } else {\n    return null;\n  }\n}"]},"metadata":{},"sourceType":"module"}