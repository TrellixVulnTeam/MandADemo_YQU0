{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { absoluteSheetReference, invalidSimpleColumnAddress, simpleColumnAddress } from '../Cell';\nimport { columnIndexToLabel } from './addressRepresentationConverters';\nexport var ReferenceType;\n\n(function (ReferenceType) {\n  ReferenceType[\"RELATIVE\"] = \"RELATIVE\";\n  ReferenceType[\"ABSOLUTE\"] = \"ABSOLUTE\";\n})(ReferenceType || (ReferenceType = {}));\n\nexport var ColumnAddress = /*#__PURE__*/function () {\n  function ColumnAddress(type, col, sheet) {\n    _classCallCheck(this, ColumnAddress);\n\n    this.type = type;\n    this.col = col;\n    this.sheet = sheet;\n  }\n\n  _createClass(ColumnAddress, [{\n    key: \"isColumnAbsolute\",\n    value: function isColumnAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE;\n    }\n  }, {\n    key: \"isColumnRelative\",\n    value: function isColumnRelative() {\n      return this.type === ReferenceType.RELATIVE;\n    }\n  }, {\n    key: \"isAbsolute\",\n    value: function isAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n    }\n  }, {\n    key: \"moved\",\n    value: function moved(toSheet, toRight, _toBottom) {\n      var newSheet = this.sheet === undefined ? undefined : toSheet;\n      return new ColumnAddress(this.type, this.col + toRight, newSheet);\n    }\n  }, {\n    key: \"shiftedByColumns\",\n    value: function shiftedByColumns(numberOfColumns) {\n      return new ColumnAddress(this.type, this.col + numberOfColumns, this.sheet);\n    }\n  }, {\n    key: \"toSimpleColumnAddress\",\n    value: function toSimpleColumnAddress(baseAddress) {\n      var sheet = absoluteSheetReference(this, baseAddress);\n      var column = this.col;\n\n      if (this.isColumnRelative()) {\n        column = baseAddress.col + this.col;\n      }\n\n      return simpleColumnAddress(sheet, column);\n    }\n  }, {\n    key: \"shiftRelativeDimensions\",\n    value: function shiftRelativeDimensions(toRight, _toBottom) {\n      var col = this.isColumnRelative() ? this.col + toRight : this.col;\n      return new ColumnAddress(this.type, col, this.sheet);\n    }\n  }, {\n    key: \"shiftAbsoluteDimensions\",\n    value: function shiftAbsoluteDimensions(toRight, _toBottom) {\n      var col = this.isColumnAbsolute() ? this.col + toRight : this.col;\n      return new ColumnAddress(this.type, col, this.sheet);\n    }\n  }, {\n    key: \"withAbsoluteSheet\",\n    value: function withAbsoluteSheet(sheet) {\n      return new ColumnAddress(this.type, this.col, sheet);\n    }\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid(baseAddress) {\n      return this.toSimpleColumnAddress(baseAddress).col < 0;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(withSheet) {\n      var sheetPart = withSheet && this.sheet !== undefined ? \"#\".concat(this.sheet) : '';\n\n      switch (this.type) {\n        case ReferenceType.RELATIVE:\n          {\n            return \"\".concat(sheetPart, \"#COLR\").concat(this.col);\n          }\n\n        case ReferenceType.ABSOLUTE:\n          {\n            return \"\".concat(sheetPart, \"#COLA\").concat(this.col);\n          }\n      }\n    }\n  }, {\n    key: \"unparse\",\n    value: function unparse(baseAddress) {\n      var simpleAddress = this.toSimpleColumnAddress(baseAddress);\n\n      if (invalidSimpleColumnAddress(simpleAddress)) {\n        return undefined;\n      }\n\n      var column = columnIndexToLabel(simpleAddress.col);\n      var dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n      return \"\".concat(dollar).concat(column);\n    }\n  }, {\n    key: \"exceedsSheetSizeLimits\",\n    value: function exceedsSheetSizeLimits(maxColumns) {\n      return this.col >= maxColumns;\n    }\n  }], [{\n    key: \"absolute\",\n    value: function absolute(column, sheet) {\n      return new ColumnAddress(ReferenceType.ABSOLUTE, column, sheet);\n    }\n  }, {\n    key: \"relative\",\n    value: function relative(column, sheet) {\n      return new ColumnAddress(ReferenceType.RELATIVE, column, sheet);\n    }\n  }]);\n\n  return ColumnAddress;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/ColumnAddress.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","absoluteSheetReference","invalidSimpleColumnAddress","simpleColumnAddress","columnIndexToLabel","ReferenceType","ColumnAddress","type","col","sheet","value","isColumnAbsolute","ABSOLUTE","isColumnRelative","RELATIVE","isAbsolute","undefined","moved","toSheet","toRight","_toBottom","newSheet","shiftedByColumns","numberOfColumns","toSimpleColumnAddress","baseAddress","column","shiftRelativeDimensions","shiftAbsoluteDimensions","withAbsoluteSheet","isInvalid","hash","withSheet","sheetPart","concat","unparse","simpleAddress","dollar","exceedsSheetSizeLimits","maxColumns","absolute","relative"],"mappings":"AAEA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;AAEvN;AACA;AACA;AACA;;;AACA,SAASkB,sBAAT,EAAiCC,0BAAjC,EAA6DC,mBAA7D,QAAwF,SAAxF;AACA,SAASC,kBAAT,QAAmC,mCAAnC;AACA,OAAO,IAAIC,aAAJ;;AAEP,CAAC,UAAUA,aAAV,EAAyB;AACxBA,EAAAA,aAAa,CAAC,UAAD,CAAb,GAA4B,UAA5B;AACAA,EAAAA,aAAa,CAAC,UAAD,CAAb,GAA4B,UAA5B;AACD,CAHD,EAGGA,aAAa,KAAKA,aAAa,GAAG,EAArB,CAHhB;;AAKA,OAAO,IAAIC,aAAa,GAAG,aAAa,YAAY;AAClD,WAASA,aAAT,CAAuBC,IAAvB,EAA6BC,GAA7B,EAAkCC,KAAlC,EAAyC;AACvC5B,IAAAA,eAAe,CAAC,IAAD,EAAOyB,aAAP,CAAf;;AAEA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;;AAEDZ,EAAAA,YAAY,CAACS,aAAD,EAAgB,CAAC;AAC3BV,IAAAA,GAAG,EAAE,kBADsB;AAE3Bc,IAAAA,KAAK,EAAE,SAASC,gBAAT,GAA4B;AACjC,aAAO,KAAKJ,IAAL,KAAcF,aAAa,CAACO,QAAnC;AACD;AAJ0B,GAAD,EAKzB;AACDhB,IAAAA,GAAG,EAAE,kBADJ;AAEDc,IAAAA,KAAK,EAAE,SAASG,gBAAT,GAA4B;AACjC,aAAO,KAAKN,IAAL,KAAcF,aAAa,CAACS,QAAnC;AACD;AAJA,GALyB,EAUzB;AACDlB,IAAAA,GAAG,EAAE,YADJ;AAEDc,IAAAA,KAAK,EAAE,SAASK,UAAT,GAAsB;AAC3B,aAAO,KAAKR,IAAL,KAAcF,aAAa,CAACO,QAA5B,IAAwC,KAAKH,KAAL,KAAeO,SAA9D;AACD;AAJA,GAVyB,EAezB;AACDpB,IAAAA,GAAG,EAAE,OADJ;AAEDc,IAAAA,KAAK,EAAE,SAASO,KAAT,CAAeC,OAAf,EAAwBC,OAAxB,EAAiCC,SAAjC,EAA4C;AACjD,UAAIC,QAAQ,GAAG,KAAKZ,KAAL,KAAeO,SAAf,GAA2BA,SAA3B,GAAuCE,OAAtD;AACA,aAAO,IAAIZ,aAAJ,CAAkB,KAAKC,IAAvB,EAA6B,KAAKC,GAAL,GAAWW,OAAxC,EAAiDE,QAAjD,CAAP;AACD;AALA,GAfyB,EAqBzB;AACDzB,IAAAA,GAAG,EAAE,kBADJ;AAEDc,IAAAA,KAAK,EAAE,SAASY,gBAAT,CAA0BC,eAA1B,EAA2C;AAChD,aAAO,IAAIjB,aAAJ,CAAkB,KAAKC,IAAvB,EAA6B,KAAKC,GAAL,GAAWe,eAAxC,EAAyD,KAAKd,KAA9D,CAAP;AACD;AAJA,GArByB,EA0BzB;AACDb,IAAAA,GAAG,EAAE,uBADJ;AAEDc,IAAAA,KAAK,EAAE,SAASc,qBAAT,CAA+BC,WAA/B,EAA4C;AACjD,UAAIhB,KAAK,GAAGR,sBAAsB,CAAC,IAAD,EAAOwB,WAAP,CAAlC;AACA,UAAIC,MAAM,GAAG,KAAKlB,GAAlB;;AAEA,UAAI,KAAKK,gBAAL,EAAJ,EAA6B;AAC3Ba,QAAAA,MAAM,GAAGD,WAAW,CAACjB,GAAZ,GAAkB,KAAKA,GAAhC;AACD;;AAED,aAAOL,mBAAmB,CAACM,KAAD,EAAQiB,MAAR,CAA1B;AACD;AAXA,GA1ByB,EAsCzB;AACD9B,IAAAA,GAAG,EAAE,yBADJ;AAEDc,IAAAA,KAAK,EAAE,SAASiB,uBAAT,CAAiCR,OAAjC,EAA0CC,SAA1C,EAAqD;AAC1D,UAAIZ,GAAG,GAAG,KAAKK,gBAAL,KAA0B,KAAKL,GAAL,GAAWW,OAArC,GAA+C,KAAKX,GAA9D;AACA,aAAO,IAAIF,aAAJ,CAAkB,KAAKC,IAAvB,EAA6BC,GAA7B,EAAkC,KAAKC,KAAvC,CAAP;AACD;AALA,GAtCyB,EA4CzB;AACDb,IAAAA,GAAG,EAAE,yBADJ;AAEDc,IAAAA,KAAK,EAAE,SAASkB,uBAAT,CAAiCT,OAAjC,EAA0CC,SAA1C,EAAqD;AAC1D,UAAIZ,GAAG,GAAG,KAAKG,gBAAL,KAA0B,KAAKH,GAAL,GAAWW,OAArC,GAA+C,KAAKX,GAA9D;AACA,aAAO,IAAIF,aAAJ,CAAkB,KAAKC,IAAvB,EAA6BC,GAA7B,EAAkC,KAAKC,KAAvC,CAAP;AACD;AALA,GA5CyB,EAkDzB;AACDb,IAAAA,GAAG,EAAE,mBADJ;AAEDc,IAAAA,KAAK,EAAE,SAASmB,iBAAT,CAA2BpB,KAA3B,EAAkC;AACvC,aAAO,IAAIH,aAAJ,CAAkB,KAAKC,IAAvB,EAA6B,KAAKC,GAAlC,EAAuCC,KAAvC,CAAP;AACD;AAJA,GAlDyB,EAuDzB;AACDb,IAAAA,GAAG,EAAE,WADJ;AAEDc,IAAAA,KAAK,EAAE,SAASoB,SAAT,CAAmBL,WAAnB,EAAgC;AACrC,aAAO,KAAKD,qBAAL,CAA2BC,WAA3B,EAAwCjB,GAAxC,GAA8C,CAArD;AACD;AAJA,GAvDyB,EA4DzB;AACDZ,IAAAA,GAAG,EAAE,MADJ;AAEDc,IAAAA,KAAK,EAAE,SAASqB,IAAT,CAAcC,SAAd,EAAyB;AAC9B,UAAIC,SAAS,GAAGD,SAAS,IAAI,KAAKvB,KAAL,KAAeO,SAA5B,GAAwC,IAAIkB,MAAJ,CAAW,KAAKzB,KAAhB,CAAxC,GAAiE,EAAjF;;AAEA,cAAQ,KAAKF,IAAb;AACE,aAAKF,aAAa,CAACS,QAAnB;AACE;AACE,mBAAO,GAAGoB,MAAH,CAAUD,SAAV,EAAqB,OAArB,EAA8BC,MAA9B,CAAqC,KAAK1B,GAA1C,CAAP;AACD;;AAEH,aAAKH,aAAa,CAACO,QAAnB;AACE;AACE,mBAAO,GAAGsB,MAAH,CAAUD,SAAV,EAAqB,OAArB,EAA8BC,MAA9B,CAAqC,KAAK1B,GAA1C,CAAP;AACD;AATL;AAWD;AAhBA,GA5DyB,EA6EzB;AACDZ,IAAAA,GAAG,EAAE,SADJ;AAEDc,IAAAA,KAAK,EAAE,SAASyB,OAAT,CAAiBV,WAAjB,EAA8B;AACnC,UAAIW,aAAa,GAAG,KAAKZ,qBAAL,CAA2BC,WAA3B,CAApB;;AAEA,UAAIvB,0BAA0B,CAACkC,aAAD,CAA9B,EAA+C;AAC7C,eAAOpB,SAAP;AACD;;AAED,UAAIU,MAAM,GAAGtB,kBAAkB,CAACgC,aAAa,CAAC5B,GAAf,CAA/B;AACA,UAAI6B,MAAM,GAAG,KAAK9B,IAAL,KAAcF,aAAa,CAACO,QAA5B,GAAuC,GAAvC,GAA6C,EAA1D;AACA,aAAO,GAAGsB,MAAH,CAAUG,MAAV,EAAkBH,MAAlB,CAAyBR,MAAzB,CAAP;AACD;AAZA,GA7EyB,EA0FzB;AACD9B,IAAAA,GAAG,EAAE,wBADJ;AAEDc,IAAAA,KAAK,EAAE,SAAS4B,sBAAT,CAAgCC,UAAhC,EAA4C;AACjD,aAAO,KAAK/B,GAAL,IAAY+B,UAAnB;AACD;AAJA,GA1FyB,CAAhB,EA+FR,CAAC;AACH3C,IAAAA,GAAG,EAAE,UADF;AAEHc,IAAAA,KAAK,EAAE,SAAS8B,QAAT,CAAkBd,MAAlB,EAA0BjB,KAA1B,EAAiC;AACtC,aAAO,IAAIH,aAAJ,CAAkBD,aAAa,CAACO,QAAhC,EAA0Cc,MAA1C,EAAkDjB,KAAlD,CAAP;AACD;AAJE,GAAD,EAKD;AACDb,IAAAA,GAAG,EAAE,UADJ;AAEDc,IAAAA,KAAK,EAAE,SAAS+B,QAAT,CAAkBf,MAAlB,EAA0BjB,KAA1B,EAAiC;AACtC,aAAO,IAAIH,aAAJ,CAAkBD,aAAa,CAACS,QAAhC,EAA0CY,MAA1C,EAAkDjB,KAAlD,CAAP;AACD;AAJA,GALC,CA/FQ,CAAZ;;AA2GA,SAAOH,aAAP;AACD,CArHuC,EAAjC","sourcesContent":["import \"core-js/modules/es.array.concat.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { absoluteSheetReference, invalidSimpleColumnAddress, simpleColumnAddress } from '../Cell';\nimport { columnIndexToLabel } from './addressRepresentationConverters';\nexport var ReferenceType;\n\n(function (ReferenceType) {\n  ReferenceType[\"RELATIVE\"] = \"RELATIVE\";\n  ReferenceType[\"ABSOLUTE\"] = \"ABSOLUTE\";\n})(ReferenceType || (ReferenceType = {}));\n\nexport var ColumnAddress = /*#__PURE__*/function () {\n  function ColumnAddress(type, col, sheet) {\n    _classCallCheck(this, ColumnAddress);\n\n    this.type = type;\n    this.col = col;\n    this.sheet = sheet;\n  }\n\n  _createClass(ColumnAddress, [{\n    key: \"isColumnAbsolute\",\n    value: function isColumnAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE;\n    }\n  }, {\n    key: \"isColumnRelative\",\n    value: function isColumnRelative() {\n      return this.type === ReferenceType.RELATIVE;\n    }\n  }, {\n    key: \"isAbsolute\",\n    value: function isAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n    }\n  }, {\n    key: \"moved\",\n    value: function moved(toSheet, toRight, _toBottom) {\n      var newSheet = this.sheet === undefined ? undefined : toSheet;\n      return new ColumnAddress(this.type, this.col + toRight, newSheet);\n    }\n  }, {\n    key: \"shiftedByColumns\",\n    value: function shiftedByColumns(numberOfColumns) {\n      return new ColumnAddress(this.type, this.col + numberOfColumns, this.sheet);\n    }\n  }, {\n    key: \"toSimpleColumnAddress\",\n    value: function toSimpleColumnAddress(baseAddress) {\n      var sheet = absoluteSheetReference(this, baseAddress);\n      var column = this.col;\n\n      if (this.isColumnRelative()) {\n        column = baseAddress.col + this.col;\n      }\n\n      return simpleColumnAddress(sheet, column);\n    }\n  }, {\n    key: \"shiftRelativeDimensions\",\n    value: function shiftRelativeDimensions(toRight, _toBottom) {\n      var col = this.isColumnRelative() ? this.col + toRight : this.col;\n      return new ColumnAddress(this.type, col, this.sheet);\n    }\n  }, {\n    key: \"shiftAbsoluteDimensions\",\n    value: function shiftAbsoluteDimensions(toRight, _toBottom) {\n      var col = this.isColumnAbsolute() ? this.col + toRight : this.col;\n      return new ColumnAddress(this.type, col, this.sheet);\n    }\n  }, {\n    key: \"withAbsoluteSheet\",\n    value: function withAbsoluteSheet(sheet) {\n      return new ColumnAddress(this.type, this.col, sheet);\n    }\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid(baseAddress) {\n      return this.toSimpleColumnAddress(baseAddress).col < 0;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(withSheet) {\n      var sheetPart = withSheet && this.sheet !== undefined ? \"#\".concat(this.sheet) : '';\n\n      switch (this.type) {\n        case ReferenceType.RELATIVE:\n          {\n            return \"\".concat(sheetPart, \"#COLR\").concat(this.col);\n          }\n\n        case ReferenceType.ABSOLUTE:\n          {\n            return \"\".concat(sheetPart, \"#COLA\").concat(this.col);\n          }\n      }\n    }\n  }, {\n    key: \"unparse\",\n    value: function unparse(baseAddress) {\n      var simpleAddress = this.toSimpleColumnAddress(baseAddress);\n\n      if (invalidSimpleColumnAddress(simpleAddress)) {\n        return undefined;\n      }\n\n      var column = columnIndexToLabel(simpleAddress.col);\n      var dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n      return \"\".concat(dollar).concat(column);\n    }\n  }, {\n    key: \"exceedsSheetSizeLimits\",\n    value: function exceedsSheetSizeLimits(maxColumns) {\n      return this.col >= maxColumns;\n    }\n  }], [{\n    key: \"absolute\",\n    value: function absolute(column, sheet) {\n      return new ColumnAddress(ReferenceType.ABSOLUTE, column, sheet);\n    }\n  }, {\n    key: \"relative\",\n    value: function relative(column, sheet) {\n      return new ColumnAddress(ReferenceType.RELATIVE, column, sheet);\n    }\n  }]);\n\n  return ColumnAddress;\n}();"]},"metadata":{},"sourceType":"module"}