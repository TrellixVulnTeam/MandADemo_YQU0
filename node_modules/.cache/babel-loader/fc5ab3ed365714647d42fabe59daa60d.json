{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { FormulaCellVertex, MatrixVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { ErrorMessage } from './error-message';\nimport { EmptyValue, getFormatOfExtendedNumber, getTypeOfExtendedNumber, isExtendedNumber, NumberType } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './interpreter/SimpleRangeValue';\n/**\n * Possible errors returned by our interpreter.\n */\n\nexport var ErrorType;\n\n(function (ErrorType) {\n  /** Division by zero. */\n  ErrorType[\"DIV_BY_ZERO\"] = \"DIV_BY_ZERO\";\n  /** Unknown function name. */\n\n  ErrorType[\"NAME\"] = \"NAME\";\n  ErrorType[\"VALUE\"] = \"VALUE\";\n  ErrorType[\"NUM\"] = \"NUM\";\n  ErrorType[\"NA\"] = \"NA\";\n  /** Cyclic dependency. */\n\n  ErrorType[\"CYCLE\"] = \"CYCLE\";\n  /** Wrong address reference. */\n\n  ErrorType[\"REF\"] = \"REF\";\n  /** Invalid/missing licence error. */\n\n  ErrorType[\"LIC\"] = \"LIC\";\n  /** Generic error */\n\n  ErrorType[\"ERROR\"] = \"ERROR\";\n})(ErrorType || (ErrorType = {}));\n\nexport var CellType;\n\n(function (CellType) {\n  CellType[\"FORMULA\"] = \"FORMULA\";\n  CellType[\"VALUE\"] = \"VALUE\";\n  CellType[\"MATRIX\"] = \"MATRIX\";\n  CellType[\"EMPTY\"] = \"EMPTY\";\n})(CellType || (CellType = {}));\n\nexport var getCellType = function getCellType(vertex) {\n  if (vertex instanceof FormulaCellVertex || vertex instanceof ParsingErrorVertex) {\n    return CellType.FORMULA;\n  }\n\n  if (vertex instanceof ValueCellVertex || vertex instanceof MatrixVertex && vertex.isNumeric()) {\n    return CellType.VALUE;\n  }\n\n  if (vertex instanceof MatrixVertex && vertex.isFormula()) {\n    return CellType.MATRIX;\n  }\n\n  return CellType.EMPTY;\n};\nexport var CellValueNoNumber;\n\n(function (CellValueNoNumber) {\n  CellValueNoNumber[\"EMPTY\"] = \"EMPTY\";\n  CellValueNoNumber[\"NUMBER\"] = \"NUMBER\";\n  CellValueNoNumber[\"STRING\"] = \"STRING\";\n  CellValueNoNumber[\"BOOLEAN\"] = \"BOOLEAN\";\n  CellValueNoNumber[\"ERROR\"] = \"ERROR\";\n})(CellValueNoNumber || (CellValueNoNumber = {}));\n\nexport var CellValueJustNumber;\n\n(function (CellValueJustNumber) {\n  CellValueJustNumber[\"NUMBER\"] = \"NUMBER\";\n})(CellValueJustNumber || (CellValueJustNumber = {}));\n\nexport var CellValueType = Object.assign(Object.assign({}, CellValueNoNumber), CellValueJustNumber);\nexport var CellValueDetailedType = Object.assign(Object.assign({}, CellValueNoNumber), NumberType);\nexport var CellValueTypeOrd = function CellValueTypeOrd(arg) {\n  switch (arg) {\n    case CellValueType.EMPTY:\n      return 0;\n\n    case CellValueType.NUMBER:\n      return 1;\n\n    case CellValueType.STRING:\n      return 2;\n\n    case CellValueType.BOOLEAN:\n      return 3;\n\n    case CellValueType.ERROR:\n      return 4;\n  }\n\n  throw new Error('Cell value not computed');\n};\nexport var getCellValueType = function getCellValueType(cellValue) {\n  if (cellValue === EmptyValue) {\n    return CellValueType.EMPTY;\n  }\n\n  if (cellValue instanceof CellError || cellValue instanceof SimpleRangeValue) {\n    return CellValueType.ERROR;\n  }\n\n  if (typeof cellValue === 'string') {\n    return CellValueType.STRING;\n  } else if (isExtendedNumber(cellValue)) {\n    return CellValueType.NUMBER;\n  } else if (typeof cellValue === 'boolean') {\n    return CellValueType.BOOLEAN;\n  }\n\n  throw new Error('Cell value not computed');\n};\nexport var getCellValueDetailedType = function getCellValueDetailedType(cellValue) {\n  if (isExtendedNumber(cellValue)) {\n    return getTypeOfExtendedNumber(cellValue);\n  } else {\n    return getCellValueType(cellValue);\n  }\n};\nexport var getCellValueFormat = function getCellValueFormat(cellValue) {\n  if (isExtendedNumber(cellValue)) {\n    return getFormatOfExtendedNumber(cellValue);\n  } else {\n    return undefined;\n  }\n};\nexport var CellError = /*#__PURE__*/function () {\n  function CellError(type, message, address) {\n    _classCallCheck(this, CellError);\n\n    this.type = type;\n    this.message = message;\n    this.address = address;\n  }\n\n  _createClass(CellError, [{\n    key: \"attachAddress\",\n    value: function attachAddress(address) {\n      if (this.address === undefined) {\n        return new CellError(this.type, this.message, address);\n      } else {\n        return this;\n      }\n    }\n  }], [{\n    key: \"parsingError\",\n    value: function parsingError() {\n      return new CellError(ErrorType.ERROR, ErrorMessage.ParseError);\n    }\n  }]);\n\n  return CellError;\n}();\nexport var simpleRowAddress = function simpleRowAddress(sheet, row) {\n  return {\n    sheet: sheet,\n    row: row\n  };\n};\nexport var invalidSimpleRowAddress = function invalidSimpleRowAddress(address) {\n  return address.row < 0;\n};\nexport var simpleColumnAddress = function simpleColumnAddress(sheet, col) {\n  return {\n    sheet: sheet,\n    col: col\n  };\n};\nexport var invalidSimpleColumnAddress = function invalidSimpleColumnAddress(address) {\n  return address.col < 0;\n};\nexport var simpleCellAddress = function simpleCellAddress(sheet, col, row) {\n  return {\n    sheet: sheet,\n    col: col,\n    row: row\n  };\n};\nexport var invalidSimpleCellAddress = function invalidSimpleCellAddress(address) {\n  return address.col < 0 || address.row < 0;\n};\nexport var movedSimpleCellAddress = function movedSimpleCellAddress(address, toSheet, toRight, toBottom) {\n  return simpleCellAddress(toSheet, address.col + toRight, address.row + toBottom);\n};\nexport var absoluteSheetReference = function absoluteSheetReference(address, baseAddress) {\n  return address.sheet === null ? baseAddress.sheet : address.sheet;\n};","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/Cell.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","FormulaCellVertex","MatrixVertex","ParsingErrorVertex","ValueCellVertex","ErrorMessage","EmptyValue","getFormatOfExtendedNumber","getTypeOfExtendedNumber","isExtendedNumber","NumberType","SimpleRangeValue","ErrorType","CellType","getCellType","vertex","FORMULA","isNumeric","VALUE","isFormula","MATRIX","EMPTY","CellValueNoNumber","CellValueJustNumber","CellValueType","assign","CellValueDetailedType","CellValueTypeOrd","arg","NUMBER","STRING","BOOLEAN","ERROR","Error","getCellValueType","cellValue","CellError","getCellValueDetailedType","getCellValueFormat","undefined","type","message","address","value","attachAddress","parsingError","ParseError","simpleRowAddress","sheet","row","invalidSimpleRowAddress","simpleColumnAddress","col","invalidSimpleColumnAddress","simpleCellAddress","invalidSimpleCellAddress","movedSimpleCellAddress","toSheet","toRight","toBottom","absoluteSheetReference","baseAddress"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport \"core-js/modules/es.object.assign.js\";\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { FormulaCellVertex, MatrixVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { ErrorMessage } from './error-message';\nimport { EmptyValue, getFormatOfExtendedNumber, getTypeOfExtendedNumber, isExtendedNumber, NumberType } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './interpreter/SimpleRangeValue';\n/**\n * Possible errors returned by our interpreter.\n */\n\nexport var ErrorType;\n\n(function (ErrorType) {\n  /** Division by zero. */\n  ErrorType[\"DIV_BY_ZERO\"] = \"DIV_BY_ZERO\";\n  /** Unknown function name. */\n\n  ErrorType[\"NAME\"] = \"NAME\";\n  ErrorType[\"VALUE\"] = \"VALUE\";\n  ErrorType[\"NUM\"] = \"NUM\";\n  ErrorType[\"NA\"] = \"NA\";\n  /** Cyclic dependency. */\n\n  ErrorType[\"CYCLE\"] = \"CYCLE\";\n  /** Wrong address reference. */\n\n  ErrorType[\"REF\"] = \"REF\";\n  /** Invalid/missing licence error. */\n\n  ErrorType[\"LIC\"] = \"LIC\";\n  /** Generic error */\n\n  ErrorType[\"ERROR\"] = \"ERROR\";\n})(ErrorType || (ErrorType = {}));\n\nexport var CellType;\n\n(function (CellType) {\n  CellType[\"FORMULA\"] = \"FORMULA\";\n  CellType[\"VALUE\"] = \"VALUE\";\n  CellType[\"MATRIX\"] = \"MATRIX\";\n  CellType[\"EMPTY\"] = \"EMPTY\";\n})(CellType || (CellType = {}));\n\nexport var getCellType = function getCellType(vertex) {\n  if (vertex instanceof FormulaCellVertex || vertex instanceof ParsingErrorVertex) {\n    return CellType.FORMULA;\n  }\n\n  if (vertex instanceof ValueCellVertex || vertex instanceof MatrixVertex && vertex.isNumeric()) {\n    return CellType.VALUE;\n  }\n\n  if (vertex instanceof MatrixVertex && vertex.isFormula()) {\n    return CellType.MATRIX;\n  }\n\n  return CellType.EMPTY;\n};\nexport var CellValueNoNumber;\n\n(function (CellValueNoNumber) {\n  CellValueNoNumber[\"EMPTY\"] = \"EMPTY\";\n  CellValueNoNumber[\"NUMBER\"] = \"NUMBER\";\n  CellValueNoNumber[\"STRING\"] = \"STRING\";\n  CellValueNoNumber[\"BOOLEAN\"] = \"BOOLEAN\";\n  CellValueNoNumber[\"ERROR\"] = \"ERROR\";\n})(CellValueNoNumber || (CellValueNoNumber = {}));\n\nexport var CellValueJustNumber;\n\n(function (CellValueJustNumber) {\n  CellValueJustNumber[\"NUMBER\"] = \"NUMBER\";\n})(CellValueJustNumber || (CellValueJustNumber = {}));\n\nexport var CellValueType = Object.assign(Object.assign({}, CellValueNoNumber), CellValueJustNumber);\nexport var CellValueDetailedType = Object.assign(Object.assign({}, CellValueNoNumber), NumberType);\nexport var CellValueTypeOrd = function CellValueTypeOrd(arg) {\n  switch (arg) {\n    case CellValueType.EMPTY:\n      return 0;\n\n    case CellValueType.NUMBER:\n      return 1;\n\n    case CellValueType.STRING:\n      return 2;\n\n    case CellValueType.BOOLEAN:\n      return 3;\n\n    case CellValueType.ERROR:\n      return 4;\n  }\n\n  throw new Error('Cell value not computed');\n};\nexport var getCellValueType = function getCellValueType(cellValue) {\n  if (cellValue === EmptyValue) {\n    return CellValueType.EMPTY;\n  }\n\n  if (cellValue instanceof CellError || cellValue instanceof SimpleRangeValue) {\n    return CellValueType.ERROR;\n  }\n\n  if (typeof cellValue === 'string') {\n    return CellValueType.STRING;\n  } else if (isExtendedNumber(cellValue)) {\n    return CellValueType.NUMBER;\n  } else if (typeof cellValue === 'boolean') {\n    return CellValueType.BOOLEAN;\n  }\n\n  throw new Error('Cell value not computed');\n};\nexport var getCellValueDetailedType = function getCellValueDetailedType(cellValue) {\n  if (isExtendedNumber(cellValue)) {\n    return getTypeOfExtendedNumber(cellValue);\n  } else {\n    return getCellValueType(cellValue);\n  }\n};\nexport var getCellValueFormat = function getCellValueFormat(cellValue) {\n  if (isExtendedNumber(cellValue)) {\n    return getFormatOfExtendedNumber(cellValue);\n  } else {\n    return undefined;\n  }\n};\nexport var CellError = /*#__PURE__*/function () {\n  function CellError(type, message, address) {\n    _classCallCheck(this, CellError);\n\n    this.type = type;\n    this.message = message;\n    this.address = address;\n  }\n\n  _createClass(CellError, [{\n    key: \"attachAddress\",\n    value: function attachAddress(address) {\n      if (this.address === undefined) {\n        return new CellError(this.type, this.message, address);\n      } else {\n        return this;\n      }\n    }\n  }], [{\n    key: \"parsingError\",\n    value: function parsingError() {\n      return new CellError(ErrorType.ERROR, ErrorMessage.ParseError);\n    }\n  }]);\n\n  return CellError;\n}();\nexport var simpleRowAddress = function simpleRowAddress(sheet, row) {\n  return {\n    sheet: sheet,\n    row: row\n  };\n};\nexport var invalidSimpleRowAddress = function invalidSimpleRowAddress(address) {\n  return address.row < 0;\n};\nexport var simpleColumnAddress = function simpleColumnAddress(sheet, col) {\n  return {\n    sheet: sheet,\n    col: col\n  };\n};\nexport var invalidSimpleColumnAddress = function invalidSimpleColumnAddress(address) {\n  return address.col < 0;\n};\nexport var simpleCellAddress = function simpleCellAddress(sheet, col, row) {\n  return {\n    sheet: sheet,\n    col: col,\n    row: row\n  };\n};\nexport var invalidSimpleCellAddress = function invalidSimpleCellAddress(address) {\n  return address.col < 0 || address.row < 0;\n};\nexport var movedSimpleCellAddress = function movedSimpleCellAddress(address, toSheet, toRight, toBottom) {\n  return simpleCellAddress(toSheet, address.col + toRight, address.row + toBottom);\n};\nexport var absoluteSheetReference = function absoluteSheetReference(address, baseAddress) {\n  return address.sheet === null ? baseAddress.sheet : address.sheet;\n};"]},"metadata":{},"sourceType":"module"}