{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { EmptyValue, getRawValue } from './interpreter/InterpreterValue';\nimport { ClipboardCellType } from './ClipboardOperations';\nimport { invalidSimpleCellAddress, simpleCellAddress } from './Cell';\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { absolutizeDependencies, filterDependenciesOutOfScope } from './absolutizeDependencies';\nimport { CellContent } from './CellContentParser';\nimport { ContentChanges } from './ContentChanges';\nimport { EmptyCellVertex, FormulaCellVertex, MatrixVertex, ParsingErrorVertex, SparseStrategy, ValueCellVertex } from './DependencyGraph';\nimport { AddColumnsTransformer } from './dependencyTransformers/AddColumnsTransformer';\nimport { AddRowsTransformer } from './dependencyTransformers/AddRowsTransformer';\nimport { MoveCellsTransformer } from './dependencyTransformers/MoveCellsTransformer';\nimport { RemoveColumnsTransformer } from './dependencyTransformers/RemoveColumnsTransformer';\nimport { RemoveRowsTransformer } from './dependencyTransformers/RemoveRowsTransformer';\nimport { RemoveSheetTransformer } from './dependencyTransformers/RemoveSheetTransformer';\nimport { InvalidArgumentsError, NamedExpressionDoesNotExistError, NoRelativeAddressesAllowedError, SheetSizeLimitExceededError, SourceLocationHasMatrixError, TargetLocationHasMatrixError } from './errors';\nimport { buildMatrixVertex } from './GraphBuilder';\nimport { doesContainRelativeReferences } from './NamedExpressions';\nimport { NamedExpressionDependency } from './parser';\nimport { findBoundaries } from './Sheet';\nimport { ColumnsSpan, RowsSpan } from './Span';\nimport { StatType } from './statistics';\nimport { CleanOutOfScopeDependenciesTransformer } from './dependencyTransformers/CleanOutOfScopeDependenciesTransformer';\nexport var RemoveRowsCommand = /*#__PURE__*/function () {\n  function RemoveRowsCommand(sheet, indexes) {\n    _classCallCheck(this, RemoveRowsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(RemoveRowsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeRemovedIndexes(this.indexes);\n    }\n  }, {\n    key: \"rowsSpans\",\n    value: function rowsSpans() {\n      var _this = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return RowsSpan.fromNumberOfRows(_this.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return RemoveRowsCommand;\n}();\nexport var AddRowsCommand = /*#__PURE__*/function () {\n  function AddRowsCommand(sheet, indexes) {\n    _classCallCheck(this, AddRowsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(AddRowsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeAddedIndexes(this.indexes);\n    }\n  }, {\n    key: \"rowsSpans\",\n    value: function rowsSpans() {\n      var _this2 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return RowsSpan.fromNumberOfRows(_this2.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return AddRowsCommand;\n}();\nexport var AddColumnsCommand = /*#__PURE__*/function () {\n  function AddColumnsCommand(sheet, indexes) {\n    _classCallCheck(this, AddColumnsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(AddColumnsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeAddedIndexes(this.indexes);\n    }\n  }, {\n    key: \"columnsSpans\",\n    value: function columnsSpans() {\n      var _this3 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return ColumnsSpan.fromNumberOfColumns(_this3.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return AddColumnsCommand;\n}();\nexport var RemoveColumnsCommand = /*#__PURE__*/function () {\n  function RemoveColumnsCommand(sheet, indexes) {\n    _classCallCheck(this, RemoveColumnsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(RemoveColumnsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeRemovedIndexes(this.indexes);\n    }\n  }, {\n    key: \"columnsSpans\",\n    value: function columnsSpans() {\n      var _this4 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return ColumnsSpan.fromNumberOfColumns(_this4.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return RemoveColumnsCommand;\n}();\nexport var Operations = /*#__PURE__*/function () {\n  function Operations(dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, config) {\n    _classCallCheck(this, Operations);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.cellContentParser = cellContentParser;\n    this.parser = parser;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.config = config;\n    this.changes = ContentChanges.empty();\n    this.allocateNamedExpressionAddressSpace();\n  }\n\n  _createClass(Operations, [{\n    key: \"removeRows\",\n    value: function removeRows(cmd) {\n      var rowsRemovals = [];\n\n      var _iterator = _createForOfIteratorHelper(cmd.rowsSpans()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rowsToRemove = _step.value;\n          var rowsRemoval = this.doRemoveRows(rowsToRemove);\n\n          if (rowsRemoval) {\n            rowsRemovals.push(rowsRemoval);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return rowsRemovals;\n    }\n  }, {\n    key: \"addRows\",\n    value: function addRows(cmd) {\n      var _iterator2 = _createForOfIteratorHelper(cmd.rowsSpans()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var addedRows = _step2.value;\n          this.doAddRows(addedRows);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(cmd) {\n      var _iterator3 = _createForOfIteratorHelper(cmd.columnsSpans()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var addedColumns = _step3.value;\n          this.doAddColumns(addedColumns);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(cmd) {\n      var columnsRemovals = [];\n\n      var _iterator4 = _createForOfIteratorHelper(cmd.columnsSpans()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var columnsToRemove = _step4.value;\n          var columnsRemoval = this.doRemoveColumns(columnsToRemove);\n\n          if (columnsRemoval) {\n            columnsRemovals.push(columnsRemoval);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return columnsRemovals;\n    }\n  }, {\n    key: \"removeSheet\",\n    value: function removeSheet(sheetName) {\n      var _this5 = this;\n\n      var sheetId = this.sheetMapping.fetch(sheetName);\n      this.dependencyGraph.removeSheet(sheetId);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveSheetTransformer(sheetId);\n        transformation.performEagerTransformations(_this5.dependencyGraph, _this5.parser);\n        version = _this5.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.sheetMapping.removeSheet(sheetId);\n      this.columnSearch.removeSheet(sheetId);\n      var scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(function (namedexpression) {\n        return _this5.removeNamedExpression(namedexpression.normalizeExpressionName(), sheetId);\n      });\n      return {\n        version: version,\n        scopedNamedExpressions: scopedNamedExpressions\n      };\n    }\n  }, {\n    key: \"clearSheet\",\n    value: function clearSheet(sheetId) {\n      this.dependencyGraph.clearSheet(sheetId);\n      this.columnSearch.removeSheet(sheetId);\n    }\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(name) {\n      var sheetId = this.sheetMapping.addSheet(name);\n      var sheet = [];\n      this.dependencyGraph.addressMapping.autoAddSheet(sheetId, sheet, findBoundaries(sheet));\n      return this.sheetMapping.fetchDisplayName(sheetId);\n    }\n  }, {\n    key: \"renameSheet\",\n    value: function renameSheet(sheetId, newName) {\n      return this.sheetMapping.renameSheet(sheetId, newName);\n    }\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(sheet, startRow, numberOfRows, targetRow) {\n      var rowsToAdd = RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);\n      this.lazilyTransformingAstService.beginCombinedMode(sheet);\n      this.doAddRows(rowsToAdd);\n\n      if (targetRow < startRow) {\n        startRow += numberOfRows;\n      }\n\n      var startAddress = simpleCellAddress(sheet, 0, startRow);\n      var targetAddress = simpleCellAddress(sheet, 0, targetRow);\n      this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);\n      var rowsToRemove = RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);\n      this.doRemoveRows(rowsToRemove);\n      return this.lazilyTransformingAstService.commitCombinedMode();\n    }\n  }, {\n    key: \"moveColumns\",\n    value: function moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n      var columnsToAdd = ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);\n      this.lazilyTransformingAstService.beginCombinedMode(sheet);\n      this.doAddColumns(columnsToAdd);\n\n      if (targetColumn < startColumn) {\n        startColumn += numberOfColumns;\n      }\n\n      var startAddress = simpleCellAddress(sheet, startColumn, 0);\n      var targetAddress = simpleCellAddress(sheet, targetColumn, 0);\n      this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);\n      var columnsToRemove = ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);\n      this.doRemoveColumns(columnsToRemove);\n      return this.lazilyTransformingAstService.commitCombinedMode();\n    }\n  }, {\n    key: \"moveCells\",\n    value: function moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      var _this6 = this;\n\n      this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n      var sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n      this.dependencyGraph.breakNumericMatricesInRange(sourceRange);\n      this.dependencyGraph.breakNumericMatricesInRange(targetRange);\n      var toRight = destinationLeftCorner.col - sourceLeftCorner.col;\n      var toBottom = destinationLeftCorner.row - sourceLeftCorner.row;\n      var toSheet = destinationLeftCorner.sheet;\n      var currentDataAtTarget = this.getRangeClipboardCells(targetRange);\n      var valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);\n      this.columnSearch.removeValues(valuesToRemove);\n      var valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);\n      this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);\n        transformation.performEagerTransformations(_this6.dependencyGraph, _this6.parser);\n        version = _this6.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);\n      var addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);\n      return {\n        version: version,\n        overwrittenCellsData: currentDataAtTarget,\n        addedGlobalNamedExpressions: addedGlobalNamedExpressions\n      };\n    }\n  }, {\n    key: \"setRowOrder\",\n    value: function setRowOrder(sheetId, rowMapping) {\n      var _this7 = this;\n\n      var buffer = [];\n      var oldContent = [];\n\n      var _iterator5 = _createForOfIteratorHelper(rowMapping),\n          _step5;\n\n      try {\n        var _loop = function _loop() {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              source = _step5$value[0],\n              target = _step5$value[1];\n\n          if (source !== target) {\n            var rowRange = AbsoluteCellRange.spanFrom({\n              sheet: sheetId,\n              col: 0,\n              row: source\n            }, Infinity, 1);\n\n            _this7.dependencyGraph.breakNumericMatricesInRange(rowRange);\n\n            var row = _this7.getRangeClipboardCells(rowRange);\n\n            oldContent = oldContent.concat(row);\n            buffer.push(row.map(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                  _ref2$ = _ref2[0],\n                  sheet = _ref2$.sheet,\n                  col = _ref2$.col,\n                  cell = _ref2[1];\n\n              return [{\n                sheet: sheet,\n                col: col,\n                row: target\n              }, cell];\n            }));\n          }\n        };\n\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      buffer.forEach(function (row) {\n        return _this7.restoreClipboardCells(sheetId, row.values());\n      });\n      return oldContent;\n    }\n  }, {\n    key: \"setColumnOrder\",\n    value: function setColumnOrder(sheetId, columnMapping) {\n      var _this8 = this;\n\n      var buffer = [];\n      var oldContent = [];\n\n      var _iterator6 = _createForOfIteratorHelper(columnMapping),\n          _step6;\n\n      try {\n        var _loop2 = function _loop2() {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              source = _step6$value[0],\n              target = _step6$value[1];\n\n          if (source !== target) {\n            var rowRange = AbsoluteCellRange.spanFrom({\n              sheet: sheetId,\n              col: source,\n              row: 0\n            }, 1, Infinity);\n\n            _this8.dependencyGraph.breakNumericMatricesInRange(rowRange);\n\n            var column = _this8.getRangeClipboardCells(rowRange);\n\n            oldContent = oldContent.concat(column);\n            buffer.push(column.map(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                  _ref4$ = _ref4[0],\n                  sheet = _ref4$.sheet,\n                  col = _ref4$.col,\n                  row = _ref4$.row,\n                  cell = _ref4[1];\n\n              return [{\n                sheet: sheet,\n                col: target,\n                row: row\n              }, cell];\n            }));\n          }\n        };\n\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      buffer.forEach(function (column) {\n        return _this8.restoreClipboardCells(sheetId, column.values());\n      });\n      return oldContent;\n    }\n  }, {\n    key: \"addNamedExpression\",\n    value: function addNamedExpression(expressionName, expression, sheetId, options) {\n      this.storeNamedExpressionInCell(this.namedExpressions.lookupNextAddress(expressionName, sheetId), expression);\n      var namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);\n      this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);\n    }\n  }, {\n    key: \"restoreNamedExpression\",\n    value: function restoreNamedExpression(namedExpression, content, sheetId) {\n      var expressionName = namedExpression.displayName;\n      this.restoreCell(namedExpression.address, content);\n      var restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);\n      this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);\n    }\n  }, {\n    key: \"changeNamedExpressionExpression\",\n    value: function changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {\n      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (!namedExpression) {\n        throw new NamedExpressionDoesNotExistError(expressionName);\n      }\n\n      var oldNamedExpression = namedExpression.copy();\n      namedExpression.options = options;\n      var content = this.getClipboardCell(namedExpression.address);\n      this.storeNamedExpressionInCell(namedExpression.address, newExpression);\n      return [oldNamedExpression, content];\n    }\n  }, {\n    key: \"removeNamedExpression\",\n    value: function removeNamedExpression(expressionName, sheetId) {\n      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (!namedExpression) {\n        throw new NamedExpressionDoesNotExistError(expressionName);\n      }\n\n      this.namedExpressions.remove(namedExpression.displayName, sheetId);\n      var content = this.getClipboardCell(namedExpression.address);\n\n      if (sheetId !== undefined) {\n        var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n        this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);\n      } else {\n        this.dependencyGraph.setCellEmpty(namedExpression.address);\n      }\n\n      return [namedExpression, content];\n    }\n  }, {\n    key: \"ensureItIsPossibleToMoveCells\",\n    value: function ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      if (invalidSimpleCellAddress(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || invalidSimpleCellAddress(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {\n        throw new InvalidArgumentsError('a valid range of cells to move.');\n      }\n\n      var sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n\n      if (targetRange.exceedsSheetSizeLimits(this.config.maxColumns, this.config.maxRows)) {\n        throw new SheetSizeLimitExceededError();\n      }\n\n      if (this.dependencyGraph.matrixMapping.isFormulaMatrixInRange(sourceRange)) {\n        throw new SourceLocationHasMatrixError();\n      }\n\n      if (this.dependencyGraph.matrixMapping.isFormulaMatrixInRange(targetRange)) {\n        throw new TargetLocationHasMatrixError();\n      }\n    }\n  }, {\n    key: \"restoreClipboardCells\",\n    value: function restoreClipboardCells(sourceSheetId, cells) {\n      var addedNamedExpressions = [];\n\n      var _iterator7 = _createForOfIteratorHelper(cells),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              address = _step7$value[0],\n              clipboardCell = _step7$value[1];\n\n          this.restoreCell(address, clipboardCell);\n\n          if (clipboardCell.type === ClipboardCellType.FORMULA) {\n            var _this$parser$fetchCac = this.parser.fetchCachedResult(clipboardCell.hash),\n                dependencies = _this$parser$fetchCac.dependencies;\n\n            addedNamedExpressions.push.apply(addedNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies)));\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return addedNamedExpressions;\n    }\n  }, {\n    key: \"restoreCell\",\n    value: function restoreCell(address, clipboardCell) {\n      switch (clipboardCell.type) {\n        case ClipboardCellType.VALUE:\n          {\n            this.setValueToCell(clipboardCell, address);\n            break;\n          }\n\n        case ClipboardCellType.FORMULA:\n          {\n            this.setFormulaToCellFromCache(clipboardCell.hash, address);\n            break;\n          }\n\n        case ClipboardCellType.EMPTY:\n          {\n            this.setCellEmpty(address);\n            break;\n          }\n\n        case ClipboardCellType.PARSING_ERROR:\n          {\n            this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);\n            break;\n          }\n      }\n    }\n    /**\n     * Removes multiple rows from sheet. </br>\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * @param sheet - sheet id from which rows will be removed\n     * @param rowStart - number of the first row to be deleted\n     * @param rowEnd - number of the last row to be deleted\n     * */\n\n  }, {\n    key: \"doRemoveRows\",\n    value: function doRemoveRows(rowsToRemove) {\n      var _this9 = this;\n\n      if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {\n        return;\n      }\n\n      var removedCells = [];\n\n      var _iterator8 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 1),\n              address = _step8$value[0];\n\n          removedCells.push({\n            address: address,\n            cellType: this.getClipboardCell(address)\n          });\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      this.dependencyGraph.removeRows(rowsToRemove);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveRowsTransformer(rowsToRemove);\n        transformation.performEagerTransformations(_this9.dependencyGraph, _this9.parser);\n        version = _this9.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      return {\n        version: version,\n        removedCells: removedCells,\n        rowFrom: rowsToRemove.rowStart,\n        rowCount: rowsToRemove.numberOfRows\n      };\n    }\n    /**\n     * Removes multiple columns from sheet. </br>\n     * Does nothing if columns are outside of effective sheet size.\n     *\n     * @param sheet - sheet id from which columns will be removed\n     * @param columnStart - number of the first column to be deleted\n     * @param columnEnd - number of the last row to be deleted\n     */\n\n  }, {\n    key: \"doRemoveColumns\",\n    value: function doRemoveColumns(columnsToRemove) {\n      var _this10 = this;\n\n      if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {\n        return;\n      }\n\n      var removedCells = [];\n\n      var _iterator9 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step9$value = _slicedToArray(_step9.value, 1),\n              address = _step9$value[0];\n\n          removedCells.push({\n            address: address,\n            cellType: this.getClipboardCell(address)\n          });\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      this.dependencyGraph.removeColumns(columnsToRemove);\n      this.columnSearch.removeColumns(columnsToRemove);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveColumnsTransformer(columnsToRemove);\n        transformation.performEagerTransformations(_this10.dependencyGraph, _this10.parser);\n        version = _this10.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      return {\n        version: version,\n        removedCells: removedCells,\n        columnFrom: columnsToRemove.columnStart,\n        columnCount: columnsToRemove.numberOfColumns\n      };\n    }\n    /**\n     * Add multiple rows to sheet. </br>\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * @param sheet - sheet id in which rows will be added\n     * @param row - row number above which the rows will be added\n     * @param numberOfRowsToAdd - number of rows to add\n     */\n\n  }, {\n    key: \"doAddRows\",\n    value: function doAddRows(addedRows) {\n      var _this11 = this;\n\n      if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {\n        return;\n      }\n\n      this.dependencyGraph.addRows(addedRows);\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new AddRowsTransformer(addedRows);\n        transformation.performEagerTransformations(_this11.dependencyGraph, _this11.parser);\n\n        _this11.lazilyTransformingAstService.addTransformation(transformation);\n      });\n    }\n    /**\n     * Add multiple columns to sheet </br>\n     * Does nothing if columns are outside of effective sheet size\n     *\n     * @param sheet - sheet id in which columns will be added\n     * @param column - column number above which the columns will be added\n     * @param numberOfColumns - number of columns to add\n     */\n\n  }, {\n    key: \"doAddColumns\",\n    value: function doAddColumns(addedColumns) {\n      var _this12 = this;\n\n      if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {\n        return;\n      }\n\n      this.dependencyGraph.addColumns(addedColumns);\n      this.columnSearch.addColumns(addedColumns);\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new AddColumnsTransformer(addedColumns);\n        transformation.performEagerTransformations(_this12.dependencyGraph, _this12.parser);\n\n        _this12.lazilyTransformingAstService.addTransformation(transformation);\n      });\n    }\n  }, {\n    key: \"getClipboardCell\",\n    value: function getClipboardCell(address) {\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex === null || vertex instanceof EmptyCellVertex) {\n        return {\n          type: ClipboardCellType.EMPTY\n        };\n      } else if (vertex instanceof ValueCellVertex) {\n        return Object.assign({\n          type: ClipboardCellType.VALUE\n        }, vertex.getValues());\n      } else if (vertex instanceof MatrixVertex) {\n        return {\n          type: ClipboardCellType.VALUE,\n          parsedValue: vertex.getMatrixCellValue(address),\n          rawValue: vertex.getMatrixCellRawValue(address)\n        };\n      } else if (vertex instanceof FormulaCellVertex) {\n        return {\n          type: ClipboardCellType.FORMULA,\n          hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n        };\n      } else if (vertex instanceof ParsingErrorVertex) {\n        return {\n          type: ClipboardCellType.PARSING_ERROR,\n          rawInput: vertex.rawInput,\n          errors: vertex.errors\n        };\n      }\n\n      throw Error('Trying to copy unsupported type');\n    }\n  }, {\n    key: \"getSheetClipboardCells\",\n    value: function getSheetClipboardCells(sheet) {\n      var sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n      var sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n      var arr = new Array(sheetHeight);\n\n      for (var i = 0; i < sheetHeight; i++) {\n        arr[i] = new Array(sheetWidth);\n\n        for (var j = 0; j < sheetWidth; j++) {\n          var address = simpleCellAddress(sheet, j, i);\n          arr[i][j] = this.getClipboardCell(address);\n        }\n      }\n\n      return arr;\n    }\n  }, {\n    key: \"getRangeClipboardCells\",\n    value: function getRangeClipboardCells(range) {\n      var result = [];\n\n      var _iterator10 = _createForOfIteratorHelper(range.addresses(this.dependencyGraph)),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var address = _step10.value;\n          result.push([address, this.getClipboardCell(address)]);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"setCellContent\",\n    value: function setCellContent(address, newCellContent) {\n      var parsedCellContent = this.cellContentParser.parse(newCellContent);\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex instanceof MatrixVertex && !vertex.isFormula() && !(parsedCellContent instanceof CellContent.Number)) {\n        this.dependencyGraph.breakNumericMatrix(vertex);\n        vertex = this.dependencyGraph.getCell(address);\n      }\n\n      if (vertex instanceof MatrixVertex && !vertex.isFormula() && parsedCellContent instanceof CellContent.Number) {\n        var newValue = parsedCellContent.value;\n        var oldValue = this.dependencyGraph.getCellValue(address);\n        this.dependencyGraph.graph.markNodeAsSpecialRecentlyChanged(vertex);\n        vertex.setMatrixCellValue(address, getRawValue(newValue));\n        this.columnSearch.change(getRawValue(oldValue), getRawValue(newValue), address);\n        this.changes.addChange(newValue, address);\n      } else if (!(vertex instanceof MatrixVertex) && parsedCellContent instanceof CellContent.MatrixFormula) {\n        var _this$parser$parse = this.parser.parse(parsedCellContent.formula, address),\n            ast = _this$parser$parse.ast,\n            errors = _this$parser$parse.errors,\n            dependencies = _this$parser$parse.dependencies;\n\n        if (errors.length > 0) {\n          this.dependencyGraph.setParsingErrorToCell(address, new ParsingErrorVertex(errors, parsedCellContent.formulaWithBraces()));\n        } else {\n          var newVertex = buildMatrixVertex(ast, address);\n\n          if (newVertex instanceof ValueCellVertex) {\n            throw Error('What if new matrix vertex is not properly constructed?');\n          }\n\n          this.dependencyGraph.addNewMatrixVertex(newVertex);\n          this.dependencyGraph.processCellDependencies(absolutizeDependencies(dependencies, address), newVertex);\n          this.dependencyGraph.graph.markNodeAsSpecialRecentlyChanged(newVertex);\n        }\n      } else if (!(vertex instanceof MatrixVertex)) {\n        if (parsedCellContent instanceof CellContent.Formula) {\n          var _this$parser$parse2 = this.parser.parse(parsedCellContent.formula, address),\n              _ast = _this$parser$parse2.ast,\n              _errors = _this$parser$parse2.errors,\n              hasVolatileFunction = _this$parser$parse2.hasVolatileFunction,\n              hasStructuralChangeFunction = _this$parser$parse2.hasStructuralChangeFunction,\n              _dependencies = _this$parser$parse2.dependencies;\n\n          if (_errors.length > 0) {\n            this.dependencyGraph.setParsingErrorToCell(address, new ParsingErrorVertex(_errors, parsedCellContent.formula));\n          } else {\n            this.dependencyGraph.setFormulaToCell(address, _ast, absolutizeDependencies(_dependencies, address), hasVolatileFunction, hasStructuralChangeFunction);\n          }\n        } else if (parsedCellContent instanceof CellContent.Empty) {\n          this.setCellEmpty(address);\n        } else if (parsedCellContent instanceof CellContent.MatrixFormula) {\n          throw new Error('Cant happen');\n        } else {\n          this.setValueToCell({\n            parsedValue: parsedCellContent.value,\n            rawValue: newCellContent\n          }, address);\n        }\n      } else {\n        throw new Error('Illegal operation');\n      }\n    }\n  }, {\n    key: \"setSheetContent\",\n    value: function setSheetContent(sheetId, newSheetContent) {\n      this.clearSheet(sheetId);\n\n      for (var i = 0; i < newSheetContent.length; i++) {\n        for (var j = 0; j < newSheetContent[i].length; j++) {\n          var address = simpleCellAddress(sheetId, j, i);\n          this.setCellContent(address, newSheetContent[i][j]);\n        }\n      }\n    }\n  }, {\n    key: \"setValueToCell\",\n    value: function setValueToCell(value, address) {\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      this.dependencyGraph.setValueToCell(address, value);\n      this.columnSearch.change(getRawValue(oldValue), getRawValue(value.parsedValue), address);\n      this.changes.addChange(value.parsedValue, address);\n    }\n  }, {\n    key: \"setCellEmpty\",\n    value: function setCellEmpty(address) {\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      this.columnSearch.remove(getRawValue(oldValue), address);\n      this.changes.addChange(EmptyValue, address);\n      this.dependencyGraph.setCellEmpty(address);\n    }\n  }, {\n    key: \"setFormulaToCellFromCache\",\n    value: function setFormulaToCellFromCache(formulaHash, address) {\n      var _this$parser$fetchCac2 = this.parser.fetchCachedResult(formulaHash),\n          ast = _this$parser$fetchCac2.ast,\n          hasVolatileFunction = _this$parser$fetchCac2.hasVolatileFunction,\n          hasStructuralChangeFunction = _this$parser$fetchCac2.hasStructuralChangeFunction,\n          dependencies = _this$parser$fetchCac2.dependencies;\n\n      var absoluteDependencies = absolutizeDependencies(dependencies, address);\n\n      var _CleanOutOfScopeDepen = new CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address),\n          _CleanOutOfScopeDepen2 = _slicedToArray(_CleanOutOfScopeDepen, 1),\n          cleanedAst = _CleanOutOfScopeDepen2[0];\n\n      this.parser.rememberNewAst(cleanedAst);\n      var cleanedDependencies = filterDependenciesOutOfScope(absoluteDependencies);\n      this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, hasVolatileFunction, hasStructuralChangeFunction);\n    }\n  }, {\n    key: \"setParsingErrorToCell\",\n    value: function setParsingErrorToCell(rawInput, errors, address) {\n      this.dependencyGraph.setParsingErrorToCell(address, new ParsingErrorVertex(errors, rawInput));\n    }\n    /**\n     * Returns true if row number is outside of given sheet.\n     *\n     * @param row - row number\n     * @param sheet - sheet id number\n     */\n\n  }, {\n    key: \"rowEffectivelyNotInSheet\",\n    value: function rowEffectivelyNotInSheet(row, sheet) {\n      var height = this.dependencyGraph.addressMapping.getHeight(sheet);\n      return row >= height;\n    }\n  }, {\n    key: \"getAndClearContentChanges\",\n    value: function getAndClearContentChanges() {\n      var changes = this.changes;\n      this.changes = ContentChanges.empty();\n      return changes;\n    }\n  }, {\n    key: \"forceApplyPostponedTransformations\",\n    value: function forceApplyPostponedTransformations() {\n      this.dependencyGraph.forceApplyPostponedTransformations();\n    }\n  }, {\n    key: \"sheetMapping\",\n    get: function get() {\n      return this.dependencyGraph.sheetMapping;\n    }\n    /**\n     * Returns true if row number is outside of given sheet.\n     *\n     * @param column - row number\n     * @param sheet - sheet id number\n     */\n\n  }, {\n    key: \"columnEffectivelyNotInSheet\",\n    value: function columnEffectivelyNotInSheet(column, sheet) {\n      var width = this.dependencyGraph.addressMapping.getWidth(sheet);\n      return column >= width;\n    }\n  }, {\n    key: \"adjustNamedExpressionEdges\",\n    value: function adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {\n      if (sheetId === undefined) {\n        return;\n      }\n\n      var localVertex = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);\n      var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n      var globalVertex = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);\n\n      var _iterator11 = _createForOfIteratorHelper(this.dependencyGraph.graph.adjacentNodes(globalVertex)),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var adjacentNode = _step11.value;\n\n          if (adjacentNode instanceof FormulaCellVertex && adjacentNode.cellAddress.sheet === sheetId) {\n            var ast = adjacentNode.getFormula(this.lazilyTransformingAstService);\n            var formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);\n\n            var _this$parser$fetchCac3 = this.parser.fetchCachedResultForAst(ast),\n                dependencies = _this$parser$fetchCac3.dependencies;\n\n            var _iterator12 = _createForOfIteratorHelper(absolutizeDependencies(dependencies, formulaAddress)),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var dependency = _step12.value;\n\n                if (dependency instanceof NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {\n                  this.dependencyGraph.graph.removeEdge(globalVertex, adjacentNode);\n                  this.dependencyGraph.graph.addEdge(localVertex, adjacentNode);\n                }\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n    }\n  }, {\n    key: \"storeNamedExpressionInCell\",\n    value: function storeNamedExpressionInCell(address, expression) {\n      var parsedCellContent = this.cellContentParser.parse(expression);\n\n      if (parsedCellContent instanceof CellContent.MatrixFormula) {\n        throw new Error('Matrix formulas are not supported');\n      } else if (parsedCellContent instanceof CellContent.Formula) {\n        var parsingResult = this.parser.parse(parsedCellContent.formula, simpleCellAddress(-1, 0, 0));\n\n        if (doesContainRelativeReferences(parsingResult.ast)) {\n          throw new NoRelativeAddressesAllowedError();\n        }\n\n        var ast = parsingResult.ast,\n            hasVolatileFunction = parsingResult.hasVolatileFunction,\n            hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,\n            dependencies = parsingResult.dependencies;\n        this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), hasVolatileFunction, hasStructuralChangeFunction);\n      } else {\n        if (parsedCellContent instanceof CellContent.Empty) {\n          this.setCellEmpty(address);\n        } else {\n          this.setValueToCell({\n            parsedValue: parsedCellContent.value,\n            rawValue: expression\n          }, address);\n        }\n      }\n    }\n  }, {\n    key: \"updateNamedExpressionsForMovedCells\",\n    value: function updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {\n        return [];\n      }\n\n      var addedGlobalNamedExpressions = [];\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n\n      var _iterator13 = _createForOfIteratorHelper(targetRange.addresses(this.dependencyGraph)),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var formulaAddress = _step13.value;\n          var vertex = this.addressMapping.fetchCell(formulaAddress);\n\n          if (vertex instanceof FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {\n            var ast = vertex.getFormula(this.lazilyTransformingAstService);\n\n            var _this$parser$fetchCac4 = this.parser.fetchCachedResultForAst(ast),\n                dependencies = _this$parser$fetchCac4.dependencies;\n\n            addedGlobalNamedExpressions.push.apply(addedGlobalNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies)));\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      return addedGlobalNamedExpressions;\n    }\n  }, {\n    key: \"updateNamedExpressionsForTargetAddress\",\n    value: function updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {\n      if (sourceSheet === targetAddress.sheet) {\n        return [];\n      }\n\n      var addedGlobalNamedExpressions = [];\n      var vertex = this.addressMapping.fetchCell(targetAddress);\n\n      var _iterator14 = _createForOfIteratorHelper(absolutizeDependencies(dependencies, targetAddress)),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var namedExpressionDependency = _step14.value;\n\n          if (!(namedExpressionDependency instanceof NamedExpressionDependency)) {\n            continue;\n          }\n\n          var expressionName = namedExpressionDependency.name;\n          var sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet);\n          var namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);\n          var targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet) : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);\n\n          if (targetScopeExpressionVertex !== sourceVertex) {\n            this.dependencyGraph.graph.softRemoveEdge(sourceVertex, vertex);\n            this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      return addedGlobalNamedExpressions;\n    }\n  }, {\n    key: \"allocateNamedExpressionAddressSpace\",\n    value: function allocateNamedExpressionAddressSpace() {\n      this.dependencyGraph.addressMapping.addSheet(-1, new SparseStrategy(0, 0));\n    }\n  }, {\n    key: \"copyOrFetchGlobalNamedExpressionVertex\",\n    value: function copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {\n      var expression = this.namedExpressions.namedExpressionForScope(expressionName);\n\n      if (expression === undefined) {\n        expression = this.namedExpressions.addNamedExpression(expressionName);\n        addedNamedExpressions.push(expression.normalizeExpressionName());\n\n        if (sourceVertex instanceof FormulaCellVertex) {\n          var parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));\n          var ast = parsingResult.ast,\n              hasVolatileFunction = parsingResult.hasVolatileFunction,\n              hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,\n              dependencies = parsingResult.dependencies;\n          this.dependencyGraph.setFormulaToCell(expression.address, ast, absolutizeDependencies(dependencies, expression.address), hasVolatileFunction, hasStructuralChangeFunction);\n        } else if (sourceVertex instanceof EmptyCellVertex) {\n          this.setCellEmpty(expression.address);\n        } else if (sourceVertex instanceof ValueCellVertex) {\n          this.setValueToCell(sourceVertex.getValues(), expression.address);\n        }\n      }\n\n      return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address);\n    }\n  }, {\n    key: \"addressMapping\",\n    get: function get() {\n      return this.dependencyGraph.addressMapping;\n    }\n  }]);\n\n  return Operations;\n}();\nexport function normalizeRemovedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n\n  var sorted = _toConsumableArray(indexes).sort(function (_ref5, _ref6) {\n    var _ref7 = _slicedToArray(_ref5, 1),\n        a = _ref7[0];\n\n    var _ref8 = _slicedToArray(_ref6, 1),\n        b = _ref8[0];\n\n    return a - b;\n  });\n  /* merge overlapping and adjacent indexes */\n\n\n  var merged = sorted.reduce(function (acc, _ref9) {\n    var _ref10 = _slicedToArray(_ref9, 2),\n        startIndex = _ref10[0],\n        amount = _ref10[1];\n\n    var previous = acc[acc.length - 1];\n    var lastIndex = previous[0] + previous[1];\n\n    if (startIndex <= lastIndex) {\n      previous[1] += Math.max(0, amount - (lastIndex - startIndex));\n    } else {\n      acc.push([startIndex, amount]);\n    }\n\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n\n  var shift = 0;\n\n  for (var i = 0; i < merged.length; ++i) {\n    merged[i][0] -= shift;\n    shift += merged[i][1];\n  }\n\n  return merged;\n}\nexport function normalizeAddedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n\n  var sorted = _toConsumableArray(indexes).sort(function (_ref11, _ref12) {\n    var _ref13 = _slicedToArray(_ref11, 1),\n        a = _ref13[0];\n\n    var _ref14 = _slicedToArray(_ref12, 1),\n        b = _ref14[0];\n\n    return a - b;\n  });\n  /* merge indexes with same start */\n\n\n  var merged = sorted.reduce(function (acc, _ref15) {\n    var _ref16 = _slicedToArray(_ref15, 2),\n        startIndex = _ref16[0],\n        amount = _ref16[1];\n\n    var previous = acc[acc.length - 1];\n\n    if (startIndex === previous[0]) {\n      previous[1] = Math.max(previous[1], amount);\n    } else {\n      acc.push([startIndex, amount]);\n    }\n\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n\n  var shift = 0;\n\n  for (var i = 0; i < merged.length; ++i) {\n    merged[i][0] += shift;\n    shift += merged[i][1];\n  }\n\n  return merged;\n}\n\nfunction isPositiveInteger(x) {\n  return Number.isInteger(x) && x > 0;\n}\n\nfunction isRowOrColumnRange(leftCorner, width, height) {\n  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/Operations.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","_i","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","_createForOfIteratorHelper","o","allowArrayLike","it","F","s","n","e","_e2","f","normalCompletion","didErr","step","_e3","return","minLen","Object","prototype","toString","slice","constructor","name","test","len","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","EmptyValue","getRawValue","ClipboardCellType","invalidSimpleCellAddress","simpleCellAddress","AbsoluteCellRange","absolutizeDependencies","filterDependenciesOutOfScope","CellContent","ContentChanges","EmptyCellVertex","FormulaCellVertex","MatrixVertex","ParsingErrorVertex","SparseStrategy","ValueCellVertex","AddColumnsTransformer","AddRowsTransformer","MoveCellsTransformer","RemoveColumnsTransformer","RemoveRowsTransformer","RemoveSheetTransformer","InvalidArgumentsError","NamedExpressionDoesNotExistError","NoRelativeAddressesAllowedError","SheetSizeLimitExceededError","SourceLocationHasMatrixError","TargetLocationHasMatrixError","buildMatrixVertex","doesContainRelativeReferences","NamedExpressionDependency","findBoundaries","ColumnsSpan","RowsSpan","StatType","CleanOutOfScopeDependenciesTransformer","RemoveRowsCommand","sheet","indexes","normalizedIndexes","normalizeRemovedIndexes","rowsSpans","_this","map","normalizedIndex","fromNumberOfRows","AddRowsCommand","normalizeAddedIndexes","_this2","AddColumnsCommand","columnsSpans","_this3","fromNumberOfColumns","RemoveColumnsCommand","_this4","Operations","dependencyGraph","columnSearch","cellContentParser","parser","stats","lazilyTransformingAstService","namedExpressions","config","changes","empty","allocateNamedExpressionAddressSpace","removeRows","cmd","rowsRemovals","_iterator","_step","rowsToRemove","rowsRemoval","doRemoveRows","addRows","_iterator2","_step2","addedRows","doAddRows","addColumns","_iterator3","_step3","addedColumns","doAddColumns","removeColumns","columnsRemovals","_iterator4","_step4","columnsToRemove","columnsRemoval","doRemoveColumns","removeSheet","sheetName","_this5","sheetId","sheetMapping","fetch","version","measure","TRANSFORM_ASTS","transformation","performEagerTransformations","addTransformation","scopedNamedExpressions","getAllNamedExpressionsForScope","namedexpression","removeNamedExpression","normalizeExpressionName","clearSheet","addSheet","addressMapping","autoAddSheet","fetchDisplayName","renameSheet","newName","moveRows","startRow","numberOfRows","targetRow","rowsToAdd","beginCombinedMode","startAddress","targetAddress","moveCells","Number","POSITIVE_INFINITY","commitCombinedMode","moveColumns","startColumn","numberOfColumns","targetColumn","columnsToAdd","sourceLeftCorner","width","height","destinationLeftCorner","_this6","ensureItIsPossibleToMoveCells","sourceRange","spanFrom","targetRange","breakNumericMatricesInRange","toRight","col","toBottom","row","toSheet","currentDataAtTarget","getRangeClipboardCells","valuesToRemove","rawValuesFromRange","removeValues","valuesToMove","moveValues","addedGlobalNamedExpressions","updateNamedExpressionsForMovedCells","overwrittenCellsData","setRowOrder","rowMapping","_this7","buffer","oldContent","_iterator5","_step5","_loop","_step5$value","source","rowRange","Infinity","concat","_ref","_ref2","_ref2$","cell","forEach","restoreClipboardCells","values","setColumnOrder","columnMapping","_this8","_iterator6","_step6","_loop2","_step6$value","column","_ref3","_ref4","_ref4$","addNamedExpression","expressionName","expression","options","storeNamedExpressionInCell","lookupNextAddress","namedExpression","adjustNamedExpressionEdges","restoreNamedExpression","content","displayName","restoreCell","address","restoredNamedExpression","changeNamedExpressionExpression","newExpression","namedExpressionForScope","oldNamedExpression","copy","getClipboardCell","remove","undefined","globalNamedExpression","workbookNamedExpressionOrPlaceholder","exchangeNode","setCellEmpty","isPositiveInteger","isRowOrColumnRange","hasSheetWithId","exceedsSheetSizeLimits","maxColumns","maxRows","matrixMapping","isFormulaMatrixInRange","sourceSheetId","cells","addedNamedExpressions","_iterator7","_step7","_step7$value","clipboardCell","type","FORMULA","_this$parser$fetchCac","fetchCachedResult","hash","dependencies","apply","updateNamedExpressionsForTargetAddress","VALUE","setValueToCell","setFormulaToCellFromCache","EMPTY","PARSING_ERROR","setParsingErrorToCell","rawInput","errors","_this9","rowEffectivelyNotInSheet","rowStart","removedCells","_iterator8","entriesFromRowsSpan","_step8","_step8$value","cellType","rowFrom","rowCount","_this10","columnEffectivelyNotInSheet","columnStart","_iterator9","entriesFromColumnsSpan","_step9","_step9$value","columnFrom","columnCount","_this11","_this12","vertex","getCell","assign","getValues","parsedValue","getMatrixCellValue","rawValue","getMatrixCellRawValue","computeHashFromAst","getFormula","Error","getSheetClipboardCells","sheetHeight","getSheetHeight","sheetWidth","getSheetWidth","j","range","result","_iterator10","addresses","_step10","setCellContent","newCellContent","parsedCellContent","parse","isFormula","breakNumericMatrix","newValue","oldValue","getCellValue","graph","markNodeAsSpecialRecentlyChanged","setMatrixCellValue","change","addChange","MatrixFormula","_this$parser$parse","formula","ast","formulaWithBraces","newVertex","addNewMatrixVertex","processCellDependencies","Formula","_this$parser$parse2","_ast","_errors","hasVolatileFunction","hasStructuralChangeFunction","_dependencies","setFormulaToCell","Empty","setSheetContent","newSheetContent","formulaHash","_this$parser$fetchCac2","absoluteDependencies","_CleanOutOfScopeDepen","transformSingleAst","_CleanOutOfScopeDepen2","cleanedAst","rememberNewAst","cleanedDependencies","getHeight","getAndClearContentChanges","forceApplyPostponedTransformations","get","getWidth","localVertex","fetchCellOrCreateEmpty","globalVertex","_iterator11","adjacentNodes","_step11","adjacentNode","cellAddress","formulaAddress","getAddress","_this$parser$fetchCac3","fetchCachedResultForAst","_iterator12","_step12","dependency","toLowerCase","removeEdge","addEdge","parsingResult","_iterator13","_step13","fetchCell","_this$parser$fetchCac4","sourceSheet","_iterator14","_step14","namedExpressionDependency","sourceVertex","fetchNamedExpressionVertex","namedExpressionInTargetScope","isExpressionInScope","targetScopeExpressionVertex","copyOrFetchGlobalNamedExpressionVertex","softRemoveEdge","sorted","sort","_ref5","_ref6","_ref7","a","_ref8","b","merged","reduce","acc","_ref9","_ref10","startIndex","amount","previous","lastIndex","Math","max","shift","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","x","isInteger","leftCorner"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { EmptyValue, getRawValue } from './interpreter/InterpreterValue';\nimport { ClipboardCellType } from './ClipboardOperations';\nimport { invalidSimpleCellAddress, simpleCellAddress } from './Cell';\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { absolutizeDependencies, filterDependenciesOutOfScope } from './absolutizeDependencies';\nimport { CellContent } from './CellContentParser';\nimport { ContentChanges } from './ContentChanges';\nimport { EmptyCellVertex, FormulaCellVertex, MatrixVertex, ParsingErrorVertex, SparseStrategy, ValueCellVertex } from './DependencyGraph';\nimport { AddColumnsTransformer } from './dependencyTransformers/AddColumnsTransformer';\nimport { AddRowsTransformer } from './dependencyTransformers/AddRowsTransformer';\nimport { MoveCellsTransformer } from './dependencyTransformers/MoveCellsTransformer';\nimport { RemoveColumnsTransformer } from './dependencyTransformers/RemoveColumnsTransformer';\nimport { RemoveRowsTransformer } from './dependencyTransformers/RemoveRowsTransformer';\nimport { RemoveSheetTransformer } from './dependencyTransformers/RemoveSheetTransformer';\nimport { InvalidArgumentsError, NamedExpressionDoesNotExistError, NoRelativeAddressesAllowedError, SheetSizeLimitExceededError, SourceLocationHasMatrixError, TargetLocationHasMatrixError } from './errors';\nimport { buildMatrixVertex } from './GraphBuilder';\nimport { doesContainRelativeReferences } from './NamedExpressions';\nimport { NamedExpressionDependency } from './parser';\nimport { findBoundaries } from './Sheet';\nimport { ColumnsSpan, RowsSpan } from './Span';\nimport { StatType } from './statistics';\nimport { CleanOutOfScopeDependenciesTransformer } from './dependencyTransformers/CleanOutOfScopeDependenciesTransformer';\nexport var RemoveRowsCommand = /*#__PURE__*/function () {\n  function RemoveRowsCommand(sheet, indexes) {\n    _classCallCheck(this, RemoveRowsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(RemoveRowsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeRemovedIndexes(this.indexes);\n    }\n  }, {\n    key: \"rowsSpans\",\n    value: function rowsSpans() {\n      var _this = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return RowsSpan.fromNumberOfRows(_this.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return RemoveRowsCommand;\n}();\nexport var AddRowsCommand = /*#__PURE__*/function () {\n  function AddRowsCommand(sheet, indexes) {\n    _classCallCheck(this, AddRowsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(AddRowsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeAddedIndexes(this.indexes);\n    }\n  }, {\n    key: \"rowsSpans\",\n    value: function rowsSpans() {\n      var _this2 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return RowsSpan.fromNumberOfRows(_this2.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return AddRowsCommand;\n}();\nexport var AddColumnsCommand = /*#__PURE__*/function () {\n  function AddColumnsCommand(sheet, indexes) {\n    _classCallCheck(this, AddColumnsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(AddColumnsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeAddedIndexes(this.indexes);\n    }\n  }, {\n    key: \"columnsSpans\",\n    value: function columnsSpans() {\n      var _this3 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return ColumnsSpan.fromNumberOfColumns(_this3.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return AddColumnsCommand;\n}();\nexport var RemoveColumnsCommand = /*#__PURE__*/function () {\n  function RemoveColumnsCommand(sheet, indexes) {\n    _classCallCheck(this, RemoveColumnsCommand);\n\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n\n  _createClass(RemoveColumnsCommand, [{\n    key: \"normalizedIndexes\",\n    value: function normalizedIndexes() {\n      return normalizeRemovedIndexes(this.indexes);\n    }\n  }, {\n    key: \"columnsSpans\",\n    value: function columnsSpans() {\n      var _this4 = this;\n\n      return this.normalizedIndexes().map(function (normalizedIndex) {\n        return ColumnsSpan.fromNumberOfColumns(_this4.sheet, normalizedIndex[0], normalizedIndex[1]);\n      });\n    }\n  }]);\n\n  return RemoveColumnsCommand;\n}();\nexport var Operations = /*#__PURE__*/function () {\n  function Operations(dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, config) {\n    _classCallCheck(this, Operations);\n\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.cellContentParser = cellContentParser;\n    this.parser = parser;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.config = config;\n    this.changes = ContentChanges.empty();\n    this.allocateNamedExpressionAddressSpace();\n  }\n\n  _createClass(Operations, [{\n    key: \"removeRows\",\n    value: function removeRows(cmd) {\n      var rowsRemovals = [];\n\n      var _iterator = _createForOfIteratorHelper(cmd.rowsSpans()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rowsToRemove = _step.value;\n          var rowsRemoval = this.doRemoveRows(rowsToRemove);\n\n          if (rowsRemoval) {\n            rowsRemovals.push(rowsRemoval);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return rowsRemovals;\n    }\n  }, {\n    key: \"addRows\",\n    value: function addRows(cmd) {\n      var _iterator2 = _createForOfIteratorHelper(cmd.rowsSpans()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var addedRows = _step2.value;\n          this.doAddRows(addedRows);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(cmd) {\n      var _iterator3 = _createForOfIteratorHelper(cmd.columnsSpans()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var addedColumns = _step3.value;\n          this.doAddColumns(addedColumns);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(cmd) {\n      var columnsRemovals = [];\n\n      var _iterator4 = _createForOfIteratorHelper(cmd.columnsSpans()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var columnsToRemove = _step4.value;\n          var columnsRemoval = this.doRemoveColumns(columnsToRemove);\n\n          if (columnsRemoval) {\n            columnsRemovals.push(columnsRemoval);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return columnsRemovals;\n    }\n  }, {\n    key: \"removeSheet\",\n    value: function removeSheet(sheetName) {\n      var _this5 = this;\n\n      var sheetId = this.sheetMapping.fetch(sheetName);\n      this.dependencyGraph.removeSheet(sheetId);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveSheetTransformer(sheetId);\n        transformation.performEagerTransformations(_this5.dependencyGraph, _this5.parser);\n        version = _this5.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.sheetMapping.removeSheet(sheetId);\n      this.columnSearch.removeSheet(sheetId);\n      var scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(function (namedexpression) {\n        return _this5.removeNamedExpression(namedexpression.normalizeExpressionName(), sheetId);\n      });\n      return {\n        version: version,\n        scopedNamedExpressions: scopedNamedExpressions\n      };\n    }\n  }, {\n    key: \"clearSheet\",\n    value: function clearSheet(sheetId) {\n      this.dependencyGraph.clearSheet(sheetId);\n      this.columnSearch.removeSheet(sheetId);\n    }\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(name) {\n      var sheetId = this.sheetMapping.addSheet(name);\n      var sheet = [];\n      this.dependencyGraph.addressMapping.autoAddSheet(sheetId, sheet, findBoundaries(sheet));\n      return this.sheetMapping.fetchDisplayName(sheetId);\n    }\n  }, {\n    key: \"renameSheet\",\n    value: function renameSheet(sheetId, newName) {\n      return this.sheetMapping.renameSheet(sheetId, newName);\n    }\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(sheet, startRow, numberOfRows, targetRow) {\n      var rowsToAdd = RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);\n      this.lazilyTransformingAstService.beginCombinedMode(sheet);\n      this.doAddRows(rowsToAdd);\n\n      if (targetRow < startRow) {\n        startRow += numberOfRows;\n      }\n\n      var startAddress = simpleCellAddress(sheet, 0, startRow);\n      var targetAddress = simpleCellAddress(sheet, 0, targetRow);\n      this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);\n      var rowsToRemove = RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);\n      this.doRemoveRows(rowsToRemove);\n      return this.lazilyTransformingAstService.commitCombinedMode();\n    }\n  }, {\n    key: \"moveColumns\",\n    value: function moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n      var columnsToAdd = ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);\n      this.lazilyTransformingAstService.beginCombinedMode(sheet);\n      this.doAddColumns(columnsToAdd);\n\n      if (targetColumn < startColumn) {\n        startColumn += numberOfColumns;\n      }\n\n      var startAddress = simpleCellAddress(sheet, startColumn, 0);\n      var targetAddress = simpleCellAddress(sheet, targetColumn, 0);\n      this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);\n      var columnsToRemove = ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);\n      this.doRemoveColumns(columnsToRemove);\n      return this.lazilyTransformingAstService.commitCombinedMode();\n    }\n  }, {\n    key: \"moveCells\",\n    value: function moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      var _this6 = this;\n\n      this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n      var sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n      this.dependencyGraph.breakNumericMatricesInRange(sourceRange);\n      this.dependencyGraph.breakNumericMatricesInRange(targetRange);\n      var toRight = destinationLeftCorner.col - sourceLeftCorner.col;\n      var toBottom = destinationLeftCorner.row - sourceLeftCorner.row;\n      var toSheet = destinationLeftCorner.sheet;\n      var currentDataAtTarget = this.getRangeClipboardCells(targetRange);\n      var valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);\n      this.columnSearch.removeValues(valuesToRemove);\n      var valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);\n      this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);\n        transformation.performEagerTransformations(_this6.dependencyGraph, _this6.parser);\n        version = _this6.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);\n      var addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);\n      return {\n        version: version,\n        overwrittenCellsData: currentDataAtTarget,\n        addedGlobalNamedExpressions: addedGlobalNamedExpressions\n      };\n    }\n  }, {\n    key: \"setRowOrder\",\n    value: function setRowOrder(sheetId, rowMapping) {\n      var _this7 = this;\n\n      var buffer = [];\n      var oldContent = [];\n\n      var _iterator5 = _createForOfIteratorHelper(rowMapping),\n          _step5;\n\n      try {\n        var _loop = function _loop() {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              source = _step5$value[0],\n              target = _step5$value[1];\n\n          if (source !== target) {\n            var rowRange = AbsoluteCellRange.spanFrom({\n              sheet: sheetId,\n              col: 0,\n              row: source\n            }, Infinity, 1);\n\n            _this7.dependencyGraph.breakNumericMatricesInRange(rowRange);\n\n            var row = _this7.getRangeClipboardCells(rowRange);\n\n            oldContent = oldContent.concat(row);\n            buffer.push(row.map(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                  _ref2$ = _ref2[0],\n                  sheet = _ref2$.sheet,\n                  col = _ref2$.col,\n                  cell = _ref2[1];\n\n              return [{\n                sheet: sheet,\n                col: col,\n                row: target\n              }, cell];\n            }));\n          }\n        };\n\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      buffer.forEach(function (row) {\n        return _this7.restoreClipboardCells(sheetId, row.values());\n      });\n      return oldContent;\n    }\n  }, {\n    key: \"setColumnOrder\",\n    value: function setColumnOrder(sheetId, columnMapping) {\n      var _this8 = this;\n\n      var buffer = [];\n      var oldContent = [];\n\n      var _iterator6 = _createForOfIteratorHelper(columnMapping),\n          _step6;\n\n      try {\n        var _loop2 = function _loop2() {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              source = _step6$value[0],\n              target = _step6$value[1];\n\n          if (source !== target) {\n            var rowRange = AbsoluteCellRange.spanFrom({\n              sheet: sheetId,\n              col: source,\n              row: 0\n            }, 1, Infinity);\n\n            _this8.dependencyGraph.breakNumericMatricesInRange(rowRange);\n\n            var column = _this8.getRangeClipboardCells(rowRange);\n\n            oldContent = oldContent.concat(column);\n            buffer.push(column.map(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                  _ref4$ = _ref4[0],\n                  sheet = _ref4$.sheet,\n                  col = _ref4$.col,\n                  row = _ref4$.row,\n                  cell = _ref4[1];\n\n              return [{\n                sheet: sheet,\n                col: target,\n                row: row\n              }, cell];\n            }));\n          }\n        };\n\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      buffer.forEach(function (column) {\n        return _this8.restoreClipboardCells(sheetId, column.values());\n      });\n      return oldContent;\n    }\n  }, {\n    key: \"addNamedExpression\",\n    value: function addNamedExpression(expressionName, expression, sheetId, options) {\n      this.storeNamedExpressionInCell(this.namedExpressions.lookupNextAddress(expressionName, sheetId), expression);\n      var namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);\n      this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);\n    }\n  }, {\n    key: \"restoreNamedExpression\",\n    value: function restoreNamedExpression(namedExpression, content, sheetId) {\n      var expressionName = namedExpression.displayName;\n      this.restoreCell(namedExpression.address, content);\n      var restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);\n      this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);\n    }\n  }, {\n    key: \"changeNamedExpressionExpression\",\n    value: function changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {\n      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (!namedExpression) {\n        throw new NamedExpressionDoesNotExistError(expressionName);\n      }\n\n      var oldNamedExpression = namedExpression.copy();\n      namedExpression.options = options;\n      var content = this.getClipboardCell(namedExpression.address);\n      this.storeNamedExpressionInCell(namedExpression.address, newExpression);\n      return [oldNamedExpression, content];\n    }\n  }, {\n    key: \"removeNamedExpression\",\n    value: function removeNamedExpression(expressionName, sheetId) {\n      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (!namedExpression) {\n        throw new NamedExpressionDoesNotExistError(expressionName);\n      }\n\n      this.namedExpressions.remove(namedExpression.displayName, sheetId);\n      var content = this.getClipboardCell(namedExpression.address);\n\n      if (sheetId !== undefined) {\n        var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n        this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);\n      } else {\n        this.dependencyGraph.setCellEmpty(namedExpression.address);\n      }\n\n      return [namedExpression, content];\n    }\n  }, {\n    key: \"ensureItIsPossibleToMoveCells\",\n    value: function ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      if (invalidSimpleCellAddress(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || invalidSimpleCellAddress(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {\n        throw new InvalidArgumentsError('a valid range of cells to move.');\n      }\n\n      var sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n\n      if (targetRange.exceedsSheetSizeLimits(this.config.maxColumns, this.config.maxRows)) {\n        throw new SheetSizeLimitExceededError();\n      }\n\n      if (this.dependencyGraph.matrixMapping.isFormulaMatrixInRange(sourceRange)) {\n        throw new SourceLocationHasMatrixError();\n      }\n\n      if (this.dependencyGraph.matrixMapping.isFormulaMatrixInRange(targetRange)) {\n        throw new TargetLocationHasMatrixError();\n      }\n    }\n  }, {\n    key: \"restoreClipboardCells\",\n    value: function restoreClipboardCells(sourceSheetId, cells) {\n      var addedNamedExpressions = [];\n\n      var _iterator7 = _createForOfIteratorHelper(cells),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              address = _step7$value[0],\n              clipboardCell = _step7$value[1];\n\n          this.restoreCell(address, clipboardCell);\n\n          if (clipboardCell.type === ClipboardCellType.FORMULA) {\n            var _this$parser$fetchCac = this.parser.fetchCachedResult(clipboardCell.hash),\n                dependencies = _this$parser$fetchCac.dependencies;\n\n            addedNamedExpressions.push.apply(addedNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies)));\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return addedNamedExpressions;\n    }\n  }, {\n    key: \"restoreCell\",\n    value: function restoreCell(address, clipboardCell) {\n      switch (clipboardCell.type) {\n        case ClipboardCellType.VALUE:\n          {\n            this.setValueToCell(clipboardCell, address);\n            break;\n          }\n\n        case ClipboardCellType.FORMULA:\n          {\n            this.setFormulaToCellFromCache(clipboardCell.hash, address);\n            break;\n          }\n\n        case ClipboardCellType.EMPTY:\n          {\n            this.setCellEmpty(address);\n            break;\n          }\n\n        case ClipboardCellType.PARSING_ERROR:\n          {\n            this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);\n            break;\n          }\n      }\n    }\n    /**\n     * Removes multiple rows from sheet. </br>\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * @param sheet - sheet id from which rows will be removed\n     * @param rowStart - number of the first row to be deleted\n     * @param rowEnd - number of the last row to be deleted\n     * */\n\n  }, {\n    key: \"doRemoveRows\",\n    value: function doRemoveRows(rowsToRemove) {\n      var _this9 = this;\n\n      if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {\n        return;\n      }\n\n      var removedCells = [];\n\n      var _iterator8 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 1),\n              address = _step8$value[0];\n\n          removedCells.push({\n            address: address,\n            cellType: this.getClipboardCell(address)\n          });\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      this.dependencyGraph.removeRows(rowsToRemove);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveRowsTransformer(rowsToRemove);\n        transformation.performEagerTransformations(_this9.dependencyGraph, _this9.parser);\n        version = _this9.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      return {\n        version: version,\n        removedCells: removedCells,\n        rowFrom: rowsToRemove.rowStart,\n        rowCount: rowsToRemove.numberOfRows\n      };\n    }\n    /**\n     * Removes multiple columns from sheet. </br>\n     * Does nothing if columns are outside of effective sheet size.\n     *\n     * @param sheet - sheet id from which columns will be removed\n     * @param columnStart - number of the first column to be deleted\n     * @param columnEnd - number of the last row to be deleted\n     */\n\n  }, {\n    key: \"doRemoveColumns\",\n    value: function doRemoveColumns(columnsToRemove) {\n      var _this10 = this;\n\n      if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {\n        return;\n      }\n\n      var removedCells = [];\n\n      var _iterator9 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step9$value = _slicedToArray(_step9.value, 1),\n              address = _step9$value[0];\n\n          removedCells.push({\n            address: address,\n            cellType: this.getClipboardCell(address)\n          });\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      this.dependencyGraph.removeColumns(columnsToRemove);\n      this.columnSearch.removeColumns(columnsToRemove);\n      var version;\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new RemoveColumnsTransformer(columnsToRemove);\n        transformation.performEagerTransformations(_this10.dependencyGraph, _this10.parser);\n        version = _this10.lazilyTransformingAstService.addTransformation(transformation);\n      });\n      return {\n        version: version,\n        removedCells: removedCells,\n        columnFrom: columnsToRemove.columnStart,\n        columnCount: columnsToRemove.numberOfColumns\n      };\n    }\n    /**\n     * Add multiple rows to sheet. </br>\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * @param sheet - sheet id in which rows will be added\n     * @param row - row number above which the rows will be added\n     * @param numberOfRowsToAdd - number of rows to add\n     */\n\n  }, {\n    key: \"doAddRows\",\n    value: function doAddRows(addedRows) {\n      var _this11 = this;\n\n      if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {\n        return;\n      }\n\n      this.dependencyGraph.addRows(addedRows);\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new AddRowsTransformer(addedRows);\n        transformation.performEagerTransformations(_this11.dependencyGraph, _this11.parser);\n\n        _this11.lazilyTransformingAstService.addTransformation(transformation);\n      });\n    }\n    /**\n     * Add multiple columns to sheet </br>\n     * Does nothing if columns are outside of effective sheet size\n     *\n     * @param sheet - sheet id in which columns will be added\n     * @param column - column number above which the columns will be added\n     * @param numberOfColumns - number of columns to add\n     */\n\n  }, {\n    key: \"doAddColumns\",\n    value: function doAddColumns(addedColumns) {\n      var _this12 = this;\n\n      if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {\n        return;\n      }\n\n      this.dependencyGraph.addColumns(addedColumns);\n      this.columnSearch.addColumns(addedColumns);\n      this.stats.measure(StatType.TRANSFORM_ASTS, function () {\n        var transformation = new AddColumnsTransformer(addedColumns);\n        transformation.performEagerTransformations(_this12.dependencyGraph, _this12.parser);\n\n        _this12.lazilyTransformingAstService.addTransformation(transformation);\n      });\n    }\n  }, {\n    key: \"getClipboardCell\",\n    value: function getClipboardCell(address) {\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex === null || vertex instanceof EmptyCellVertex) {\n        return {\n          type: ClipboardCellType.EMPTY\n        };\n      } else if (vertex instanceof ValueCellVertex) {\n        return Object.assign({\n          type: ClipboardCellType.VALUE\n        }, vertex.getValues());\n      } else if (vertex instanceof MatrixVertex) {\n        return {\n          type: ClipboardCellType.VALUE,\n          parsedValue: vertex.getMatrixCellValue(address),\n          rawValue: vertex.getMatrixCellRawValue(address)\n        };\n      } else if (vertex instanceof FormulaCellVertex) {\n        return {\n          type: ClipboardCellType.FORMULA,\n          hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n        };\n      } else if (vertex instanceof ParsingErrorVertex) {\n        return {\n          type: ClipboardCellType.PARSING_ERROR,\n          rawInput: vertex.rawInput,\n          errors: vertex.errors\n        };\n      }\n\n      throw Error('Trying to copy unsupported type');\n    }\n  }, {\n    key: \"getSheetClipboardCells\",\n    value: function getSheetClipboardCells(sheet) {\n      var sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n      var sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n      var arr = new Array(sheetHeight);\n\n      for (var i = 0; i < sheetHeight; i++) {\n        arr[i] = new Array(sheetWidth);\n\n        for (var j = 0; j < sheetWidth; j++) {\n          var address = simpleCellAddress(sheet, j, i);\n          arr[i][j] = this.getClipboardCell(address);\n        }\n      }\n\n      return arr;\n    }\n  }, {\n    key: \"getRangeClipboardCells\",\n    value: function getRangeClipboardCells(range) {\n      var result = [];\n\n      var _iterator10 = _createForOfIteratorHelper(range.addresses(this.dependencyGraph)),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var address = _step10.value;\n          result.push([address, this.getClipboardCell(address)]);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"setCellContent\",\n    value: function setCellContent(address, newCellContent) {\n      var parsedCellContent = this.cellContentParser.parse(newCellContent);\n      var vertex = this.dependencyGraph.getCell(address);\n\n      if (vertex instanceof MatrixVertex && !vertex.isFormula() && !(parsedCellContent instanceof CellContent.Number)) {\n        this.dependencyGraph.breakNumericMatrix(vertex);\n        vertex = this.dependencyGraph.getCell(address);\n      }\n\n      if (vertex instanceof MatrixVertex && !vertex.isFormula() && parsedCellContent instanceof CellContent.Number) {\n        var newValue = parsedCellContent.value;\n        var oldValue = this.dependencyGraph.getCellValue(address);\n        this.dependencyGraph.graph.markNodeAsSpecialRecentlyChanged(vertex);\n        vertex.setMatrixCellValue(address, getRawValue(newValue));\n        this.columnSearch.change(getRawValue(oldValue), getRawValue(newValue), address);\n        this.changes.addChange(newValue, address);\n      } else if (!(vertex instanceof MatrixVertex) && parsedCellContent instanceof CellContent.MatrixFormula) {\n        var _this$parser$parse = this.parser.parse(parsedCellContent.formula, address),\n            ast = _this$parser$parse.ast,\n            errors = _this$parser$parse.errors,\n            dependencies = _this$parser$parse.dependencies;\n\n        if (errors.length > 0) {\n          this.dependencyGraph.setParsingErrorToCell(address, new ParsingErrorVertex(errors, parsedCellContent.formulaWithBraces()));\n        } else {\n          var newVertex = buildMatrixVertex(ast, address);\n\n          if (newVertex instanceof ValueCellVertex) {\n            throw Error('What if new matrix vertex is not properly constructed?');\n          }\n\n          this.dependencyGraph.addNewMatrixVertex(newVertex);\n          this.dependencyGraph.processCellDependencies(absolutizeDependencies(dependencies, address), newVertex);\n          this.dependencyGraph.graph.markNodeAsSpecialRecentlyChanged(newVertex);\n        }\n      } else if (!(vertex instanceof MatrixVertex)) {\n        if (parsedCellContent instanceof CellContent.Formula) {\n          var _this$parser$parse2 = this.parser.parse(parsedCellContent.formula, address),\n              _ast = _this$parser$parse2.ast,\n              _errors = _this$parser$parse2.errors,\n              hasVolatileFunction = _this$parser$parse2.hasVolatileFunction,\n              hasStructuralChangeFunction = _this$parser$parse2.hasStructuralChangeFunction,\n              _dependencies = _this$parser$parse2.dependencies;\n\n          if (_errors.length > 0) {\n            this.dependencyGraph.setParsingErrorToCell(address, new ParsingErrorVertex(_errors, parsedCellContent.formula));\n          } else {\n            this.dependencyGraph.setFormulaToCell(address, _ast, absolutizeDependencies(_dependencies, address), hasVolatileFunction, hasStructuralChangeFunction);\n          }\n        } else if (parsedCellContent instanceof CellContent.Empty) {\n          this.setCellEmpty(address);\n        } else if (parsedCellContent instanceof CellContent.MatrixFormula) {\n          throw new Error('Cant happen');\n        } else {\n          this.setValueToCell({\n            parsedValue: parsedCellContent.value,\n            rawValue: newCellContent\n          }, address);\n        }\n      } else {\n        throw new Error('Illegal operation');\n      }\n    }\n  }, {\n    key: \"setSheetContent\",\n    value: function setSheetContent(sheetId, newSheetContent) {\n      this.clearSheet(sheetId);\n\n      for (var i = 0; i < newSheetContent.length; i++) {\n        for (var j = 0; j < newSheetContent[i].length; j++) {\n          var address = simpleCellAddress(sheetId, j, i);\n          this.setCellContent(address, newSheetContent[i][j]);\n        }\n      }\n    }\n  }, {\n    key: \"setValueToCell\",\n    value: function setValueToCell(value, address) {\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      this.dependencyGraph.setValueToCell(address, value);\n      this.columnSearch.change(getRawValue(oldValue), getRawValue(value.parsedValue), address);\n      this.changes.addChange(value.parsedValue, address);\n    }\n  }, {\n    key: \"setCellEmpty\",\n    value: function setCellEmpty(address) {\n      var oldValue = this.dependencyGraph.getCellValue(address);\n      this.columnSearch.remove(getRawValue(oldValue), address);\n      this.changes.addChange(EmptyValue, address);\n      this.dependencyGraph.setCellEmpty(address);\n    }\n  }, {\n    key: \"setFormulaToCellFromCache\",\n    value: function setFormulaToCellFromCache(formulaHash, address) {\n      var _this$parser$fetchCac2 = this.parser.fetchCachedResult(formulaHash),\n          ast = _this$parser$fetchCac2.ast,\n          hasVolatileFunction = _this$parser$fetchCac2.hasVolatileFunction,\n          hasStructuralChangeFunction = _this$parser$fetchCac2.hasStructuralChangeFunction,\n          dependencies = _this$parser$fetchCac2.dependencies;\n\n      var absoluteDependencies = absolutizeDependencies(dependencies, address);\n\n      var _CleanOutOfScopeDepen = new CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address),\n          _CleanOutOfScopeDepen2 = _slicedToArray(_CleanOutOfScopeDepen, 1),\n          cleanedAst = _CleanOutOfScopeDepen2[0];\n\n      this.parser.rememberNewAst(cleanedAst);\n      var cleanedDependencies = filterDependenciesOutOfScope(absoluteDependencies);\n      this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, hasVolatileFunction, hasStructuralChangeFunction);\n    }\n  }, {\n    key: \"setParsingErrorToCell\",\n    value: function setParsingErrorToCell(rawInput, errors, address) {\n      this.dependencyGraph.setParsingErrorToCell(address, new ParsingErrorVertex(errors, rawInput));\n    }\n    /**\n     * Returns true if row number is outside of given sheet.\n     *\n     * @param row - row number\n     * @param sheet - sheet id number\n     */\n\n  }, {\n    key: \"rowEffectivelyNotInSheet\",\n    value: function rowEffectivelyNotInSheet(row, sheet) {\n      var height = this.dependencyGraph.addressMapping.getHeight(sheet);\n      return row >= height;\n    }\n  }, {\n    key: \"getAndClearContentChanges\",\n    value: function getAndClearContentChanges() {\n      var changes = this.changes;\n      this.changes = ContentChanges.empty();\n      return changes;\n    }\n  }, {\n    key: \"forceApplyPostponedTransformations\",\n    value: function forceApplyPostponedTransformations() {\n      this.dependencyGraph.forceApplyPostponedTransformations();\n    }\n  }, {\n    key: \"sheetMapping\",\n    get: function get() {\n      return this.dependencyGraph.sheetMapping;\n    }\n    /**\n     * Returns true if row number is outside of given sheet.\n     *\n     * @param column - row number\n     * @param sheet - sheet id number\n     */\n\n  }, {\n    key: \"columnEffectivelyNotInSheet\",\n    value: function columnEffectivelyNotInSheet(column, sheet) {\n      var width = this.dependencyGraph.addressMapping.getWidth(sheet);\n      return column >= width;\n    }\n  }, {\n    key: \"adjustNamedExpressionEdges\",\n    value: function adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {\n      if (sheetId === undefined) {\n        return;\n      }\n\n      var localVertex = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);\n      var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n      var globalVertex = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);\n\n      var _iterator11 = _createForOfIteratorHelper(this.dependencyGraph.graph.adjacentNodes(globalVertex)),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var adjacentNode = _step11.value;\n\n          if (adjacentNode instanceof FormulaCellVertex && adjacentNode.cellAddress.sheet === sheetId) {\n            var ast = adjacentNode.getFormula(this.lazilyTransformingAstService);\n            var formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);\n\n            var _this$parser$fetchCac3 = this.parser.fetchCachedResultForAst(ast),\n                dependencies = _this$parser$fetchCac3.dependencies;\n\n            var _iterator12 = _createForOfIteratorHelper(absolutizeDependencies(dependencies, formulaAddress)),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var dependency = _step12.value;\n\n                if (dependency instanceof NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {\n                  this.dependencyGraph.graph.removeEdge(globalVertex, adjacentNode);\n                  this.dependencyGraph.graph.addEdge(localVertex, adjacentNode);\n                }\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n    }\n  }, {\n    key: \"storeNamedExpressionInCell\",\n    value: function storeNamedExpressionInCell(address, expression) {\n      var parsedCellContent = this.cellContentParser.parse(expression);\n\n      if (parsedCellContent instanceof CellContent.MatrixFormula) {\n        throw new Error('Matrix formulas are not supported');\n      } else if (parsedCellContent instanceof CellContent.Formula) {\n        var parsingResult = this.parser.parse(parsedCellContent.formula, simpleCellAddress(-1, 0, 0));\n\n        if (doesContainRelativeReferences(parsingResult.ast)) {\n          throw new NoRelativeAddressesAllowedError();\n        }\n\n        var ast = parsingResult.ast,\n            hasVolatileFunction = parsingResult.hasVolatileFunction,\n            hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,\n            dependencies = parsingResult.dependencies;\n        this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), hasVolatileFunction, hasStructuralChangeFunction);\n      } else {\n        if (parsedCellContent instanceof CellContent.Empty) {\n          this.setCellEmpty(address);\n        } else {\n          this.setValueToCell({\n            parsedValue: parsedCellContent.value,\n            rawValue: expression\n          }, address);\n        }\n      }\n    }\n  }, {\n    key: \"updateNamedExpressionsForMovedCells\",\n    value: function updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {\n        return [];\n      }\n\n      var addedGlobalNamedExpressions = [];\n      var targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n\n      var _iterator13 = _createForOfIteratorHelper(targetRange.addresses(this.dependencyGraph)),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var formulaAddress = _step13.value;\n          var vertex = this.addressMapping.fetchCell(formulaAddress);\n\n          if (vertex instanceof FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {\n            var ast = vertex.getFormula(this.lazilyTransformingAstService);\n\n            var _this$parser$fetchCac4 = this.parser.fetchCachedResultForAst(ast),\n                dependencies = _this$parser$fetchCac4.dependencies;\n\n            addedGlobalNamedExpressions.push.apply(addedGlobalNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies)));\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      return addedGlobalNamedExpressions;\n    }\n  }, {\n    key: \"updateNamedExpressionsForTargetAddress\",\n    value: function updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {\n      if (sourceSheet === targetAddress.sheet) {\n        return [];\n      }\n\n      var addedGlobalNamedExpressions = [];\n      var vertex = this.addressMapping.fetchCell(targetAddress);\n\n      var _iterator14 = _createForOfIteratorHelper(absolutizeDependencies(dependencies, targetAddress)),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var namedExpressionDependency = _step14.value;\n\n          if (!(namedExpressionDependency instanceof NamedExpressionDependency)) {\n            continue;\n          }\n\n          var expressionName = namedExpressionDependency.name;\n          var sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet);\n          var namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);\n          var targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet) : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);\n\n          if (targetScopeExpressionVertex !== sourceVertex) {\n            this.dependencyGraph.graph.softRemoveEdge(sourceVertex, vertex);\n            this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      return addedGlobalNamedExpressions;\n    }\n  }, {\n    key: \"allocateNamedExpressionAddressSpace\",\n    value: function allocateNamedExpressionAddressSpace() {\n      this.dependencyGraph.addressMapping.addSheet(-1, new SparseStrategy(0, 0));\n    }\n  }, {\n    key: \"copyOrFetchGlobalNamedExpressionVertex\",\n    value: function copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {\n      var expression = this.namedExpressions.namedExpressionForScope(expressionName);\n\n      if (expression === undefined) {\n        expression = this.namedExpressions.addNamedExpression(expressionName);\n        addedNamedExpressions.push(expression.normalizeExpressionName());\n\n        if (sourceVertex instanceof FormulaCellVertex) {\n          var parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));\n          var ast = parsingResult.ast,\n              hasVolatileFunction = parsingResult.hasVolatileFunction,\n              hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,\n              dependencies = parsingResult.dependencies;\n          this.dependencyGraph.setFormulaToCell(expression.address, ast, absolutizeDependencies(dependencies, expression.address), hasVolatileFunction, hasStructuralChangeFunction);\n        } else if (sourceVertex instanceof EmptyCellVertex) {\n          this.setCellEmpty(expression.address);\n        } else if (sourceVertex instanceof ValueCellVertex) {\n          this.setValueToCell(sourceVertex.getValues(), expression.address);\n        }\n      }\n\n      return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address);\n    }\n  }, {\n    key: \"addressMapping\",\n    get: function get() {\n      return this.dependencyGraph.addressMapping;\n    }\n  }]);\n\n  return Operations;\n}();\nexport function normalizeRemovedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n\n  var sorted = _toConsumableArray(indexes).sort(function (_ref5, _ref6) {\n    var _ref7 = _slicedToArray(_ref5, 1),\n        a = _ref7[0];\n\n    var _ref8 = _slicedToArray(_ref6, 1),\n        b = _ref8[0];\n\n    return a - b;\n  });\n  /* merge overlapping and adjacent indexes */\n\n\n  var merged = sorted.reduce(function (acc, _ref9) {\n    var _ref10 = _slicedToArray(_ref9, 2),\n        startIndex = _ref10[0],\n        amount = _ref10[1];\n\n    var previous = acc[acc.length - 1];\n    var lastIndex = previous[0] + previous[1];\n\n    if (startIndex <= lastIndex) {\n      previous[1] += Math.max(0, amount - (lastIndex - startIndex));\n    } else {\n      acc.push([startIndex, amount]);\n    }\n\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n\n  var shift = 0;\n\n  for (var i = 0; i < merged.length; ++i) {\n    merged[i][0] -= shift;\n    shift += merged[i][1];\n  }\n\n  return merged;\n}\nexport function normalizeAddedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n\n  var sorted = _toConsumableArray(indexes).sort(function (_ref11, _ref12) {\n    var _ref13 = _slicedToArray(_ref11, 1),\n        a = _ref13[0];\n\n    var _ref14 = _slicedToArray(_ref12, 1),\n        b = _ref14[0];\n\n    return a - b;\n  });\n  /* merge indexes with same start */\n\n\n  var merged = sorted.reduce(function (acc, _ref15) {\n    var _ref16 = _slicedToArray(_ref15, 2),\n        startIndex = _ref16[0],\n        amount = _ref16[1];\n\n    var previous = acc[acc.length - 1];\n\n    if (startIndex === previous[0]) {\n      previous[1] = Math.max(previous[1], amount);\n    } else {\n      acc.push([startIndex, amount]);\n    }\n\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n\n  var shift = 0;\n\n  for (var i = 0; i < merged.length; ++i) {\n    merged[i][0] += shift;\n    shift += merged[i][1];\n  }\n\n  return merged;\n}\n\nfunction isPositiveInteger(x) {\n  return Number.isInteger(x) && x > 0;\n}\n\nfunction isRowOrColumnRange(leftCorner, width, height) {\n  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;\n}"]},"metadata":{},"sourceType":"module"}