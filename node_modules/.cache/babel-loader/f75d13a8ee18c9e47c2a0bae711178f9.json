{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { CellType, getCellType as _getCellType, getCellValueType as _getCellValueType, getCellValueDetailedType as _getCellValueDetailedType, getCellValueFormat as _getCellValueFormat } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { numberToSimpleTime } from './DateTimeHelper';\nimport { buildTranslationPackage } from './i18n';\nimport { normalizeAddedIndexes, normalizeRemovedIndexes } from './Operations';\nimport { EvaluationSuspendedError, LanguageAlreadyRegisteredError, LanguageNotRegisteredError, NotAFormulaError } from './errors';\nimport { AstNodeType, simpleCellAddressFromString as _simpleCellAddressFromString, simpleCellAddressToString as _simpleCellAddressToString } from './parser';\nimport { Emitter, Events } from './Emitter';\nimport { BuildEngineFactory } from './BuildEngineFactory';\nimport { FunctionRegistry } from './interpreter/FunctionRegistry';\n/**\n * This is a class for creating HyperFormula instance, all the following public methods\n * ale related to this class.\n *\n * The instance can be created only by calling one of the static methods\n * `buildFromArray`, `buildFromSheets` or `buildEmpty` and should be disposed of with the\n * `destroy` method when it's no longer needed to free the resources.\n *\n * The instance can be seen as a workbook where worksheets can be created and\n * manipulated. They are organized within a widely know structure of columns and rows\n * which can be manipulated as well. The smallest possible data unit are the cells, which\n * may contain simple values or formulas to be calculated.\n *\n * All CRUD methods are called directly on HyperFormula instance and will trigger\n * corresponding lifecycle events. The events are marked accordingly, as well as thrown\n * errors so they can be correctly handled.\n */\n\nexport var HyperFormula = /*#__PURE__*/function () {\n  function HyperFormula(_config, _stats, _dependencyGraph, _columnSearch, _parser, _unparser, _cellContentParser, _evaluator, _lazilyTransformingAstService, _crudOperations, _exporter, _namedExpressions, _serialization, _functionRegistry) {\n    _classCallCheck(this, HyperFormula);\n\n    this._config = _config;\n    this._stats = _stats;\n    this._dependencyGraph = _dependencyGraph;\n    this._columnSearch = _columnSearch;\n    this._parser = _parser;\n    this._unparser = _unparser;\n    this._cellContentParser = _cellContentParser;\n    this._evaluator = _evaluator;\n    this._lazilyTransformingAstService = _lazilyTransformingAstService;\n    this._crudOperations = _crudOperations;\n    this._exporter = _exporter;\n    this._namedExpressions = _namedExpressions;\n    this._serialization = _serialization;\n    this._functionRegistry = _functionRegistry;\n    this._emitter = new Emitter();\n    this._evaluationSuspended = false;\n  }\n  /**\n   * Calls the `graph` method on the dependency graph.\n   * Allows to execute `graph` directly without a need to refer to `dependencyGraph`.\n   *\n   * @internal\n   */\n\n\n  _createClass(HyperFormula, [{\n    key: \"graph\",\n    get: function get() {\n      return this.dependencyGraph.graph;\n    }\n    /**\n     * Calls the `rangeMapping` method on the dependency graph.\n     * Allows to execute `rangeMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"rangeMapping\",\n    get: function get() {\n      return this.dependencyGraph.rangeMapping;\n    }\n    /**\n     * Calls the `matrixMapping` method on the dependency graph.\n     * Allows to execute `matrixMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"matrixMapping\",\n    get: function get() {\n      return this.dependencyGraph.matrixMapping;\n    }\n    /**\n     * Calls the `sheetMapping` method on the dependency graph.\n     * Allows to execute `sheetMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"sheetMapping\",\n    get: function get() {\n      return this.dependencyGraph.sheetMapping;\n    }\n    /**\n     * Calls the `addressMapping` method on the dependency graph.\n     * Allows to execute `addressMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"addressMapping\",\n    get: function get() {\n      return this.dependencyGraph.addressMapping;\n    }\n    /** @internal */\n\n  }, {\n    key: \"dependencyGraph\",\n    get: function get() {\n      return this._dependencyGraph;\n    }\n    /** @internal */\n\n  }, {\n    key: \"evaluator\",\n    get: function get() {\n      return this._evaluator;\n    }\n    /** @internal */\n\n  }, {\n    key: \"columnSearch\",\n    get: function get() {\n      return this._columnSearch;\n    }\n    /** @internal */\n\n  }, {\n    key: \"lazilyTransformingAstService\",\n    get: function get() {\n      return this._lazilyTransformingAstService;\n    }\n    /**\n     * Returns state of the validity of the license key.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"licenseKeyValidityState\",\n    get: function get() {\n      return this._config.licenseKeyValidityState;\n    }\n  }, {\n    key: \"getCellValue\",\n    value:\n    /**\n     * Returns the cell value of a given address.\n     * Applies rounding and post-processing.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '2'],\n     * ]);\n     *\n     * // get value of A1 cell, should be '6'\n     * const A1Value = hfInstance.getCellValue({ sheet: 0, col: 0, row: 0 });\n     *\n     * // get value of B1 cell, should be '2'\n     * const B1Value = hfInstance.getCellValue({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n    function getCellValue(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getCellValue(cellAddress);\n    }\n  }, {\n    key: \"ensureEvaluationIsNotSuspended\",\n    value: function ensureEvaluationIsNotSuspended() {\n      if (this._evaluationSuspended) {\n        throw new EvaluationSuspendedError();\n      }\n    }\n    /**\n     * Returns a normalized formula string from the cell of a given address or `undefined` for an address that does not exist and empty values.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '0'],\n     * ]);\n     *\n     * // should return a normalized A1 cell formula: '=SUM(1,2,3)'\n     * const A1Formula = hfInstance.getCellFormula({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return a normalized B1 cell formula: 'undefined'\n     * const B1Formula = hfInstance.getCellFormula({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellFormula\",\n    value: function getCellFormula(cellAddress) {\n      return this._serialization.getCellFormula(cellAddress);\n    }\n    /**\n     * Returns [[CellValue]] which a serialized content of the cell of a given address either a cell formula, an explicit value, or an error.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '0'],\n     * ]);\n     *\n     * // should return serialized content of A1 cell: '=SUM(1,2,3)'\n     * const cellA1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return serialized content of B1 cell: '0'\n     * const cellB1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellSerialized\",\n    value: function getCellSerialized(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getCellSerialized(cellAddress);\n    }\n    /**\n     * Returns an array of arrays of [[CellValue]] with values of all cells from [[Sheet]].\n     * Applies rounding and post-processing.\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @param {number} sheetId - sheet ID number\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return all values of a sheet: [[0, 6, 0], [1, '1.0%', 0], [2, 6, 0]]\n     * const sheetValues = hfInstance.getSheetValues(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetValues\",\n    value: function getSheetValues(sheetId) {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getSheetValues(sheetId);\n    }\n    /**\n     * Returns an array with normalized formula strings from [[Sheet]] or `undefined` for a cells that have no value.\n     *\n     * @param {SimpleCellAddress} sheetId - sheet ID number\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return all formulas of a sheet:\n     * // [\n     * //  [undefined, '=SUM(1,2,3)', '=A1'],\n     * //  [undefined, '=TEXT(A2, \"0.0%\")', '=C1'],\n     * //  [undefined, '=SUM(A1:C1)', '=C1'],\n     * // ];\n     * const sheetFormulas = hfInstance.getSheetFormulas(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetFormulas\",\n    value: function getSheetFormulas(sheetId) {\n      return this._serialization.getSheetFormulas(sheetId);\n    }\n    /**\n     * Returns an array of arrays of [[NoErrorCellValue]] with serialized content of cells from [[Sheet]], either a cell formula or an explicit value.\n     *\n     * @param {SimpleCellAddress} sheetId - sheet ID number\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return:\n     * // [\n     * //  ['0', '=SUM(1,2,3)', '=A1'],\n     * //  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     * //  ['2', '=SUM(A1:C1)', '=C1'],\n     * // ];\n     * const serializedContent = hfInstance.getSheetSerialized(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetSerialized\",\n    value: function getSheetSerialized(sheetId) {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getSheetSerialized(sheetId);\n    }\n    /**\n     * Returns a map containing dimensions of all sheets for the engine instance represented as a key-value pairs where keys are sheet IDs and dimensions are returned as numbers, width and height respectively.\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   Sheet1: [\n     *    ['1', '2', '=Sheet2!$A1'],\n     *   ],\n     *   Sheet2: [\n     *    ['3'],\n     *    ['4'],\n     *   ],\n     * });\n     *\n     * // should return the dimensions of all sheets:\n     * // { Sheet1: { width: 3, height: 1 }, Sheet2: { width: 1, height: 2 } }\n     * const allSheetsDimensions = hfInstance.getAllSheetsDimensions();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsDimensions\",\n    value: function getAllSheetsDimensions() {\n      var _this = this;\n\n      return this._serialization.genericAllSheetsGetter(function (arg) {\n        return _this.getSheetDimensions(arg);\n      });\n    }\n    /**\n     * Returns dimensions of a specified sheet.\n     * The sheet dimensions is represented with numbers: width and height.\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @param {number} sheetId - sheet ID number\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *    ['1', '2', '=Sheet2!$A1'],\n     * ]);\n     *\n     * // should return provided sheet's dimensions: { width: 3, height: 1 }\n     * const sheetDimensions = hfInstance.getSheetDimensions(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetDimensions\",\n    value: function getSheetDimensions(sheetId) {\n      return {\n        width: this.dependencyGraph.getSheetWidth(sheetId),\n        height: this.dependencyGraph.getSheetHeight(sheetId)\n      };\n    }\n    /**\n     * Returns values of all sheets in a form of an object which property keys are strings and values are arrays of arrays of [[CellValue]].\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '=A1+10', '3'],\n     * ]);\n     *\n     * // should return all sheets values: { Sheet1: [ [ 1, 11, 3 ] ] }\n     * const allSheetsValues = hfInstance.getAllSheetsValues();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsValues\",\n    value: function getAllSheetsValues() {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getAllSheetsValues();\n    }\n    /**\n     * Returns formulas of all sheets in a form of an object which property keys are strings and values are arrays of arrays of strings or possibly `undefined` when the call does not contain a formula.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1+10'],\n     * ]);\n     *\n     * // should return only formulas: { Sheet1: [ [ undefined, undefined, '=A1+10' ] ] }\n     * const allSheetsFormulas = hfInstance.getAllSheetsFormulas();\n     * ```\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsFormulas\",\n    value: function getAllSheetsFormulas() {\n      return this._serialization.getAllSheetsFormulas();\n    }\n    /**\n     * Returns formulas or values of all sheets in a form of an object which property keys are strings and values are arrays of arrays of [[CellValue]].\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1+10'],\n     * ]);\n     *\n     * // should return all sheets serialized content: { Sheet1: [ [ 1, 2, '=A1+10' ] ] }\n     * const allSheetsSerialized = hfInstance.getAllSheetsSerialized();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsSerialized\",\n    value: function getAllSheetsSerialized() {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getAllSheetsSerialized();\n    }\n    /**\n     * Updates the config with given new metadata.\n     *\n     * @param {Partial<ConfigParams>} newParams configuration options to be updated or added\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // add a config param, for example maxColumns,\n     * // you can check the configuration with getConfig method\n     * hfInstance.updateConfig({ maxColumns: 1000 });\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(newParams) {\n      var _this2 = this;\n\n      var newConfig = this._config.mergeConfig(newParams);\n\n      var configNewLanguage = this._config.mergeConfig({\n        language: newParams.language\n      });\n\n      var serializedSheets = this._serialization.withNewConfig(configNewLanguage, this._namedExpressions).getAllSheetsSerialized();\n\n      var serializedNamedExpressions = this._serialization.getAllNamedExpressionsSerialized();\n\n      var newEngine = BuildEngineFactory.rebuildWithConfig(newConfig, serializedSheets, this._stats);\n      this._config = newEngine.config;\n      this._stats = newEngine.stats;\n      this._dependencyGraph = newEngine.dependencyGraph;\n      this._columnSearch = newEngine.columnSearch;\n      this._parser = newEngine.parser;\n      this._unparser = newEngine.unparser;\n      this._cellContentParser = newEngine.cellContentParser;\n      this._evaluator = newEngine.evaluator;\n      this._lazilyTransformingAstService = newEngine.lazilyTransformingAstService;\n      this._crudOperations = newEngine.crudOperations;\n      this._exporter = newEngine.exporter;\n      this._namedExpressions = newEngine.namedExpressions;\n      this._serialization = newEngine.serialization;\n      this._functionRegistry = newEngine.functionRegistry;\n      serializedNamedExpressions.forEach(function (entry) {\n        _this2.addNamedExpression(entry.name, entry.expression, entry.scope, entry.options);\n      });\n    }\n    /**\n     * Returns current configuration of the engine instance.\n     *\n     * @example\n     * ```js\n     * // should return all config metadata including default and those which were added\n     * const hfConfig = hfInstance.getConfig();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this._config.getConfig();\n    }\n    /**\n     * Serializes and deserializes whole engine, effectively reloading it.\n     *\n     * @example\n     * ```js\n     * hfInstance.rebuildAndRecalculate();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"rebuildAndRecalculate\",\n    value: function rebuildAndRecalculate() {\n      this.updateConfig({});\n    }\n    /**\n     * Returns a snapshot of computation time statistics.\n     * It returns a map with key-value pairs where keys are enums for stat type and time (number).\n     *\n     * @internal\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return this._stats.snapshot();\n    }\n    /**\n     * Undo the previous operation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoOperationToUndoError]] when there is no operation running that can be undone\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     *  ['3', ''],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // do an undo, it should return the changes\n     * const changes = hfInstance.undo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      this._crudOperations.undo();\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Re-do recently undone operation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoOperationToRedoError]] when there is no operation running that can be re-done\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     *  ['3'],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // do an undo, it should return prvious values: [['1'], ['2'], ['3']]\n     * hfInstance.undo();\n     *\n     * // do a redo, it should return the values after removing the second row: [['1'], ['3']]\n     * const changes = hfInstance.redo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      this._crudOperations.redo();\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if there is at least one operation that can be undone.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     *  ['3'],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // should return 'true', it is possible to undo last operation\n     * // which is removing rows in this example\n     * const isSomethingToUndo = hfInstance.isThereSomethingToUndo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"isThereSomethingToUndo\",\n    value: function isThereSomethingToUndo() {\n      return this._crudOperations.isThereSomethingToUndo();\n    }\n    /**\n     * Checks if there is at least one operation that can be re-done.\n     *\n     * @example\n     * ```js\n     * hfInstance.undo();\n     *\n     * // when there is an action to redo, this will return 'true'\n     * const isSomethingToRedo = hfInstance.isThereSomethingToRedo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"isThereSomethingToRedo\",\n    value: function isThereSomethingToRedo() {\n      return this._crudOperations.isThereSomethingToRedo();\n    }\n    /**\n     * Returns information whether it is possible to change the content in a rectangular area bounded by the box.\n     * If returns `true`, doing [[setCellContents]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside selected cells, the address is invalid or the sheet does not exist.\n     *\n     * @param {SimpleCellAddress} topLeftCornerAddress -  top left corner of block of cells\n     * @param {number} width - width of the box\n     * @param {number} height - height of the box\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // choose the address and assign it to a variable\n     * const address = { col: 0, row: 0, sheet: 0 };\n     *\n     * // should return 'true' for this example, it is possible to set content of\n     * // width 2, height 1 in the first row and column of sheet 0\n     * const isSettable = hfInstance.isItPossibleToSetCellContents(address, 2, 1);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isItPossibleToSetCellContents\",\n    value: function isItPossibleToSetCellContents(topLeftCornerAddress) {\n      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      try {\n        this._crudOperations.ensureRangeInSizeLimits(AbsoluteCellRange.spanFrom(topLeftCornerAddress, width, height));\n\n        for (var i = 0; i < width; i++) {\n          for (var j = 0; j < height; j++) {\n            this._crudOperations.ensureItIsPossibleToChangeContent({\n              col: topLeftCornerAddress.col + i,\n              row: topLeftCornerAddress.row + j,\n              sheet: topLeftCornerAddress.sheet\n            });\n          }\n        }\n      } catch (e) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Sets the content for a block of cells of a given coordinates.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} topLeftCornerAddress - top left corner of block of cells\n     * @param {(RawCellContent[][]|RawCellContent)} cellContents - array with content\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the value is not an array of arrays or a raw cell value\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws an error when it is an attempt to set cells content inside matrices during batch operation\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1'],\n     * ]);\n     *\n     * // should set the content, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 3, row: 0 },\n     * //   newValue: 2,\n     * // }]\n     * const changes = hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"setCellContents\",\n    value: function setCellContents(topLeftCornerAddress, cellContents) {\n      this._crudOperations.setCellContents(topLeftCornerAddress, cellContents);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Reorders rows of a sheet according to a source-target mapping.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // should set swap rows 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 2 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 2 },\n     * //   newValue: null,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 5,\n     * // }]\n     * const changes = hfInstance.swapRowIndexes(0, [[0,2],[2,0]]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"swapRowIndexes\",\n    value: function swapRowIndexes(sheetId, rowMapping) {\n      this._crudOperations.setRowOrder(sheetId, rowMapping);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if it is possible to reorder rows of a sheet according to a source-target mapping.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // returns true\n     * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0,2],[2,0]]);\n     *\n     * // returns false\n     * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0,1]]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToSwapRowIndexes\",\n    value: function isItPossibleToSwapRowIndexes(sheetId, rowMapping) {\n      try {\n        this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);\n\n        this._crudOperations.testRowOrderForMatrices(sheetId, rowMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders rows of a sheet according to a permutation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newRowOrder - permutation of rows\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // should set swap rows 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 2 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 2 },\n     * //   newValue: null,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 5,\n     * // }]\n     * const changes = hfInstance.setRowOrder(0, [2, 1, 0]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"setRowOrder\",\n    value: function setRowOrder(sheetId, newRowOrder) {\n      var mapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');\n\n      return this.swapRowIndexes(sheetId, mapping);\n    }\n    /**\n     * Checks if it is possible to reorder rows of a sheet according to a permutation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newRowOrder - permutation of rows\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSetRowOrder(0, [2, 1, 0]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSetRowOrder(0, [2]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToSetRowOrder\",\n    value: function isItPossibleToSetRowOrder(sheetId, newRowOrder) {\n      try {\n        var rowMapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');\n\n        this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);\n\n        this._crudOperations.testRowOrderForMatrices(sheetId, rowMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders columns of a sheet according to a source-target mapping.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} columnMapping - array mapping original positions to final positions of columns\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // should set swap columns 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 2, row: 0 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 2, row: 1 },\n     * //   newValue: 5,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 1 },\n     * //   newValue: null,\n     * // }]\n     * const changes = hfInstance.swapColumnIndexes(0, [[0,2],[2,0]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"swapColumnIndexes\",\n    value: function swapColumnIndexes(sheetId, columnMapping) {\n      this._crudOperations.setColumnOrder(sheetId, columnMapping);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if it is possible to reorder columns of a sheet according to a source-target mapping.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0,2],[2,0]]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0,1]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToSwapColumnIndexes\",\n    value: function isItPossibleToSwapColumnIndexes(sheetId, columnMapping) {\n      try {\n        this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);\n\n        this._crudOperations.testColumnOrderForMatrices(sheetId, columnMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders columns of a sheet according to a permutation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newColumnOrder - permutation of columns\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // should set swap columns 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 2, row: 0 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 2, row: 1 },\n     * //   newValue: 5,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 1 },\n     * //   newValue: null,\n     * // }]\n     * const changes = hfInstance.setColumnOrder(0, [2, 1, 0]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"setColumnOrder\",\n    value: function setColumnOrder(sheetId, newColumnOrder) {\n      var mapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');\n\n      return this.swapColumnIndexes(sheetId, mapping);\n    }\n    /**\n     * Checks if it possible to reorder columns of a sheet according to a permutation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newColumnOrder - permutation of columns\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSetColumnOrder(0, [2, 1, 0]]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSetColumnOrder(0, [1]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToSetColumnOrder\",\n    value: function isItPossibleToSetColumnOrder(sheetId, newRowOrder) {\n      try {\n        var columnMapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'column');\n\n        this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);\n\n        this._crudOperations.testColumnOrderForMatrices(sheetId, columnMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Returns information whether it is possible to add rows into a specified position in a given sheet.\n     * Checks against particular rules to ascertain that addRows can be called.\n     * If returns `true`, doing [[addRows]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected rows.\n     *\n     * @param {number} sheetId - sheet ID in which rows will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '3'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add one row in the second row of sheet 0\n     * const isAddable = hfInstance.isItPossibleToAddRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToAddRows\",\n    value: function isItPossibleToAddRows(sheetId) {\n      for (var _len = arguments.length, indexes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        indexes[_key - 1] = arguments[_key];\n      }\n\n      var normalizedIndexes = normalizeAddedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations;\n\n        (_this$_crudOperations = this._crudOperations).ensureItIsPossibleToAddRows.apply(_this$_crudOperations, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds multiple rows into a specified position in a given sheet.\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID in which rows will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[TargetLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.addRows(0, [0, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"addRows\",\n    value: function addRows(sheetId) {\n      var _this$_crudOperations2;\n\n      for (var _len2 = arguments.length, indexes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        indexes[_key2 - 1] = arguments[_key2];\n      }\n\n      (_this$_crudOperations2 = this._crudOperations).addRows.apply(_this$_crudOperations2, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove rows from a specified position in a given sheet.\n     * Checks against particular rules to ascertain that removeRows can be called.\n     * If returns `true`, doing [[removeRows]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected rows.\n     *\n     * @param {number} sheetId - sheet ID from which rows will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to remove one row from row 1 of sheet 0\n     * const isRemovable = hfInstance.isItPossibleToRemoveRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveRows\",\n    value: function isItPossibleToRemoveRows(sheetId) {\n      for (var _len3 = arguments.length, indexes = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        indexes[_key3 - 1] = arguments[_key3];\n      }\n\n      var normalizedIndexes = normalizeRemovedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations3;\n\n        (_this$_crudOperations3 = this._crudOperations).ensureItIsPossibleToRemoveRows.apply(_this$_crudOperations3, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes multiple rows from a specified position in a given sheet.\n     * Does nothing if rows are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID from which rows will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return: [{ sheet: 0, col: 1, row: 2, value: null }] for this example\n     * const changes = hfInstance.removeRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"removeRows\",\n    value: function removeRows(sheetId) {\n      var _this$_crudOperations4;\n\n      for (var _len4 = arguments.length, indexes = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        indexes[_key4 - 1] = arguments[_key4];\n      }\n\n      (_this$_crudOperations4 = this._crudOperations).removeRows.apply(_this$_crudOperations4, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to add columns into a specified position in a given sheet.\n     * Checks against particular rules to ascertain that addColumns can be called.\n     * If returns `true`, doing [[addColumns]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected columns.\n     *\n     * @param {number} sheetId - sheet ID in which columns will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add 1 column in sheet 0, at column 1\n     * const isAddable = hfInstance.isItPossibleToAddColumns(0, [1, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToAddColumns\",\n    value: function isItPossibleToAddColumns(sheetId) {\n      for (var _len5 = arguments.length, indexes = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        indexes[_key5 - 1] = arguments[_key5];\n      }\n\n      var normalizedIndexes = normalizeAddedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations5;\n\n        (_this$_crudOperations5 = this._crudOperations).ensureItIsPossibleToAddColumns.apply(_this$_crudOperations5, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds multiple columns into a specified position in a given sheet.\n     * Does nothing if the columns are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID in which columns will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[TargetLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=RAND()', '42'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 0.92754862796338,\n     * // }]\n     * const changes = hfInstance.addColumns(0, [0, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(sheetId) {\n      var _this$_crudOperations6;\n\n      for (var _len6 = arguments.length, indexes = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        indexes[_key6 - 1] = arguments[_key6];\n      }\n\n      (_this$_crudOperations6 = this._crudOperations).addColumns.apply(_this$_crudOperations6, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove columns from a specified position in a given sheet.\n     * Checks against particular rules to ascertain that removeColumns can be called.\n     * If returns `true`, doing [[removeColumns]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected columns.\n     *\n     * @param {number} sheetId - sheet ID from which columns will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [column, amount]\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to remove one column, in place of the second column of sheet 0\n     * const isRemovable = hfInstance.isItPossibleToRemoveColumns(0, [1, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveColumns\",\n    value: function isItPossibleToRemoveColumns(sheetId) {\n      for (var _len7 = arguments.length, indexes = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        indexes[_key7 - 1] = arguments[_key7];\n      }\n\n      var normalizedIndexes = normalizeRemovedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations7;\n\n        (_this$_crudOperations7 = this._crudOperations).ensureItIsPossibleToRemoveColumns.apply(_this$_crudOperations7, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes multiple columns from a specified position in a given sheet.\n     * Does nothing if columns are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID from which columns will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount]\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: { error: [CellError], value: '#REF!' },\n     * // }]\n     * const changes = hfInstance.removeColumns(0, [0, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(sheetId) {\n      var _this$_crudOperations8;\n\n      for (var _len8 = arguments.length, indexes = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        indexes[_key8 - 1] = arguments[_key8];\n      }\n\n      (_this$_crudOperations8 = this._crudOperations).removeColumns.apply(_this$_crudOperations8, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move cells to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveCells can be called.\n     * If returns `true`, doing [[moveCells]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected columns, the target location has matrix or the provided address is invalid.\n     *\n     * @param {SimpleCellAddress} sourceLeftCorner - address of the upper left corner of a moved block\n     * @param {number} width - width of the cell block that is being moved\n     * @param {number} height - height of the cell block that is being moved\n     * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // choose the coordinates and assign them to variables\n     * const source = { sheet: 0, col: 1, row: 0 };\n     * const destination = { sheet: 0, col: 3, row: 0 };\n     *\n     * // should return 'true' for this example\n     * // it is possible to move a block of width 1 and height 1\n     * // from the corner: column 1 and row 0 of sheet 0\n     * // into destination corner: column 3, row 0 of sheet 0\n     * const isMovable = hfInstance.isItPossibleToMoveCells(source, 1, 1, destination);\n     * ```\n     * @category Cells\n     */\n\n  }, {\n    key: \"isItPossibleToMoveCells\",\n    value: function isItPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      try {\n        this._crudOperations.operations.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves the content of a cell block from source to the target location.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} sourceLeftCorner - address of the upper left corner of a moved block\n     * @param {number} width - width of the cell block that is being moved\n     * @param {number} height - height of the cell block that is being moved\n     * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[SourceLocationHasMatrixError]] when the source location has matrix inside - matrix cannot be moved\n     * @throws [[TargetLocationHasMatrixError]] when the target location has matrix inside - cells cannot be replaced by the matrix\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=RAND()', '42'],\n     * ]);\n     *\n     * // choose the coordinates and assign them to variables\n     * const source = { sheet: 0, col: 1, row: 0 };\n     * const destination = { sheet: 0, col: 3, row: 0 };\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 0.93524248002062,\n     * // }]\n     * const changes = hfInstance.moveCells(source, 1, 1, destination);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"moveCells\",\n    value: function moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      this._crudOperations.moveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move a particular number of rows to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveRows can be called.\n     * If returns `true`, doing [[moveRows]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected rows, the target location has matrix or the provided address is invalid.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startRow - number of the first row to move\n     * @param {number} numberOfRows - number of rows to move\n     * @param {number} targetRow - row number before which rows will be moved\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to move one row from row 0 into row 2\n     * const isMovable = hfInstance.isItPossibleToMoveRows(0, 0, 1, 2);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToMoveRows\",\n    value: function isItPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow) {\n      try {\n        this._crudOperations.ensureItIsPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves a particular number of rows to a specified position in a given sheet.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startRow - number of the first row to move\n     * @param {number} numberOfRows - number of rows to move\n     * @param {number} targetRow - row number before which rows will be moved\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasMatrixError]] when the source location has matrix inside - matrix cannot be moved\n     * @throws [[TargetLocationHasMatrixError]] when the target location has matrix inside - cells cannot be replaced by the matrix\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.moveRows(0, 0, 1, 2);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(sheetId, startRow, numberOfRows, targetRow) {\n      this._crudOperations.moveRows(sheetId, startRow, numberOfRows, targetRow);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move a particular number of columns to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveColumns can be called.\n     * If returns `true`, doing [[moveColumns]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected columns, the target location has matrix or the provided address is invalid.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startColumn - number of the first column to move\n     * @param {number} numberOfColumns - number of columns to move\n     * @param {number} targetColumn - column number before which columns will be moved\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to move one column from column 1 into column 2 of sheet 0\n     * const isMovable = hfInstance.isItPossibleToMoveColumns(0, 1, 1, 2);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToMoveColumns\",\n    value: function isItPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {\n      try {\n        this._crudOperations.ensureItIsPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves a particular number of columns to a specified position in a given sheet.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startColumn - number of the first column to move\n     * @param {number} numberOfColumns - number of columns to move\n     * @param {number} targetColumn - column number before which columns will be moved\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasMatrixError]] when the source location has matrix inside - matrix cannot be moved\n     * @throws [[TargetLocationHasMatrixError]] when the target location has matrix inside - cells cannot be replaced by the matrix\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '3', '=RAND()', '=SUM(A1:C1)'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 0.16210054671639,\n     * //  }, {\n     * //   address: { sheet: 0, col: 4, row: 0 },\n     * //   newValue: 6.16210054671639,\n     * // }]\n     * const changes = hfInstance.moveColumns(0, 1, 1, 2);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"moveColumns\",\n    value: function moveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {\n      this._crudOperations.moveColumns(sheetId, startColumn, numberOfColumns, targetColumn);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Stores a copy of the cell block in internal clipboard for the further paste.\n     * Returns values of cells for use in external clipboard.\n     *\n     * @param {SimpleCellAddress} sourceLeftCorner - address of the upper left corner of a copied block\n     * @param {number} width - width of the cell block being copied\n     * @param {number} height - height of the cell block being copied\n     *\n     * @throws an error while attempting to copy unsupported content type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return: [ [ 2 ] ]\n     * const clipboardContent = hfInstance.copy({ sheet: 0, col: 1, row: 0 }, 1, 1);\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(sourceLeftCorner, width, height) {\n      this._crudOperations.copy(sourceLeftCorner, width, height);\n\n      return this.getRangeValues(sourceLeftCorner, width, height);\n    }\n    /**\n     * Stores information of the cell block in internal clipboard for further paste.\n     * Calling [[paste]] right after this method is equivalent to call [[moveCells]].\n     * Almost any CRUD operation called after this method will abort the cut operation.\n     * Returns values of cells for use in external clipboard.\n     *\n     * @param {SimpleCellAddress} sourceLeftCorner - address of the upper left corner of a copied block\n     * @param {number} width - width of the cell block being copied\n     * @param {number} height - height of the cell block being copied\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return values that were cut: [ [ 1 ] ]\n     * const clipboardContent = hfInstance.cut({ sheet: 0, col: 0, row: 0 }, 1, 1);\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"cut\",\n    value: function cut(sourceLeftCorner, width, height) {\n      this._crudOperations.cut(sourceLeftCorner, width, height);\n\n      return this.getRangeValues(sourceLeftCorner, width, height);\n    }\n    /**\n     * When called after [[copy]] it will paste copied values and formulas into a cell block.\n     * When called after [[cut]] it will perform [[moveCells]] operation into the cell block.\n     * Does nothing if the clipboard is empty.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} targetLeftCorner - upper left address of the target cell block\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws an error while attempting to paste onto a matrix\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[NothingToPasteError]] when clipboard is empty\n     * @throws [[TargetLocationHasMatrixError]] when the selected target area has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // do a copy, [ [ 2 ] ] was copied\n     * hfInstance.copy({ sheet: 0, col: 0, row: 0 }, 1, 1);\n     *\n     * // do a paste, should return a list of cells which values changed\n     * // after the operation, their absolute addresses and new values\n     * const changes = hfInstance.paste({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"paste\",\n    value: function paste(targetLeftCorner) {\n      this.ensureEvaluationIsNotSuspended();\n\n      this._crudOperations.paste(targetLeftCorner);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether there is something in the clipboard.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // copy desired content\n     * hfInstance.copy({ sheet: 0, col: 1, row: 0 }, 1, 1);\n     *\n     * // returns 'false', there is content in the clipboard\n     * const isClipboardEmpty = hfInstance.isClipboardEmpty();\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"isClipboardEmpty\",\n    value: function isClipboardEmpty() {\n      return this._crudOperations.isClipboardEmpty();\n    }\n    /**\n     * Clears the clipboard content.\n     *\n     * @example\n     * ```js\n     * // clears the clipboard, isClipboardEmpty() should return true if called afterwards\n     * hfInstance.clearClipboard();\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"clearClipboard\",\n    value: function clearClipboard() {\n      this._crudOperations.clearClipboard();\n    }\n    /**\n     * Clears the redo stack in undoRedo history.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   ['1', '2', '3'],\n     * ]);\n     *\n     * // do an operation, for example remove columns\n     * hfInstance.removeColumns(0, [0, 1]);\n     *\n     * // undo the operation\n     * hfInstance.undo();\n     *\n     * // redo the operation\n     * hfInstance.redo();\n     *\n     * // clear the redo stack\n     * hfInstance.clearRedoStack();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"clearRedoStack\",\n    value: function clearRedoStack() {\n      this._crudOperations.undoRedo.clearRedoStack();\n    }\n    /**\n     * Clears the undo stack in undoRedo history.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   ['1', '2', '3'],\n     * ]);\n     *\n     * // do an operation, for example remove columns\n     * hfInstance.removeColumns(0, [0, 1]);\n     *\n     * // undo the operation\n     * hfInstance.undo();\n     *\n     * // clear the undo stack\n     * hfInstance.clearUndoStack();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"clearUndoStack\",\n    value: function clearUndoStack() {\n      this._crudOperations.undoRedo.clearUndoStack();\n    }\n    /**\n     * Returns the cell content of a given range in a [[CellValue]][][] format.\n     *\n     * @param {SimpleCellAddress} leftCorner - address of the upper left corner of a range\n     * @param {number} width - width of a range\n     * @param {number} height - height of a range\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     *\n     * // returns calculated cells content: [ [ 3, 2 ], [ 5, 6 ] ]\n     * const rangeValues = hfInstance.getRangeValues({ sheet: 0, col: 0, row: 0 }, 2, 2);\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeValues\",\n    value: function getRangeValues(leftCorner, width, height) {\n      var _this3 = this;\n\n      var cellRange = AbsoluteCellRange.spanFrom(leftCorner, width, height);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this3.getCellValue(address);\n        });\n      });\n    }\n    /**\n     * Returns cell formulas in given range.\n     *\n     * @param {SimpleCellAddress} leftCorner - address of the upper left corner of a range\n     * @param {number} width - width of a range\n     * @param {number} height - height of a range\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     * // returns cell formulas of a given range only:\n     * // [ [ '=SUM(1,2)', undefined ], [ undefined, undefined ] ]\n     * const rangeFormulas = hfInstance.getRangeFormulas({ sheet: 0, col: 0, row: 0 }, 2, 2);\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeFormulas\",\n    value: function getRangeFormulas(leftCorner, width, height) {\n      var _this4 = this;\n\n      var cellRange = AbsoluteCellRange.spanFrom(leftCorner, width, height);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this4.getCellFormula(address);\n        });\n      });\n    }\n    /**\n     * Returns serialized cells in given range.\n     *\n     * @param {SimpleCellAddress} leftCorner - address of the upper left corner of a range\n     * @param {number} width - width of a range\n     * @param {number} height - height of a range\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     * // should return serialized cell content for the given range:\n     * // [ [ '=SUM(1,2)', 2 ], [ 5, 6 ] ]\n     * const rangeSerialized = hfInstance.getRangeSerialized({ sheet: 0, col: 0, row: 0 }, 2, 2);\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeSerialized\",\n    value: function getRangeSerialized(leftCorner, width, height) {\n      var _this5 = this;\n\n      var cellRange = AbsoluteCellRange.spanFrom(leftCorner, width, height);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this5.getCellSerialized(address);\n        });\n      });\n    }\n    /**\n     * Returns information whether it is possible to add a sheet to the engine.\n     * Checks against particular rules to ascertain that addSheet can be called.\n     * If returns `true`, doing [[addSheet]] operation won't throw any errors and it possible to add sheet with provided name.\n     * Returns `false` if the chosen name is already used.\n     *\n     * @param {string} sheetName - sheet name, case insensitive\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'false' because 'MySheet2' already exists\n     * const isAddable = hfInstance.isItPossibleToAddSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToAddSheet\",\n    value: function isItPossibleToAddSheet(sheetName) {\n      try {\n        this._crudOperations.ensureItIsPossibleToAddSheet(sheetName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds a new sheet to the HyperFormula instance. Returns given or autogenerated name of a new sheet.\n     *\n     * @param {string} [sheetName] - if not specified, name will be autogenerated\n     *\n     * @fires [[sheetAdded]] after the sheet was added\n     *\n     * @throws [[SheetNameAlreadyTakenError]] when sheet with a given name already exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'MySheet3'\n     * const nameProvided = hfInstance.addSheet('MySheet3');\n     *\n     * // should return autogenerated 'Sheet4'\n     * // because no name was provided and 3 other ones already exist\n     * const generatedName = hfInstance.addSheet();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName) {\n      var addedSheetName = this._crudOperations.addSheet(sheetName);\n\n      this._emitter.emit(Events.SheetAdded, addedSheetName);\n\n      return addedSheetName;\n    }\n    /**\n     * Returns information whether it is possible to remove sheet for the engine.\n     * Returns `true` if the provided name of a sheet exists and therefore it can be removed, doing [[removeSheet]] operation won't throw any errors.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {string} sheetName - sheet name, case insensitive\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet2' exists and is removable\n     * const isRemovable = hfInstance.isItPossibleToRemoveSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveSheet\",\n    value: function isItPossibleToRemoveSheet(sheetName) {\n      try {\n        this._crudOperations.ensureSheetExists(sheetName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes sheet with a specified name.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} sheetName - sheet name, case insensitive\n     *\n     * @fires [[sheetRemoved]] after the sheet was removed\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: { error: [CellError], value: '#REF!' },\n     * // }]\n     * const changes = hfInstance.removeSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"removeSheet\",\n    value: function removeSheet(sheetName) {\n      var displayName = this.sheetMapping.getDisplayNameByName(sheetName);\n\n      this._crudOperations.removeSheet(sheetName);\n\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.SheetRemoved, displayName, changes);\n\n      return changes;\n    }\n    /**\n     * Returns information whether it is possible to clear a specified sheet.\n     * If returns `true`, doing [[clearSheet]] operation won't throw any errors, provided name of a sheet exists and then its content can be cleared.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {string} sheetName - sheet name, case insensitive.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet2' exists and can be cleared\n     * const isClearable = hfInstance.isItPossibleToClearSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToClearSheet\",\n    value: function isItPossibleToClearSheet(sheetName) {\n      try {\n        this._crudOperations.ensureSheetExists(sheetName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Clears the sheet content. Based on that the method finds the ID of a sheet to be cleared.\n     * Double-checks if the sheet exists.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} sheetName - sheet name, case insensitive.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 0,\n     * // }]\n     * const changes = hfInstance.clearSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"clearSheet\",\n    value: function clearSheet(sheetName) {\n      this._crudOperations.ensureSheetExists(sheetName);\n\n      this._crudOperations.clearSheet(sheetName);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to replace the sheet content.\n     * If returns `true`, doing [[setSheetContent]] operation won't throw any errors, the provided name of a sheet exists and then its content can be replaced.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {string} sheetName - sheet name, case insensitive.\n     * @param {RawCellContent[][]} values - array of new values\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet1' exists\n     * // and the provided content can be placed in this sheet\n     * const isReplaceable = hfInstance.isItPossibleToReplaceSheetContent('MySheet1', [['50'], ['60']]);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToReplaceSheetContent\",\n    value: function isItPossibleToReplaceSheetContent(sheetName, values) {\n      try {\n        this._crudOperations.ensureSheetExists(sheetName);\n\n        var sheetId = this.sheetMapping.fetch(sheetName);\n\n        this._crudOperations.ensureItIsPossibleToChangeSheetContents(sheetId, values);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Replaces the sheet content with new values.\n     * The new value is to be provided as an array of arrays of [[RawCellContent]].\n     * The method finds sheet ID based on the provided sheet name.\n     *\n     * @param {string} sheetName - sheet name, case insensitive.\n     * @param {RawCellContent[][]} values - array of new values\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     * @throws [[InvalidArgumentsError]] when values is not an array of arrays\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.setSheetContent('MySheet1', [['50'], ['60']]);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"setSheetContent\",\n    value: function setSheetContent(sheetName, values) {\n      this._crudOperations.setSheetContent(sheetName, values);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Computes simple (absolute) address of a cell address based on its string representation.\n     * If sheet name is present in string representation but not present in the engine, returns `undefined`.\n     * If sheet name is not present in string representation, returns the sheet number.\n     * Returns an absolute representation of address.\n     *\n     * @param {string} cellAddress - string representation of cell address in A1 notation\n     * @param {number} sheetId - override sheet index regardless of sheet mapping\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // should return { sheet: 0, col: 0, row: 0 }\n     * const simpleCellAddress = hfInstance.simpleCellAddressFromString('A1', 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellAddressFromString\",\n    value: function simpleCellAddressFromString(cellAddress, sheetId) {\n      return _simpleCellAddressFromString(this.sheetMapping.get, cellAddress, sheetId);\n    }\n    /**\n     * Returns string representation of an absolute address in A1 notation or `undefined` if the sheet index is not present in the engine.\n     *\n     * @param {SimpleCellAddress} cellAddress - object representation of an absolute address\n     * @param {number} sheetId - if is not equal with address sheet index, string representation will contain sheet name\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // should return 'B2'\n     * const A1Notation = hfInstance.simpleCellAddressToString({ sheet: 0, col: 1, row: 1 }, 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellAddressToString\",\n    value: function simpleCellAddressToString(cellAddress, sheetId) {\n      return _simpleCellAddressToString(this.sheetMapping.fetchDisplayName, cellAddress, sheetId);\n    }\n    /**\n     * Returns all addresses and ranges whose computation depends on input address or range provided.\n     *\n     * @param {SimpleCellAddress | AbsoluteCellRange} address - object representation of an absolute address or range of addresses\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n     *\n     * hfInstance.getCellDependents({ sheet: 0, col: 0, row: 0});\n     * // should return [{ sheet: 0, col: 1, row: 0}, { sheet: 0, col: 2, row: 0}]\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"getCellDependents\",\n    value: function getCellDependents(address) {\n      var vertex;\n\n      if (address instanceof AbsoluteCellRange) {\n        vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);\n\n        if (vertex === undefined) {\n          return [];\n        }\n      } else {\n        vertex = this._dependencyGraph.addressMapping.getCell(address);\n\n        if (vertex === null) {\n          return [];\n        }\n      }\n\n      return this._dependencyGraph.getAdjacentNodesAddresses(vertex);\n    }\n    /**\n     * Returns all addresses and ranges necessary for computation of a given address or range.\n     *\n     * @param {SimpleCellAddress | AbsoluteCellRange} address - object representation of an absolute address or range of addresses\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n     *\n     * hfInstance.getCellPrecedents({ sheet: 0, col: 2, row: 0});\n     * // should return [{ sheet: 0, col: 0, row: 0}, { sheet: 0, col: 1, row: 0}]\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"getCellPrecedents\",\n    value: function getCellPrecedents(address) {\n      var _a;\n\n      var vertex;\n\n      if (address instanceof AbsoluteCellRange) {\n        vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);\n\n        if (vertex === undefined) {\n          return [];\n        }\n      } else {\n        vertex = this._dependencyGraph.addressMapping.getCell(address);\n\n        if (vertex === null) {\n          return [];\n        }\n      }\n\n      return (_a = this._dependencyGraph.dependencyQueryAddresses(vertex)) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Returns a unique sheet name assigned to the sheet of a given ID or `undefined` if the there is no sheet with a given ID.\n     *\n     * @param {number} sheetId - ID of the sheet, for which we want to retrieve name\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'MySheet2' as this sheet is the second one\n     * const sheetName = hfInstance.getSheetName(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetName\",\n    value: function getSheetName(sheetId) {\n      return this.sheetMapping.getDisplayName(sheetId);\n    }\n    /**\n     * List all sheet names.\n     * Returns an array of sheet names as strings.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return all sheets names: ['MySheet1', 'MySheet2']\n     * const sheetNames = hfInstance.getSheetNames();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetNames\",\n    value: function getSheetNames() {\n      return this.sheetMapping.sheetNames();\n    }\n    /**\n     * Returns a unique sheet ID assigned to the sheet with a given name or `undefined` if the sheet does not exist.\n     *\n     * @param {string} sheetName - name of the sheet, for which we want to retrieve ID, case insensitive.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return '0' because 'MySheet1' is of ID '0'\n     * const sheetID = hfInstance.getSheetId('MySheet1');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetId\",\n    value: function getSheetId(sheetName) {\n      return this.sheetMapping.get(sheetName);\n    }\n    /**\n     * Returns `true` whether sheet with a given name exists. The methods accepts sheet name to be checked.\n     *\n     * @param {string} sheetName - name of the sheet, case insensitive.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' since 'MySheet1' exists\n     * const sheetExist = hfInstance.doesSheetExist('MySheet1');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"doesSheetExist\",\n    value: function doesSheetExist(sheetName) {\n      return this.sheetMapping.hasSheetWithName(sheetName);\n    }\n    /**\n     * Returns type of a specified cell of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'FORMULA', the cell of given coordinates is of this type\n     * const cellA1Type = hfInstance.getCellType({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'VALUE', the cell of given coordinates is of this type\n     * const cellB1Type = hfInstance.getCellType({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(cellAddress) {\n      var vertex = this.dependencyGraph.getCell(cellAddress);\n      return _getCellType(vertex);\n    }\n    /**\n     * Returns `true` if the specified cell contains a simple value.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'true' since the selected cell contains a simple value\n     * const isA1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false' since the selected cell does not contain a simple value\n     * const isB1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"doesCellHaveSimpleValue\",\n    value: function doesCellHaveSimpleValue(cellAddress) {\n      return this.getCellType(cellAddress) === CellType.VALUE;\n    }\n    /**\n     * Returns `true` if the specified cell contains a formula.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'true' since the A1 cell contains a formula\n     * const A1Formula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false' since the B1 cell does not contain a formula\n     * const B1NoFormula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"doesCellHaveFormula\",\n    value: function doesCellHaveFormula(cellAddress) {\n      return this.getCellType(cellAddress) === CellType.FORMULA;\n    }\n    /**\n     * Returns`true` if the specified cell is empty.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   [null, '1'],\n     * ]);\n     *\n     * // should return 'true', cell of provided coordinates is empty\n     * const isEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false', cell of provided coordinates is not empty\n     * const isNotEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isCellEmpty\",\n    value: function isCellEmpty(cellAddress) {\n      return this.getCellType(cellAddress) === CellType.EMPTY;\n    }\n    /**\n     * Returns `true` if a given cell is a part of a matrix.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *    ['{=TRANSPOSE(B1:B1)}'],\n     * ]);\n     *\n     * // should return 'true', cell of provided coordinates is a part of a matrix\n     * const isPartOfMatrix = hfInstance.isCellPartOfMatrix({ sheet: 0, col: 0, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isCellPartOfMatrix\",\n    value: function isCellPartOfMatrix(cellAddress) {\n      return this.getCellType(cellAddress) === CellType.MATRIX;\n    }\n    /**\n     * Returns type of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '2'],\n     * ]);\n     *\n     * // should return 'NUMBER', cell value type of provided coordinates is a number\n     * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });\n     *\n     * // should return 'NUMBER', cell value type of provided coordinates is a number\n     * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueType\",\n    value: function getCellValueType(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueType(value);\n    }\n    /**\n     * Returns detailed type of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1%', '1$'],\n     * ]);\n     *\n     * // should return 'NUMBER_PERCENT', cell value type of provided coordinates is a number with a format inference percent.\n     * const cellType = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'NUMBER_CURRENCY', cell value type of provided coordinates is a number with a format inference currency.\n     * const cellType = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueDetailedType\",\n    value: function getCellValueDetailedType(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueDetailedType(value);\n    }\n    /**\n     * Returns auxilary format information of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1$', '1'],\n     * ]);\n     *\n     * // should return '$', cell value type of provided coordinates is a number with a format inference currency, parsed as using '$' as currency.\n     * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return undefined, cell value type of provided coordinates is a number with no format information.\n     * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueFormat\",\n    value: function getCellValueFormat(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueFormat(value);\n    }\n    /**\n     * Returns the number of existing sheets.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return the number of sheets which is '1'\n     * const sheetsCount = hfInstance.countSheets();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"countSheets\",\n    value: function countSheets() {\n      return this.sheetMapping.numberOfSheets();\n    }\n    /**\n     * Returns information whether it is possible to rename sheet.\n     * Returns `true` if the sheet with provided id exists and new name is available\n     * Returns `false` if sheet cannot be renamed\n     *\n     * @param {number} sheetId - a sheet number\n     * @param {string} newName - a name of the sheet to be given\n     *\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // returns true\n     * hfInstance.isItPossibleToRenameSheet(0, 'MySheet0');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToRenameSheet\",\n    value: function isItPossibleToRenameSheet(sheetId, newName) {\n      try {\n        this._crudOperations.ensureItIsPossibleToRenameSheet(sheetId, newName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Renames a specified sheet.\n     *\n     * @param {number} sheetId - a sheet number\n     * @param {string} newName - a name of the sheet to be given, if is the same as the old one the method does nothing\n     *\n     * @fires [[sheetRenamed]] after the sheet was renamed\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @throws [[SheetNameAlreadyTakenError]] when the provided sheet name already exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // renames the sheet 'MySheet1'\n     * hfInstance.renameSheet(0, 'MySheet0');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"renameSheet\",\n    value: function renameSheet(sheetId, newName) {\n      var oldName = this._crudOperations.renameSheet(sheetId, newName);\n\n      if (oldName !== undefined) {\n        this._emitter.emit(Events.SheetRenamed, oldName, newName);\n      }\n    }\n    /**\n     * Runs multiple operations and recomputes formulas at the end.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {() => void} batchOperations\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     * @fires [[evaluationSuspended]] always\n     * @fires [[evaluationResumed]] after the recomputation of necessary values\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // multiple operations in a single callback will trigger evaluation only once\n     * // and only one set of changes is returned as a combined result of all\n     * // the operations that were triggered within the callback\n     * const changes = hfInstance.batch(() => {\n     *  hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     *  hfInstance.setCellContents({ col: 4, row: 0, sheet: 0 }, [['=A1']]);\n     * });\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch(batchOperations) {\n      this.suspendEvaluation();\n\n      this._crudOperations.beginUndoRedoBatchMode();\n\n      try {\n        batchOperations();\n      } catch (e) {\n        this._crudOperations.commitUndoRedoBatchMode();\n\n        this.resumeEvaluation();\n        throw e;\n      }\n\n      this._crudOperations.commitUndoRedoBatchMode();\n\n      return this.resumeEvaluation();\n    }\n    /**\n     * Suspends the dependency graph recalculation.\n     * It allows optimizing the performance.\n     * With this method, multiple CRUD operations can be done without triggering recalculation after every operation.\n     * Suspending evaluation should result in an overall faster calculation compared to recalculating after each operation separately.\n     * To resume the evaluation use [[resumeEvaluation]].\n     *\n     * @fires [[evaluationSuspended]] always\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // similar to batch() but operations are not within a callback,\n     * // one method suspends the recalculation\n     * // the second will resume calculations and return the changes\n     *\n     * // suspend the evaluation with this method\n     * hfInstance.suspendEvaluation();\n     *\n     * // perform operations\n     * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * hfInstance.setSheetContent('MySheet2', [['50'], ['60']]);\n     *\n     * // use resumeEvaluation to resume\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"suspendEvaluation\",\n    value: function suspendEvaluation() {\n      this._evaluationSuspended = true;\n\n      this._emitter.emit(Events.EvaluationSuspended);\n    }\n    /**\n     * Resumes the dependency graph recalculation that was suspended with [[suspendEvaluation]].\n     * It also triggers the recalculation and returns changes that are a result of all batched operations.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     * @fires [[evaluationResumed]] after the recomputation of necessary values\n     *\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // similar to batch() but operations are not within a callback,\n     * // one method suspends the recalculation\n     * // the second will resume calculations and return the changes\n     *\n     * // first, suspend the evaluation\n     * hfInstance.suspendEvaluation();\n     *\n     * // perform operations\n     * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * hfInstance.setSheetContent('MySheet2', [['50'], ['60']]);\n     *\n     * // resume the evaluation\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"resumeEvaluation\",\n    value: function resumeEvaluation() {\n      this._evaluationSuspended = false;\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.EvaluationResumed, changes);\n\n      return changes;\n    }\n    /**\n     * Checks if the dependency graph recalculation process is suspended or not.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // suspend the evaluation\n     * hfInstance.suspendEvaluation();\n     *\n     * // between suspendEvaluation() and resumeEvaluation()\n     * // or inside batch() callback it will return 'true', otherwise 'false'\n     * const isEvaluationSuspended = hfInstance.isEvaluationSuspended();\n     *\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"isEvaluationSuspended\",\n    value: function isEvaluationSuspended() {\n      return this._evaluationSuspended;\n    }\n    /**\n     * Returns information whether it is possible to add named expression into a specific scope.\n     * Checks against particular rules to ascertain that addNamedExpression can be called.\n     * If returns `true`, doing [[addNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - a name of the expression to be added\n     * @param {RawCellContent} expression - the expression\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add named expression to global scope\n     * const isAddable = hfInstance.isItPossibleToAddNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToAddNamedExpression\",\n    value: function isItPossibleToAddNamedExpression(expressionName, expression, scope) {\n      try {\n        this._crudOperations.ensureItIsPossibleToAddNamedExpression(expressionName, expression, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds a specified named expression.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - a name of the expression to be added\n     * @param {RawCellContent} expression - the expression\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     * @param {NamedExpressionOptions?} options - additional metadata related to named expression\n     *\n     * @fires [[namedExpressionAdded]] always, unless [[batch]] mode is used\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NamedExpressionNameIsAlreadyTakenError]] when the named expression name is not available.\n     * @throws [[NamedExpressionNameIsInvalidError]] when the named expression name is not valid\n     * @throws [[MatrixFormulasNotSupportedError]] when the named expression formula is a Matrix formula\n     * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add own expression, scope limited to 'Sheet1', the method should return a list of cells which values\n     * // changed after the operation, their absolute addresses and new values\n     * // for this example:\n     * // [{\n     * //   name: 'prettyName',\n     * //   newValue: 142,\n     * // }]\n     * const changes = hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"addNamedExpression\",\n    value: function addNamedExpression(expressionName, expression, scope, options) {\n      this._crudOperations.addNamedExpression(expressionName, expression, scope, options);\n\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.NamedExpressionAdded, expressionName, changes);\n\n      return changes;\n    }\n    /**\n     * Gets specified named expression value.\n     * Returns a [[CellValue]] or undefined if the given named expression does not exists.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression, only 'Sheet1' considered as it is the scope\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // returns the calculated value of a passed named expression, '142' for this example\n     * const myFormula = hfInstance.getNamedExpressionValue('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpressionValue\",\n    value: function getNamedExpressionValue(expressionName, scope) {\n      this.ensureEvaluationIsNotSuspended();\n\n      var sheetId = this._crudOperations.scopeId(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (namedExpression) {\n        return this._serialization.getCellValue(namedExpression.address);\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a normalized formula string for given named expression or `undefined` for a named expression that does not exist or does not hold a formula.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression in 'Sheet1'\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // returns a normalized formula string corresponding to a passed name from 'Sheet1',\n     * // '=Sheet1!A1+100' for this example\n     * const myFormula = hfInstance.getNamedExpressionFormula('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpressionFormula\",\n    value: function getNamedExpressionFormula(expressionName, scope) {\n      var sheetId = this._crudOperations.scopeId(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (namedExpression === undefined) {\n        return undefined;\n      } else {\n        return this._serialization.getCellFormula(namedExpression.address);\n      }\n    }\n    /**\n     * Returns named expression a normalized formula string for given named expression or `undefined` for a named expression that does not exist or does not hold a formula.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression in 'Sheet1'\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // returns a normalized formula string corresponding to a passed name from 'Sheet1',\n     * // '=Sheet1!$A$1+100' for this example\n     * const myFormula = hfInstance.getNamedExpression('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpression\",\n    value: function getNamedExpression(expressionName, scope) {\n      var sheetId = this._crudOperations.scopeId(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (namedExpression === undefined) {\n        return undefined;\n      }\n\n      var expression = this._serialization.getCellFormula(namedExpression.address);\n\n      return {\n        name: expressionName,\n        scope: scope,\n        expression: expression,\n        options: namedExpression.options\n      };\n    }\n    /**\n     * Returns information whether it is possible to change named expression in a specific scope.\n     * Checks against particular rules to ascertain that changeNamedExpression can be called.\n     * If returns `true`, doing [[changeNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {RawCellContent} newExpression - a new expression\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     *\n     * // should return 'true' for this example,\n     * // it is possible to change named expression\n     * const isAddable = hfInstance.isItPossibleToChangeNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToChangeNamedExpression\",\n    value: function isItPossibleToChangeNamedExpression(expressionName, newExpression, scope) {\n      try {\n        this._crudOperations.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Changes a given named expression to a specified formula.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {RawCellContent} newExpression - a new expression\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     * @param {NamedExpressionOptions?} options - additional metadata related to named expression\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     * @throws [[MatrixFormulasNotSupportedError]] when the named expression formula is a Matrix formula\n     * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression, scope limited to 'Sheet1'\n     * hfInstance.addNamedExpression('prettyName', 'Sheet1', '=Sheet1!$A$1+100');\n     *\n     * // change the named expression\n     * const changes = hfInstance.changeNamedExpression('prettyName', '=Sheet1!$A$1+200');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"changeNamedExpression\",\n    value: function changeNamedExpression(expressionName, newExpression, scope, options) {\n      this._crudOperations.changeNamedExpressionExpression(expressionName, scope, newExpression, options);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove named expression from a specific scope.\n     * Checks against particular rules to ascertain that removeNamedExpression can be called.\n     * If returns `true`, doing [[removeNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     *\n     * // should return 'true' for this example,\n     * // it is possible to change named expression\n     * const isAddable = hfInstance.isItPossibleToRemoveNamedExpression('prettyName');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveNamedExpression\",\n    value: function isItPossibleToRemoveNamedExpression(expressionName, scope) {\n      try {\n        this._crudOperations.isItPossibleToRemoveNamedExpression(expressionName, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes a named expression.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @fires [[namedExpressionRemoved]] after the expression was removed\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // remove the named expression\n     * const changes = hfInstance.removeNamedExpression('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"removeNamedExpression\",\n    value: function removeNamedExpression(expressionName, scope) {\n      var removedNamedExpression = this._crudOperations.removeNamedExpression(expressionName, scope);\n\n      if (removedNamedExpression) {\n        var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n        this._emitter.emit(Events.NamedExpressionRemoved, removedNamedExpression.displayName, changes);\n\n        return changes;\n      } else {\n        return [];\n      }\n    }\n    /**\n     * Lists all named expressions.\n     * Returns an array of expression names defined in a scope, as strings.\n     *\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     *  ['60'],\n     * ]);\n     *\n     * // add two named expressions and one scoped\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!A1+100');\n     * hfInstance.addNamedExpression('prettyName2', '=Sheet1!A2+100');\n     * hfInstance.addNamedExpression('prettyName3', '=Sheet1!A3+100', 'Sheet1');\n     *\n     * // list the expressions, should return: ['prettyName', 'prettyName2'] for this example\n     * const listOfExpressions = hfInstance.listNamedExpressions();\n     *\n     *  // list the expressions, should return: ['prettyName3'] for this example\n     * const listOfExpressions = hfInstance.listNamedExpressions('Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"listNamedExpressions\",\n    value: function listNamedExpressions(scope) {\n      var scopeId = this._crudOperations.scopeId(scope);\n\n      return this._namedExpressions.getAllNamedExpressionsNamesInScope(scopeId);\n    }\n    /**\n     * Returns a normalized formula.\n     *\n     * @param {string} formulaString - a formula in a proper format - it must start with \"=\"\n     *\n     * @throws [[NotAFormulaError]] when the provided string is not a valid formula, i.e does not start with \"=\"\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     * ]);\n     *\n     * // normalize the formula, should return '=Sheet1!A1+10' for this example\n     * const normalizedFormula = hfInstance.normalizeFormula('=SHEET1!A1+10');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"normalizeFormula\",\n    value: function normalizeFormula(formulaString) {\n      var _this$extractTemporar = this.extractTemporaryFormula(formulaString),\n          _this$extractTemporar2 = _slicedToArray(_this$extractTemporar, 2),\n          ast = _this$extractTemporar2[0],\n          address = _this$extractTemporar2[1];\n\n      if (ast === undefined) {\n        throw new NotAFormulaError();\n      }\n\n      return this._unparser.unparse(ast, address);\n    }\n    /**\n     * Calculates fire-and-forget formula, returns the calculated value.\n     *\n     * @param {string} formulaString -  a formula in a proper format - it must start with \"=\"\n     * @param {string} sheetName - a name of the sheet in context of which we evaluate formula, case insensitive.\n     *\n     * @throws [[NotAFormulaError]] when the provided string is not a valid formula, i.e does not start with \"=\"\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  Sheet1: [['22']],\n     *  Sheet2: [['58']],\n     * });\n     *\n     * // returns the value of calculated formula, '32' for this example\n     * const calculatedFormula = hfInstance.calculateFormula('=A1+10', 'Sheet1');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"calculateFormula\",\n    value: function calculateFormula(formulaString, sheetName) {\n      this._crudOperations.ensureSheetExists(sheetName);\n\n      var sheetId = this.sheetMapping.fetch(sheetName);\n\n      var _this$extractTemporar3 = this.extractTemporaryFormula(formulaString, sheetId),\n          _this$extractTemporar4 = _slicedToArray(_this$extractTemporar3, 3),\n          ast = _this$extractTemporar4[0],\n          address = _this$extractTemporar4[1],\n          dependencies = _this$extractTemporar4[2];\n\n      if (ast === undefined) {\n        throw new NotAFormulaError();\n      }\n\n      var internalCellValue = this.evaluator.runAndForget(ast, address, dependencies);\n      return this._exporter.exportValue(internalCellValue);\n    }\n    /**\n     * Validates the formula.\n     * If the provided string starts with \"=\" and is a parsable formula the method returns `true`.\n     *\n     * @param {string} formulaString -  a formula in a proper format - it must start with \"=\"\n     *\n     * @example\n     * ```js\n     * // checks if the given string is a valid formula, should return 'true' for this example\n     * const isFormula = hfInstance.validateFormula('=SUM(1,2)');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"validateFormula\",\n    value: function validateFormula(formulaString) {\n      var _this$extractTemporar5 = this.extractTemporaryFormula(formulaString),\n          _this$extractTemporar6 = _slicedToArray(_this$extractTemporar5, 1),\n          ast = _this$extractTemporar6[0];\n\n      if (ast === undefined) {\n        return false;\n      }\n\n      if (ast.type === AstNodeType.ERROR && !ast.error) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Returns translated names of all functions registered in this instance of HyperFormula\n     * according to the language set in the configuration\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // return translated names of all functions, assign to a variable\n     * const allNames = hfInstance.getRegisteredFunctionNames();\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getRegisteredFunctionNames\",\n    value: function getRegisteredFunctionNames() {\n      var language = HyperFormula.getLanguage(this._config.language);\n      return language.getFunctionTranslations(this._functionRegistry.getRegisteredFunctionIds());\n    }\n    /**\n     * Returns class of a plugin used by function with given id\n     *\n     * @param {string} functionId - id of a function, e.g. 'SUMIF'\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // register a plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     *\n     * // get the plugin\n     * const myPlugin = hfInstance.getFunctionPlugin('EXAMPLE');\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getFunctionPlugin\",\n    value: function getFunctionPlugin(functionId) {\n      return this._functionRegistry.getFunctionPlugin(functionId);\n    }\n    /**\n     * Returns classes of all plugins registered in this instance of HyperFormula\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // return classes of all plugins registered, assign to a variable\n     * const allNames = hfInstance.getAllFunctionPlugins();\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getAllFunctionPlugins\",\n    value: function getAllFunctionPlugins() {\n      return this._functionRegistry.getPlugins();\n    }\n    /**\n     * Interprets number as a date + time.\n     *\n     * @param {number} val - number of days since nullDate, should be nonnegative, fractions are interpreted as hours/minutes/seconds.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass the number of days since nullDate\n     * // the method should return formatted date and time, for this example:\n     * // {year: 2020, month: 1, day: 15, hours: 2, minutes: 24, seconds: 0}\n     * const dateTimeFromNumber = hfInstance.numberToDateTime(43845.1);\n     *\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToDateTime\",\n    value: function numberToDateTime(val) {\n      return this._evaluator.dateHelper.numberToSimpleDateTime(val);\n    }\n    /**\n     * Interprets number as a date.\n     *\n     * @param {number} val - number of days since nullDate, should be nonnegative, fractions are ignored.\n        * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass the number of days since nullDate\n     * // the method should return formatted date, for this example:\n     * // {year: 2020, month: 1, day: 15}\n     * const dateFromNumber = hfInstance.numberToDate(43845);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToDate\",\n    value: function numberToDate(val) {\n      return this._evaluator.dateHelper.numberToSimpleDate(val);\n    }\n    /**\n     * Interprets number as a time (hours/minutes/seconds).\n     *\n     * @param {number} val - time in 24h units.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass a number to be interpreted as a time\n     * // should return {hours: 26, minutes: 24} for this example\n     * const timeFromNumber = hfInstance.numberToTime(1.1);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToTime\",\n    value: function numberToTime(val) {\n      return numberToSimpleTime(val);\n    }\n  }, {\n    key: \"extractTemporaryFormula\",\n    value: function extractTemporaryFormula(formulaString) {\n      var sheetId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var parsedCellContent = this._cellContentParser.parse(formulaString);\n\n      var exampleTemporaryFormulaAddress = {\n        sheet: sheetId,\n        col: 0,\n        row: 0\n      };\n\n      if (!(parsedCellContent instanceof CellContent.Formula)) {\n        return [undefined, exampleTemporaryFormulaAddress, []];\n      }\n\n      var _this$_parser$parse = this._parser.parse(parsedCellContent.formula, exampleTemporaryFormulaAddress),\n          ast = _this$_parser$parse.ast,\n          errors = _this$_parser$parse.errors,\n          dependencies = _this$_parser$parse.dependencies;\n\n      if (errors.length > 0) {\n        return [undefined, exampleTemporaryFormulaAddress, []];\n      }\n\n      return [ast, exampleTemporaryFormulaAddress, dependencies];\n    }\n    /**\n     * A method that subscribes to an event.\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // subscribe to a 'sheetAdded', pass a simple handler\n     * hfInstance.on('sheetAdded', ( ) => { console.log('foo') });\n     *\n     * // add a sheet to trigger an event,\n     * // console should print 'foo' after each time sheet is added in this example\n     * hfInstance.addSheet('FooBar');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this._emitter.on(event, listener);\n    }\n    /**\n     * A method that subscribes to an event once.\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // subscribe to a 'sheetAdded', pass a simple handler\n     * hfInstance.once('sheetAdded', ( ) => { console.log('foo') });\n     *\n     * // call addSheet twice,\n     * // console should print 'foo' only once when the sheet is added in this example\n     * hfInstance.addSheet('FooBar');\n     * hfInstance.addSheet('FooBaz');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(event, listener) {\n      this._emitter.once(event, listener);\n    }\n    /**\n     * A method that unsubscribe from an event or all events.\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // define a simple function to be called upon emitting an event\n     * const handler = ( ) => { console.log('baz') }\n     *\n     * // subscribe to a 'sheetAdded', pass the handler\n     * hfInstance.on('sheetAdded', handler);\n     *\n     * // add a sheet to trigger an event,\n     * // console should print 'baz' each time a sheet is added\n     * hfInstance.addSheet('FooBar');\n     *\n     * // unsubscribe from a 'sheetAdded'\n     * hfInstance.off('sheetAdded', handler);\n     *\n     * // add a sheet, the console should not print anything\n     * hfInstance.addSheet('FooBaz');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.off(event, listener);\n    }\n    /**\n     * Destroys instance of HyperFormula.\n     *\n     * @example\n     * ```js\n     * // destroys the instance\n     * hfInstance.destroy();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.dependencyGraph.destroy();\n      this.columnSearch.destroy();\n      this.evaluator.destroy();\n\n      this._parser.destroy();\n\n      this._lazilyTransformingAstService.destroy();\n\n      this._stats.destroy();\n\n      this._crudOperations.clearClipboard();\n    }\n    /**\n     * Runs a recomputation starting from recently changed vertices.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     */\n\n  }, {\n    key: \"recomputeIfDependencyGraphNeedsIt\",\n    value: function recomputeIfDependencyGraphNeedsIt() {\n      if (!this._evaluationSuspended) {\n        var changes = this._crudOperations.getAndClearContentChanges();\n\n        var verticesToRecomputeFrom = Array.from(this.dependencyGraph.verticesToRecompute());\n        this.dependencyGraph.clearRecentlyChangedVertices();\n\n        if (verticesToRecomputeFrom.length > 0) {\n          changes.addAll(this.evaluator.partialRun(verticesToRecomputeFrom));\n        }\n\n        var exportedChanges = changes.exportChanges(this._exporter);\n\n        if (!changes.isEmpty()) {\n          this._emitter.emit(Events.ValuesUpdated, exportedChanges);\n        }\n\n        return exportedChanges;\n      } else {\n        return [];\n      }\n    }\n  }], [{\n    key: \"buildFromEngineState\",\n    value: function buildFromEngineState(engine) {\n      return new HyperFormula(engine.config, engine.stats, engine.dependencyGraph, engine.columnSearch, engine.parser, engine.unparser, engine.cellContentParser, engine.evaluator, engine.lazilyTransformingAstService, engine.crudOperations, engine.exporter, engine.namedExpressions, engine.serialization, engine.functionRegistry);\n    }\n    /**\n     * Builds the engine for a sheet from a two-dimensional array representation.\n     * The engine is created with a single sheet.\n     * Can be configured with the optional second parameter that represents a [[ConfigParams]].\n     * If not specified, the engine will be built with the default configuration.\n     *\n     * @param {Sheet} sheet - two-dimensional array representation of sheet\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     *\n     * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits\n     * @throws [[InvalidArgumentsError]] when sheet is not an array of arrays\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     *\n     * @example\n     * ```js\n     * // data represented as an array\n     * const sheetData = [\n     *  ['0', '=SUM(1,2,3)', '52'],\n     *  ['=SUM(A1:C1)', '', '=A1'],\n     *  ['2', '=SUM(A1:C1)', '91'],\n     * ];\n     *\n     * // method with optional config parameter maxColumns\n     * const hfInstance = HyperFormula.buildFromArray(sheetData, { maxColumns: 1000 });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildFromArray\",\n    value: function buildFromArray(sheet, configInput) {\n      return this.buildFromEngineState(BuildEngineFactory.buildFromSheet(sheet, configInput));\n    }\n    /**\n     * Builds the engine from an object containing multiple sheets with names.\n     * The engine is created with one or more sheets.\n     * Can be configured with the optional second parameter that represents a [[ConfigParams]].\n     * If not specified the engine will be built with the default configuration.\n     *\n     * @param {Sheet} sheets - object with sheets definition\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     *\n     * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits\n     * @throws [[InvalidArgumentsError]] when any sheet is not an array of arrays\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     *\n     * @example\n     * ```js\n     * // data represented as an object with sheets: Sheet1 and Sheet2\n     * const sheetData = {\n     *  'Sheet1': [\n     *    ['1', '', '=Sheet2!$A1'],\n     *    ['', '2', '=SUM(1,2,3)'],\n     *    ['=Sheet2!$A2', '2', ''],\n     *   ],\n     *  'Sheet2': [\n     *    ['', '4', '=Sheet1!$B1'],\n     *    ['', '8', '=SUM(9,3,3)'],\n     *    ['=Sheet1!$B1', '2', ''],\n     *   ],\n     * };\n     *\n     * // method with optional config parameter useColumnIndex\n     * const hfInstance = HyperFormula.buildFromSheets(sheetData, { useColumnIndex: true });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildFromSheets\",\n    value: function buildFromSheets(sheets, configInput) {\n      return this.buildFromEngineState(BuildEngineFactory.buildFromSheets(sheets, configInput));\n    }\n    /**\n     * Builds an empty engine instance.\n     * Can be configured with the optional parameter that represents a [[ConfigParams]].\n     * If not specified the engine will be built with the default configuration.\n     *\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     *\n     * @example\n     * ```js\n     * // build with no initial data and with optional config parameter maxColumns\n     * const hfInstance = HyperFormula.buildEmpty({ maxColumns: 1000 });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildEmpty\",\n    value: function buildEmpty(configInput) {\n      return this.buildFromEngineState(BuildEngineFactory.buildEmpty(configInput));\n    }\n    /**\n     * Returns registered language from its code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     *\n     * @throws [[LanguageNotRegisteredError]] when trying to retrieve not registered language\n     *\n     * @example\n     * ```js\n     * // return registered language\n     * const language = HyperFormula.getLanguage('enGB');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getLanguage\",\n    value: function getLanguage(languageCode) {\n      var val = this.registeredLanguages.get(languageCode);\n\n      if (val === undefined) {\n        throw new LanguageNotRegisteredError();\n      } else {\n        return val;\n      }\n    }\n    /**\n     * Registers language from under given code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     * @param {RawTranslationPackage} languagePackage - translation package to be registered\n     *\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     * @throws [[LanguageAlreadyRegisteredError]] when given language is already registered\n     *\n     * @example\n     * ```js\n     * // return registered language\n     * HyperFormula.registerLanguage('plPL', plPL);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerLanguage\",\n    value: function registerLanguage(languageCode, languagePackage) {\n      if (this.registeredLanguages.has(languageCode)) {\n        throw new LanguageAlreadyRegisteredError();\n      } else {\n        this.registeredLanguages.set(languageCode, buildTranslationPackage(languagePackage));\n      }\n    }\n    /**\n     * Unregisters language that is registered under given code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     *\n     * @throws [[LanguageNotRegisteredError]] when given language is not registered\n     *\n     * @example\n     * ```js\n     * // register the language for the instance\n     * HyperFormula.registerLanguage('plPL', plPL);\n     *\n     * // unregister plPL\n     * HyperFormula.unregisterLanguage('plPL');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterLanguage\",\n    value: function unregisterLanguage(languageCode) {\n      if (this.registeredLanguages.has(languageCode)) {\n        this.registeredLanguages.delete(languageCode);\n      } else {\n        throw new LanguageNotRegisteredError();\n      }\n    }\n    /**\n     * Returns all registered languages codes.\n     *\n     * @example\n     * ```js\n     * // should return all registered language codes: ['enGB', 'plPL']\n     * const registeredLangugaes = HyperFormula.getRegisteredLanguagesCodes();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getRegisteredLanguagesCodes\",\n    value: function getRegisteredLanguagesCodes() {\n      return Array.from(this.registeredLanguages.keys());\n    }\n    /**\n     * Registers all functions in a given plugin with optional translations\n     *\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     * @param {FunctionTranslationsPackage} translations - optional package of function names translations\n     *\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register the plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerFunctionPlugin\",\n    value: function registerFunctionPlugin(plugin, translations) {\n      FunctionRegistry.registerFunctionPlugin(plugin, translations);\n    }\n    /**\n     * Unregisters all functions defined in given plugin\n     *\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     *\n     * @example\n     * ```js\n     * // get the class of a plugin\n     * const registeredPluginClass = HyperFormula.getFunctionPlugin('EXAMPLE');\n     *\n     * // unregister all functions defined in a plugin of ID 'EXAMPLE'\n     * HyperFormula.unregisterFunctionPlugin(registeredPluginClass);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterFunctionPlugin\",\n    value: function unregisterFunctionPlugin(plugin) {\n      FunctionRegistry.unregisterFunctionPlugin(plugin);\n    }\n    /**\n     * Registers a function with a given id if such exists in a plugin.\n     *\n     * @param {string} functionId - function id, e.g. 'SUMIF'\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     * @param translations\n     *\n     * @throws [[FunctionPluginValidationError]] when function with a given id does not exists in plugin or plugin class definition is not consistent with metadata\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a function\n     * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerFunction\",\n    value: function registerFunction(functionId, plugin, translations) {\n      FunctionRegistry.registerFunction(functionId, plugin, translations);\n    }\n    /**\n     * Unregisters a function with a given id\n     *\n     * @param {string} functionId - function id, e.g. 'SUMIF'\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a function\n     * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);\n     *\n     * // unregister a function\n     * HyperFormula.unregisterFunction('EXAMPLE');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterFunction\",\n    value: function unregisterFunction(functionId) {\n      FunctionRegistry.unregisterFunction(functionId);\n    }\n    /**\n     * Clears function registry\n     *\n     * @example\n     * ```js\n     * HyperFormula.unregisterAllFunctions();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterAllFunctions\",\n    value: function unregisterAllFunctions() {\n      FunctionRegistry.unregisterAll();\n    }\n    /**\n     * Returns translated names of all registered functions for a given language\n     *\n     * @param {string} code - language code\n     *\n     * @example\n     * ```js\n     * // return a list of function names registered for enGB\n     * const allNames = HyperFormula.getRegisteredFunctionNames('enGB');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getRegisteredFunctionNames\",\n    value: function getRegisteredFunctionNames(code) {\n      var functionIds = FunctionRegistry.getRegisteredFunctionIds();\n      var language = this.getLanguage(code);\n      return language.getFunctionTranslations(functionIds);\n    }\n    /**\n     * Returns class of a plugin used by function with given id\n     *\n     * @param {string} functionId - id of a function, e.g. 'SUMIF'\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     *\n     * // return the class of a given plugin\n     * const myFunctionClass = HyperFormula.getFunctionPlugin('EXAMPLE');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getFunctionPlugin\",\n    value: function getFunctionPlugin(functionId) {\n      return FunctionRegistry.getFunctionPlugin(functionId);\n    }\n    /**\n     * Returns classes of all plugins registered in this instance of HyperFormula\n     *\n     * @example\n     * ```js\n     * // return classes of all plugins\n     * const allClasses = HyperFormula.getAllFunctionPlugins();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getAllFunctionPlugins\",\n    value: function getAllFunctionPlugins() {\n      return FunctionRegistry.getPlugins();\n    }\n  }]);\n\n  return HyperFormula;\n}();\n/**\n * Version of the HyperFormula.\n *\n * @category Static Properties\n */\n\nHyperFormula.version = \"0.6.0\";\n/**\n * Latest build date.\n *\n * @category Static Properties\n */\n\nHyperFormula.buildDate = \"27/04/2021 11:27:25\";\n/**\n * A release date.\n *\n * @category Static Properties\n */\n\nHyperFormula.releaseDate = \"27/04/2021\";\n/**\n * Contains all available languages to use in registerLanguage.\n *\n * @category Static Properties\n */\n\nHyperFormula.languages = {};\nHyperFormula.registeredLanguages = new Map();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/HyperFormula.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","_i","Symbol","iterator","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","slice","constructor","name","from","test","iter","len","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","AbsoluteCellRange","CellType","getCellType","_getCellType","getCellValueType","_getCellValueType","getCellValueDetailedType","_getCellValueDetailedType","getCellValueFormat","_getCellValueFormat","CellContent","numberToSimpleTime","buildTranslationPackage","normalizeAddedIndexes","normalizeRemovedIndexes","EvaluationSuspendedError","LanguageAlreadyRegisteredError","LanguageNotRegisteredError","NotAFormulaError","AstNodeType","simpleCellAddressFromString","_simpleCellAddressFromString","simpleCellAddressToString","_simpleCellAddressToString","Emitter","Events","BuildEngineFactory","FunctionRegistry","HyperFormula","_config","_stats","_dependencyGraph","_columnSearch","_parser","_unparser","_cellContentParser","_evaluator","_lazilyTransformingAstService","_crudOperations","_exporter","_namedExpressions","_serialization","_functionRegistry","_emitter","_evaluationSuspended","get","dependencyGraph","graph","rangeMapping","matrixMapping","sheetMapping","addressMapping","licenseKeyValidityState","getCellValue","cellAddress","ensureEvaluationIsNotSuspended","getCellFormula","getCellSerialized","getSheetValues","sheetId","getSheetFormulas","getSheetSerialized","getAllSheetsDimensions","_this","genericAllSheetsGetter","arg","getSheetDimensions","width","getSheetWidth","height","getSheetHeight","getAllSheetsValues","getAllSheetsFormulas","getAllSheetsSerialized","updateConfig","newParams","_this2","newConfig","mergeConfig","configNewLanguage","language","serializedSheets","withNewConfig","serializedNamedExpressions","getAllNamedExpressionsSerialized","newEngine","rebuildWithConfig","config","stats","columnSearch","parser","unparser","cellContentParser","evaluator","lazilyTransformingAstService","crudOperations","exporter","namedExpressions","serialization","functionRegistry","forEach","entry","addNamedExpression","expression","scope","options","getConfig","rebuildAndRecalculate","getStats","snapshot","undo","recomputeIfDependencyGraphNeedsIt","redo","isThereSomethingToUndo","isThereSomethingToRedo","isItPossibleToSetCellContents","topLeftCornerAddress","arguments","undefined","ensureRangeInSizeLimits","spanFrom","j","ensureItIsPossibleToChangeContent","col","row","sheet","e","setCellContents","cellContents","swapRowIndexes","rowMapping","setRowOrder","isItPossibleToSwapRowIndexes","validateSwapRowIndexes","testRowOrderForMatrices","newRowOrder","mapping","mappingFromOrder","isItPossibleToSetRowOrder","swapColumnIndexes","columnMapping","setColumnOrder","isItPossibleToSwapColumnIndexes","validateSwapColumnIndexes","testColumnOrderForMatrices","newColumnOrder","isItPossibleToSetColumnOrder","isItPossibleToAddRows","_len","indexes","_key","normalizedIndexes","_this$_crudOperations","ensureItIsPossibleToAddRows","apply","concat","addRows","_this$_crudOperations2","_len2","_key2","isItPossibleToRemoveRows","_len3","_key3","_this$_crudOperations3","ensureItIsPossibleToRemoveRows","removeRows","_this$_crudOperations4","_len4","_key4","isItPossibleToAddColumns","_len5","_key5","_this$_crudOperations5","ensureItIsPossibleToAddColumns","addColumns","_this$_crudOperations6","_len6","_key6","isItPossibleToRemoveColumns","_len7","_key7","_this$_crudOperations7","ensureItIsPossibleToRemoveColumns","removeColumns","_this$_crudOperations8","_len8","_key8","isItPossibleToMoveCells","sourceLeftCorner","destinationLeftCorner","operations","ensureItIsPossibleToMoveCells","moveCells","isItPossibleToMoveRows","startRow","numberOfRows","targetRow","ensureItIsPossibleToMoveRows","moveRows","isItPossibleToMoveColumns","startColumn","numberOfColumns","targetColumn","ensureItIsPossibleToMoveColumns","moveColumns","copy","getRangeValues","cut","paste","targetLeftCorner","isClipboardEmpty","clearClipboard","clearRedoStack","undoRedo","clearUndoStack","leftCorner","_this3","cellRange","arrayOfAddressesInRange","map","subarray","address","getRangeFormulas","_this4","getRangeSerialized","_this5","isItPossibleToAddSheet","sheetName","ensureItIsPossibleToAddSheet","addSheet","addedSheetName","emit","SheetAdded","isItPossibleToRemoveSheet","ensureSheetExists","removeSheet","displayName","getDisplayNameByName","changes","SheetRemoved","isItPossibleToClearSheet","clearSheet","isItPossibleToReplaceSheetContent","values","fetch","ensureItIsPossibleToChangeSheetContents","setSheetContent","fetchDisplayName","getCellDependents","vertex","getRange","start","end","getCell","getAdjacentNodesAddresses","getCellPrecedents","_a","dependencyQueryAddresses","getSheetName","getDisplayName","getSheetNames","sheetNames","getSheetId","doesSheetExist","hasSheetWithName","doesCellHaveSimpleValue","VALUE","doesCellHaveFormula","FORMULA","isCellEmpty","EMPTY","isCellPartOfMatrix","MATRIX","countSheets","numberOfSheets","isItPossibleToRenameSheet","newName","ensureItIsPossibleToRenameSheet","renameSheet","oldName","SheetRenamed","batch","batchOperations","suspendEvaluation","beginUndoRedoBatchMode","commitUndoRedoBatchMode","resumeEvaluation","EvaluationSuspended","EvaluationResumed","isEvaluationSuspended","isItPossibleToAddNamedExpression","expressionName","ensureItIsPossibleToAddNamedExpression","NamedExpressionAdded","getNamedExpressionValue","scopeId","namedExpression","namedExpressionForScope","getNamedExpressionFormula","getNamedExpression","isItPossibleToChangeNamedExpression","newExpression","ensureItIsPossibleToChangeNamedExpression","changeNamedExpression","changeNamedExpressionExpression","isItPossibleToRemoveNamedExpression","removeNamedExpression","removedNamedExpression","NamedExpressionRemoved","listNamedExpressions","getAllNamedExpressionsNamesInScope","normalizeFormula","formulaString","_this$extractTemporar","extractTemporaryFormula","_this$extractTemporar2","ast","unparse","calculateFormula","_this$extractTemporar3","_this$extractTemporar4","dependencies","internalCellValue","runAndForget","exportValue","validateFormula","_this$extractTemporar5","_this$extractTemporar6","type","ERROR","error","getRegisteredFunctionNames","getLanguage","getFunctionTranslations","getRegisteredFunctionIds","getFunctionPlugin","functionId","getAllFunctionPlugins","getPlugins","numberToDateTime","val","dateHelper","numberToSimpleDateTime","numberToDate","numberToSimpleDate","numberToTime","parsedCellContent","parse","exampleTemporaryFormulaAddress","Formula","_this$_parser$parse","formula","errors","on","event","listener","once","off","destroy","getAndClearContentChanges","verticesToRecomputeFrom","verticesToRecompute","clearRecentlyChangedVertices","addAll","partialRun","exportedChanges","exportChanges","isEmpty","ValuesUpdated","buildFromEngineState","engine","buildFromArray","configInput","buildFromSheet","buildFromSheets","sheets","buildEmpty","languageCode","registeredLanguages","registerLanguage","languagePackage","has","set","unregisterLanguage","delete","getRegisteredLanguagesCodes","keys","registerFunctionPlugin","plugin","translations","unregisterFunctionPlugin","registerFunction","unregisterFunction","unregisterAllFunctions","unregisterAll","code","functionIds","version","buildDate","releaseDate","languages","Map"],"mappings":"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AAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1BK,GAvJwB,EAmLxB;AACD1D,IAAAA,GAAG,EAAE,mBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASgG,iBAAT,CAA2BH,WAA3B,EAAwC;AAC7C,WAAKC,8BAAL;AACA,aAAO,KAAKd,cAAL,CAAoBgB,iBAApB,CAAsCH,WAAtC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GAnLwB,EAiNxB;AACD1D,IAAAA,GAAG,EAAE,gBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASiG,cAAT,CAAwBC,OAAxB,EAAiC;AACtC,WAAKJ,8BAAL;AACA,aAAO,KAAKd,cAAL,CAAoBiB,cAApB,CAAmCC,OAAnC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/BK,GAjNwB,EAkPxB;AACD/D,IAAAA,GAAG,EAAE,kBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASmG,gBAAT,CAA0BD,OAA1B,EAAmC;AACxC,aAAO,KAAKlB,cAAL,CAAoBmB,gBAApB,CAAqCD,OAArC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/BK,GAlPwB,EAmRxB;AACD/D,IAAAA,GAAG,EAAE,oBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASoG,kBAAT,CAA4BF,OAA5B,EAAqC;AAC1C,WAAKJ,8BAAL;AACA,aAAO,KAAKd,cAAL,CAAoBoB,kBAApB,CAAuCF,OAAvC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7BK,GAnRwB,EAkTxB;AACD/D,IAAAA,GAAG,EAAE,wBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASqG,sBAAT,GAAkC;AACvC,UAAIC,KAAK,GAAG,IAAZ;;AAEA,aAAO,KAAKtB,cAAL,CAAoBuB,sBAApB,CAA2C,UAAUC,GAAV,EAAe;AAC/D,eAAOF,KAAK,CAACG,kBAAN,CAAyBD,GAAzB,CAAP;AACD,OAFM,CAAP;AAGD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GAlTwB,EAgVxB;AACDrE,IAAAA,GAAG,EAAE,oBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyG,kBAAT,CAA4BP,OAA5B,EAAqC;AAC1C,aAAO;AACLQ,QAAAA,KAAK,EAAE,KAAKrB,eAAL,CAAqBsB,aAArB,CAAmCT,OAAnC,CADF;AAELU,QAAAA,MAAM,EAAE,KAAKvB,eAAL,CAAqBwB,cAArB,CAAoCX,OAApC;AAFH,OAAP;AAID;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxBK,GAhVwB,EA0WxB;AACD/D,IAAAA,GAAG,EAAE,oBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS8G,kBAAT,GAA8B;AACnC,WAAKhB,8BAAL;AACA,aAAO,KAAKd,cAAL,CAAoB8B,kBAApB,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnBK,GA1WwB,EA+XxB;AACD3E,IAAAA,GAAG,EAAE,sBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS+G,oBAAT,GAAgC;AACrC,aAAO,KAAK/B,cAAL,CAAoB+B,oBAApB,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArBK,GA/XwB,EAsZxB;AACD5E,IAAAA,GAAG,EAAE,wBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASgH,sBAAT,GAAkC;AACvC,WAAKlB,8BAAL;AACA,aAAO,KAAKd,cAAL,CAAoBgC,sBAApB,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvBK,GAtZwB,EA+axB;AACD7E,IAAAA,GAAG,EAAE,cADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASiH,YAAT,CAAsBC,SAAtB,EAAiC;AACtC,UAAIC,MAAM,GAAG,IAAb;;AAEA,UAAIC,SAAS,GAAG,KAAKhD,OAAL,CAAaiD,WAAb,CAAyBH,SAAzB,CAAhB;;AAEA,UAAII,iBAAiB,GAAG,KAAKlD,OAAL,CAAaiD,WAAb,CAAyB;AAC/CE,QAAAA,QAAQ,EAAEL,SAAS,CAACK;AAD2B,OAAzB,CAAxB;;AAIA,UAAIC,gBAAgB,GAAG,KAAKxC,cAAL,CAAoByC,aAApB,CAAkCH,iBAAlC,EAAqD,KAAKvC,iBAA1D,EAA6EiC,sBAA7E,EAAvB;;AAEA,UAAIU,0BAA0B,GAAG,KAAK1C,cAAL,CAAoB2C,gCAApB,EAAjC;;AAEA,UAAIC,SAAS,GAAG3D,kBAAkB,CAAC4D,iBAAnB,CAAqCT,SAArC,EAAgDI,gBAAhD,EAAkE,KAAKnD,MAAvE,CAAhB;AACA,WAAKD,OAAL,GAAewD,SAAS,CAACE,MAAzB;AACA,WAAKzD,MAAL,GAAcuD,SAAS,CAACG,KAAxB;AACA,WAAKzD,gBAAL,GAAwBsD,SAAS,CAACvC,eAAlC;AACA,WAAKd,aAAL,GAAqBqD,SAAS,CAACI,YAA/B;AACA,WAAKxD,OAAL,GAAeoD,SAAS,CAACK,MAAzB;AACA,WAAKxD,SAAL,GAAiBmD,SAAS,CAACM,QAA3B;AACA,WAAKxD,kBAAL,GAA0BkD,SAAS,CAACO,iBAApC;AACA,WAAKxD,UAAL,GAAkBiD,SAAS,CAACQ,SAA5B;AACA,WAAKxD,6BAAL,GAAqCgD,SAAS,CAACS,4BAA/C;AACA,WAAKxD,eAAL,GAAuB+C,SAAS,CAACU,cAAjC;AACA,WAAKxD,SAAL,GAAiB8C,SAAS,CAACW,QAA3B;AACA,WAAKxD,iBAAL,GAAyB6C,SAAS,CAACY,gBAAnC;AACA,WAAKxD,cAAL,GAAsB4C,SAAS,CAACa,aAAhC;AACA,WAAKxD,iBAAL,GAAyB2C,SAAS,CAACc,gBAAnC;AACAhB,MAAAA,0BAA0B,CAACiB,OAA3B,CAAmC,UAAUC,KAAV,EAAiB;AAClDzB,QAAAA,MAAM,CAAC0B,kBAAP,CAA0BD,KAAK,CAAC1H,IAAhC,EAAsC0H,KAAK,CAACE,UAA5C,EAAwDF,KAAK,CAACG,KAA9D,EAAqEH,KAAK,CAACI,OAA3E;AACD,OAFD;AAGD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5CK,GA/awB,EA6dxB;AACD7G,IAAAA,GAAG,EAAE,WADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASiJ,SAAT,GAAqB;AAC1B,aAAO,KAAK7E,OAAL,CAAa6E,SAAb,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAdK,GA7dwB,EA6exB;AACD9G,IAAAA,GAAG,EAAE,uBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASkJ,qBAAT,GAAiC;AACtC,WAAKjC,YAAL,CAAkB,EAAlB;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAZK,GA7ewB,EA2fxB;AACD9E,IAAAA,GAAG,EAAE,UADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASmJ,QAAT,GAAoB;AACzB,aAAO,KAAK9E,MAAL,CAAY+E,QAAZ,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7BK,GA3fwB,EA0hBxB;AACDjH,IAAAA,GAAG,EAAE,MADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASqJ,IAAT,GAAgB;AACrB,WAAKxE,eAAL,CAAqBwE,IAArB;;AAEA,aAAO,KAAKC,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnCK,GA1hBwB,EA+jBxB;AACDnH,IAAAA,GAAG,EAAE,MADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASuJ,IAAT,GAAgB;AACrB,WAAK1E,eAAL,CAAqB0E,IAArB;;AAEA,aAAO,KAAKD,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3BK,GA/jBwB,EA4lBxB;AACDnH,IAAAA,GAAG,EAAE,wBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASwJ,sBAAT,GAAkC;AACvC,aAAO,KAAK3E,eAAL,CAAqB2E,sBAArB,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjBK,GA5lBwB,EA+mBxB;AACDrH,IAAAA,GAAG,EAAE,wBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyJ,sBAAT,GAAkC;AACvC,aAAO,KAAK5E,eAAL,CAAqB4E,sBAArB,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7BK,GA/mBwB,EA8oBxB;AACDtH,IAAAA,GAAG,EAAE,+BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS0J,6BAAT,CAAuCC,oBAAvC,EAA6D;AAClE,UAAIjD,KAAK,GAAGkD,SAAS,CAAC3J,MAAV,GAAmB,CAAnB,IAAwB2J,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAhF;AACA,UAAIhD,MAAM,GAAGgD,SAAS,CAAC3J,MAAV,GAAmB,CAAnB,IAAwB2J,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAjF;;AAEA,UAAI;AACF,aAAK/E,eAAL,CAAqBiF,uBAArB,CAA6CvH,iBAAiB,CAACwH,QAAlB,CAA2BJ,oBAA3B,EAAiDjD,KAAjD,EAAwDE,MAAxD,CAA7C;;AAEA,aAAK,IAAI9H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4H,KAApB,EAA2B5H,CAAC,EAA5B,EAAgC;AAC9B,eAAK,IAAIkL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpD,MAApB,EAA4BoD,CAAC,EAA7B,EAAiC;AAC/B,iBAAKnF,eAAL,CAAqBoF,iCAArB,CAAuD;AACrDC,cAAAA,GAAG,EAAEP,oBAAoB,CAACO,GAArB,GAA2BpL,CADqB;AAErDqL,cAAAA,GAAG,EAAER,oBAAoB,CAACQ,GAArB,GAA2BH,CAFqB;AAGrDI,cAAAA,KAAK,EAAET,oBAAoB,CAACS;AAHyB,aAAvD;AAKD;AACF;AACF,OAZD,CAYE,OAAOC,CAAP,EAAU;AACV,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArDK,GA9oBwB,EAqsBxB;AACDlI,IAAAA,GAAG,EAAE,iBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASsK,eAAT,CAAyBX,oBAAzB,EAA+CY,YAA/C,EAA6D;AAClE,WAAK1F,eAAL,CAAqByF,eAArB,CAAqCX,oBAArC,EAA2DY,YAA3D;;AAEA,aAAO,KAAKjB,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlDK,GArsBwB,EAyvBxB;AACDnH,IAAAA,GAAG,EAAE,gBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASwK,cAAT,CAAwBtE,OAAxB,EAAiCuE,UAAjC,EAA6C;AAClD,WAAK5F,eAAL,CAAqB6F,WAArB,CAAiCxE,OAAjC,EAA0CuE,UAA1C;;AAEA,aAAO,KAAKnB,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7BK,GAzvBwB,EAwxBxB;AACDnH,IAAAA,GAAG,EAAE,8BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS2K,4BAAT,CAAsCzE,OAAtC,EAA+CuE,UAA/C,EAA2D;AAChE,UAAI;AACF,aAAK5F,eAAL,CAAqB+F,sBAArB,CAA4C1E,OAA5C,EAAqDuE,UAArD;;AAEA,aAAK5F,eAAL,CAAqBgG,uBAArB,CAA6C3E,OAA7C,EAAsDuE,UAAtD;;AAEA,eAAO,IAAP;AACD,OAND,CAME,OAAOJ,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxDK,GAxxBwB,EAk1BxB;AACDlI,IAAAA,GAAG,EAAE,aADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS0K,WAAT,CAAqBxE,OAArB,EAA8B4E,WAA9B,EAA2C;AAChD,UAAIC,OAAO,GAAG,KAAKlG,eAAL,CAAqBmG,gBAArB,CAAsC9E,OAAtC,EAA+C4E,WAA/C,EAA4D,KAA5D,CAAd;;AAEA,aAAO,KAAKN,cAAL,CAAoBtE,OAApB,EAA6B6E,OAA7B,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7BK,GAl1BwB,EAi3BxB;AACD5I,IAAAA,GAAG,EAAE,2BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASiL,yBAAT,CAAmC/E,OAAnC,EAA4C4E,WAA5C,EAAyD;AAC9D,UAAI;AACF,YAAIL,UAAU,GAAG,KAAK5F,eAAL,CAAqBmG,gBAArB,CAAsC9E,OAAtC,EAA+C4E,WAA/C,EAA4D,KAA5D,CAAjB;;AAEA,aAAKjG,eAAL,CAAqB+F,sBAArB,CAA4C1E,OAA5C,EAAqDuE,UAArD;;AAEA,aAAK5F,eAAL,CAAqBgG,uBAArB,CAA6C3E,OAA7C,EAAsDuE,UAAtD;;AAEA,eAAO,IAAP;AACD,OARD,CAQE,OAAOJ,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzDK,GAj3BwB,EA46BxB;AACDlI,IAAAA,GAAG,EAAE,mBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASkL,iBAAT,CAA2BhF,OAA3B,EAAoCiF,aAApC,EAAmD;AACxD,WAAKtG,eAAL,CAAqBuG,cAArB,CAAoClF,OAApC,EAA6CiF,aAA7C;;AAEA,aAAO,KAAK7B,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3BK,GA56BwB,EAy8BxB;AACDnH,IAAAA,GAAG,EAAE,iCADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASqL,+BAAT,CAAyCnF,OAAzC,EAAkDiF,aAAlD,EAAiE;AACtE,UAAI;AACF,aAAKtG,eAAL,CAAqByG,yBAArB,CAA+CpF,OAA/C,EAAwDiF,aAAxD;;AAEA,aAAKtG,eAAL,CAAqB0G,0BAArB,CAAgDrF,OAAhD,EAAyDiF,aAAzD;;AAEA,eAAO,IAAP;AACD,OAND,CAME,OAAOd,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvDK,GAz8BwB,EAkgCxB;AACDlI,IAAAA,GAAG,EAAE,gBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASoL,cAAT,CAAwBlF,OAAxB,EAAiCsF,cAAjC,EAAiD;AACtD,UAAIT,OAAO,GAAG,KAAKlG,eAAL,CAAqBmG,gBAArB,CAAsC9E,OAAtC,EAA+CsF,cAA/C,EAA+D,QAA/D,CAAd;;AAEA,aAAO,KAAKN,iBAAL,CAAuBhF,OAAvB,EAAgC6E,OAAhC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GAlgCwB,EAgiCxB;AACD5I,IAAAA,GAAG,EAAE,8BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyL,4BAAT,CAAsCvF,OAAtC,EAA+C4E,WAA/C,EAA4D;AACjE,UAAI;AACF,YAAIK,aAAa,GAAG,KAAKtG,eAAL,CAAqBmG,gBAArB,CAAsC9E,OAAtC,EAA+C4E,WAA/C,EAA4D,QAA5D,CAApB;;AAEA,aAAKjG,eAAL,CAAqByG,yBAArB,CAA+CpF,OAA/C,EAAwDiF,aAAxD;;AAEA,aAAKtG,eAAL,CAAqB0G,0BAArB,CAAgDrF,OAAhD,EAAyDiF,aAAzD;;AAEA,eAAO,IAAP;AACD,OARD,CAQE,OAAOd,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApCK,GAhiCwB,EAskCxB;AACDlI,IAAAA,GAAG,EAAE,uBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS0L,qBAAT,CAA+BxF,OAA/B,EAAwC;AAC7C,WAAK,IAAIyF,IAAI,GAAG/B,SAAS,CAAC3J,MAArB,EAA6B2L,OAAO,GAAG,IAAIzL,KAAJ,CAAUwL,IAAI,GAAG,CAAP,GAAWA,IAAI,GAAG,CAAlB,GAAsB,CAAhC,CAAvC,EAA2EE,IAAI,GAAG,CAAvF,EAA0FA,IAAI,GAAGF,IAAjG,EAAuGE,IAAI,EAA3G,EAA+G;AAC7GD,QAAAA,OAAO,CAACC,IAAI,GAAG,CAAR,CAAP,GAAoBjC,SAAS,CAACiC,IAAD,CAA7B;AACD;;AAED,UAAIC,iBAAiB,GAAG1I,qBAAqB,CAACwI,OAAD,CAA7C;;AAEA,UAAI;AACF,YAAIG,qBAAJ;;AAEA,SAACA,qBAAqB,GAAG,KAAKlH,eAA9B,EAA+CmH,2BAA/C,CAA2EC,KAA3E,CAAiFF,qBAAjF,EAAwG,CAAC7F,OAAD,EAAUgG,MAAV,CAAiB7L,kBAAkB,CAACyL,iBAAD,CAAnC,CAAxG;;AAEA,eAAO,IAAP;AACD,OAND,CAME,OAAOzB,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/CK,GAtkCwB,EAunCxB;AACDlI,IAAAA,GAAG,EAAE,SADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASmM,OAAT,CAAiBjG,OAAjB,EAA0B;AAC/B,UAAIkG,sBAAJ;;AAEA,WAAK,IAAIC,KAAK,GAAGzC,SAAS,CAAC3J,MAAtB,EAA8B2L,OAAO,GAAG,IAAIzL,KAAJ,CAAUkM,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAlC,CAAxC,EAA8EC,KAAK,GAAG,CAA3F,EAA8FA,KAAK,GAAGD,KAAtG,EAA6GC,KAAK,EAAlH,EAAsH;AACpHV,QAAAA,OAAO,CAACU,KAAK,GAAG,CAAT,CAAP,GAAqB1C,SAAS,CAAC0C,KAAD,CAA9B;AACD;;AAED,OAACF,sBAAsB,GAAG,KAAKvH,eAA/B,EAAgDsH,OAAhD,CAAwDF,KAAxD,CAA8DG,sBAA9D,EAAsF,CAAClG,OAAD,EAAUgG,MAAV,CAAiBN,OAAjB,CAAtF;;AAEA,aAAO,KAAKtC,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnCK,GAvnCwB,EA4pCxB;AACDnH,IAAAA,GAAG,EAAE,0BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASuM,wBAAT,CAAkCrG,OAAlC,EAA2C;AAChD,WAAK,IAAIsG,KAAK,GAAG5C,SAAS,CAAC3J,MAAtB,EAA8B2L,OAAO,GAAG,IAAIzL,KAAJ,CAAUqM,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAlC,CAAxC,EAA8EC,KAAK,GAAG,CAA3F,EAA8FA,KAAK,GAAGD,KAAtG,EAA6GC,KAAK,EAAlH,EAAsH;AACpHb,QAAAA,OAAO,CAACa,KAAK,GAAG,CAAT,CAAP,GAAqB7C,SAAS,CAAC6C,KAAD,CAA9B;AACD;;AAED,UAAIX,iBAAiB,GAAGzI,uBAAuB,CAACuI,OAAD,CAA/C;;AAEA,UAAI;AACF,YAAIc,sBAAJ;;AAEA,SAACA,sBAAsB,GAAG,KAAK7H,eAA/B,EAAgD8H,8BAAhD,CAA+EV,KAA/E,CAAqFS,sBAArF,EAA6G,CAACxG,OAAD,EAAUgG,MAAV,CAAiB7L,kBAAkB,CAACyL,iBAAD,CAAnC,CAA7G;;AAEA,eAAO,IAAP;AACD,OAND,CAME,OAAOzB,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA9CK,GA5pCwB,EA4sCxB;AACDlI,IAAAA,GAAG,EAAE,YADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS4M,UAAT,CAAoB1G,OAApB,EAA6B;AAClC,UAAI2G,sBAAJ;;AAEA,WAAK,IAAIC,KAAK,GAAGlD,SAAS,CAAC3J,MAAtB,EAA8B2L,OAAO,GAAG,IAAIzL,KAAJ,CAAU2M,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAlC,CAAxC,EAA8EC,KAAK,GAAG,CAA3F,EAA8FA,KAAK,GAAGD,KAAtG,EAA6GC,KAAK,EAAlH,EAAsH;AACpHnB,QAAAA,OAAO,CAACmB,KAAK,GAAG,CAAT,CAAP,GAAqBnD,SAAS,CAACmD,KAAD,CAA9B;AACD;;AAED,OAACF,sBAAsB,GAAG,KAAKhI,eAA/B,EAAgD+H,UAAhD,CAA2DX,KAA3D,CAAiEY,sBAAjE,EAAyF,CAAC3G,OAAD,EAAUgG,MAAV,CAAiBN,OAAjB,CAAzF;;AAEA,aAAO,KAAKtC,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlCK,GA5sCwB,EAgvCxB;AACDnH,IAAAA,GAAG,EAAE,0BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASgN,wBAAT,CAAkC9G,OAAlC,EAA2C;AAChD,WAAK,IAAI+G,KAAK,GAAGrD,SAAS,CAAC3J,MAAtB,EAA8B2L,OAAO,GAAG,IAAIzL,KAAJ,CAAU8M,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAlC,CAAxC,EAA8EC,KAAK,GAAG,CAA3F,EAA8FA,KAAK,GAAGD,KAAtG,EAA6GC,KAAK,EAAlH,EAAsH;AACpHtB,QAAAA,OAAO,CAACsB,KAAK,GAAG,CAAT,CAAP,GAAqBtD,SAAS,CAACsD,KAAD,CAA9B;AACD;;AAED,UAAIpB,iBAAiB,GAAG1I,qBAAqB,CAACwI,OAAD,CAA7C;;AAEA,UAAI;AACF,YAAIuB,sBAAJ;;AAEA,SAACA,sBAAsB,GAAG,KAAKtI,eAA/B,EAAgDuI,8BAAhD,CAA+EnB,KAA/E,CAAqFkB,sBAArF,EAA6G,CAACjH,OAAD,EAAUgG,MAAV,CAAiB7L,kBAAkB,CAACyL,iBAAD,CAAnC,CAA7G;;AAEA,eAAO,IAAP;AACD,OAND,CAME,OAAOzB,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnDK,GAhvCwB,EAqyCxB;AACDlI,IAAAA,GAAG,EAAE,YADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASqN,UAAT,CAAoBnH,OAApB,EAA6B;AAClC,UAAIoH,sBAAJ;;AAEA,WAAK,IAAIC,KAAK,GAAG3D,SAAS,CAAC3J,MAAtB,EAA8B2L,OAAO,GAAG,IAAIzL,KAAJ,CAAUoN,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAlC,CAAxC,EAA8EC,KAAK,GAAG,CAA3F,EAA8FA,KAAK,GAAGD,KAAtG,EAA6GC,KAAK,EAAlH,EAAsH;AACpH5B,QAAAA,OAAO,CAAC4B,KAAK,GAAG,CAAT,CAAP,GAAqB5D,SAAS,CAAC4D,KAAD,CAA9B;AACD;;AAED,OAACF,sBAAsB,GAAG,KAAKzI,eAA/B,EAAgDwI,UAAhD,CAA2DpB,KAA3D,CAAiEqB,sBAAjE,EAAyF,CAACpH,OAAD,EAAUgG,MAAV,CAAiBN,OAAjB,CAAzF;;AAEA,aAAO,KAAKtC,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlCK,GAryCwB,EAy0CxB;AACDnH,IAAAA,GAAG,EAAE,6BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyN,2BAAT,CAAqCvH,OAArC,EAA8C;AACnD,WAAK,IAAIwH,KAAK,GAAG9D,SAAS,CAAC3J,MAAtB,EAA8B2L,OAAO,GAAG,IAAIzL,KAAJ,CAAUuN,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAlC,CAAxC,EAA8EC,KAAK,GAAG,CAA3F,EAA8FA,KAAK,GAAGD,KAAtG,EAA6GC,KAAK,EAAlH,EAAsH;AACpH/B,QAAAA,OAAO,CAAC+B,KAAK,GAAG,CAAT,CAAP,GAAqB/D,SAAS,CAAC+D,KAAD,CAA9B;AACD;;AAED,UAAI7B,iBAAiB,GAAGzI,uBAAuB,CAACuI,OAAD,CAA/C;;AAEA,UAAI;AACF,YAAIgC,sBAAJ;;AAEA,SAACA,sBAAsB,GAAG,KAAK/I,eAA/B,EAAgDgJ,iCAAhD,CAAkF5B,KAAlF,CAAwF2B,sBAAxF,EAAgH,CAAC1H,OAAD,EAAUgG,MAAV,CAAiB7L,kBAAkB,CAACyL,iBAAD,CAAnC,CAAhH;;AAEA,eAAO,IAAP;AACD,OAND,CAME,OAAOzB,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlDK,GAz0CwB,EA63CxB;AACDlI,IAAAA,GAAG,EAAE,eADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS8N,aAAT,CAAuB5H,OAAvB,EAAgC;AACrC,UAAI6H,sBAAJ;;AAEA,WAAK,IAAIC,KAAK,GAAGpE,SAAS,CAAC3J,MAAtB,EAA8B2L,OAAO,GAAG,IAAIzL,KAAJ,CAAU6N,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAlC,CAAxC,EAA8EC,KAAK,GAAG,CAA3F,EAA8FA,KAAK,GAAGD,KAAtG,EAA6GC,KAAK,EAAlH,EAAsH;AACpHrC,QAAAA,OAAO,CAACqC,KAAK,GAAG,CAAT,CAAP,GAAqBrE,SAAS,CAACqE,KAAD,CAA9B;AACD;;AAED,OAACF,sBAAsB,GAAG,KAAKlJ,eAA/B,EAAgDiJ,aAAhD,CAA8D7B,KAA9D,CAAoE8B,sBAApE,EAA4F,CAAC7H,OAAD,EAAUgG,MAAV,CAAiBN,OAAjB,CAA5F;;AAEA,aAAO,KAAKtC,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzCK,GA73CwB,EAw6CxB;AACDnH,IAAAA,GAAG,EAAE,yBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASkO,uBAAT,CAAiCC,gBAAjC,EAAmDzH,KAAnD,EAA0DE,MAA1D,EAAkEwH,qBAAlE,EAAyF;AAC9F,UAAI;AACF,aAAKvJ,eAAL,CAAqBwJ,UAArB,CAAgCC,6BAAhC,CAA8DH,gBAA9D,EAAgFzH,KAAhF,EAAuFE,MAAvF,EAA+FwH,qBAA/F;;AAEA,eAAO,IAAP;AACD,OAJD,CAIE,OAAO/D,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhDK,GAx6CwB,EA09CxB;AACDlI,IAAAA,GAAG,EAAE,WADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASuO,SAAT,CAAmBJ,gBAAnB,EAAqCzH,KAArC,EAA4CE,MAA5C,EAAoDwH,qBAApD,EAA2E;AAChF,WAAKvJ,eAAL,CAAqB0J,SAArB,CAA+BJ,gBAA/B,EAAiDzH,KAAjD,EAAwDE,MAAxD,EAAgEwH,qBAAhE;;AAEA,aAAO,KAAK9E,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/BK,GA19CwB,EA2/CxB;AACDnH,IAAAA,GAAG,EAAE,wBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASwO,sBAAT,CAAgCtI,OAAhC,EAAyCuI,QAAzC,EAAmDC,YAAnD,EAAiEC,SAAjE,EAA4E;AACjF,UAAI;AACF,aAAK9J,eAAL,CAAqB+J,4BAArB,CAAkD1I,OAAlD,EAA2DuI,QAA3D,EAAqEC,YAArE,EAAmFC,SAAnF;;AAEA,eAAO,IAAP;AACD,OAJD,CAIE,OAAOtE,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxCK,GA3/CwB,EAqiDxB;AACDlI,IAAAA,GAAG,EAAE,UADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS6O,QAAT,CAAkB3I,OAAlB,EAA2BuI,QAA3B,EAAqCC,YAArC,EAAmDC,SAAnD,EAA8D;AACnE,WAAK9J,eAAL,CAAqBgK,QAArB,CAA8B3I,OAA9B,EAAuCuI,QAAvC,EAAiDC,YAAjD,EAA+DC,SAA/D;;AAEA,aAAO,KAAKrF,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA9BK,GAriDwB,EAqkDxB;AACDnH,IAAAA,GAAG,EAAE,2BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS8O,yBAAT,CAAmC5I,OAAnC,EAA4C6I,WAA5C,EAAyDC,eAAzD,EAA0EC,YAA1E,EAAwF;AAC7F,UAAI;AACF,aAAKpK,eAAL,CAAqBqK,+BAArB,CAAqDhJ,OAArD,EAA8D6I,WAA9D,EAA2EC,eAA3E,EAA4FC,YAA5F;;AAEA,eAAO,IAAP;AACD,OAJD,CAIE,OAAO5E,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA9CK,GArkDwB,EAqnDxB;AACDlI,IAAAA,GAAG,EAAE,aADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASmP,WAAT,CAAqBjJ,OAArB,EAA8B6I,WAA9B,EAA2CC,eAA3C,EAA4DC,YAA5D,EAA0E;AAC/E,WAAKpK,eAAL,CAAqBsK,WAArB,CAAiCjJ,OAAjC,EAA0C6I,WAA1C,EAAuDC,eAAvD,EAAwEC,YAAxE;;AAEA,aAAO,KAAK3F,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GArnDwB,EAmpDxB;AACDnH,IAAAA,GAAG,EAAE,MADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASoP,IAAT,CAAcjB,gBAAd,EAAgCzH,KAAhC,EAAuCE,MAAvC,EAA+C;AACpD,WAAK/B,eAAL,CAAqBuK,IAArB,CAA0BjB,gBAA1B,EAA4CzH,KAA5C,EAAmDE,MAAnD;;AAEA,aAAO,KAAKyI,cAAL,CAAoBlB,gBAApB,EAAsCzH,KAAtC,EAA6CE,MAA7C,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GAnpDwB,EAirDxB;AACDzE,IAAAA,GAAG,EAAE,KADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASsP,GAAT,CAAanB,gBAAb,EAA+BzH,KAA/B,EAAsCE,MAAtC,EAA8C;AACnD,WAAK/B,eAAL,CAAqByK,GAArB,CAAyBnB,gBAAzB,EAA2CzH,KAA3C,EAAkDE,MAAlD;;AAEA,aAAO,KAAKyI,cAAL,CAAoBlB,gBAApB,EAAsCzH,KAAtC,EAA6CE,MAA7C,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvCK,GAjrDwB,EA0tDxB;AACDzE,IAAAA,GAAG,EAAE,OADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASuP,KAAT,CAAeC,gBAAf,EAAiC;AACtC,WAAK1J,8BAAL;;AAEA,WAAKjB,eAAL,CAAqB0K,KAArB,CAA2BC,gBAA3B;;AAEA,aAAO,KAAKlG,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1BK,GA1tDwB,EAsvDxB;AACDnH,IAAAA,GAAG,EAAE,kBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyP,gBAAT,GAA4B;AACjC,aAAO,KAAK5K,eAAL,CAAqB4K,gBAArB,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAfK,GAtvDwB,EAuwDxB;AACDtN,IAAAA,GAAG,EAAE,gBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS0P,cAAT,GAA0B;AAC/B,WAAK7K,eAAL,CAAqB6K,cAArB;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GAvwDwB,EAqyDxB;AACDvN,IAAAA,GAAG,EAAE,gBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS2P,cAAT,GAA0B;AAC/B,WAAK9K,eAAL,CAAqB+K,QAArB,CAA8BD,cAA9B;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzBK,GAryDwB,EAg0DxB;AACDxN,IAAAA,GAAG,EAAE,gBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS6P,cAAT,GAA0B;AAC/B,WAAKhL,eAAL,CAAqB+K,QAArB,CAA8BC,cAA9B;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1BK,GAh0DwB,EA41DxB;AACD1N,IAAAA,GAAG,EAAE,gBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASqP,cAAT,CAAwBS,UAAxB,EAAoCpJ,KAApC,EAA2CE,MAA3C,EAAmD;AACxD,UAAImJ,MAAM,GAAG,IAAb;;AAEA,UAAIC,SAAS,GAAGzN,iBAAiB,CAACwH,QAAlB,CAA2B+F,UAA3B,EAAuCpJ,KAAvC,EAA8CE,MAA9C,CAAhB;AACA,aAAOoJ,SAAS,CAACC,uBAAV,GAAoCC,GAApC,CAAwC,UAAUC,QAAV,EAAoB;AACjE,eAAOA,QAAQ,CAACD,GAAT,CAAa,UAAUE,OAAV,EAAmB;AACrC,iBAAOL,MAAM,CAACnK,YAAP,CAAoBwK,OAApB,CAAP;AACD,SAFM,CAAP;AAGD,OAJM,CAAP;AAKD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjCK,GA51DwB,EA+3DxB;AACDjO,IAAAA,GAAG,EAAE,kBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASqQ,gBAAT,CAA0BP,UAA1B,EAAsCpJ,KAAtC,EAA6CE,MAA7C,EAAqD;AAC1D,UAAI0J,MAAM,GAAG,IAAb;;AAEA,UAAIN,SAAS,GAAGzN,iBAAiB,CAACwH,QAAlB,CAA2B+F,UAA3B,EAAuCpJ,KAAvC,EAA8CE,MAA9C,CAAhB;AACA,aAAOoJ,SAAS,CAACC,uBAAV,GAAoCC,GAApC,CAAwC,UAAUC,QAAV,EAAoB;AACjE,eAAOA,QAAQ,CAACD,GAAT,CAAa,UAAUE,OAAV,EAAmB;AACrC,iBAAOE,MAAM,CAACvK,cAAP,CAAsBqK,OAAtB,CAAP;AACD,SAFM,CAAP;AAGD,OAJM,CAAP;AAKD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjCK,GA/3DwB,EAk6DxB;AACDjO,IAAAA,GAAG,EAAE,oBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASuQ,kBAAT,CAA4BT,UAA5B,EAAwCpJ,KAAxC,EAA+CE,MAA/C,EAAuD;AAC5D,UAAI4J,MAAM,GAAG,IAAb;;AAEA,UAAIR,SAAS,GAAGzN,iBAAiB,CAACwH,QAAlB,CAA2B+F,UAA3B,EAAuCpJ,KAAvC,EAA8CE,MAA9C,CAAhB;AACA,aAAOoJ,SAAS,CAACC,uBAAV,GAAoCC,GAApC,CAAwC,UAAUC,QAAV,EAAoB;AACjE,eAAOA,QAAQ,CAACD,GAAT,CAAa,UAAUE,OAAV,EAAmB;AACrC,iBAAOI,MAAM,CAACxK,iBAAP,CAAyBoK,OAAzB,CAAP;AACD,SAFM,CAAP;AAGD,OAJM,CAAP;AAKD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhCK,GAl6DwB,EAo8DxB;AACDjO,IAAAA,GAAG,EAAE,wBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyQ,sBAAT,CAAgCC,SAAhC,EAA2C;AAChD,UAAI;AACF,aAAK7L,eAAL,CAAqB8L,4BAArB,CAAkDD,SAAlD;;AAEA,eAAO,IAAP;AACD,OAJD,CAIE,OAAOrG,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApCK,GAp8DwB,EA0+DxB;AACDlI,IAAAA,GAAG,EAAE,UADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS4Q,QAAT,CAAkBF,SAAlB,EAA6B;AAClC,UAAIG,cAAc,GAAG,KAAKhM,eAAL,CAAqB+L,QAArB,CAA8BF,SAA9B,CAArB;;AAEA,WAAKxL,QAAL,CAAc4L,IAAd,CAAmB9M,MAAM,CAAC+M,UAA1B,EAAsCF,cAAtC;;AAEA,aAAOA,cAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GA1+DwB,EAwgExB;AACD1O,IAAAA,GAAG,EAAE,2BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASgR,yBAAT,CAAmCN,SAAnC,EAA8C;AACnD,UAAI;AACF,aAAK7L,eAAL,CAAqBoM,iBAArB,CAAuCP,SAAvC;;AAEA,eAAO,IAAP;AACD,OAJD,CAIE,OAAOrG,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxCK,GAxgEwB,EAkjExB;AACDlI,IAAAA,GAAG,EAAE,aADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASkR,WAAT,CAAqBR,SAArB,EAAgC;AACrC,UAAIS,WAAW,GAAG,KAAK1L,YAAL,CAAkB2L,oBAAlB,CAAuCV,SAAvC,CAAlB;;AAEA,WAAK7L,eAAL,CAAqBqM,WAArB,CAAiCR,SAAjC;;AAEA,UAAIW,OAAO,GAAG,KAAK/H,iCAAL,EAAd;;AAEA,WAAKpE,QAAL,CAAc4L,IAAd,CAAmB9M,MAAM,CAACsN,YAA1B,EAAwCH,WAAxC,EAAqDE,OAArD;;AAEA,aAAOA,OAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhCK,GAljEwB,EAolExB;AACDlP,IAAAA,GAAG,EAAE,0BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASuR,wBAAT,CAAkCb,SAAlC,EAA6C;AAClD,UAAI;AACF,aAAK7L,eAAL,CAAqBoM,iBAArB,CAAuCP,SAAvC;;AAEA,eAAO,IAAP;AACD,OAJD,CAIE,OAAOrG,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxCK,GAplEwB,EA8nExB;AACDlI,IAAAA,GAAG,EAAE,YADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASwR,UAAT,CAAoBd,SAApB,EAA+B;AACpC,WAAK7L,eAAL,CAAqBoM,iBAArB,CAAuCP,SAAvC;;AAEA,WAAK7L,eAAL,CAAqB2M,UAArB,CAAgCd,SAAhC;;AAEA,aAAO,KAAKpH,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA9BK,GA9nEwB,EA8pExB;AACDnH,IAAAA,GAAG,EAAE,mCADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyR,iCAAT,CAA2Cf,SAA3C,EAAsDgB,MAAtD,EAA8D;AACnE,UAAI;AACF,aAAK7M,eAAL,CAAqBoM,iBAArB,CAAuCP,SAAvC;;AAEA,YAAIxK,OAAO,GAAG,KAAKT,YAAL,CAAkBkM,KAAlB,CAAwBjB,SAAxB,CAAd;;AAEA,aAAK7L,eAAL,CAAqB+M,uCAArB,CAA6D1L,OAA7D,EAAsEwL,MAAtE;;AAEA,eAAO,IAAP;AACD,OARD,CAQE,OAAOrH,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvCK,GA9pEwB,EAusExB;AACDlI,IAAAA,GAAG,EAAE,iBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS6R,eAAT,CAAyBnB,SAAzB,EAAoCgB,MAApC,EAA4C;AACjD,WAAK7M,eAAL,CAAqBgN,eAArB,CAAqCnB,SAArC,EAAgDgB,MAAhD;;AAEA,aAAO,KAAKpI,iCAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzBK,GAvsEwB,EAkuExB;AACDnH,IAAAA,GAAG,EAAE,6BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS2D,2BAAT,CAAqCkC,WAArC,EAAkDK,OAAlD,EAA2D;AAChE,aAAOtC,4BAA4B,CAAC,KAAK6B,YAAL,CAAkBL,GAAnB,EAAwBS,WAAxB,EAAqCK,OAArC,CAAnC;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApBK,GAluEwB,EAwvExB;AACD/D,IAAAA,GAAG,EAAE,2BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS6D,yBAAT,CAAmCgC,WAAnC,EAAgDK,OAAhD,EAAyD;AAC9D,aAAOpC,0BAA0B,CAAC,KAAK2B,YAAL,CAAkBqM,gBAAnB,EAAqCjM,WAArC,EAAkDK,OAAlD,CAAjC;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnBK,GAxvEwB,EA6wExB;AACD/D,IAAAA,GAAG,EAAE,mBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS+R,iBAAT,CAA2B3B,OAA3B,EAAoC;AACzC,UAAI4B,MAAJ;;AAEA,UAAI5B,OAAO,YAAY7N,iBAAvB,EAA0C;AACxCyP,QAAAA,MAAM,GAAG,KAAK1N,gBAAL,CAAsBiB,YAAtB,CAAmC0M,QAAnC,CAA4C7B,OAAO,CAAC8B,KAApD,EAA2D9B,OAAO,CAAC+B,GAAnE,CAAT;;AAEA,YAAIH,MAAM,KAAKnI,SAAf,EAA0B;AACxB,iBAAO,EAAP;AACD;AACF,OAND,MAMO;AACLmI,QAAAA,MAAM,GAAG,KAAK1N,gBAAL,CAAsBoB,cAAtB,CAAqC0M,OAArC,CAA6ChC,OAA7C,CAAT;;AAEA,YAAI4B,MAAM,KAAK,IAAf,EAAqB;AACnB,iBAAO,EAAP;AACD;AACF;;AAED,aAAO,KAAK1N,gBAAL,CAAsB+N,yBAAtB,CAAgDL,MAAhD,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnCK,GA7wEwB,EAkzExB;AACD7P,IAAAA,GAAG,EAAE,mBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASsS,iBAAT,CAA2BlC,OAA3B,EAAoC;AACzC,UAAImC,EAAJ;;AAEA,UAAIP,MAAJ;;AAEA,UAAI5B,OAAO,YAAY7N,iBAAvB,EAA0C;AACxCyP,QAAAA,MAAM,GAAG,KAAK1N,gBAAL,CAAsBiB,YAAtB,CAAmC0M,QAAnC,CAA4C7B,OAAO,CAAC8B,KAApD,EAA2D9B,OAAO,CAAC+B,GAAnE,CAAT;;AAEA,YAAIH,MAAM,KAAKnI,SAAf,EAA0B;AACxB,iBAAO,EAAP;AACD;AACF,OAND,MAMO;AACLmI,QAAAA,MAAM,GAAG,KAAK1N,gBAAL,CAAsBoB,cAAtB,CAAqC0M,OAArC,CAA6ChC,OAA7C,CAAT;;AAEA,YAAI4B,MAAM,KAAK,IAAf,EAAqB;AACnB,iBAAO,EAAP;AACD;AACF;;AAED,aAAO,CAACO,EAAE,GAAG,KAAKjO,gBAAL,CAAsBkO,wBAAtB,CAA+CR,MAA/C,CAAN,MAAkE,IAAlE,IAA0EO,EAAE,KAAK,KAAK,CAAtF,GAA0FA,EAA1F,GAA+F,EAAtG;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxCK,GAlzEwB,EA41ExB;AACDpQ,IAAAA,GAAG,EAAE,cADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyS,YAAT,CAAsBvM,OAAtB,EAA+B;AACpC,aAAO,KAAKT,YAAL,CAAkBiN,cAAlB,CAAiCxM,OAAjC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArBK,GA51EwB,EAm3ExB;AACD/D,IAAAA,GAAG,EAAE,eADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS2S,aAAT,GAAyB;AAC9B,aAAO,KAAKlN,YAAL,CAAkBmN,UAAlB,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtBK,GAn3EwB,EA24ExB;AACDzQ,IAAAA,GAAG,EAAE,YADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS6S,UAAT,CAAoBnC,SAApB,EAA+B;AACpC,aAAO,KAAKjL,YAAL,CAAkBL,GAAlB,CAAsBsL,SAAtB,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtBK,GA34EwB,EAm6ExB;AACDvO,IAAAA,GAAG,EAAE,gBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS8S,cAAT,CAAwBpC,SAAxB,EAAmC;AACxC,aAAO,KAAKjL,YAAL,CAAkBsN,gBAAlB,CAAmCrC,SAAnC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3BK,GAn6EwB,EAg8ExB;AACDvO,IAAAA,GAAG,EAAE,aADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyC,WAAT,CAAqBoD,WAArB,EAAkC;AACvC,UAAImM,MAAM,GAAG,KAAK3M,eAAL,CAAqB+M,OAArB,CAA6BvM,WAA7B,CAAb;AACA,aAAOnD,YAAY,CAACsP,MAAD,CAAnB;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1BK,GAh8EwB,EA49ExB;AACD7P,IAAAA,GAAG,EAAE,yBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASgT,uBAAT,CAAiCnN,WAAjC,EAA8C;AACnD,aAAO,KAAKpD,WAAL,CAAiBoD,WAAjB,MAAkCrD,QAAQ,CAACyQ,KAAlD;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzBK,GA59EwB,EAu/ExB;AACD9Q,IAAAA,GAAG,EAAE,qBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASkT,mBAAT,CAA6BrN,WAA7B,EAA0C;AAC/C,aAAO,KAAKpD,WAAL,CAAiBoD,WAAjB,MAAkCrD,QAAQ,CAAC2Q,OAAlD;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzBK,GAv/EwB,EAkhFxB;AACDhR,IAAAA,GAAG,EAAE,aADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASoT,WAAT,CAAqBvN,WAArB,EAAkC;AACvC,aAAO,KAAKpD,WAAL,CAAiBoD,WAAjB,MAAkCrD,QAAQ,CAAC6Q,KAAlD;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtBK,GAlhFwB,EA0iFxB;AACDlR,IAAAA,GAAG,EAAE,oBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASsT,kBAAT,CAA4BzN,WAA5B,EAAyC;AAC9C,aAAO,KAAKpD,WAAL,CAAiBoD,WAAjB,MAAkCrD,QAAQ,CAAC+Q,MAAlD;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3BK,GA1iFwB,EAukFxB;AACDpR,IAAAA,GAAG,EAAE,kBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS2C,gBAAT,CAA0BkD,WAA1B,EAAuC;AAC5C,WAAKC,8BAAL;AACA,UAAI9F,KAAK,GAAG,KAAKqF,eAAL,CAAqBO,YAArB,CAAkCC,WAAlC,CAAZ;AACA,aAAOjD,iBAAiB,CAAC5C,KAAD,CAAxB;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7BK,GAvkFwB,EAsmFxB;AACDmC,IAAAA,GAAG,EAAE,0BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS6C,wBAAT,CAAkCgD,WAAlC,EAA+C;AACpD,WAAKC,8BAAL;AACA,UAAI9F,KAAK,GAAG,KAAKqF,eAAL,CAAqBO,YAArB,CAAkCC,WAAlC,CAAZ;AACA,aAAO/C,yBAAyB,CAAC9C,KAAD,CAAhC;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7BK,GAtmFwB,EAqoFxB;AACDmC,IAAAA,GAAG,EAAE,oBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS+C,kBAAT,CAA4B8C,WAA5B,EAAyC;AAC9C,WAAKC,8BAAL;AACA,UAAI9F,KAAK,GAAG,KAAKqF,eAAL,CAAqBO,YAArB,CAAkCC,WAAlC,CAAZ;AACA,aAAO7C,mBAAmB,CAAChD,KAAD,CAA1B;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArBK,GAroFwB,EA4pFxB;AACDmC,IAAAA,GAAG,EAAE,aADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASwT,WAAT,GAAuB;AAC5B,aAAO,KAAK/N,YAAL,CAAkBgO,cAAlB,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1BK,GA5pFwB,EAwrFxB;AACDtR,IAAAA,GAAG,EAAE,2BADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS0T,yBAAT,CAAmCxN,OAAnC,EAA4CyN,OAA5C,EAAqD;AAC1D,UAAI;AACF,aAAK9O,eAAL,CAAqB+O,+BAArB,CAAqD1N,OAArD,EAA8DyN,OAA9D;;AAEA,eAAO,IAAP;AACD,OAJD,CAIE,OAAOtJ,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnCK,GAxrFwB,EA6tFxB;AACDlI,IAAAA,GAAG,EAAE,aADJ;AAEDnC,IAAAA,KAAK,EAAE,SAAS6T,WAAT,CAAqB3N,OAArB,EAA8ByN,OAA9B,EAAuC;AAC5C,UAAIG,OAAO,GAAG,KAAKjP,eAAL,CAAqBgP,WAArB,CAAiC3N,OAAjC,EAA0CyN,OAA1C,CAAd;;AAEA,UAAIG,OAAO,KAAKjK,SAAhB,EAA2B;AACzB,aAAK3E,QAAL,CAAc4L,IAAd,CAAmB9M,MAAM,CAAC+P,YAA1B,EAAwCD,OAAxC,EAAiDH,OAAjD;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApCK,GA7tFwB,EAmwFxB;AACDxR,IAAAA,GAAG,EAAE,OADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASgU,KAAT,CAAeC,eAAf,EAAgC;AACrC,WAAKC,iBAAL;;AAEA,WAAKrP,eAAL,CAAqBsP,sBAArB;;AAEA,UAAI;AACFF,QAAAA,eAAe;AAChB,OAFD,CAEE,OAAO5J,CAAP,EAAU;AACV,aAAKxF,eAAL,CAAqBuP,uBAArB;;AAEA,aAAKC,gBAAL;AACA,cAAMhK,CAAN;AACD;;AAED,WAAKxF,eAAL,CAAqBuP,uBAArB;;AAEA,aAAO,KAAKC,gBAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApDK,GAnwFwB,EAyzFxB;AACDlS,IAAAA,GAAG,EAAE,mBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASkU,iBAAT,GAA6B;AAClC,WAAK/O,oBAAL,GAA4B,IAA5B;;AAEA,WAAKD,QAAL,CAAc4L,IAAd,CAAmB9M,MAAM,CAACsQ,mBAA1B;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtCK,GAzzFwB,EAi2FxB;AACDnS,IAAAA,GAAG,EAAE,kBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASqU,gBAAT,GAA4B;AACjC,WAAKlP,oBAAL,GAA4B,KAA5B;AACA,UAAIkM,OAAO,GAAG,KAAK/H,iCAAL,EAAd;;AAEA,WAAKpE,QAAL,CAAc4L,IAAd,CAAmB9M,MAAM,CAACuQ,iBAA1B,EAA6ClD,OAA7C;;AAEA,aAAOA,OAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GAj2FwB,EA+3FxB;AACDlP,IAAAA,GAAG,EAAE,uBADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASwU,qBAAT,GAAiC;AACtC,aAAO,KAAKrP,oBAAZ;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3BK,GA/3FwB,EA45FxB;AACDhD,IAAAA,GAAG,EAAE,kCADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASyU,gCAAT,CA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","sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { CellType, getCellType as _getCellType, getCellValueType as _getCellValueType, getCellValueDetailedType as _getCellValueDetailedType, getCellValueFormat as _getCellValueFormat } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { numberToSimpleTime } from './DateTimeHelper';\nimport { buildTranslationPackage } from './i18n';\nimport { normalizeAddedIndexes, normalizeRemovedIndexes } from './Operations';\nimport { EvaluationSuspendedError, LanguageAlreadyRegisteredError, LanguageNotRegisteredError, NotAFormulaError } from './errors';\nimport { AstNodeType, simpleCellAddressFromString as _simpleCellAddressFromString, simpleCellAddressToString as _simpleCellAddressToString } from './parser';\nimport { Emitter, Events } from './Emitter';\nimport { BuildEngineFactory } from './BuildEngineFactory';\nimport { FunctionRegistry } from './interpreter/FunctionRegistry';\n/**\n * This is a class for creating HyperFormula instance, all the following public methods\n * ale related to this class.\n *\n * The instance can be created only by calling one of the static methods\n * `buildFromArray`, `buildFromSheets` or `buildEmpty` and should be disposed of with the\n * `destroy` method when it's no longer needed to free the resources.\n *\n * The instance can be seen as a workbook where worksheets can be created and\n * manipulated. They are organized within a widely know structure of columns and rows\n * which can be manipulated as well. The smallest possible data unit are the cells, which\n * may contain simple values or formulas to be calculated.\n *\n * All CRUD methods are called directly on HyperFormula instance and will trigger\n * corresponding lifecycle events. The events are marked accordingly, as well as thrown\n * errors so they can be correctly handled.\n */\n\nexport var HyperFormula = /*#__PURE__*/function () {\n  function HyperFormula(_config, _stats, _dependencyGraph, _columnSearch, _parser, _unparser, _cellContentParser, _evaluator, _lazilyTransformingAstService, _crudOperations, _exporter, _namedExpressions, _serialization, _functionRegistry) {\n    _classCallCheck(this, HyperFormula);\n\n    this._config = _config;\n    this._stats = _stats;\n    this._dependencyGraph = _dependencyGraph;\n    this._columnSearch = _columnSearch;\n    this._parser = _parser;\n    this._unparser = _unparser;\n    this._cellContentParser = _cellContentParser;\n    this._evaluator = _evaluator;\n    this._lazilyTransformingAstService = _lazilyTransformingAstService;\n    this._crudOperations = _crudOperations;\n    this._exporter = _exporter;\n    this._namedExpressions = _namedExpressions;\n    this._serialization = _serialization;\n    this._functionRegistry = _functionRegistry;\n    this._emitter = new Emitter();\n    this._evaluationSuspended = false;\n  }\n  /**\n   * Calls the `graph` method on the dependency graph.\n   * Allows to execute `graph` directly without a need to refer to `dependencyGraph`.\n   *\n   * @internal\n   */\n\n\n  _createClass(HyperFormula, [{\n    key: \"graph\",\n    get: function get() {\n      return this.dependencyGraph.graph;\n    }\n    /**\n     * Calls the `rangeMapping` method on the dependency graph.\n     * Allows to execute `rangeMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"rangeMapping\",\n    get: function get() {\n      return this.dependencyGraph.rangeMapping;\n    }\n    /**\n     * Calls the `matrixMapping` method on the dependency graph.\n     * Allows to execute `matrixMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"matrixMapping\",\n    get: function get() {\n      return this.dependencyGraph.matrixMapping;\n    }\n    /**\n     * Calls the `sheetMapping` method on the dependency graph.\n     * Allows to execute `sheetMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"sheetMapping\",\n    get: function get() {\n      return this.dependencyGraph.sheetMapping;\n    }\n    /**\n     * Calls the `addressMapping` method on the dependency graph.\n     * Allows to execute `addressMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"addressMapping\",\n    get: function get() {\n      return this.dependencyGraph.addressMapping;\n    }\n    /** @internal */\n\n  }, {\n    key: \"dependencyGraph\",\n    get: function get() {\n      return this._dependencyGraph;\n    }\n    /** @internal */\n\n  }, {\n    key: \"evaluator\",\n    get: function get() {\n      return this._evaluator;\n    }\n    /** @internal */\n\n  }, {\n    key: \"columnSearch\",\n    get: function get() {\n      return this._columnSearch;\n    }\n    /** @internal */\n\n  }, {\n    key: \"lazilyTransformingAstService\",\n    get: function get() {\n      return this._lazilyTransformingAstService;\n    }\n    /**\n     * Returns state of the validity of the license key.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"licenseKeyValidityState\",\n    get: function get() {\n      return this._config.licenseKeyValidityState;\n    }\n  }, {\n    key: \"getCellValue\",\n    value:\n    /**\n     * Returns the cell value of a given address.\n     * Applies rounding and post-processing.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '2'],\n     * ]);\n     *\n     * // get value of A1 cell, should be '6'\n     * const A1Value = hfInstance.getCellValue({ sheet: 0, col: 0, row: 0 });\n     *\n     * // get value of B1 cell, should be '2'\n     * const B1Value = hfInstance.getCellValue({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n    function getCellValue(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getCellValue(cellAddress);\n    }\n  }, {\n    key: \"ensureEvaluationIsNotSuspended\",\n    value: function ensureEvaluationIsNotSuspended() {\n      if (this._evaluationSuspended) {\n        throw new EvaluationSuspendedError();\n      }\n    }\n    /**\n     * Returns a normalized formula string from the cell of a given address or `undefined` for an address that does not exist and empty values.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '0'],\n     * ]);\n     *\n     * // should return a normalized A1 cell formula: '=SUM(1,2,3)'\n     * const A1Formula = hfInstance.getCellFormula({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return a normalized B1 cell formula: 'undefined'\n     * const B1Formula = hfInstance.getCellFormula({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellFormula\",\n    value: function getCellFormula(cellAddress) {\n      return this._serialization.getCellFormula(cellAddress);\n    }\n    /**\n     * Returns [[CellValue]] which a serialized content of the cell of a given address either a cell formula, an explicit value, or an error.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '0'],\n     * ]);\n     *\n     * // should return serialized content of A1 cell: '=SUM(1,2,3)'\n     * const cellA1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return serialized content of B1 cell: '0'\n     * const cellB1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellSerialized\",\n    value: function getCellSerialized(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getCellSerialized(cellAddress);\n    }\n    /**\n     * Returns an array of arrays of [[CellValue]] with values of all cells from [[Sheet]].\n     * Applies rounding and post-processing.\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @param {number} sheetId - sheet ID number\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return all values of a sheet: [[0, 6, 0], [1, '1.0%', 0], [2, 6, 0]]\n     * const sheetValues = hfInstance.getSheetValues(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetValues\",\n    value: function getSheetValues(sheetId) {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getSheetValues(sheetId);\n    }\n    /**\n     * Returns an array with normalized formula strings from [[Sheet]] or `undefined` for a cells that have no value.\n     *\n     * @param {SimpleCellAddress} sheetId - sheet ID number\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return all formulas of a sheet:\n     * // [\n     * //  [undefined, '=SUM(1,2,3)', '=A1'],\n     * //  [undefined, '=TEXT(A2, \"0.0%\")', '=C1'],\n     * //  [undefined, '=SUM(A1:C1)', '=C1'],\n     * // ];\n     * const sheetFormulas = hfInstance.getSheetFormulas(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetFormulas\",\n    value: function getSheetFormulas(sheetId) {\n      return this._serialization.getSheetFormulas(sheetId);\n    }\n    /**\n     * Returns an array of arrays of [[NoErrorCellValue]] with serialized content of cells from [[Sheet]], either a cell formula or an explicit value.\n     *\n     * @param {SimpleCellAddress} sheetId - sheet ID number\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return:\n     * // [\n     * //  ['0', '=SUM(1,2,3)', '=A1'],\n     * //  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     * //  ['2', '=SUM(A1:C1)', '=C1'],\n     * // ];\n     * const serializedContent = hfInstance.getSheetSerialized(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetSerialized\",\n    value: function getSheetSerialized(sheetId) {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getSheetSerialized(sheetId);\n    }\n    /**\n     * Returns a map containing dimensions of all sheets for the engine instance represented as a key-value pairs where keys are sheet IDs and dimensions are returned as numbers, width and height respectively.\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   Sheet1: [\n     *    ['1', '2', '=Sheet2!$A1'],\n     *   ],\n     *   Sheet2: [\n     *    ['3'],\n     *    ['4'],\n     *   ],\n     * });\n     *\n     * // should return the dimensions of all sheets:\n     * // { Sheet1: { width: 3, height: 1 }, Sheet2: { width: 1, height: 2 } }\n     * const allSheetsDimensions = hfInstance.getAllSheetsDimensions();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsDimensions\",\n    value: function getAllSheetsDimensions() {\n      var _this = this;\n\n      return this._serialization.genericAllSheetsGetter(function (arg) {\n        return _this.getSheetDimensions(arg);\n      });\n    }\n    /**\n     * Returns dimensions of a specified sheet.\n     * The sheet dimensions is represented with numbers: width and height.\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @param {number} sheetId - sheet ID number\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *    ['1', '2', '=Sheet2!$A1'],\n     * ]);\n     *\n     * // should return provided sheet's dimensions: { width: 3, height: 1 }\n     * const sheetDimensions = hfInstance.getSheetDimensions(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetDimensions\",\n    value: function getSheetDimensions(sheetId) {\n      return {\n        width: this.dependencyGraph.getSheetWidth(sheetId),\n        height: this.dependencyGraph.getSheetHeight(sheetId)\n      };\n    }\n    /**\n     * Returns values of all sheets in a form of an object which property keys are strings and values are arrays of arrays of [[CellValue]].\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '=A1+10', '3'],\n     * ]);\n     *\n     * // should return all sheets values: { Sheet1: [ [ 1, 11, 3 ] ] }\n     * const allSheetsValues = hfInstance.getAllSheetsValues();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsValues\",\n    value: function getAllSheetsValues() {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getAllSheetsValues();\n    }\n    /**\n     * Returns formulas of all sheets in a form of an object which property keys are strings and values are arrays of arrays of strings or possibly `undefined` when the call does not contain a formula.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1+10'],\n     * ]);\n     *\n     * // should return only formulas: { Sheet1: [ [ undefined, undefined, '=A1+10' ] ] }\n     * const allSheetsFormulas = hfInstance.getAllSheetsFormulas();\n     * ```\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsFormulas\",\n    value: function getAllSheetsFormulas() {\n      return this._serialization.getAllSheetsFormulas();\n    }\n    /**\n     * Returns formulas or values of all sheets in a form of an object which property keys are strings and values are arrays of arrays of [[CellValue]].\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1+10'],\n     * ]);\n     *\n     * // should return all sheets serialized content: { Sheet1: [ [ 1, 2, '=A1+10' ] ] }\n     * const allSheetsSerialized = hfInstance.getAllSheetsSerialized();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsSerialized\",\n    value: function getAllSheetsSerialized() {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getAllSheetsSerialized();\n    }\n    /**\n     * Updates the config with given new metadata.\n     *\n     * @param {Partial<ConfigParams>} newParams configuration options to be updated or added\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // add a config param, for example maxColumns,\n     * // you can check the configuration with getConfig method\n     * hfInstance.updateConfig({ maxColumns: 1000 });\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(newParams) {\n      var _this2 = this;\n\n      var newConfig = this._config.mergeConfig(newParams);\n\n      var configNewLanguage = this._config.mergeConfig({\n        language: newParams.language\n      });\n\n      var serializedSheets = this._serialization.withNewConfig(configNewLanguage, this._namedExpressions).getAllSheetsSerialized();\n\n      var serializedNamedExpressions = this._serialization.getAllNamedExpressionsSerialized();\n\n      var newEngine = BuildEngineFactory.rebuildWithConfig(newConfig, serializedSheets, this._stats);\n      this._config = newEngine.config;\n      this._stats = newEngine.stats;\n      this._dependencyGraph = newEngine.dependencyGraph;\n      this._columnSearch = newEngine.columnSearch;\n      this._parser = newEngine.parser;\n      this._unparser = newEngine.unparser;\n      this._cellContentParser = newEngine.cellContentParser;\n      this._evaluator = newEngine.evaluator;\n      this._lazilyTransformingAstService = newEngine.lazilyTransformingAstService;\n      this._crudOperations = newEngine.crudOperations;\n      this._exporter = newEngine.exporter;\n      this._namedExpressions = newEngine.namedExpressions;\n      this._serialization = newEngine.serialization;\n      this._functionRegistry = newEngine.functionRegistry;\n      serializedNamedExpressions.forEach(function (entry) {\n        _this2.addNamedExpression(entry.name, entry.expression, entry.scope, entry.options);\n      });\n    }\n    /**\n     * Returns current configuration of the engine instance.\n     *\n     * @example\n     * ```js\n     * // should return all config metadata including default and those which were added\n     * const hfConfig = hfInstance.getConfig();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this._config.getConfig();\n    }\n    /**\n     * Serializes and deserializes whole engine, effectively reloading it.\n     *\n     * @example\n     * ```js\n     * hfInstance.rebuildAndRecalculate();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"rebuildAndRecalculate\",\n    value: function rebuildAndRecalculate() {\n      this.updateConfig({});\n    }\n    /**\n     * Returns a snapshot of computation time statistics.\n     * It returns a map with key-value pairs where keys are enums for stat type and time (number).\n     *\n     * @internal\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return this._stats.snapshot();\n    }\n    /**\n     * Undo the previous operation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoOperationToUndoError]] when there is no operation running that can be undone\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     *  ['3', ''],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // do an undo, it should return the changes\n     * const changes = hfInstance.undo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      this._crudOperations.undo();\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Re-do recently undone operation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoOperationToRedoError]] when there is no operation running that can be re-done\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     *  ['3'],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // do an undo, it should return prvious values: [['1'], ['2'], ['3']]\n     * hfInstance.undo();\n     *\n     * // do a redo, it should return the values after removing the second row: [['1'], ['3']]\n     * const changes = hfInstance.redo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      this._crudOperations.redo();\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if there is at least one operation that can be undone.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     *  ['3'],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // should return 'true', it is possible to undo last operation\n     * // which is removing rows in this example\n     * const isSomethingToUndo = hfInstance.isThereSomethingToUndo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"isThereSomethingToUndo\",\n    value: function isThereSomethingToUndo() {\n      return this._crudOperations.isThereSomethingToUndo();\n    }\n    /**\n     * Checks if there is at least one operation that can be re-done.\n     *\n     * @example\n     * ```js\n     * hfInstance.undo();\n     *\n     * // when there is an action to redo, this will return 'true'\n     * const isSomethingToRedo = hfInstance.isThereSomethingToRedo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"isThereSomethingToRedo\",\n    value: function isThereSomethingToRedo() {\n      return this._crudOperations.isThereSomethingToRedo();\n    }\n    /**\n     * Returns information whether it is possible to change the content in a rectangular area bounded by the box.\n     * If returns `true`, doing [[setCellContents]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside selected cells, the address is invalid or the sheet does not exist.\n     *\n     * @param {SimpleCellAddress} topLeftCornerAddress -  top left corner of block of cells\n     * @param {number} width - width of the box\n     * @param {number} height - height of the box\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // choose the address and assign it to a variable\n     * const address = { col: 0, row: 0, sheet: 0 };\n     *\n     * // should return 'true' for this example, it is possible to set content of\n     * // width 2, height 1 in the first row and column of sheet 0\n     * const isSettable = hfInstance.isItPossibleToSetCellContents(address, 2, 1);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isItPossibleToSetCellContents\",\n    value: function isItPossibleToSetCellContents(topLeftCornerAddress) {\n      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      try {\n        this._crudOperations.ensureRangeInSizeLimits(AbsoluteCellRange.spanFrom(topLeftCornerAddress, width, height));\n\n        for (var i = 0; i < width; i++) {\n          for (var j = 0; j < height; j++) {\n            this._crudOperations.ensureItIsPossibleToChangeContent({\n              col: topLeftCornerAddress.col + i,\n              row: topLeftCornerAddress.row + j,\n              sheet: topLeftCornerAddress.sheet\n            });\n          }\n        }\n      } catch (e) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Sets the content for a block of cells of a given coordinates.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} topLeftCornerAddress - top left corner of block of cells\n     * @param {(RawCellContent[][]|RawCellContent)} cellContents - array with content\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the value is not an array of arrays or a raw cell value\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws an error when it is an attempt to set cells content inside matrices during batch operation\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1'],\n     * ]);\n     *\n     * // should set the content, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 3, row: 0 },\n     * //   newValue: 2,\n     * // }]\n     * const changes = hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"setCellContents\",\n    value: function setCellContents(topLeftCornerAddress, cellContents) {\n      this._crudOperations.setCellContents(topLeftCornerAddress, cellContents);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Reorders rows of a sheet according to a source-target mapping.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // should set swap rows 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 2 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 2 },\n     * //   newValue: null,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 5,\n     * // }]\n     * const changes = hfInstance.swapRowIndexes(0, [[0,2],[2,0]]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"swapRowIndexes\",\n    value: function swapRowIndexes(sheetId, rowMapping) {\n      this._crudOperations.setRowOrder(sheetId, rowMapping);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if it is possible to reorder rows of a sheet according to a source-target mapping.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // returns true\n     * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0,2],[2,0]]);\n     *\n     * // returns false\n     * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0,1]]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToSwapRowIndexes\",\n    value: function isItPossibleToSwapRowIndexes(sheetId, rowMapping) {\n      try {\n        this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);\n\n        this._crudOperations.testRowOrderForMatrices(sheetId, rowMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders rows of a sheet according to a permutation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newRowOrder - permutation of rows\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // should set swap rows 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 2 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 2 },\n     * //   newValue: null,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 5,\n     * // }]\n     * const changes = hfInstance.setRowOrder(0, [2, 1, 0]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"setRowOrder\",\n    value: function setRowOrder(sheetId, newRowOrder) {\n      var mapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');\n\n      return this.swapRowIndexes(sheetId, mapping);\n    }\n    /**\n     * Checks if it is possible to reorder rows of a sheet according to a permutation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newRowOrder - permutation of rows\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSetRowOrder(0, [2, 1, 0]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSetRowOrder(0, [2]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToSetRowOrder\",\n    value: function isItPossibleToSetRowOrder(sheetId, newRowOrder) {\n      try {\n        var rowMapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');\n\n        this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);\n\n        this._crudOperations.testRowOrderForMatrices(sheetId, rowMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders columns of a sheet according to a source-target mapping.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} columnMapping - array mapping original positions to final positions of columns\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // should set swap columns 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 2, row: 0 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 2, row: 1 },\n     * //   newValue: 5,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 1 },\n     * //   newValue: null,\n     * // }]\n     * const changes = hfInstance.swapColumnIndexes(0, [[0,2],[2,0]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"swapColumnIndexes\",\n    value: function swapColumnIndexes(sheetId, columnMapping) {\n      this._crudOperations.setColumnOrder(sheetId, columnMapping);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if it is possible to reorder columns of a sheet according to a source-target mapping.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0,2],[2,0]]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0,1]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToSwapColumnIndexes\",\n    value: function isItPossibleToSwapColumnIndexes(sheetId, columnMapping) {\n      try {\n        this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);\n\n        this._crudOperations.testColumnOrderForMatrices(sheetId, columnMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders columns of a sheet according to a permutation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newColumnOrder - permutation of columns\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // should set swap columns 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 2, row: 0 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 2, row: 1 },\n     * //   newValue: 5,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 1 },\n     * //   newValue: null,\n     * // }]\n     * const changes = hfInstance.setColumnOrder(0, [2, 1, 0]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"setColumnOrder\",\n    value: function setColumnOrder(sheetId, newColumnOrder) {\n      var mapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');\n\n      return this.swapColumnIndexes(sheetId, mapping);\n    }\n    /**\n     * Checks if it possible to reorder columns of a sheet according to a permutation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newColumnOrder - permutation of columns\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSetColumnOrder(0, [2, 1, 0]]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSetColumnOrder(0, [1]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToSetColumnOrder\",\n    value: function isItPossibleToSetColumnOrder(sheetId, newRowOrder) {\n      try {\n        var columnMapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'column');\n\n        this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);\n\n        this._crudOperations.testColumnOrderForMatrices(sheetId, columnMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Returns information whether it is possible to add rows into a specified position in a given sheet.\n     * Checks against particular rules to ascertain that addRows can be called.\n     * If returns `true`, doing [[addRows]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected rows.\n     *\n     * @param {number} sheetId - sheet ID in which rows will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '3'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add one row in the second row of sheet 0\n     * const isAddable = hfInstance.isItPossibleToAddRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToAddRows\",\n    value: function isItPossibleToAddRows(sheetId) {\n      for (var _len = arguments.length, indexes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        indexes[_key - 1] = arguments[_key];\n      }\n\n      var normalizedIndexes = normalizeAddedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations;\n\n        (_this$_crudOperations = this._crudOperations).ensureItIsPossibleToAddRows.apply(_this$_crudOperations, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds multiple rows into a specified position in a given sheet.\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID in which rows will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[TargetLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.addRows(0, [0, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"addRows\",\n    value: function addRows(sheetId) {\n      var _this$_crudOperations2;\n\n      for (var _len2 = arguments.length, indexes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        indexes[_key2 - 1] = arguments[_key2];\n      }\n\n      (_this$_crudOperations2 = this._crudOperations).addRows.apply(_this$_crudOperations2, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove rows from a specified position in a given sheet.\n     * Checks against particular rules to ascertain that removeRows can be called.\n     * If returns `true`, doing [[removeRows]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected rows.\n     *\n     * @param {number} sheetId - sheet ID from which rows will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to remove one row from row 1 of sheet 0\n     * const isRemovable = hfInstance.isItPossibleToRemoveRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveRows\",\n    value: function isItPossibleToRemoveRows(sheetId) {\n      for (var _len3 = arguments.length, indexes = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        indexes[_key3 - 1] = arguments[_key3];\n      }\n\n      var normalizedIndexes = normalizeRemovedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations3;\n\n        (_this$_crudOperations3 = this._crudOperations).ensureItIsPossibleToRemoveRows.apply(_this$_crudOperations3, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes multiple rows from a specified position in a given sheet.\n     * Does nothing if rows are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID from which rows will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return: [{ sheet: 0, col: 1, row: 2, value: null }] for this example\n     * const changes = hfInstance.removeRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"removeRows\",\n    value: function removeRows(sheetId) {\n      var _this$_crudOperations4;\n\n      for (var _len4 = arguments.length, indexes = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        indexes[_key4 - 1] = arguments[_key4];\n      }\n\n      (_this$_crudOperations4 = this._crudOperations).removeRows.apply(_this$_crudOperations4, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to add columns into a specified position in a given sheet.\n     * Checks against particular rules to ascertain that addColumns can be called.\n     * If returns `true`, doing [[addColumns]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected columns.\n     *\n     * @param {number} sheetId - sheet ID in which columns will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add 1 column in sheet 0, at column 1\n     * const isAddable = hfInstance.isItPossibleToAddColumns(0, [1, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToAddColumns\",\n    value: function isItPossibleToAddColumns(sheetId) {\n      for (var _len5 = arguments.length, indexes = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        indexes[_key5 - 1] = arguments[_key5];\n      }\n\n      var normalizedIndexes = normalizeAddedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations5;\n\n        (_this$_crudOperations5 = this._crudOperations).ensureItIsPossibleToAddColumns.apply(_this$_crudOperations5, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds multiple columns into a specified position in a given sheet.\n     * Does nothing if the columns are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID in which columns will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[TargetLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=RAND()', '42'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 0.92754862796338,\n     * // }]\n     * const changes = hfInstance.addColumns(0, [0, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(sheetId) {\n      var _this$_crudOperations6;\n\n      for (var _len6 = arguments.length, indexes = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        indexes[_key6 - 1] = arguments[_key6];\n      }\n\n      (_this$_crudOperations6 = this._crudOperations).addColumns.apply(_this$_crudOperations6, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove columns from a specified position in a given sheet.\n     * Checks against particular rules to ascertain that removeColumns can be called.\n     * If returns `true`, doing [[removeColumns]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected columns.\n     *\n     * @param {number} sheetId - sheet ID from which columns will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [column, amount]\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to remove one column, in place of the second column of sheet 0\n     * const isRemovable = hfInstance.isItPossibleToRemoveColumns(0, [1, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveColumns\",\n    value: function isItPossibleToRemoveColumns(sheetId) {\n      for (var _len7 = arguments.length, indexes = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        indexes[_key7 - 1] = arguments[_key7];\n      }\n\n      var normalizedIndexes = normalizeRemovedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations7;\n\n        (_this$_crudOperations7 = this._crudOperations).ensureItIsPossibleToRemoveColumns.apply(_this$_crudOperations7, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes multiple columns from a specified position in a given sheet.\n     * Does nothing if columns are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID from which columns will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount]\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasMatrixError]] when the selected position has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: { error: [CellError], value: '#REF!' },\n     * // }]\n     * const changes = hfInstance.removeColumns(0, [0, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(sheetId) {\n      var _this$_crudOperations8;\n\n      for (var _len8 = arguments.length, indexes = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        indexes[_key8 - 1] = arguments[_key8];\n      }\n\n      (_this$_crudOperations8 = this._crudOperations).removeColumns.apply(_this$_crudOperations8, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move cells to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveCells can be called.\n     * If returns `true`, doing [[moveCells]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected columns, the target location has matrix or the provided address is invalid.\n     *\n     * @param {SimpleCellAddress} sourceLeftCorner - address of the upper left corner of a moved block\n     * @param {number} width - width of the cell block that is being moved\n     * @param {number} height - height of the cell block that is being moved\n     * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // choose the coordinates and assign them to variables\n     * const source = { sheet: 0, col: 1, row: 0 };\n     * const destination = { sheet: 0, col: 3, row: 0 };\n     *\n     * // should return 'true' for this example\n     * // it is possible to move a block of width 1 and height 1\n     * // from the corner: column 1 and row 0 of sheet 0\n     * // into destination corner: column 3, row 0 of sheet 0\n     * const isMovable = hfInstance.isItPossibleToMoveCells(source, 1, 1, destination);\n     * ```\n     * @category Cells\n     */\n\n  }, {\n    key: \"isItPossibleToMoveCells\",\n    value: function isItPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      try {\n        this._crudOperations.operations.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves the content of a cell block from source to the target location.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} sourceLeftCorner - address of the upper left corner of a moved block\n     * @param {number} width - width of the cell block that is being moved\n     * @param {number} height - height of the cell block that is being moved\n     * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[SourceLocationHasMatrixError]] when the source location has matrix inside - matrix cannot be moved\n     * @throws [[TargetLocationHasMatrixError]] when the target location has matrix inside - cells cannot be replaced by the matrix\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=RAND()', '42'],\n     * ]);\n     *\n     * // choose the coordinates and assign them to variables\n     * const source = { sheet: 0, col: 1, row: 0 };\n     * const destination = { sheet: 0, col: 3, row: 0 };\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 0.93524248002062,\n     * // }]\n     * const changes = hfInstance.moveCells(source, 1, 1, destination);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"moveCells\",\n    value: function moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n      this._crudOperations.moveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move a particular number of rows to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveRows can be called.\n     * If returns `true`, doing [[moveRows]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected rows, the target location has matrix or the provided address is invalid.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startRow - number of the first row to move\n     * @param {number} numberOfRows - number of rows to move\n     * @param {number} targetRow - row number before which rows will be moved\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to move one row from row 0 into row 2\n     * const isMovable = hfInstance.isItPossibleToMoveRows(0, 0, 1, 2);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToMoveRows\",\n    value: function isItPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow) {\n      try {\n        this._crudOperations.ensureItIsPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves a particular number of rows to a specified position in a given sheet.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startRow - number of the first row to move\n     * @param {number} numberOfRows - number of rows to move\n     * @param {number} targetRow - row number before which rows will be moved\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasMatrixError]] when the source location has matrix inside - matrix cannot be moved\n     * @throws [[TargetLocationHasMatrixError]] when the target location has matrix inside - cells cannot be replaced by the matrix\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.moveRows(0, 0, 1, 2);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(sheetId, startRow, numberOfRows, targetRow) {\n      this._crudOperations.moveRows(sheetId, startRow, numberOfRows, targetRow);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move a particular number of columns to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveColumns can be called.\n     * If returns `true`, doing [[moveColumns]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is a matrix inside the selected columns, the target location has matrix or the provided address is invalid.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startColumn - number of the first column to move\n     * @param {number} numberOfColumns - number of columns to move\n     * @param {number} targetColumn - column number before which columns will be moved\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to move one column from column 1 into column 2 of sheet 0\n     * const isMovable = hfInstance.isItPossibleToMoveColumns(0, 1, 1, 2);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToMoveColumns\",\n    value: function isItPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {\n      try {\n        this._crudOperations.ensureItIsPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves a particular number of columns to a specified position in a given sheet.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startColumn - number of the first column to move\n     * @param {number} numberOfColumns - number of columns to move\n     * @param {number} targetColumn - column number before which columns will be moved\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasMatrixError]] when the source location has matrix inside - matrix cannot be moved\n     * @throws [[TargetLocationHasMatrixError]] when the target location has matrix inside - cells cannot be replaced by the matrix\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '3', '=RAND()', '=SUM(A1:C1)'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 0.16210054671639,\n     * //  }, {\n     * //   address: { sheet: 0, col: 4, row: 0 },\n     * //   newValue: 6.16210054671639,\n     * // }]\n     * const changes = hfInstance.moveColumns(0, 1, 1, 2);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"moveColumns\",\n    value: function moveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {\n      this._crudOperations.moveColumns(sheetId, startColumn, numberOfColumns, targetColumn);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Stores a copy of the cell block in internal clipboard for the further paste.\n     * Returns values of cells for use in external clipboard.\n     *\n     * @param {SimpleCellAddress} sourceLeftCorner - address of the upper left corner of a copied block\n     * @param {number} width - width of the cell block being copied\n     * @param {number} height - height of the cell block being copied\n     *\n     * @throws an error while attempting to copy unsupported content type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return: [ [ 2 ] ]\n     * const clipboardContent = hfInstance.copy({ sheet: 0, col: 1, row: 0 }, 1, 1);\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(sourceLeftCorner, width, height) {\n      this._crudOperations.copy(sourceLeftCorner, width, height);\n\n      return this.getRangeValues(sourceLeftCorner, width, height);\n    }\n    /**\n     * Stores information of the cell block in internal clipboard for further paste.\n     * Calling [[paste]] right after this method is equivalent to call [[moveCells]].\n     * Almost any CRUD operation called after this method will abort the cut operation.\n     * Returns values of cells for use in external clipboard.\n     *\n     * @param {SimpleCellAddress} sourceLeftCorner - address of the upper left corner of a copied block\n     * @param {number} width - width of the cell block being copied\n     * @param {number} height - height of the cell block being copied\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return values that were cut: [ [ 1 ] ]\n     * const clipboardContent = hfInstance.cut({ sheet: 0, col: 0, row: 0 }, 1, 1);\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"cut\",\n    value: function cut(sourceLeftCorner, width, height) {\n      this._crudOperations.cut(sourceLeftCorner, width, height);\n\n      return this.getRangeValues(sourceLeftCorner, width, height);\n    }\n    /**\n     * When called after [[copy]] it will paste copied values and formulas into a cell block.\n     * When called after [[cut]] it will perform [[moveCells]] operation into the cell block.\n     * Does nothing if the clipboard is empty.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} targetLeftCorner - upper left address of the target cell block\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws an error while attempting to paste onto a matrix\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[NothingToPasteError]] when clipboard is empty\n     * @throws [[TargetLocationHasMatrixError]] when the selected target area has matrix inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // do a copy, [ [ 2 ] ] was copied\n     * hfInstance.copy({ sheet: 0, col: 0, row: 0 }, 1, 1);\n     *\n     * // do a paste, should return a list of cells which values changed\n     * // after the operation, their absolute addresses and new values\n     * const changes = hfInstance.paste({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"paste\",\n    value: function paste(targetLeftCorner) {\n      this.ensureEvaluationIsNotSuspended();\n\n      this._crudOperations.paste(targetLeftCorner);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether there is something in the clipboard.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // copy desired content\n     * hfInstance.copy({ sheet: 0, col: 1, row: 0 }, 1, 1);\n     *\n     * // returns 'false', there is content in the clipboard\n     * const isClipboardEmpty = hfInstance.isClipboardEmpty();\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"isClipboardEmpty\",\n    value: function isClipboardEmpty() {\n      return this._crudOperations.isClipboardEmpty();\n    }\n    /**\n     * Clears the clipboard content.\n     *\n     * @example\n     * ```js\n     * // clears the clipboard, isClipboardEmpty() should return true if called afterwards\n     * hfInstance.clearClipboard();\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"clearClipboard\",\n    value: function clearClipboard() {\n      this._crudOperations.clearClipboard();\n    }\n    /**\n     * Clears the redo stack in undoRedo history.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   ['1', '2', '3'],\n     * ]);\n     *\n     * // do an operation, for example remove columns\n     * hfInstance.removeColumns(0, [0, 1]);\n     *\n     * // undo the operation\n     * hfInstance.undo();\n     *\n     * // redo the operation\n     * hfInstance.redo();\n     *\n     * // clear the redo stack\n     * hfInstance.clearRedoStack();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"clearRedoStack\",\n    value: function clearRedoStack() {\n      this._crudOperations.undoRedo.clearRedoStack();\n    }\n    /**\n     * Clears the undo stack in undoRedo history.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   ['1', '2', '3'],\n     * ]);\n     *\n     * // do an operation, for example remove columns\n     * hfInstance.removeColumns(0, [0, 1]);\n     *\n     * // undo the operation\n     * hfInstance.undo();\n     *\n     * // clear the undo stack\n     * hfInstance.clearUndoStack();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"clearUndoStack\",\n    value: function clearUndoStack() {\n      this._crudOperations.undoRedo.clearUndoStack();\n    }\n    /**\n     * Returns the cell content of a given range in a [[CellValue]][][] format.\n     *\n     * @param {SimpleCellAddress} leftCorner - address of the upper left corner of a range\n     * @param {number} width - width of a range\n     * @param {number} height - height of a range\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     *\n     * // returns calculated cells content: [ [ 3, 2 ], [ 5, 6 ] ]\n     * const rangeValues = hfInstance.getRangeValues({ sheet: 0, col: 0, row: 0 }, 2, 2);\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeValues\",\n    value: function getRangeValues(leftCorner, width, height) {\n      var _this3 = this;\n\n      var cellRange = AbsoluteCellRange.spanFrom(leftCorner, width, height);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this3.getCellValue(address);\n        });\n      });\n    }\n    /**\n     * Returns cell formulas in given range.\n     *\n     * @param {SimpleCellAddress} leftCorner - address of the upper left corner of a range\n     * @param {number} width - width of a range\n     * @param {number} height - height of a range\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     * // returns cell formulas of a given range only:\n     * // [ [ '=SUM(1,2)', undefined ], [ undefined, undefined ] ]\n     * const rangeFormulas = hfInstance.getRangeFormulas({ sheet: 0, col: 0, row: 0 }, 2, 2);\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeFormulas\",\n    value: function getRangeFormulas(leftCorner, width, height) {\n      var _this4 = this;\n\n      var cellRange = AbsoluteCellRange.spanFrom(leftCorner, width, height);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this4.getCellFormula(address);\n        });\n      });\n    }\n    /**\n     * Returns serialized cells in given range.\n     *\n     * @param {SimpleCellAddress} leftCorner - address of the upper left corner of a range\n     * @param {number} width - width of a range\n     * @param {number} height - height of a range\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     * // should return serialized cell content for the given range:\n     * // [ [ '=SUM(1,2)', 2 ], [ 5, 6 ] ]\n     * const rangeSerialized = hfInstance.getRangeSerialized({ sheet: 0, col: 0, row: 0 }, 2, 2);\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeSerialized\",\n    value: function getRangeSerialized(leftCorner, width, height) {\n      var _this5 = this;\n\n      var cellRange = AbsoluteCellRange.spanFrom(leftCorner, width, height);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this5.getCellSerialized(address);\n        });\n      });\n    }\n    /**\n     * Returns information whether it is possible to add a sheet to the engine.\n     * Checks against particular rules to ascertain that addSheet can be called.\n     * If returns `true`, doing [[addSheet]] operation won't throw any errors and it possible to add sheet with provided name.\n     * Returns `false` if the chosen name is already used.\n     *\n     * @param {string} sheetName - sheet name, case insensitive\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'false' because 'MySheet2' already exists\n     * const isAddable = hfInstance.isItPossibleToAddSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToAddSheet\",\n    value: function isItPossibleToAddSheet(sheetName) {\n      try {\n        this._crudOperations.ensureItIsPossibleToAddSheet(sheetName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds a new sheet to the HyperFormula instance. Returns given or autogenerated name of a new sheet.\n     *\n     * @param {string} [sheetName] - if not specified, name will be autogenerated\n     *\n     * @fires [[sheetAdded]] after the sheet was added\n     *\n     * @throws [[SheetNameAlreadyTakenError]] when sheet with a given name already exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'MySheet3'\n     * const nameProvided = hfInstance.addSheet('MySheet3');\n     *\n     * // should return autogenerated 'Sheet4'\n     * // because no name was provided and 3 other ones already exist\n     * const generatedName = hfInstance.addSheet();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName) {\n      var addedSheetName = this._crudOperations.addSheet(sheetName);\n\n      this._emitter.emit(Events.SheetAdded, addedSheetName);\n\n      return addedSheetName;\n    }\n    /**\n     * Returns information whether it is possible to remove sheet for the engine.\n     * Returns `true` if the provided name of a sheet exists and therefore it can be removed, doing [[removeSheet]] operation won't throw any errors.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {string} sheetName - sheet name, case insensitive\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet2' exists and is removable\n     * const isRemovable = hfInstance.isItPossibleToRemoveSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveSheet\",\n    value: function isItPossibleToRemoveSheet(sheetName) {\n      try {\n        this._crudOperations.ensureSheetExists(sheetName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes sheet with a specified name.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} sheetName - sheet name, case insensitive\n     *\n     * @fires [[sheetRemoved]] after the sheet was removed\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: { error: [CellError], value: '#REF!' },\n     * // }]\n     * const changes = hfInstance.removeSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"removeSheet\",\n    value: function removeSheet(sheetName) {\n      var displayName = this.sheetMapping.getDisplayNameByName(sheetName);\n\n      this._crudOperations.removeSheet(sheetName);\n\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.SheetRemoved, displayName, changes);\n\n      return changes;\n    }\n    /**\n     * Returns information whether it is possible to clear a specified sheet.\n     * If returns `true`, doing [[clearSheet]] operation won't throw any errors, provided name of a sheet exists and then its content can be cleared.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {string} sheetName - sheet name, case insensitive.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet2' exists and can be cleared\n     * const isClearable = hfInstance.isItPossibleToClearSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToClearSheet\",\n    value: function isItPossibleToClearSheet(sheetName) {\n      try {\n        this._crudOperations.ensureSheetExists(sheetName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Clears the sheet content. Based on that the method finds the ID of a sheet to be cleared.\n     * Double-checks if the sheet exists.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} sheetName - sheet name, case insensitive.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 0,\n     * // }]\n     * const changes = hfInstance.clearSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"clearSheet\",\n    value: function clearSheet(sheetName) {\n      this._crudOperations.ensureSheetExists(sheetName);\n\n      this._crudOperations.clearSheet(sheetName);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to replace the sheet content.\n     * If returns `true`, doing [[setSheetContent]] operation won't throw any errors, the provided name of a sheet exists and then its content can be replaced.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {string} sheetName - sheet name, case insensitive.\n     * @param {RawCellContent[][]} values - array of new values\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet1' exists\n     * // and the provided content can be placed in this sheet\n     * const isReplaceable = hfInstance.isItPossibleToReplaceSheetContent('MySheet1', [['50'], ['60']]);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToReplaceSheetContent\",\n    value: function isItPossibleToReplaceSheetContent(sheetName, values) {\n      try {\n        this._crudOperations.ensureSheetExists(sheetName);\n\n        var sheetId = this.sheetMapping.fetch(sheetName);\n\n        this._crudOperations.ensureItIsPossibleToChangeSheetContents(sheetId, values);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Replaces the sheet content with new values.\n     * The new value is to be provided as an array of arrays of [[RawCellContent]].\n     * The method finds sheet ID based on the provided sheet name.\n     *\n     * @param {string} sheetName - sheet name, case insensitive.\n     * @param {RawCellContent[][]} values - array of new values\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     * @throws [[InvalidArgumentsError]] when values is not an array of arrays\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.setSheetContent('MySheet1', [['50'], ['60']]);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"setSheetContent\",\n    value: function setSheetContent(sheetName, values) {\n      this._crudOperations.setSheetContent(sheetName, values);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Computes simple (absolute) address of a cell address based on its string representation.\n     * If sheet name is present in string representation but not present in the engine, returns `undefined`.\n     * If sheet name is not present in string representation, returns the sheet number.\n     * Returns an absolute representation of address.\n     *\n     * @param {string} cellAddress - string representation of cell address in A1 notation\n     * @param {number} sheetId - override sheet index regardless of sheet mapping\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // should return { sheet: 0, col: 0, row: 0 }\n     * const simpleCellAddress = hfInstance.simpleCellAddressFromString('A1', 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellAddressFromString\",\n    value: function simpleCellAddressFromString(cellAddress, sheetId) {\n      return _simpleCellAddressFromString(this.sheetMapping.get, cellAddress, sheetId);\n    }\n    /**\n     * Returns string representation of an absolute address in A1 notation or `undefined` if the sheet index is not present in the engine.\n     *\n     * @param {SimpleCellAddress} cellAddress - object representation of an absolute address\n     * @param {number} sheetId - if is not equal with address sheet index, string representation will contain sheet name\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // should return 'B2'\n     * const A1Notation = hfInstance.simpleCellAddressToString({ sheet: 0, col: 1, row: 1 }, 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellAddressToString\",\n    value: function simpleCellAddressToString(cellAddress, sheetId) {\n      return _simpleCellAddressToString(this.sheetMapping.fetchDisplayName, cellAddress, sheetId);\n    }\n    /**\n     * Returns all addresses and ranges whose computation depends on input address or range provided.\n     *\n     * @param {SimpleCellAddress | AbsoluteCellRange} address - object representation of an absolute address or range of addresses\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n     *\n     * hfInstance.getCellDependents({ sheet: 0, col: 0, row: 0});\n     * // should return [{ sheet: 0, col: 1, row: 0}, { sheet: 0, col: 2, row: 0}]\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"getCellDependents\",\n    value: function getCellDependents(address) {\n      var vertex;\n\n      if (address instanceof AbsoluteCellRange) {\n        vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);\n\n        if (vertex === undefined) {\n          return [];\n        }\n      } else {\n        vertex = this._dependencyGraph.addressMapping.getCell(address);\n\n        if (vertex === null) {\n          return [];\n        }\n      }\n\n      return this._dependencyGraph.getAdjacentNodesAddresses(vertex);\n    }\n    /**\n     * Returns all addresses and ranges necessary for computation of a given address or range.\n     *\n     * @param {SimpleCellAddress | AbsoluteCellRange} address - object representation of an absolute address or range of addresses\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n     *\n     * hfInstance.getCellPrecedents({ sheet: 0, col: 2, row: 0});\n     * // should return [{ sheet: 0, col: 0, row: 0}, { sheet: 0, col: 1, row: 0}]\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"getCellPrecedents\",\n    value: function getCellPrecedents(address) {\n      var _a;\n\n      var vertex;\n\n      if (address instanceof AbsoluteCellRange) {\n        vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);\n\n        if (vertex === undefined) {\n          return [];\n        }\n      } else {\n        vertex = this._dependencyGraph.addressMapping.getCell(address);\n\n        if (vertex === null) {\n          return [];\n        }\n      }\n\n      return (_a = this._dependencyGraph.dependencyQueryAddresses(vertex)) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Returns a unique sheet name assigned to the sheet of a given ID or `undefined` if the there is no sheet with a given ID.\n     *\n     * @param {number} sheetId - ID of the sheet, for which we want to retrieve name\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'MySheet2' as this sheet is the second one\n     * const sheetName = hfInstance.getSheetName(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetName\",\n    value: function getSheetName(sheetId) {\n      return this.sheetMapping.getDisplayName(sheetId);\n    }\n    /**\n     * List all sheet names.\n     * Returns an array of sheet names as strings.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return all sheets names: ['MySheet1', 'MySheet2']\n     * const sheetNames = hfInstance.getSheetNames();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetNames\",\n    value: function getSheetNames() {\n      return this.sheetMapping.sheetNames();\n    }\n    /**\n     * Returns a unique sheet ID assigned to the sheet with a given name or `undefined` if the sheet does not exist.\n     *\n     * @param {string} sheetName - name of the sheet, for which we want to retrieve ID, case insensitive.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return '0' because 'MySheet1' is of ID '0'\n     * const sheetID = hfInstance.getSheetId('MySheet1');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetId\",\n    value: function getSheetId(sheetName) {\n      return this.sheetMapping.get(sheetName);\n    }\n    /**\n     * Returns `true` whether sheet with a given name exists. The methods accepts sheet name to be checked.\n     *\n     * @param {string} sheetName - name of the sheet, case insensitive.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' since 'MySheet1' exists\n     * const sheetExist = hfInstance.doesSheetExist('MySheet1');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"doesSheetExist\",\n    value: function doesSheetExist(sheetName) {\n      return this.sheetMapping.hasSheetWithName(sheetName);\n    }\n    /**\n     * Returns type of a specified cell of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'FORMULA', the cell of given coordinates is of this type\n     * const cellA1Type = hfInstance.getCellType({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'VALUE', the cell of given coordinates is of this type\n     * const cellB1Type = hfInstance.getCellType({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(cellAddress) {\n      var vertex = this.dependencyGraph.getCell(cellAddress);\n      return _getCellType(vertex);\n    }\n    /**\n     * Returns `true` if the specified cell contains a simple value.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'true' since the selected cell contains a simple value\n     * const isA1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false' since the selected cell does not contain a simple value\n     * const isB1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"doesCellHaveSimpleValue\",\n    value: function doesCellHaveSimpleValue(cellAddress) {\n      return this.getCellType(cellAddress) === CellType.VALUE;\n    }\n    /**\n     * Returns `true` if the specified cell contains a formula.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'true' since the A1 cell contains a formula\n     * const A1Formula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false' since the B1 cell does not contain a formula\n     * const B1NoFormula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"doesCellHaveFormula\",\n    value: function doesCellHaveFormula(cellAddress) {\n      return this.getCellType(cellAddress) === CellType.FORMULA;\n    }\n    /**\n     * Returns`true` if the specified cell is empty.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   [null, '1'],\n     * ]);\n     *\n     * // should return 'true', cell of provided coordinates is empty\n     * const isEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false', cell of provided coordinates is not empty\n     * const isNotEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isCellEmpty\",\n    value: function isCellEmpty(cellAddress) {\n      return this.getCellType(cellAddress) === CellType.EMPTY;\n    }\n    /**\n     * Returns `true` if a given cell is a part of a matrix.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *    ['{=TRANSPOSE(B1:B1)}'],\n     * ]);\n     *\n     * // should return 'true', cell of provided coordinates is a part of a matrix\n     * const isPartOfMatrix = hfInstance.isCellPartOfMatrix({ sheet: 0, col: 0, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isCellPartOfMatrix\",\n    value: function isCellPartOfMatrix(cellAddress) {\n      return this.getCellType(cellAddress) === CellType.MATRIX;\n    }\n    /**\n     * Returns type of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '2'],\n     * ]);\n     *\n     * // should return 'NUMBER', cell value type of provided coordinates is a number\n     * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });\n     *\n     * // should return 'NUMBER', cell value type of provided coordinates is a number\n     * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueType\",\n    value: function getCellValueType(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueType(value);\n    }\n    /**\n     * Returns detailed type of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1%', '1$'],\n     * ]);\n     *\n     * // should return 'NUMBER_PERCENT', cell value type of provided coordinates is a number with a format inference percent.\n     * const cellType = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'NUMBER_CURRENCY', cell value type of provided coordinates is a number with a format inference currency.\n     * const cellType = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueDetailedType\",\n    value: function getCellValueDetailedType(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueDetailedType(value);\n    }\n    /**\n     * Returns auxilary format information of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1$', '1'],\n     * ]);\n     *\n     * // should return '$', cell value type of provided coordinates is a number with a format inference currency, parsed as using '$' as currency.\n     * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return undefined, cell value type of provided coordinates is a number with no format information.\n     * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueFormat\",\n    value: function getCellValueFormat(cellAddress) {\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueFormat(value);\n    }\n    /**\n     * Returns the number of existing sheets.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return the number of sheets which is '1'\n     * const sheetsCount = hfInstance.countSheets();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"countSheets\",\n    value: function countSheets() {\n      return this.sheetMapping.numberOfSheets();\n    }\n    /**\n     * Returns information whether it is possible to rename sheet.\n     * Returns `true` if the sheet with provided id exists and new name is available\n     * Returns `false` if sheet cannot be renamed\n     *\n     * @param {number} sheetId - a sheet number\n     * @param {string} newName - a name of the sheet to be given\n     *\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // returns true\n     * hfInstance.isItPossibleToRenameSheet(0, 'MySheet0');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToRenameSheet\",\n    value: function isItPossibleToRenameSheet(sheetId, newName) {\n      try {\n        this._crudOperations.ensureItIsPossibleToRenameSheet(sheetId, newName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Renames a specified sheet.\n     *\n     * @param {number} sheetId - a sheet number\n     * @param {string} newName - a name of the sheet to be given, if is the same as the old one the method does nothing\n     *\n     * @fires [[sheetRenamed]] after the sheet was renamed\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @throws [[SheetNameAlreadyTakenError]] when the provided sheet name already exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // renames the sheet 'MySheet1'\n     * hfInstance.renameSheet(0, 'MySheet0');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"renameSheet\",\n    value: function renameSheet(sheetId, newName) {\n      var oldName = this._crudOperations.renameSheet(sheetId, newName);\n\n      if (oldName !== undefined) {\n        this._emitter.emit(Events.SheetRenamed, oldName, newName);\n      }\n    }\n    /**\n     * Runs multiple operations and recomputes formulas at the end.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {() => void} batchOperations\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     * @fires [[evaluationSuspended]] always\n     * @fires [[evaluationResumed]] after the recomputation of necessary values\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // multiple operations in a single callback will trigger evaluation only once\n     * // and only one set of changes is returned as a combined result of all\n     * // the operations that were triggered within the callback\n     * const changes = hfInstance.batch(() => {\n     *  hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     *  hfInstance.setCellContents({ col: 4, row: 0, sheet: 0 }, [['=A1']]);\n     * });\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch(batchOperations) {\n      this.suspendEvaluation();\n\n      this._crudOperations.beginUndoRedoBatchMode();\n\n      try {\n        batchOperations();\n      } catch (e) {\n        this._crudOperations.commitUndoRedoBatchMode();\n\n        this.resumeEvaluation();\n        throw e;\n      }\n\n      this._crudOperations.commitUndoRedoBatchMode();\n\n      return this.resumeEvaluation();\n    }\n    /**\n     * Suspends the dependency graph recalculation.\n     * It allows optimizing the performance.\n     * With this method, multiple CRUD operations can be done without triggering recalculation after every operation.\n     * Suspending evaluation should result in an overall faster calculation compared to recalculating after each operation separately.\n     * To resume the evaluation use [[resumeEvaluation]].\n     *\n     * @fires [[evaluationSuspended]] always\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // similar to batch() but operations are not within a callback,\n     * // one method suspends the recalculation\n     * // the second will resume calculations and return the changes\n     *\n     * // suspend the evaluation with this method\n     * hfInstance.suspendEvaluation();\n     *\n     * // perform operations\n     * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * hfInstance.setSheetContent('MySheet2', [['50'], ['60']]);\n     *\n     * // use resumeEvaluation to resume\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"suspendEvaluation\",\n    value: function suspendEvaluation() {\n      this._evaluationSuspended = true;\n\n      this._emitter.emit(Events.EvaluationSuspended);\n    }\n    /**\n     * Resumes the dependency graph recalculation that was suspended with [[suspendEvaluation]].\n     * It also triggers the recalculation and returns changes that are a result of all batched operations.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     * @fires [[evaluationResumed]] after the recomputation of necessary values\n     *\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // similar to batch() but operations are not within a callback,\n     * // one method suspends the recalculation\n     * // the second will resume calculations and return the changes\n     *\n     * // first, suspend the evaluation\n     * hfInstance.suspendEvaluation();\n     *\n     * // perform operations\n     * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * hfInstance.setSheetContent('MySheet2', [['50'], ['60']]);\n     *\n     * // resume the evaluation\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"resumeEvaluation\",\n    value: function resumeEvaluation() {\n      this._evaluationSuspended = false;\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.EvaluationResumed, changes);\n\n      return changes;\n    }\n    /**\n     * Checks if the dependency graph recalculation process is suspended or not.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // suspend the evaluation\n     * hfInstance.suspendEvaluation();\n     *\n     * // between suspendEvaluation() and resumeEvaluation()\n     * // or inside batch() callback it will return 'true', otherwise 'false'\n     * const isEvaluationSuspended = hfInstance.isEvaluationSuspended();\n     *\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"isEvaluationSuspended\",\n    value: function isEvaluationSuspended() {\n      return this._evaluationSuspended;\n    }\n    /**\n     * Returns information whether it is possible to add named expression into a specific scope.\n     * Checks against particular rules to ascertain that addNamedExpression can be called.\n     * If returns `true`, doing [[addNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - a name of the expression to be added\n     * @param {RawCellContent} expression - the expression\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add named expression to global scope\n     * const isAddable = hfInstance.isItPossibleToAddNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToAddNamedExpression\",\n    value: function isItPossibleToAddNamedExpression(expressionName, expression, scope) {\n      try {\n        this._crudOperations.ensureItIsPossibleToAddNamedExpression(expressionName, expression, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds a specified named expression.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - a name of the expression to be added\n     * @param {RawCellContent} expression - the expression\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     * @param {NamedExpressionOptions?} options - additional metadata related to named expression\n     *\n     * @fires [[namedExpressionAdded]] always, unless [[batch]] mode is used\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NamedExpressionNameIsAlreadyTakenError]] when the named expression name is not available.\n     * @throws [[NamedExpressionNameIsInvalidError]] when the named expression name is not valid\n     * @throws [[MatrixFormulasNotSupportedError]] when the named expression formula is a Matrix formula\n     * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add own expression, scope limited to 'Sheet1', the method should return a list of cells which values\n     * // changed after the operation, their absolute addresses and new values\n     * // for this example:\n     * // [{\n     * //   name: 'prettyName',\n     * //   newValue: 142,\n     * // }]\n     * const changes = hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"addNamedExpression\",\n    value: function addNamedExpression(expressionName, expression, scope, options) {\n      this._crudOperations.addNamedExpression(expressionName, expression, scope, options);\n\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.NamedExpressionAdded, expressionName, changes);\n\n      return changes;\n    }\n    /**\n     * Gets specified named expression value.\n     * Returns a [[CellValue]] or undefined if the given named expression does not exists.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression, only 'Sheet1' considered as it is the scope\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // returns the calculated value of a passed named expression, '142' for this example\n     * const myFormula = hfInstance.getNamedExpressionValue('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpressionValue\",\n    value: function getNamedExpressionValue(expressionName, scope) {\n      this.ensureEvaluationIsNotSuspended();\n\n      var sheetId = this._crudOperations.scopeId(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (namedExpression) {\n        return this._serialization.getCellValue(namedExpression.address);\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a normalized formula string for given named expression or `undefined` for a named expression that does not exist or does not hold a formula.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression in 'Sheet1'\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // returns a normalized formula string corresponding to a passed name from 'Sheet1',\n     * // '=Sheet1!A1+100' for this example\n     * const myFormula = hfInstance.getNamedExpressionFormula('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpressionFormula\",\n    value: function getNamedExpressionFormula(expressionName, scope) {\n      var sheetId = this._crudOperations.scopeId(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (namedExpression === undefined) {\n        return undefined;\n      } else {\n        return this._serialization.getCellFormula(namedExpression.address);\n      }\n    }\n    /**\n     * Returns named expression a normalized formula string for given named expression or `undefined` for a named expression that does not exist or does not hold a formula.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression in 'Sheet1'\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // returns a normalized formula string corresponding to a passed name from 'Sheet1',\n     * // '=Sheet1!$A$1+100' for this example\n     * const myFormula = hfInstance.getNamedExpression('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpression\",\n    value: function getNamedExpression(expressionName, scope) {\n      var sheetId = this._crudOperations.scopeId(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, sheetId);\n\n      if (namedExpression === undefined) {\n        return undefined;\n      }\n\n      var expression = this._serialization.getCellFormula(namedExpression.address);\n\n      return {\n        name: expressionName,\n        scope: scope,\n        expression: expression,\n        options: namedExpression.options\n      };\n    }\n    /**\n     * Returns information whether it is possible to change named expression in a specific scope.\n     * Checks against particular rules to ascertain that changeNamedExpression can be called.\n     * If returns `true`, doing [[changeNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {RawCellContent} newExpression - a new expression\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     *\n     * // should return 'true' for this example,\n     * // it is possible to change named expression\n     * const isAddable = hfInstance.isItPossibleToChangeNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToChangeNamedExpression\",\n    value: function isItPossibleToChangeNamedExpression(expressionName, newExpression, scope) {\n      try {\n        this._crudOperations.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Changes a given named expression to a specified formula.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {RawCellContent} newExpression - a new expression\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     * @param {NamedExpressionOptions?} options - additional metadata related to named expression\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     * @throws [[MatrixFormulasNotSupportedError]] when the named expression formula is a Matrix formula\n     * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression, scope limited to 'Sheet1'\n     * hfInstance.addNamedExpression('prettyName', 'Sheet1', '=Sheet1!$A$1+100');\n     *\n     * // change the named expression\n     * const changes = hfInstance.changeNamedExpression('prettyName', '=Sheet1!$A$1+200');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"changeNamedExpression\",\n    value: function changeNamedExpression(expressionName, newExpression, scope, options) {\n      this._crudOperations.changeNamedExpressionExpression(expressionName, scope, newExpression, options);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove named expression from a specific scope.\n     * Checks against particular rules to ascertain that removeNamedExpression can be called.\n     * If returns `true`, doing [[removeNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     *\n     * // should return 'true' for this example,\n     * // it is possible to change named expression\n     * const isAddable = hfInstance.isItPossibleToRemoveNamedExpression('prettyName');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveNamedExpression\",\n    value: function isItPossibleToRemoveNamedExpression(expressionName, scope) {\n      try {\n        this._crudOperations.isItPossibleToRemoveNamedExpression(expressionName, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes a named expression.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @fires [[namedExpressionRemoved]] after the expression was removed\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // remove the named expression\n     * const changes = hfInstance.removeNamedExpression('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"removeNamedExpression\",\n    value: function removeNamedExpression(expressionName, scope) {\n      var removedNamedExpression = this._crudOperations.removeNamedExpression(expressionName, scope);\n\n      if (removedNamedExpression) {\n        var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n        this._emitter.emit(Events.NamedExpressionRemoved, removedNamedExpression.displayName, changes);\n\n        return changes;\n      } else {\n        return [];\n      }\n    }\n    /**\n     * Lists all named expressions.\n     * Returns an array of expression names defined in a scope, as strings.\n     *\n     * @param {string?} scope - scope definition, `sheetName` for local scope or `undefined` for global scope\n     *\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     *  ['60'],\n     * ]);\n     *\n     * // add two named expressions and one scoped\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!A1+100');\n     * hfInstance.addNamedExpression('prettyName2', '=Sheet1!A2+100');\n     * hfInstance.addNamedExpression('prettyName3', '=Sheet1!A3+100', 'Sheet1');\n     *\n     * // list the expressions, should return: ['prettyName', 'prettyName2'] for this example\n     * const listOfExpressions = hfInstance.listNamedExpressions();\n     *\n     *  // list the expressions, should return: ['prettyName3'] for this example\n     * const listOfExpressions = hfInstance.listNamedExpressions('Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"listNamedExpressions\",\n    value: function listNamedExpressions(scope) {\n      var scopeId = this._crudOperations.scopeId(scope);\n\n      return this._namedExpressions.getAllNamedExpressionsNamesInScope(scopeId);\n    }\n    /**\n     * Returns a normalized formula.\n     *\n     * @param {string} formulaString - a formula in a proper format - it must start with \"=\"\n     *\n     * @throws [[NotAFormulaError]] when the provided string is not a valid formula, i.e does not start with \"=\"\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     * ]);\n     *\n     * // normalize the formula, should return '=Sheet1!A1+10' for this example\n     * const normalizedFormula = hfInstance.normalizeFormula('=SHEET1!A1+10');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"normalizeFormula\",\n    value: function normalizeFormula(formulaString) {\n      var _this$extractTemporar = this.extractTemporaryFormula(formulaString),\n          _this$extractTemporar2 = _slicedToArray(_this$extractTemporar, 2),\n          ast = _this$extractTemporar2[0],\n          address = _this$extractTemporar2[1];\n\n      if (ast === undefined) {\n        throw new NotAFormulaError();\n      }\n\n      return this._unparser.unparse(ast, address);\n    }\n    /**\n     * Calculates fire-and-forget formula, returns the calculated value.\n     *\n     * @param {string} formulaString -  a formula in a proper format - it must start with \"=\"\n     * @param {string} sheetName - a name of the sheet in context of which we evaluate formula, case insensitive.\n     *\n     * @throws [[NotAFormulaError]] when the provided string is not a valid formula, i.e does not start with \"=\"\n     * @throws [[NoSheetWithNameError]] when the given sheet name does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  Sheet1: [['22']],\n     *  Sheet2: [['58']],\n     * });\n     *\n     * // returns the value of calculated formula, '32' for this example\n     * const calculatedFormula = hfInstance.calculateFormula('=A1+10', 'Sheet1');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"calculateFormula\",\n    value: function calculateFormula(formulaString, sheetName) {\n      this._crudOperations.ensureSheetExists(sheetName);\n\n      var sheetId = this.sheetMapping.fetch(sheetName);\n\n      var _this$extractTemporar3 = this.extractTemporaryFormula(formulaString, sheetId),\n          _this$extractTemporar4 = _slicedToArray(_this$extractTemporar3, 3),\n          ast = _this$extractTemporar4[0],\n          address = _this$extractTemporar4[1],\n          dependencies = _this$extractTemporar4[2];\n\n      if (ast === undefined) {\n        throw new NotAFormulaError();\n      }\n\n      var internalCellValue = this.evaluator.runAndForget(ast, address, dependencies);\n      return this._exporter.exportValue(internalCellValue);\n    }\n    /**\n     * Validates the formula.\n     * If the provided string starts with \"=\" and is a parsable formula the method returns `true`.\n     *\n     * @param {string} formulaString -  a formula in a proper format - it must start with \"=\"\n     *\n     * @example\n     * ```js\n     * // checks if the given string is a valid formula, should return 'true' for this example\n     * const isFormula = hfInstance.validateFormula('=SUM(1,2)');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"validateFormula\",\n    value: function validateFormula(formulaString) {\n      var _this$extractTemporar5 = this.extractTemporaryFormula(formulaString),\n          _this$extractTemporar6 = _slicedToArray(_this$extractTemporar5, 1),\n          ast = _this$extractTemporar6[0];\n\n      if (ast === undefined) {\n        return false;\n      }\n\n      if (ast.type === AstNodeType.ERROR && !ast.error) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Returns translated names of all functions registered in this instance of HyperFormula\n     * according to the language set in the configuration\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // return translated names of all functions, assign to a variable\n     * const allNames = hfInstance.getRegisteredFunctionNames();\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getRegisteredFunctionNames\",\n    value: function getRegisteredFunctionNames() {\n      var language = HyperFormula.getLanguage(this._config.language);\n      return language.getFunctionTranslations(this._functionRegistry.getRegisteredFunctionIds());\n    }\n    /**\n     * Returns class of a plugin used by function with given id\n     *\n     * @param {string} functionId - id of a function, e.g. 'SUMIF'\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // register a plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     *\n     * // get the plugin\n     * const myPlugin = hfInstance.getFunctionPlugin('EXAMPLE');\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getFunctionPlugin\",\n    value: function getFunctionPlugin(functionId) {\n      return this._functionRegistry.getFunctionPlugin(functionId);\n    }\n    /**\n     * Returns classes of all plugins registered in this instance of HyperFormula\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // return classes of all plugins registered, assign to a variable\n     * const allNames = hfInstance.getAllFunctionPlugins();\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getAllFunctionPlugins\",\n    value: function getAllFunctionPlugins() {\n      return this._functionRegistry.getPlugins();\n    }\n    /**\n     * Interprets number as a date + time.\n     *\n     * @param {number} val - number of days since nullDate, should be nonnegative, fractions are interpreted as hours/minutes/seconds.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass the number of days since nullDate\n     * // the method should return formatted date and time, for this example:\n     * // {year: 2020, month: 1, day: 15, hours: 2, minutes: 24, seconds: 0}\n     * const dateTimeFromNumber = hfInstance.numberToDateTime(43845.1);\n     *\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToDateTime\",\n    value: function numberToDateTime(val) {\n      return this._evaluator.dateHelper.numberToSimpleDateTime(val);\n    }\n    /**\n     * Interprets number as a date.\n     *\n     * @param {number} val - number of days since nullDate, should be nonnegative, fractions are ignored.\n        * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass the number of days since nullDate\n     * // the method should return formatted date, for this example:\n     * // {year: 2020, month: 1, day: 15}\n     * const dateFromNumber = hfInstance.numberToDate(43845);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToDate\",\n    value: function numberToDate(val) {\n      return this._evaluator.dateHelper.numberToSimpleDate(val);\n    }\n    /**\n     * Interprets number as a time (hours/minutes/seconds).\n     *\n     * @param {number} val - time in 24h units.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass a number to be interpreted as a time\n     * // should return {hours: 26, minutes: 24} for this example\n     * const timeFromNumber = hfInstance.numberToTime(1.1);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToTime\",\n    value: function numberToTime(val) {\n      return numberToSimpleTime(val);\n    }\n  }, {\n    key: \"extractTemporaryFormula\",\n    value: function extractTemporaryFormula(formulaString) {\n      var sheetId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var parsedCellContent = this._cellContentParser.parse(formulaString);\n\n      var exampleTemporaryFormulaAddress = {\n        sheet: sheetId,\n        col: 0,\n        row: 0\n      };\n\n      if (!(parsedCellContent instanceof CellContent.Formula)) {\n        return [undefined, exampleTemporaryFormulaAddress, []];\n      }\n\n      var _this$_parser$parse = this._parser.parse(parsedCellContent.formula, exampleTemporaryFormulaAddress),\n          ast = _this$_parser$parse.ast,\n          errors = _this$_parser$parse.errors,\n          dependencies = _this$_parser$parse.dependencies;\n\n      if (errors.length > 0) {\n        return [undefined, exampleTemporaryFormulaAddress, []];\n      }\n\n      return [ast, exampleTemporaryFormulaAddress, dependencies];\n    }\n    /**\n     * A method that subscribes to an event.\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // subscribe to a 'sheetAdded', pass a simple handler\n     * hfInstance.on('sheetAdded', ( ) => { console.log('foo') });\n     *\n     * // add a sheet to trigger an event,\n     * // console should print 'foo' after each time sheet is added in this example\n     * hfInstance.addSheet('FooBar');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this._emitter.on(event, listener);\n    }\n    /**\n     * A method that subscribes to an event once.\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // subscribe to a 'sheetAdded', pass a simple handler\n     * hfInstance.once('sheetAdded', ( ) => { console.log('foo') });\n     *\n     * // call addSheet twice,\n     * // console should print 'foo' only once when the sheet is added in this example\n     * hfInstance.addSheet('FooBar');\n     * hfInstance.addSheet('FooBaz');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(event, listener) {\n      this._emitter.once(event, listener);\n    }\n    /**\n     * A method that unsubscribe from an event or all events.\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // define a simple function to be called upon emitting an event\n     * const handler = ( ) => { console.log('baz') }\n     *\n     * // subscribe to a 'sheetAdded', pass the handler\n     * hfInstance.on('sheetAdded', handler);\n     *\n     * // add a sheet to trigger an event,\n     * // console should print 'baz' each time a sheet is added\n     * hfInstance.addSheet('FooBar');\n     *\n     * // unsubscribe from a 'sheetAdded'\n     * hfInstance.off('sheetAdded', handler);\n     *\n     * // add a sheet, the console should not print anything\n     * hfInstance.addSheet('FooBaz');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.off(event, listener);\n    }\n    /**\n     * Destroys instance of HyperFormula.\n     *\n     * @example\n     * ```js\n     * // destroys the instance\n     * hfInstance.destroy();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.dependencyGraph.destroy();\n      this.columnSearch.destroy();\n      this.evaluator.destroy();\n\n      this._parser.destroy();\n\n      this._lazilyTransformingAstService.destroy();\n\n      this._stats.destroy();\n\n      this._crudOperations.clearClipboard();\n    }\n    /**\n     * Runs a recomputation starting from recently changed vertices.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     */\n\n  }, {\n    key: \"recomputeIfDependencyGraphNeedsIt\",\n    value: function recomputeIfDependencyGraphNeedsIt() {\n      if (!this._evaluationSuspended) {\n        var changes = this._crudOperations.getAndClearContentChanges();\n\n        var verticesToRecomputeFrom = Array.from(this.dependencyGraph.verticesToRecompute());\n        this.dependencyGraph.clearRecentlyChangedVertices();\n\n        if (verticesToRecomputeFrom.length > 0) {\n          changes.addAll(this.evaluator.partialRun(verticesToRecomputeFrom));\n        }\n\n        var exportedChanges = changes.exportChanges(this._exporter);\n\n        if (!changes.isEmpty()) {\n          this._emitter.emit(Events.ValuesUpdated, exportedChanges);\n        }\n\n        return exportedChanges;\n      } else {\n        return [];\n      }\n    }\n  }], [{\n    key: \"buildFromEngineState\",\n    value: function buildFromEngineState(engine) {\n      return new HyperFormula(engine.config, engine.stats, engine.dependencyGraph, engine.columnSearch, engine.parser, engine.unparser, engine.cellContentParser, engine.evaluator, engine.lazilyTransformingAstService, engine.crudOperations, engine.exporter, engine.namedExpressions, engine.serialization, engine.functionRegistry);\n    }\n    /**\n     * Builds the engine for a sheet from a two-dimensional array representation.\n     * The engine is created with a single sheet.\n     * Can be configured with the optional second parameter that represents a [[ConfigParams]].\n     * If not specified, the engine will be built with the default configuration.\n     *\n     * @param {Sheet} sheet - two-dimensional array representation of sheet\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     *\n     * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits\n     * @throws [[InvalidArgumentsError]] when sheet is not an array of arrays\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     *\n     * @example\n     * ```js\n     * // data represented as an array\n     * const sheetData = [\n     *  ['0', '=SUM(1,2,3)', '52'],\n     *  ['=SUM(A1:C1)', '', '=A1'],\n     *  ['2', '=SUM(A1:C1)', '91'],\n     * ];\n     *\n     * // method with optional config parameter maxColumns\n     * const hfInstance = HyperFormula.buildFromArray(sheetData, { maxColumns: 1000 });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildFromArray\",\n    value: function buildFromArray(sheet, configInput) {\n      return this.buildFromEngineState(BuildEngineFactory.buildFromSheet(sheet, configInput));\n    }\n    /**\n     * Builds the engine from an object containing multiple sheets with names.\n     * The engine is created with one or more sheets.\n     * Can be configured with the optional second parameter that represents a [[ConfigParams]].\n     * If not specified the engine will be built with the default configuration.\n     *\n     * @param {Sheet} sheets - object with sheets definition\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     *\n     * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits\n     * @throws [[InvalidArgumentsError]] when any sheet is not an array of arrays\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     *\n     * @example\n     * ```js\n     * // data represented as an object with sheets: Sheet1 and Sheet2\n     * const sheetData = {\n     *  'Sheet1': [\n     *    ['1', '', '=Sheet2!$A1'],\n     *    ['', '2', '=SUM(1,2,3)'],\n     *    ['=Sheet2!$A2', '2', ''],\n     *   ],\n     *  'Sheet2': [\n     *    ['', '4', '=Sheet1!$B1'],\n     *    ['', '8', '=SUM(9,3,3)'],\n     *    ['=Sheet1!$B1', '2', ''],\n     *   ],\n     * };\n     *\n     * // method with optional config parameter useColumnIndex\n     * const hfInstance = HyperFormula.buildFromSheets(sheetData, { useColumnIndex: true });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildFromSheets\",\n    value: function buildFromSheets(sheets, configInput) {\n      return this.buildFromEngineState(BuildEngineFactory.buildFromSheets(sheets, configInput));\n    }\n    /**\n     * Builds an empty engine instance.\n     * Can be configured with the optional parameter that represents a [[ConfigParams]].\n     * If not specified the engine will be built with the default configuration.\n     *\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     *\n     * @example\n     * ```js\n     * // build with no initial data and with optional config parameter maxColumns\n     * const hfInstance = HyperFormula.buildEmpty({ maxColumns: 1000 });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildEmpty\",\n    value: function buildEmpty(configInput) {\n      return this.buildFromEngineState(BuildEngineFactory.buildEmpty(configInput));\n    }\n    /**\n     * Returns registered language from its code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     *\n     * @throws [[LanguageNotRegisteredError]] when trying to retrieve not registered language\n     *\n     * @example\n     * ```js\n     * // return registered language\n     * const language = HyperFormula.getLanguage('enGB');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getLanguage\",\n    value: function getLanguage(languageCode) {\n      var val = this.registeredLanguages.get(languageCode);\n\n      if (val === undefined) {\n        throw new LanguageNotRegisteredError();\n      } else {\n        return val;\n      }\n    }\n    /**\n     * Registers language from under given code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     * @param {RawTranslationPackage} languagePackage - translation package to be registered\n     *\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     * @throws [[LanguageAlreadyRegisteredError]] when given language is already registered\n     *\n     * @example\n     * ```js\n     * // return registered language\n     * HyperFormula.registerLanguage('plPL', plPL);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerLanguage\",\n    value: function registerLanguage(languageCode, languagePackage) {\n      if (this.registeredLanguages.has(languageCode)) {\n        throw new LanguageAlreadyRegisteredError();\n      } else {\n        this.registeredLanguages.set(languageCode, buildTranslationPackage(languagePackage));\n      }\n    }\n    /**\n     * Unregisters language that is registered under given code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     *\n     * @throws [[LanguageNotRegisteredError]] when given language is not registered\n     *\n     * @example\n     * ```js\n     * // register the language for the instance\n     * HyperFormula.registerLanguage('plPL', plPL);\n     *\n     * // unregister plPL\n     * HyperFormula.unregisterLanguage('plPL');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterLanguage\",\n    value: function unregisterLanguage(languageCode) {\n      if (this.registeredLanguages.has(languageCode)) {\n        this.registeredLanguages.delete(languageCode);\n      } else {\n        throw new LanguageNotRegisteredError();\n      }\n    }\n    /**\n     * Returns all registered languages codes.\n     *\n     * @example\n     * ```js\n     * // should return all registered language codes: ['enGB', 'plPL']\n     * const registeredLangugaes = HyperFormula.getRegisteredLanguagesCodes();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getRegisteredLanguagesCodes\",\n    value: function getRegisteredLanguagesCodes() {\n      return Array.from(this.registeredLanguages.keys());\n    }\n    /**\n     * Registers all functions in a given plugin with optional translations\n     *\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     * @param {FunctionTranslationsPackage} translations - optional package of function names translations\n     *\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register the plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerFunctionPlugin\",\n    value: function registerFunctionPlugin(plugin, translations) {\n      FunctionRegistry.registerFunctionPlugin(plugin, translations);\n    }\n    /**\n     * Unregisters all functions defined in given plugin\n     *\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     *\n     * @example\n     * ```js\n     * // get the class of a plugin\n     * const registeredPluginClass = HyperFormula.getFunctionPlugin('EXAMPLE');\n     *\n     * // unregister all functions defined in a plugin of ID 'EXAMPLE'\n     * HyperFormula.unregisterFunctionPlugin(registeredPluginClass);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterFunctionPlugin\",\n    value: function unregisterFunctionPlugin(plugin) {\n      FunctionRegistry.unregisterFunctionPlugin(plugin);\n    }\n    /**\n     * Registers a function with a given id if such exists in a plugin.\n     *\n     * @param {string} functionId - function id, e.g. 'SUMIF'\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     * @param translations\n     *\n     * @throws [[FunctionPluginValidationError]] when function with a given id does not exists in plugin or plugin class definition is not consistent with metadata\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a function\n     * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerFunction\",\n    value: function registerFunction(functionId, plugin, translations) {\n      FunctionRegistry.registerFunction(functionId, plugin, translations);\n    }\n    /**\n     * Unregisters a function with a given id\n     *\n     * @param {string} functionId - function id, e.g. 'SUMIF'\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a function\n     * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);\n     *\n     * // unregister a function\n     * HyperFormula.unregisterFunction('EXAMPLE');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterFunction\",\n    value: function unregisterFunction(functionId) {\n      FunctionRegistry.unregisterFunction(functionId);\n    }\n    /**\n     * Clears function registry\n     *\n     * @example\n     * ```js\n     * HyperFormula.unregisterAllFunctions();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterAllFunctions\",\n    value: function unregisterAllFunctions() {\n      FunctionRegistry.unregisterAll();\n    }\n    /**\n     * Returns translated names of all registered functions for a given language\n     *\n     * @param {string} code - language code\n     *\n     * @example\n     * ```js\n     * // return a list of function names registered for enGB\n     * const allNames = HyperFormula.getRegisteredFunctionNames('enGB');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getRegisteredFunctionNames\",\n    value: function getRegisteredFunctionNames(code) {\n      var functionIds = FunctionRegistry.getRegisteredFunctionIds();\n      var language = this.getLanguage(code);\n      return language.getFunctionTranslations(functionIds);\n    }\n    /**\n     * Returns class of a plugin used by function with given id\n     *\n     * @param {string} functionId - id of a function, e.g. 'SUMIF'\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     *\n     * // return the class of a given plugin\n     * const myFunctionClass = HyperFormula.getFunctionPlugin('EXAMPLE');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getFunctionPlugin\",\n    value: function getFunctionPlugin(functionId) {\n      return FunctionRegistry.getFunctionPlugin(functionId);\n    }\n    /**\n     * Returns classes of all plugins registered in this instance of HyperFormula\n     *\n     * @example\n     * ```js\n     * // return classes of all plugins\n     * const allClasses = HyperFormula.getAllFunctionPlugins();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getAllFunctionPlugins\",\n    value: function getAllFunctionPlugins() {\n      return FunctionRegistry.getPlugins();\n    }\n  }]);\n\n  return HyperFormula;\n}();\n/**\n * Version of the HyperFormula.\n *\n * @category Static Properties\n */\n\nHyperFormula.version = \"0.6.0\";\n/**\n * Latest build date.\n *\n * @category Static Properties\n */\n\nHyperFormula.buildDate = \"27/04/2021 11:27:25\";\n/**\n * A release date.\n *\n * @category Static Properties\n */\n\nHyperFormula.releaseDate = \"27/04/2021\";\n/**\n * Contains all available languages to use in registerLanguage.\n *\n * @category Static Properties\n */\n\nHyperFormula.languages = {};\nHyperFormula.registeredLanguages = new Map();"]},"metadata":{},"sourceType":"module"}