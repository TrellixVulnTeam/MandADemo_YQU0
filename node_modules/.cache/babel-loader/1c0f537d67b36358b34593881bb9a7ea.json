{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { absoluteSheetReference, invalidSimpleRowAddress, simpleRowAddress } from '../Cell';\nimport { ReferenceType } from './ColumnAddress';\nexport var RowAddress = /*#__PURE__*/function () {\n  function RowAddress(type, row, sheet) {\n    _classCallCheck(this, RowAddress);\n\n    this.type = type;\n    this.row = row;\n    this.sheet = sheet;\n  }\n\n  _createClass(RowAddress, [{\n    key: \"isRowAbsolute\",\n    value: function isRowAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE;\n    }\n  }, {\n    key: \"isRowRelative\",\n    value: function isRowRelative() {\n      return this.type === ReferenceType.RELATIVE;\n    }\n  }, {\n    key: \"isAbsolute\",\n    value: function isAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n    }\n  }, {\n    key: \"moved\",\n    value: function moved(toSheet, toRight, toBottom) {\n      var newSheet = this.sheet === undefined ? undefined : toSheet;\n      return new RowAddress(this.type, this.row + toBottom, newSheet);\n    }\n  }, {\n    key: \"shiftedByRows\",\n    value: function shiftedByRows(numberOfColumns) {\n      return new RowAddress(this.type, this.row + numberOfColumns, this.sheet);\n    }\n  }, {\n    key: \"toSimpleRowAddress\",\n    value: function toSimpleRowAddress(baseAddress) {\n      var sheet = absoluteSheetReference(this, baseAddress);\n      var row = this.row;\n\n      if (this.isRowRelative()) {\n        row = baseAddress.row + this.row;\n      }\n\n      return simpleRowAddress(sheet, row);\n    }\n  }, {\n    key: \"shiftRelativeDimensions\",\n    value: function shiftRelativeDimensions(toRight, toBottom) {\n      var row = this.isRowRelative() ? this.row + toBottom : this.row;\n      return new RowAddress(this.type, row, this.sheet);\n    }\n  }, {\n    key: \"shiftAbsoluteDimensions\",\n    value: function shiftAbsoluteDimensions(toRight, toBottom) {\n      var row = this.isRowAbsolute() ? this.row + toBottom : this.row;\n      return new RowAddress(this.type, row, this.sheet);\n    }\n  }, {\n    key: \"withAbsoluteSheet\",\n    value: function withAbsoluteSheet(sheet) {\n      return new RowAddress(this.type, this.row, sheet);\n    }\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid(baseAddress) {\n      return this.toSimpleRowAddress(baseAddress).row < 0;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(withSheet) {\n      var sheetPart = withSheet && this.sheet !== undefined ? \"#\".concat(this.sheet) : '';\n\n      switch (this.type) {\n        case ReferenceType.RELATIVE:\n          {\n            return \"\".concat(sheetPart, \"#ROWR\").concat(this.row);\n          }\n\n        case ReferenceType.ABSOLUTE:\n          {\n            return \"\".concat(sheetPart, \"#ROWA\").concat(this.row);\n          }\n      }\n    }\n  }, {\n    key: \"unparse\",\n    value: function unparse(baseAddress) {\n      var simpleAddress = this.toSimpleRowAddress(baseAddress);\n\n      if (invalidSimpleRowAddress(simpleAddress)) {\n        return undefined;\n      }\n\n      var dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n      return \"\".concat(dollar).concat(simpleAddress.row + 1);\n    }\n  }, {\n    key: \"exceedsSheetSizeLimits\",\n    value: function exceedsSheetSizeLimits(maxRows) {\n      return this.row >= maxRows;\n    }\n  }], [{\n    key: \"absolute\",\n    value: function absolute(row, sheet) {\n      return new RowAddress(ReferenceType.ABSOLUTE, row, sheet);\n    }\n  }, {\n    key: \"relative\",\n    value: function relative(row, sheet) {\n      return new RowAddress(ReferenceType.RELATIVE, row, sheet);\n    }\n  }]);\n\n  return RowAddress;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/RowAddress.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","absoluteSheetReference","invalidSimpleRowAddress","simpleRowAddress","ReferenceType","RowAddress","type","row","sheet","value","isRowAbsolute","ABSOLUTE","isRowRelative","RELATIVE","isAbsolute","undefined","moved","toSheet","toRight","toBottom","newSheet","shiftedByRows","numberOfColumns","toSimpleRowAddress","baseAddress","shiftRelativeDimensions","shiftAbsoluteDimensions","withAbsoluteSheet","isInvalid","hash","withSheet","sheetPart","concat","unparse","simpleAddress","dollar","exceedsSheetSizeLimits","maxRows","absolute","relative"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.concat.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { absoluteSheetReference, invalidSimpleRowAddress, simpleRowAddress } from '../Cell';\nimport { ReferenceType } from './ColumnAddress';\nexport var RowAddress = /*#__PURE__*/function () {\n  function RowAddress(type, row, sheet) {\n    _classCallCheck(this, RowAddress);\n\n    this.type = type;\n    this.row = row;\n    this.sheet = sheet;\n  }\n\n  _createClass(RowAddress, [{\n    key: \"isRowAbsolute\",\n    value: function isRowAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE;\n    }\n  }, {\n    key: \"isRowRelative\",\n    value: function isRowRelative() {\n      return this.type === ReferenceType.RELATIVE;\n    }\n  }, {\n    key: \"isAbsolute\",\n    value: function isAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n    }\n  }, {\n    key: \"moved\",\n    value: function moved(toSheet, toRight, toBottom) {\n      var newSheet = this.sheet === undefined ? undefined : toSheet;\n      return new RowAddress(this.type, this.row + toBottom, newSheet);\n    }\n  }, {\n    key: \"shiftedByRows\",\n    value: function shiftedByRows(numberOfColumns) {\n      return new RowAddress(this.type, this.row + numberOfColumns, this.sheet);\n    }\n  }, {\n    key: \"toSimpleRowAddress\",\n    value: function toSimpleRowAddress(baseAddress) {\n      var sheet = absoluteSheetReference(this, baseAddress);\n      var row = this.row;\n\n      if (this.isRowRelative()) {\n        row = baseAddress.row + this.row;\n      }\n\n      return simpleRowAddress(sheet, row);\n    }\n  }, {\n    key: \"shiftRelativeDimensions\",\n    value: function shiftRelativeDimensions(toRight, toBottom) {\n      var row = this.isRowRelative() ? this.row + toBottom : this.row;\n      return new RowAddress(this.type, row, this.sheet);\n    }\n  }, {\n    key: \"shiftAbsoluteDimensions\",\n    value: function shiftAbsoluteDimensions(toRight, toBottom) {\n      var row = this.isRowAbsolute() ? this.row + toBottom : this.row;\n      return new RowAddress(this.type, row, this.sheet);\n    }\n  }, {\n    key: \"withAbsoluteSheet\",\n    value: function withAbsoluteSheet(sheet) {\n      return new RowAddress(this.type, this.row, sheet);\n    }\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid(baseAddress) {\n      return this.toSimpleRowAddress(baseAddress).row < 0;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(withSheet) {\n      var sheetPart = withSheet && this.sheet !== undefined ? \"#\".concat(this.sheet) : '';\n\n      switch (this.type) {\n        case ReferenceType.RELATIVE:\n          {\n            return \"\".concat(sheetPart, \"#ROWR\").concat(this.row);\n          }\n\n        case ReferenceType.ABSOLUTE:\n          {\n            return \"\".concat(sheetPart, \"#ROWA\").concat(this.row);\n          }\n      }\n    }\n  }, {\n    key: \"unparse\",\n    value: function unparse(baseAddress) {\n      var simpleAddress = this.toSimpleRowAddress(baseAddress);\n\n      if (invalidSimpleRowAddress(simpleAddress)) {\n        return undefined;\n      }\n\n      var dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n      return \"\".concat(dollar).concat(simpleAddress.row + 1);\n    }\n  }, {\n    key: \"exceedsSheetSizeLimits\",\n    value: function exceedsSheetSizeLimits(maxRows) {\n      return this.row >= maxRows;\n    }\n  }], [{\n    key: \"absolute\",\n    value: function absolute(row, sheet) {\n      return new RowAddress(ReferenceType.ABSOLUTE, row, sheet);\n    }\n  }, {\n    key: \"relative\",\n    value: function relative(row, sheet) {\n      return new RowAddress(ReferenceType.RELATIVE, row, sheet);\n    }\n  }]);\n\n  return RowAddress;\n}();"]},"metadata":{},"sourceType":"module"}