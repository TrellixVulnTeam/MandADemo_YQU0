{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { forEach, contains, PRINT_ERROR, PRINT_WARNING, find, isArray, every, values } from \"../utils/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\";\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n\n  try {\n    var ast = getRegExpAst(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n\n      PRINT_ERROR(failedOptimizationPrefixMsg + \"\\n\" + (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") + (\"\\tUsing the regexp-to-ast library version: \" + VERSION + \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n\n  return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n\n      break;\n\n    case \"Alternative\":\n      var terms = ast.value;\n\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i]; // skip terms that cannot effect the first char results\n\n        switch (term.type) {\n          case \"EndAnchor\": // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n\n          case \"GroupBackReference\": // assertions do not affect potential starting codes\n\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n\n        var atom = term;\n\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n\n            forEach(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code; // cannot optimize when ignoreCase is\n\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                } // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  } // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n\n\n                  if (range.to >= minOptimizationVal) {\n                    var minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        } // reached a mandatory production, no more **start** codes can be found on this alternative\n\n\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n\n        if ( // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false || atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n\n      break;\n\n    /* istanbul ignore next */\n\n    default:\n      throw Error(\"non exhaustive match!\");\n  } // console.log(Object.keys(result).length)\n\n\n  return values(result);\n}\n\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\n\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n\n  if (upperChar !== char) {\n    var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n\n    if (lowerChar !== char) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\n\nfunction findCode(setNode, targetCharCodes) {\n  return find(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return contains(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return find(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\n\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true;\n  }\n\n  if (!ast.value) {\n    return false;\n  }\n\n  return isArray(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\n\nvar CharCodeFinder = function (_super) {\n  __extends(CharCodeFinder, _super);\n\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    } // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n\n\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n\n    _super.prototype.visitChildren.call(this, node);\n  };\n\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if (contains(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n\n  return CharCodeFinder;\n}(BaseRegExpVisitor);\n\nexport function canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = getRegExpAst(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return find(pattern, function (char) {\n      return contains(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/scan/reg_exp.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","VERSION","BaseRegExpVisitor","forEach","contains","PRINT_ERROR","PRINT_WARNING","find","isArray","every","values","getRegExpAst","charCodeToOptimizedIndex","minOptimizationVal","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","regExp","ensureOptimizations","ast","firstChars","firstCharOptimizedIndices","value","flags","ignoreCase","e","message","toString","msgSuffix","result","type","i","length","terms","term","atom","addOptimizedIdxToResult","complement","Error","code","range","rangeCode","from","to","minUnOptVal","maxUnOptVal","minOptIdx","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","undefined","atLeast","isWholeOptional","optimizedCharIdx","handleIgnoreCase","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","codeOrRange","range_1","targetCode","CharCodeFinder","_super","_this","call","found","visitChildren","node","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","canMatchCharCode","charCodes","pattern","RegExp","charCodeFinder","visit"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { forEach, contains, PRINT_ERROR, PRINT_WARNING, find, isArray, every, values } from \"../utils/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\";\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\n    try {\n        var ast = getRegExpAst(regExp);\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                PRINT_WARNING(\"\" + failedOptimizationPrefixMsg +\n                    (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            var msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            PRINT_ERROR(failedOptimizationPrefixMsg + \"\\n\" +\n                (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") +\n                (\"\\tUsing the regexp-to-ast library version: \" + VERSION + \"\\n\") +\n                \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (var i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            var terms = ast.value;\n            for (var i = 0; i < terms.length; i++) {\n                var term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                var atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        forEach(atom.value, function (code) {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                var range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (var rangeCode = range.from; rangeCode <= range.to &&\n                                        rangeCode < minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= minOptimizationVal) {\n                                        var minUnOptVal = range.from >= minOptimizationVal\n                                            ? range.from\n                                            : minOptimizationVal;\n                                        var maxUnOptVal = range.to;\n                                        var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                                        var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                var isOptionalQuantifier = atom.quantifier !== undefined &&\n                    atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" &&\n                    isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return values(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    var optimizedCharIdx = charCodeToOptimizedIndex(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    var char = String.fromCharCode(code);\n    var upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        var lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            var optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return find(setNode.value, function (codeOrRange) {\n        if (typeof codeOrRange === \"number\") {\n            return contains(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            var range_1 = codeOrRange;\n            return (find(targetCharCodes, function (targetCode) {\n                return range_1.from <= targetCode && targetCode <= range_1.to;\n            }) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    if (ast.quantifier && ast.quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return isArray(ast.value)\n        ? every(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */ (function (_super) {\n    __extends(CharCodeFinder, _super);\n    function CharCodeFinder(targetCharCodes) {\n        var _this = _super.call(this) || this;\n        _this.targetCharCodes = targetCharCodes;\n        _this.found = false;\n        return _this;\n    }\n    CharCodeFinder.prototype.visitChildren = function (node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        _super.prototype.visitChildren.call(this, node);\n    };\n    CharCodeFinder.prototype.visitCharacter = function (node) {\n        if (contains(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    };\n    CharCodeFinder.prototype.visitSet = function (node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    };\n    return CharCodeFinder;\n}(BaseRegExpVisitor));\nexport function canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        var ast = getRegExpAst(pattern);\n        var charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return (find(pattern, function (char) {\n            return contains(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\n//# sourceMappingURL=reg_exp.js.map"]},"metadata":{},"sourceType":"module"}