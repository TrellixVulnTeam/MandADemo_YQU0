{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { AbsoluteCellRange, isSimpleCellRange } from './AbsoluteCellRange';\nimport { validateArgToType } from './ArgumentSanitization';\nimport { BuildEngineFactory } from './BuildEngineFactory';\nimport { CellType, getCellType as _getCellType, getCellValueDetailedType as _getCellValueDetailedType, getCellValueFormat as _getCellValueFormat, getCellValueType as _getCellValueType, isSimpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { numberToSimpleTime } from './DateTimeHelper';\nimport { objectDestroy } from './Destroy';\nimport { Emitter, Events } from './Emitter';\nimport { EvaluationSuspendedError, ExpectedValueOfTypeError, LanguageAlreadyRegisteredError, LanguageNotRegisteredError, NotAFormulaError, SheetsNotEqual } from './errors';\nimport { buildTranslationPackage } from './i18n';\nimport { FunctionRegistry } from './interpreter/FunctionRegistry';\nimport { normalizeAddedIndexes, normalizeRemovedIndexes } from './Operations';\nimport { AstNodeType, simpleCellAddressFromString as _simpleCellAddressFromString, simpleCellAddressToString as _simpleCellAddressToString, simpleCellRangeFromString as _simpleCellRangeFromString, simpleCellRangeToString as _simpleCellRangeToString } from './parser';\n/**\n * This is a class for creating HyperFormula instance, all the following public methods\n * ale related to this class.\n *\n * The instance can be created only by calling one of the static methods\n * `buildFromArray`, `buildFromSheets` or `buildEmpty` and should be disposed of with the\n * `destroy` method when it's no longer needed to free the resources.\n *\n * The instance can be seen as a workbook where worksheets can be created and\n * manipulated. They are organized within a widely know structure of columns and rows\n * which can be manipulated as well. The smallest possible data unit are the cells, which\n * may contain simple values or formulas to be calculated.\n *\n * All CRUD methods are called directly on HyperFormula instance and will trigger\n * corresponding lifecycle events. The events are marked accordingly, as well as thrown\n * errors so they can be correctly handled.\n */\n\nexport var HyperFormula = /*#__PURE__*/function () {\n  function HyperFormula(_config, _stats, _dependencyGraph, _columnSearch, _parser, _unparser, _cellContentParser, _evaluator, _lazilyTransformingAstService, _crudOperations, _exporter, _namedExpressions, _serialization, _functionRegistry) {\n    _classCallCheck(this, HyperFormula);\n\n    this._config = _config;\n    this._stats = _stats;\n    this._dependencyGraph = _dependencyGraph;\n    this._columnSearch = _columnSearch;\n    this._parser = _parser;\n    this._unparser = _unparser;\n    this._cellContentParser = _cellContentParser;\n    this._evaluator = _evaluator;\n    this._lazilyTransformingAstService = _lazilyTransformingAstService;\n    this._crudOperations = _crudOperations;\n    this._exporter = _exporter;\n    this._namedExpressions = _namedExpressions;\n    this._serialization = _serialization;\n    this._functionRegistry = _functionRegistry;\n    this._emitter = new Emitter();\n    this._evaluationSuspended = false;\n  }\n  /**\n   * Calls the `graph` method on the dependency graph.\n   * Allows to execute `graph` directly without a need to refer to `dependencyGraph`.\n   *\n   * @internal\n   */\n\n\n  _createClass(HyperFormula, [{\n    key: \"graph\",\n    get: function get() {\n      return this.dependencyGraph.graph;\n    }\n    /**\n     * Calls the `rangeMapping` method on the dependency graph.\n     * Allows to execute `rangeMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"rangeMapping\",\n    get: function get() {\n      return this.dependencyGraph.rangeMapping;\n    }\n    /**\n     * Calls the `arrayMapping` method on the dependency graph.\n     * Allows to execute `arrayMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"arrayMapping\",\n    get: function get() {\n      return this.dependencyGraph.arrayMapping;\n    }\n    /**\n     * Calls the `sheetMapping` method on the dependency graph.\n     * Allows to execute `sheetMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"sheetMapping\",\n    get: function get() {\n      return this.dependencyGraph.sheetMapping;\n    }\n    /**\n     * Calls the `addressMapping` method on the dependency graph.\n     * Allows to execute `addressMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"addressMapping\",\n    get: function get() {\n      return this.dependencyGraph.addressMapping;\n    }\n    /** @internal */\n\n  }, {\n    key: \"dependencyGraph\",\n    get: function get() {\n      return this._dependencyGraph;\n    }\n    /** @internal */\n\n  }, {\n    key: \"evaluator\",\n    get: function get() {\n      return this._evaluator;\n    }\n    /** @internal */\n\n  }, {\n    key: \"columnSearch\",\n    get: function get() {\n      return this._columnSearch;\n    }\n    /** @internal */\n\n  }, {\n    key: \"lazilyTransformingAstService\",\n    get: function get() {\n      return this._lazilyTransformingAstService;\n    }\n    /**\n     * Returns state of the validity of the license key.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"licenseKeyValidityState\",\n    get: function get() {\n      return this._config.licenseKeyValidityState;\n    }\n  }, {\n    key: \"getCellValue\",\n    value:\n    /**\n     * Returns the cell value of a given address.\n     * Applies rounding and post-processing.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '2'],\n     * ]);\n     *\n     * // get value of A1 cell, should be '6'\n     * const A1Value = hfInstance.getCellValue({ sheet: 0, col: 0, row: 0 });\n     *\n     * // get value of B1 cell, should be '2'\n     * const B1Value = hfInstance.getCellValue({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n    function getCellValue(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getCellValue(cellAddress);\n    }\n  }, {\n    key: \"ensureEvaluationIsNotSuspended\",\n    value: function ensureEvaluationIsNotSuspended() {\n      if (this._evaluationSuspended) {\n        throw new EvaluationSuspendedError();\n      }\n    }\n    /**\n     * Returns a normalized formula string from the cell of a given address or `undefined` for an address that does not exist and empty values.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '0'],\n     * ]);\n     *\n     * // should return a normalized A1 cell formula: '=SUM(1,2,3)'\n     * const A1Formula = hfInstance.getCellFormula({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return a normalized B1 cell formula: 'undefined'\n     * const B1Formula = hfInstance.getCellFormula({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellFormula\",\n    value: function getCellFormula(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      return this._serialization.getCellFormula(cellAddress);\n    }\n    /**\n     * Returns [[RawCellContent]] with a serialized content of the cell of a given address: either a cell formula, an explicit value, or an error.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '0'],\n     * ]);\n     *\n     * // should return serialized content of A1 cell: '=SUM(1,2,3)'\n     * const cellA1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return serialized content of B1 cell: '0'\n     * const cellB1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellSerialized\",\n    value: function getCellSerialized(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getCellSerialized(cellAddress);\n    }\n    /**\n     * Returns an array of arrays of [[CellValue]] with values of all cells from [[Sheet]].\n     * Applies rounding and post-processing.\n     *\n     * @param {number} sheetId - sheet ID number\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return all values of a sheet: [[0, 6, 0], [1, '1.0%', 0], [2, 6, 0]]\n     * const sheetValues = hfInstance.getSheetValues(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetValues\",\n    value: function getSheetValues(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getSheetValues(sheetId);\n    }\n    /**\n     * Returns an array with normalized formula strings from [[Sheet]] or `undefined` for a cells that have no value.\n     *\n     * @param {SimpleCellAddress} sheetId - sheet ID number\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return all formulas of a sheet:\n     * // [\n     * //  [undefined, '=SUM(1,2,3)', '=A1'],\n     * //  [undefined, '=TEXT(A2, \"0.0%\")', '=C1'],\n     * //  [undefined, '=SUM(A1:C1)', '=C1'],\n     * // ];\n     * const sheetFormulas = hfInstance.getSheetFormulas(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetFormulas\",\n    value: function getSheetFormulas(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return this._serialization.getSheetFormulas(sheetId);\n    }\n    /**\n     * Returns an array of arrays of [[RawCellContent]] with serialized content of cells from [[Sheet]], either a cell formula or an explicit value.\n     *\n     * @param {SimpleCellAddress} sheetId - sheet ID number\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return:\n     * // [\n     * //  ['0', '=SUM(1,2,3)', '=A1'],\n     * //  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     * //  ['2', '=SUM(A1:C1)', '=C1'],\n     * // ];\n     * const serializedContent = hfInstance.getSheetSerialized(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetSerialized\",\n    value: function getSheetSerialized(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getSheetSerialized(sheetId);\n    }\n    /**\n     * Returns a map containing dimensions of all sheets for the engine instance represented as a key-value pairs where keys are sheet IDs and dimensions are returned as numbers, width and height respectively.\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   Sheet1: [\n     *    ['1', '2', '=Sheet2!$A1'],\n     *   ],\n     *   Sheet2: [\n     *    ['3'],\n     *    ['4'],\n     *   ],\n     * });\n     *\n     * // should return the dimensions of all sheets:\n     * // { Sheet1: { width: 3, height: 1 }, Sheet2: { width: 1, height: 2 } }\n     * const allSheetsDimensions = hfInstance.getAllSheetsDimensions();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsDimensions\",\n    value: function getAllSheetsDimensions() {\n      var _this = this;\n\n      return this._serialization.genericAllSheetsGetter(function (arg) {\n        return _this.getSheetDimensions(arg);\n      });\n    }\n    /**\n     * Returns dimensions of a specified sheet.\n     * The sheet dimensions is represented with numbers: width and height.\n     *\n     * @param {number} sheetId - sheet ID number\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *    ['1', '2', '=Sheet2!$A1'],\n     * ]);\n     *\n     * // should return provided sheet's dimensions: { width: 3, height: 1 }\n     * const sheetDimensions = hfInstance.getSheetDimensions(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetDimensions\",\n    value: function getSheetDimensions(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return {\n        width: this.dependencyGraph.getSheetWidth(sheetId),\n        height: this.dependencyGraph.getSheetHeight(sheetId)\n      };\n    }\n    /**\n     * Returns values of all sheets in a form of an object which property keys are strings and values are arrays of arrays of [[CellValue]].\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '=A1+10', '3'],\n     * ]);\n     *\n     * // should return all sheets values: { Sheet1: [ [ 1, 11, 3 ] ] }\n     * const allSheetsValues = hfInstance.getAllSheetsValues();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsValues\",\n    value: function getAllSheetsValues() {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getAllSheetsValues();\n    }\n    /**\n     * Returns formulas of all sheets in a form of an object which property keys are strings and values are arrays of arrays of strings or possibly `undefined` when the call does not contain a formula.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1+10'],\n     * ]);\n     *\n     * // should return only formulas: { Sheet1: [ [ undefined, undefined, '=A1+10' ] ] }\n     * const allSheetsFormulas = hfInstance.getAllSheetsFormulas();\n     * ```\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsFormulas\",\n    value: function getAllSheetsFormulas() {\n      return this._serialization.getAllSheetsFormulas();\n    }\n    /**\n     * Returns formulas or values of all sheets in a form of an object which property keys are strings and values are arrays of arrays of [[RawCellContent]].\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1+10'],\n     * ]);\n     *\n     * // should return all sheets serialized content: { Sheet1: [ [ 1, 2, '=A1+10' ] ] }\n     * const allSheetsSerialized = hfInstance.getAllSheetsSerialized();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsSerialized\",\n    value: function getAllSheetsSerialized() {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getAllSheetsSerialized();\n    }\n    /**\n     * Updates the config with given new metadata.\n     *\n     * @param {Partial<ConfigParams>} newParams configuration options to be updated or added\n     *\n     * @throws [[ExpectedValueOfTypeError]] when some parameters of config are of wrong type (e.g. currencySymbol)\n     * @throws [[ConfigValueEmpty]] when some parameters of config are of invalid value (e.g. currencySymbol)\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // add a config param, for example maxColumns,\n     * // you can check the configuration with getConfig method\n     * hfInstance.updateConfig({ maxColumns: 1000 });\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(newParams) {\n      var newConfig = this._config.mergeConfig(newParams);\n\n      var configNewLanguage = this._config.mergeConfig({\n        language: newParams.language\n      });\n\n      var serializedSheets = this._serialization.withNewConfig(configNewLanguage, this._namedExpressions).getAllSheetsSerialized();\n\n      var serializedNamedExpressions = this._serialization.getAllNamedExpressionsSerialized();\n\n      var newEngine = BuildEngineFactory.rebuildWithConfig(newConfig, serializedSheets, serializedNamedExpressions, this._stats);\n      this._config = newEngine.config;\n      this._stats = newEngine.stats;\n      this._dependencyGraph = newEngine.dependencyGraph;\n      this._columnSearch = newEngine.columnSearch;\n      this._parser = newEngine.parser;\n      this._unparser = newEngine.unparser;\n      this._cellContentParser = newEngine.cellContentParser;\n      this._evaluator = newEngine.evaluator;\n      this._lazilyTransformingAstService = newEngine.lazilyTransformingAstService;\n      this._crudOperations = newEngine.crudOperations;\n      this._exporter = newEngine.exporter;\n      this._namedExpressions = newEngine.namedExpressions;\n      this._serialization = newEngine.serialization;\n      this._functionRegistry = newEngine.functionRegistry;\n    }\n    /**\n     * Returns current configuration of the engine instance.\n     *\n     * @example\n     * ```js\n     * // should return all config metadata including default and those which were added\n     * const hfConfig = hfInstance.getConfig();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this._config.getConfig();\n    }\n    /**\n     * Serializes and deserializes whole engine, effectively reloading it.\n     *\n     * @example\n     * ```js\n     * hfInstance.rebuildAndRecalculate();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"rebuildAndRecalculate\",\n    value: function rebuildAndRecalculate() {\n      this.updateConfig({});\n    }\n    /**\n     * Returns a snapshot of computation time statistics.\n     * It returns a map with key-value pairs where keys are enums for stat type and time (number).\n     *\n     * @internal\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return this._stats.snapshot();\n    }\n    /**\n     * Undo the previous operation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoOperationToUndoError]] when there is no operation running that can be undone\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     *  ['3', ''],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // do an undo, it should return the changes\n     * const changes = hfInstance.undo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      this._crudOperations.undo();\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Re-do recently undone operation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoOperationToRedoError]] when there is no operation running that can be re-done\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     *  ['3'],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // do an undo, it should return prvious values: [['1'], ['2'], ['3']]\n     * hfInstance.undo();\n     *\n     * // do a redo, it should return the values after removing the second row: [['1'], ['3']]\n     * const changes = hfInstance.redo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      this._crudOperations.redo();\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if there is at least one operation that can be undone.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     *  ['3'],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // should return 'true', it is possible to undo last operation\n     * // which is removing rows in this example\n     * const isSomethingToUndo = hfInstance.isThereSomethingToUndo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"isThereSomethingToUndo\",\n    value: function isThereSomethingToUndo() {\n      return this._crudOperations.isThereSomethingToUndo();\n    }\n    /**\n     * Checks if there is at least one operation that can be re-done.\n     *\n     * @example\n     * ```js\n     * hfInstance.undo();\n     *\n     * // when there is an action to redo, this returns 'true'\n     * const isSomethingToRedo = hfInstance.isThereSomethingToRedo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"isThereSomethingToRedo\",\n    value: function isThereSomethingToRedo() {\n      return this._crudOperations.isThereSomethingToRedo();\n    }\n    /**\n     * Returns information whether it is possible to change the content in a rectangular area bounded by the box.\n     * If returns `true`, doing [[setCellContents]] operation won't throw any errors.\n     * Returns `false` if the address is invalid or the sheet does not exist.\n     *\n     * @param {SimpleCellAddress | SimpleCellRange} address - single cell or block of cells to check\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // top left corner\n     * const address1 = { col: 0, row: 0, sheet: 0 };\n     * // bottom right corner\n     * const address2 = { col: 1, row: 0, sheet: 0 };\n     *\n     * // should return 'true' for this example, it is possible to set content of\n     * // width 2, height 1 in the first row and column of sheet 0\n     * const isSettable = hfInstance.isItPossibleToSetCellContents({ start: address1, end: address2 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isItPossibleToSetCellContents\",\n    value: function isItPossibleToSetCellContents(address) {\n      var range;\n\n      if (isSimpleCellAddress(address)) {\n        range = new AbsoluteCellRange(address, address);\n      } else if (isSimpleCellRange(address)) {\n        range = new AbsoluteCellRange(address.start, address.end);\n      } else {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', 'address');\n      }\n\n      try {\n        this._crudOperations.ensureRangeInSizeLimits(range);\n\n        var _iterator = _createForOfIteratorHelper(range.addresses(this._dependencyGraph)),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var it = _step.value;\n\n            this._crudOperations.ensureItIsPossibleToChangeContent(it);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } catch (e) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Sets the content for a block of cells of a given coordinates.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} topLeftCornerAddress - top left corner of block of cells\n     * @param {(RawCellContent[][]|RawCellContent)} cellContents - array with content\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the value is not an array of arrays or a raw cell value\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[ExpectedValueOfTypeError]] if topLeftCornerAddress argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1'],\n     * ]);\n     *\n     * // should set the content, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 3, row: 0 },\n     * //   newValue: 2,\n     * // }]\n     * const changes = hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"setCellContents\",\n    value: function setCellContents(topLeftCornerAddress, cellContents) {\n      this._crudOperations.setCellContents(topLeftCornerAddress, cellContents);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Reorders rows of a sheet according to a source-target mapping.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet\n     * @throws [[SourceLocationHasArrayError]] when the selected position has array inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // should set swap rows 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 2 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 2 },\n     * //   newValue: null,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 5,\n     * // }]\n     * const changes = hfInstance.swapRowIndexes(0, [[0,2],[2,0]]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"swapRowIndexes\",\n    value: function swapRowIndexes(sheetId, rowMapping) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.setRowOrder(sheetId, rowMapping);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if it is possible to reorder rows of a sheet according to a source-target mapping.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // returns true\n     * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0,2],[2,0]]);\n     *\n     * // returns false\n     * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0,1]]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToSwapRowIndexes\",\n    value: function isItPossibleToSwapRowIndexes(sheetId, rowMapping) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);\n\n        this._crudOperations.testRowOrderForArrays(sheetId, rowMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders rows of a sheet according to a permutation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newRowOrder - permutation of rows\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet\n     * @throws [[SourceLocationHasArrayError]] when the selected position has array inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     * // rows 0 and 2 swap places\n     *\n     * // returns:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 2 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 2 },\n     * //   newValue: null,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 5,\n     * // }]\n     * const changes = hfInstance.setRowOrder(0, [2, 1, 0]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"setRowOrder\",\n    value: function setRowOrder(sheetId, newRowOrder) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      var mapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');\n\n      return this.swapRowIndexes(sheetId, mapping);\n    }\n    /**\n     * Checks if it is possible to reorder rows of a sheet according to a permutation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newRowOrder - permutation of rows\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSetRowOrder(0, [2, 1, 0]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSetRowOrder(0, [2]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToSetRowOrder\",\n    value: function isItPossibleToSetRowOrder(sheetId, newRowOrder) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        var rowMapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');\n\n        this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);\n\n        this._crudOperations.testRowOrderForArrays(sheetId, rowMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders columns of a sheet according to a source-target mapping.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} columnMapping - array mapping original positions to final positions of columns\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet\n     * @throws [[SourceLocationHasArrayError]] when the selected position has array inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // should set swap columns 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 2, row: 0 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 2, row: 1 },\n     * //   newValue: 5,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 1 },\n     * //   newValue: null,\n     * // }]\n     * const changes = hfInstance.swapColumnIndexes(0, [[0,2],[2,0]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"swapColumnIndexes\",\n    value: function swapColumnIndexes(sheetId, columnMapping) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.setColumnOrder(sheetId, columnMapping);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if it is possible to reorder columns of a sheet according to a source-target mapping.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0,2],[2,0]]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0,1]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToSwapColumnIndexes\",\n    value: function isItPossibleToSwapColumnIndexes(sheetId, columnMapping) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);\n\n        this._crudOperations.testColumnOrderForArrays(sheetId, columnMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders columns of a sheet according to a permutation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newColumnOrder - permutation of columns\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet\n     * @throws [[SourceLocationHasArrayError]] when the selected position has array inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     * // columns 0 and 2 swap places\n     *\n     * // returns:\n     * // [{\n     * //   address: { sheet: 0, col: 2, row: 0 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 2, row: 1 },\n     * //   newValue: 5,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 1 },\n     * //   newValue: null,\n     * // }]\n     * const changes = hfInstance.setColumnOrder(0, [2, 1, 0]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"setColumnOrder\",\n    value: function setColumnOrder(sheetId, newColumnOrder) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      var mapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');\n\n      return this.swapColumnIndexes(sheetId, mapping);\n    }\n    /**\n     * Checks if it possible to reorder columns of a sheet according to a permutation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newColumnOrder - permutation of columns\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSetColumnOrder(0, [2, 1, 0]]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSetColumnOrder(0, [1]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToSetColumnOrder\",\n    value: function isItPossibleToSetColumnOrder(sheetId, newColumnOrder) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        var columnMapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');\n\n        this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);\n\n        this._crudOperations.testColumnOrderForArrays(sheetId, columnMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Returns information whether it is possible to add rows into a specified position in a given sheet.\n     * Checks against particular rules to ascertain that addRows can be called.\n     * If returns `true`, doing [[addRows]] operation won't throw any errors.\n     * Returns `false` if adding rows would exceed the sheet size limit or given arguments are invalid.\n     *\n     * @param {number} sheetId - sheet ID in which rows will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '3'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add one row in the second row of sheet 0\n     * const isAddable = hfInstance.isItPossibleToAddRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToAddRows\",\n    value: function isItPossibleToAddRows(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len = arguments.length, indexes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        indexes[_key - 1] = arguments[_key];\n      }\n\n      var normalizedIndexes = normalizeAddedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations;\n\n        (_this$_crudOperations = this._crudOperations).ensureItIsPossibleToAddRows.apply(_this$_crudOperations, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds multiple rows into a specified position in a given sheet.\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID in which rows will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.addRows(0, [0, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"addRows\",\n    value: function addRows(sheetId) {\n      var _this$_crudOperations2;\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len2 = arguments.length, indexes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        indexes[_key2 - 1] = arguments[_key2];\n      }\n\n      (_this$_crudOperations2 = this._crudOperations).addRows.apply(_this$_crudOperations2, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove rows from a specified position in a given sheet.\n     * Checks against particular rules to ascertain that removeRows can be called.\n     * If returns `true`, doing [[removeRows]] operation won't throw any errors.\n     * Returns `false` if given arguments are invalid.\n     *\n     * @param {number} sheetId - sheet ID from which rows will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to remove one row from row 1 of sheet 0\n     * const isRemovable = hfInstance.isItPossibleToRemoveRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveRows\",\n    value: function isItPossibleToRemoveRows(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len3 = arguments.length, indexes = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        indexes[_key3 - 1] = arguments[_key3];\n      }\n\n      var normalizedIndexes = normalizeRemovedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations3;\n\n        (_this$_crudOperations3 = this._crudOperations).ensureItIsPossibleToRemoveRows.apply(_this$_crudOperations3, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes multiple rows from a specified position in a given sheet.\n     * Does nothing if rows are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID from which rows will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return: [{ sheet: 0, col: 1, row: 2, value: null }] for this example\n     * const changes = hfInstance.removeRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"removeRows\",\n    value: function removeRows(sheetId) {\n      var _this$_crudOperations4;\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len4 = arguments.length, indexes = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        indexes[_key4 - 1] = arguments[_key4];\n      }\n\n      (_this$_crudOperations4 = this._crudOperations).removeRows.apply(_this$_crudOperations4, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to add columns into a specified position in a given sheet.\n     * Checks against particular rules to ascertain that addColumns can be called.\n     * If returns `true`, doing [[addColumns]] operation won't throw any errors.\n     * Returns `false` if adding columns would exceed the sheet size limit or given arguments are invalid.\n     *\n     * @param {number} sheetId - sheet ID in which columns will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add 1 column in sheet 0, at column 1\n     * const isAddable = hfInstance.isItPossibleToAddColumns(0, [1, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToAddColumns\",\n    value: function isItPossibleToAddColumns(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len5 = arguments.length, indexes = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        indexes[_key5 - 1] = arguments[_key5];\n      }\n\n      var normalizedIndexes = normalizeAddedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations5;\n\n        (_this$_crudOperations5 = this._crudOperations).ensureItIsPossibleToAddColumns.apply(_this$_crudOperations5, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds multiple columns into a specified position in a given sheet.\n     * Does nothing if the columns are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID in which columns will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=RAND()', '42'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 0.92754862796338,\n     * // }]\n     * const changes = hfInstance.addColumns(0, [0, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(sheetId) {\n      var _this$_crudOperations6;\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len6 = arguments.length, indexes = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        indexes[_key6 - 1] = arguments[_key6];\n      }\n\n      (_this$_crudOperations6 = this._crudOperations).addColumns.apply(_this$_crudOperations6, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove columns from a specified position in a given sheet.\n     * Checks against particular rules to ascertain that removeColumns can be called.\n     * If returns `true`, doing [[removeColumns]] operation won't throw any errors.\n     * Returns `false` if given arguments are invalid.\n     *\n     * @param {number} sheetId - sheet ID from which columns will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [column, amount]\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to remove one column, in place of the second column of sheet 0\n     * const isRemovable = hfInstance.isItPossibleToRemoveColumns(0, [1, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveColumns\",\n    value: function isItPossibleToRemoveColumns(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len7 = arguments.length, indexes = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        indexes[_key7 - 1] = arguments[_key7];\n      }\n\n      var normalizedIndexes = normalizeRemovedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations7;\n\n        (_this$_crudOperations7 = this._crudOperations).ensureItIsPossibleToRemoveColumns.apply(_this$_crudOperations7, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes multiple columns from a specified position in a given sheet.\n     * Does nothing if columns are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID from which columns will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount]\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: { error: [CellError], value: '#REF!' },\n     * // }]\n     * const changes = hfInstance.removeColumns(0, [0, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(sheetId) {\n      var _this$_crudOperations8;\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len8 = arguments.length, indexes = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        indexes[_key8 - 1] = arguments[_key8];\n      }\n\n      (_this$_crudOperations8 = this._crudOperations).removeColumns.apply(_this$_crudOperations8, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move cells to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveCells can be called.\n     * If returns `true`, doing [[moveCells]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is an array inside the selected columns, the target location has array or the provided address is invalid.\n     *\n     * @param {SimpleCellRange} source - range for a moved block\n     * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block\n     *\n     * @throws [[ExpectedValueOfTypeError]] if destinationLeftCorner, source, or any of basic type arguments are of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // choose the coordinates and assign them to variables\n     * const source = { sheet: 0, col: 1, row: 0 };\n     * const destination = { sheet: 0, col: 3, row: 0 };\n     *\n     * // should return 'true' for this example\n     * // it is possible to move a block of width 1 and height 1\n     * // from the corner: column 1 and row 0 of sheet 0\n     * // into destination corner: column 3, row 0 of sheet 0\n     * const isMovable = hfInstance.isItPossibleToMoveCells({ start: source, end: source }, destination);\n     * ```\n     * @category Cells\n     */\n\n  }, {\n    key: \"isItPossibleToMoveCells\",\n    value: function isItPossibleToMoveCells(source, destinationLeftCorner) {\n      if (!isSimpleCellAddress(destinationLeftCorner)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'destinationLeftCorner');\n      }\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      try {\n        var range = new AbsoluteCellRange(source.start, source.end);\n\n        this._crudOperations.operations.ensureItIsPossibleToMoveCells(range.start, range.width(), range.height(), destinationLeftCorner);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves the content of a cell block from source to the target location.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellRange} source - range for a moved block\n     * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if destinationLeftCorner or source are of wrong type\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved\n     * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=RAND()', '42'],\n     * ]);\n     *\n     * // choose the coordinates and assign them to variables\n     * const source = { sheet: 0, col: 1, row: 0 };\n     * const destination = { sheet: 0, col: 3, row: 0 };\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 0.93524248002062,\n     * // }]\n     * const changes = hfInstance.moveCells({ start: source, end: source }, destination);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"moveCells\",\n    value: function moveCells(source, destinationLeftCorner) {\n      if (!isSimpleCellAddress(destinationLeftCorner)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'destinationLeftCorner');\n      }\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var range = new AbsoluteCellRange(source.start, source.end);\n\n      this._crudOperations.moveCells(range.start, range.width(), range.height(), destinationLeftCorner);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move a particular number of rows to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveRows can be called.\n     * If returns `true`, doing [[moveRows]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is an array inside the selected rows, the target location has array or the provided address is invalid.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startRow - number of the first row to move\n     * @param {number} numberOfRows - number of rows to move\n     * @param {number} targetRow - row number before which rows will be moved\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to move one row from row 0 into row 2\n     * const isMovable = hfInstance.isItPossibleToMoveRows(0, 0, 1, 2);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToMoveRows\",\n    value: function isItPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(startRow, 'number', 'startRow');\n      validateArgToType(numberOfRows, 'number', 'numberOfRows');\n      validateArgToType(targetRow, 'number', 'targetRow');\n\n      try {\n        this._crudOperations.ensureItIsPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves a particular number of rows to a specified position in a given sheet.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startRow - number of the first row to move\n     * @param {number} numberOfRows - number of rows to move\n     * @param {number} targetRow - row number before which rows will be moved\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved\n     * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.moveRows(0, 0, 1, 2);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(sheetId, startRow, numberOfRows, targetRow) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(startRow, 'number', 'startRow');\n      validateArgToType(numberOfRows, 'number', 'numberOfRows');\n      validateArgToType(targetRow, 'number', 'targetRow');\n\n      this._crudOperations.moveRows(sheetId, startRow, numberOfRows, targetRow);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move a particular number of columns to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveColumns can be called.\n     * If returns `true`, doing [[moveColumns]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is an array inside the selected columns, the target location has array or the provided address is invalid.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startColumn - number of the first column to move\n     * @param {number} numberOfColumns - number of columns to move\n     * @param {number} targetColumn - column number before which columns will be moved\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to move one column from column 1 into column 2 of sheet 0\n     * const isMovable = hfInstance.isItPossibleToMoveColumns(0, 1, 1, 2);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToMoveColumns\",\n    value: function isItPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(startColumn, 'number', 'startColumn');\n      validateArgToType(numberOfColumns, 'number', 'numberOfColumns');\n      validateArgToType(targetColumn, 'number', 'targetColumn');\n\n      try {\n        this._crudOperations.ensureItIsPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves a particular number of columns to a specified position in a given sheet.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startColumn - number of the first column to move\n     * @param {number} numberOfColumns - number of columns to move\n     * @param {number} targetColumn - column number before which columns will be moved\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved\n     * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '3', '=RAND()', '=SUM(A1:C1)'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 0.16210054671639,\n     * //  }, {\n     * //   address: { sheet: 0, col: 4, row: 0 },\n     * //   newValue: 6.16210054671639,\n     * // }]\n     * const changes = hfInstance.moveColumns(0, 1, 1, 2);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"moveColumns\",\n    value: function moveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(startColumn, 'number', 'startColumn');\n      validateArgToType(numberOfColumns, 'number', 'numberOfColumns');\n      validateArgToType(targetColumn, 'number', 'targetColumn');\n\n      this._crudOperations.moveColumns(sheetId, startColumn, numberOfColumns, targetColumn);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Stores a copy of the cell block in internal clipboard for the further paste.\n     * Returns values of cells for use in external clipboard.\n     *\n     * @param {SimpleCellRange} source - rectangle range to copy\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return: [ [ 2 ] ]\n     * const clipboardContent = hfInstance.copy({ start: { sheet: 0, col: 1, row: 0 }, end: { sheet: 0, col: 1, row: 0 } });\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var range = new AbsoluteCellRange(source.start, source.end);\n\n      this._crudOperations.copy(range.start, range.width(), range.height());\n\n      return this.getRangeValues(source);\n    }\n    /**\n     * Stores information of the cell block in internal clipboard for further paste.\n     * Calling [[paste]] right after this method is equivalent to call [[moveCells]].\n     * Almost any CRUD operation called after this method will abort the cut operation.\n     * Returns values of cells for use in external clipboard.\n     *\n     * @param {SimpleCellRange} source - rectangle range to cut\n     *\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return values that were cut: [ [ 1 ] ]\n     * const clipboardContent = hfInstance.cut({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 0, row: 0 } });\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"cut\",\n    value: function cut(source) {\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var range = new AbsoluteCellRange(source.start, source.end);\n\n      this._crudOperations.cut(range.start, range.width(), range.height());\n\n      return this.getRangeValues(source);\n    }\n    /**\n     * When called after [[copy]] it pastes copied values and formulas into a cell block.\n     * When called after [[cut]] it performs [[moveCells]] operation into the cell block.\n     * Does nothing if the clipboard is empty.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} targetLeftCorner - upper left address of the target cell block\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[NothingToPasteError]] when clipboard is empty\n     * @throws [[TargetLocationHasArrayError]] when the selected target area has array inside\n     * @throws [[ExpectedValueOfTypeError]] if targetLeftCorner is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // do a copy, [ [ 2 ] ] was copied\n     * hfInstance.copy({ sheet: 0, col: 0, row: 0 }, 1, 1);\n     *\n     * // do a paste, should return a list of cells which values changed\n     * // after the operation, their absolute addresses and new values\n     * const changes = hfInstance.paste({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"paste\",\n    value: function paste(targetLeftCorner) {\n      if (!isSimpleCellAddress(targetLeftCorner)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'targetLeftCorner');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n\n      this._crudOperations.paste(targetLeftCorner);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether there is something in the clipboard.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // copy desired content\n     * hfInstance.copy({ sheet: 0, col: 1, row: 0 }, 1, 1);\n     *\n     * // returns 'false', there is content in the clipboard\n     * const isClipboardEmpty = hfInstance.isClipboardEmpty();\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"isClipboardEmpty\",\n    value: function isClipboardEmpty() {\n      return this._crudOperations.isClipboardEmpty();\n    }\n    /**\n     * Clears the clipboard content.\n     *\n     * @example\n     * ```js\n     * // clears the clipboard, isClipboardEmpty() should return true if called afterwards\n     * hfInstance.clearClipboard();\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"clearClipboard\",\n    value: function clearClipboard() {\n      this._crudOperations.clearClipboard();\n    }\n    /**\n     * Clears the redo stack in undoRedo history.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   ['1', '2', '3'],\n     * ]);\n     *\n     * // do an operation, for example remove columns\n     * hfInstance.removeColumns(0, [0, 1]);\n     *\n     * // undo the operation\n     * hfInstance.undo();\n     *\n     * // redo the operation\n     * hfInstance.redo();\n     *\n     * // clear the redo stack\n     * hfInstance.clearRedoStack();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"clearRedoStack\",\n    value: function clearRedoStack() {\n      this._crudOperations.undoRedo.clearRedoStack();\n    }\n    /**\n     * Clears the undo stack in undoRedo history.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   ['1', '2', '3'],\n     * ]);\n     *\n     * // do an operation, for example remove columns\n     * hfInstance.removeColumns(0, [0, 1]);\n     *\n     * // undo the operation\n     * hfInstance.undo();\n     *\n     * // clear the undo stack\n     * hfInstance.clearUndoStack();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"clearUndoStack\",\n    value: function clearUndoStack() {\n      this._crudOperations.undoRedo.clearUndoStack();\n    }\n    /**\n     * Returns the cell content of a given range in a [[CellValue]][][] format.\n     *\n     * @param {SimpleCellRange} source - rectangular range\n     *\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     *\n     * // returns calculated cells content: [ [ 3, 2 ], [ 5, 6 ] ]\n     * const rangeValues = hfInstance.getRangeValues({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeValues\",\n    value: function getRangeValues(source) {\n      var _this2 = this;\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var cellRange = new AbsoluteCellRange(source.start, source.end);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this2.getCellValue(address);\n        });\n      });\n    }\n    /**\n     * Returns cell formulas in given range.\n     *\n     * @param {SimpleCellRange} source - rectangular range\n     *\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     * // returns cell formulas of a given range only:\n     * // [ [ '=SUM(1,2)', undefined ], [ undefined, undefined ] ]\n     * const rangeFormulas = hfInstance.getRangeFormulas({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeFormulas\",\n    value: function getRangeFormulas(source) {\n      var _this3 = this;\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var cellRange = new AbsoluteCellRange(source.start, source.end);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this3.getCellFormula(address);\n        });\n      });\n    }\n    /**\n     * Returns serialized cells in given range.\n     *\n     * @param {SimpleCellRange} source - rectangular range\n     *\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     * // should return serialized cell content for the given range:\n     * // [ [ '=SUM(1,2)', 2 ], [ 5, 6 ] ]\n     * const rangeSerialized = hfInstance.getRangeSerialized({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeSerialized\",\n    value: function getRangeSerialized(source) {\n      var _this4 = this;\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var cellRange = new AbsoluteCellRange(source.start, source.end);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this4.getCellSerialized(address);\n        });\n      });\n    }\n    /**\n     * Returns values to fill target range using source range, with properly extending the range using wrap-around heuristic.\n     *\n     * @param {SimpleCellRange} source of data\n     * @param {SimpleCellRange} target range where data is intended to be put\n     * @param {boolean} offsetsFromTarget if true, offsets are computed from target corner, otherwise from source corner\n     *\n     * @throws [[SheetsNotEqual]] if both ranges are not from the same sheet\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] if source or target are of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([[1, '=A1'], ['=$A$1', '2']]);\n     *\n     * // should return [['2', '=$A$1', '2'], ['=A3', 1, '=C3'], ['2', '=$A$1', '2']]\n     * hfInstance.getFillRangeData( {start: {sheet: 0, row: 0, col: 0}}, end: {sheet: 0, row: 1, col: 1}},\n     * {start: {sheet: 0, row: 1, col: 1}, end: {sheet: 0, row: 3, col: 3}});\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getFillRangeData\",\n    value: function getFillRangeData(source, target) {\n      var _this5 = this;\n\n      var offsetsFromTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      if (!isSimpleCellRange(target)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'target');\n      }\n\n      var sourceRange = new AbsoluteCellRange(source.start, source.end);\n      var targetRange = new AbsoluteCellRange(target.start, target.end);\n\n      if (sourceRange.sheet !== targetRange.sheet) {\n        throw new SheetsNotEqual(sourceRange.sheet, targetRange.sheet);\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      return targetRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          var row = ((address.row - (offsetsFromTarget ? target : source).start.row) % sourceRange.height() + sourceRange.height()) % sourceRange.height() + source.start.row;\n          var col = ((address.col - (offsetsFromTarget ? target : source).start.col) % sourceRange.width() + sourceRange.width()) % sourceRange.width() + source.start.col;\n          return _this5._serialization.getCellSerialized({\n            row: row,\n            col: col,\n            sheet: targetRange.sheet\n          }, address);\n        });\n      });\n    }\n    /**\n     * Returns information whether it is possible to add a sheet to the engine.\n     * Checks against particular rules to ascertain that addSheet can be called.\n     * If returns `true`, doing [[addSheet]] operation won't throw any errors and it possible to add sheet with provided name.\n     * Returns `false` if the chosen name is already used.\n     *\n     * @param {string} sheetName - sheet name, case insensitive\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'false' because 'MySheet2' already exists\n     * const isAddable = hfInstance.isItPossibleToAddSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToAddSheet\",\n    value: function isItPossibleToAddSheet(sheetName) {\n      validateArgToType(sheetName, 'string', 'sheetName');\n\n      try {\n        this._crudOperations.ensureItIsPossibleToAddSheet(sheetName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds a new sheet to the HyperFormula instance. Returns given or autogenerated name of a new sheet.\n     *\n     * @param {string} [sheetName] - if not specified, name is autogenerated\n     *\n     * @fires [[sheetAdded]] after the sheet was added\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[SheetNameAlreadyTakenError]] when sheet with a given name already exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'MySheet3'\n     * const nameProvided = hfInstance.addSheet('MySheet3');\n     *\n     * // should return autogenerated 'Sheet4'\n     * // because no name was provided and 3 other ones already exist\n     * const generatedName = hfInstance.addSheet();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName) {\n      if (sheetName !== undefined) {\n        validateArgToType(sheetName, 'string', 'sheetName');\n      }\n\n      var addedSheetName = this._crudOperations.addSheet(sheetName);\n\n      this._emitter.emit(Events.SheetAdded, addedSheetName);\n\n      return addedSheetName;\n    }\n    /**\n     * Returns information whether it is possible to remove sheet for the engine.\n     * Returns `true` if the provided name of a sheet exists and therefore it can be removed, doing [[removeSheet]] operation won't throw any errors.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {number} sheetId - sheet ID.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because sheet with ID 1 exists and is removable\n     * const isRemovable = hfInstance.isItPossibleToRemoveSheet(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveSheet\",\n    value: function isItPossibleToRemoveSheet(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.ensureScopeIdIsValid(sheetId);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes sheet with a specified name.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID.\n     *\n     * @fires [[sheetRemoved]] after the sheet was removed\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: { error: [CellError], value: '#REF!' },\n     * // }]\n     * const changes = hfInstance.removeSheet(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"removeSheet\",\n    value: function removeSheet(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      var displayName = this.sheetMapping.getDisplayName(sheetId);\n\n      this._crudOperations.removeSheet(sheetId);\n\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.SheetRemoved, displayName, changes);\n\n      return changes;\n    }\n    /**\n     * Returns information whether it is possible to clear a specified sheet.\n     * If returns `true`, doing [[clearSheet]] operation won't throw any errors, provided name of a sheet exists and then its content can be cleared.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {number} sheetId - sheet ID.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet2' exists and can be cleared\n     * const isClearable = hfInstance.isItPossibleToClearSheet(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToClearSheet\",\n    value: function isItPossibleToClearSheet(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.ensureScopeIdIsValid(sheetId);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Clears the sheet content. Based on that the method finds the ID of a sheet to be cleared.\n     * Double-checks if the sheet exists.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 0,\n     * // }]\n     * const changes = hfInstance.clearSheet(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"clearSheet\",\n    value: function clearSheet(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.clearSheet(sheetId);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to replace the sheet content.\n     * If returns `true`, doing [[setSheetContent]] operation won't throw any errors, the provided name of a sheet exists and then its content can be replaced.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {number} sheetId - sheet ID.\n     * @param {RawCellContent[][]} values - array of new values\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet1' (sheetId=0) exists\n     * // and the provided content can be placed in this sheet\n     * const isReplaceable = hfInstance.isItPossibleToReplaceSheetContent(0, [['50'], ['60']]);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToReplaceSheetContent\",\n    value: function isItPossibleToReplaceSheetContent(sheetId, values) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.ensureScopeIdIsValid(sheetId);\n\n        this._crudOperations.ensureItIsPossibleToChangeSheetContents(sheetId, values);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Replaces the sheet content with new values.\n     * The new value is to be provided as an array of arrays of [[RawCellContent]].\n     * The method finds sheet ID based on the provided sheet name.\n     *\n     * @param {number} sheetId - sheet ID.\n     * @param {RawCellContent[][]} values - array of new values\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exists\n     * @throws [[InvalidArgumentsError]] when values is not an array of arrays\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.setSheetContent(0, [['50'], ['60']]);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"setSheetContent\",\n    value: function setSheetContent(sheetId, values) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.setSheetContent(sheetId, values);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Computes simple (absolute) address of a cell address based on its string representation.\n     * If sheet name is present in string representation but not present in the engine, returns `undefined`.\n     *\n     * @param {string} cellAddress - string representation of cell address in A1 notation\n     * @param {number} sheetId - context used in case of missing sheet in the first argument\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     * hfInstance.addSheet('Sheet0'); //sheetId = 0\n     *\n     * // returns { sheet: 0, col: 0, row: 0 }\n     * const simpleCellAddress = hfInstance.simpleCellAddressFromString('A1', 0);\n     *\n     * // returns { sheet: 0, col: 0, row: 5 }\n     * const simpleCellAddressTwo = hfInstance.simpleCellAddressFromString('Sheet1!A6');\n     *\n     * // returns { sheet: 0, col: 0, row: 5 }\n     * const simpleCellAddressTwo = hfInstance.simpleCellAddressFromString('Sheet1!$A$6');\n     *\n     * // returns 'undefined', as there's no 'Sheet 2' in the HyperFormula instance\n     * const simpleCellAddressTwo = hfInstance.simpleCellAddressFromString('Sheet2!A6');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellAddressFromString\",\n    value: function simpleCellAddressFromString(cellAddress, sheetId) {\n      validateArgToType(cellAddress, 'string', 'cellAddress');\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return _simpleCellAddressFromString(this.sheetMapping.get, cellAddress, sheetId);\n    }\n    /**\n     * Computes simple (absolute) address of a cell range based on its string representation.\n     * If sheet name is present in string representation but not present in the engine, returns `undefined`.\n     *\n     * @param {string} cellRange - string representation of cell range in A1 notation\n     * @param {number} sheetId - context used in case of missing sheet in the first argument\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     * hfInstance.addSheet('Sheet0'); //sheetId = 0\n     *\n     * // should return { start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 0 } }\n     * const simpleCellAddress = hfInstance.simpleCellRangeFromString('A1:A2', 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellRangeFromString\",\n    value: function simpleCellRangeFromString(cellRange, sheetId) {\n      validateArgToType(cellRange, 'string', 'cellRange');\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return _simpleCellRangeFromString(this.sheetMapping.get, cellRange, sheetId);\n    }\n    /**\n     * Returns string representation of an absolute address in A1 notation or `undefined` if the sheet index is not present in the engine.\n     *\n     * @param {SimpleCellAddress} cellAddress - object representation of an absolute address\n     * @param {number} sheetId - context used in case of missing sheet in the first argument\n     *\n     * @throws [[ExpectedValueOfTypeError]] if its arguments are of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     * hfInstance.addSheet('Sheet0'); //sheetId = 0\n     *\n     * // should return 'B2'\n     * const A1Notation = hfInstance.simpleCellAddressToString({ sheet: 0, col: 1, row: 1 }, 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellAddressToString\",\n    value: function simpleCellAddressToString(cellAddress, sheetId) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return _simpleCellAddressToString(this.sheetMapping.fetchDisplayName, cellAddress, sheetId);\n    }\n    /**\n     * Returns string representation of an absolute range in A1 notation or `undefined` if the sheet index is not present in the engine.\n     *\n     * @param {SimpleCellRange} cellRange - object representation of an absolute range\n     * @param {number} sheetId - context used in case of missing sheet in the first argument\n     *\n     * @throws [[ExpectedValueOfTypeError]] if its arguments are of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     * hfInstance.addSheet('Sheet0'); //sheetId = 0\n     * hfInstance.addSheet('Sheet1'); //sheetId = 1\n     *\n     * // should return 'B2:C2'\n     * const A1Notation = hfInstance.simpleCellRangeToString({ start: { sheet: 0, col: 1, row: 1 }, end: { sheet: 0, col: 2, row: 1 } }, 0);\n     *\n     *  // should return 'Sheet1!B2:C2'\n     * const another = hfInstance.simpleCellRangeToString({ start: { sheet: 1, col: 1, row: 1 }, end: { sheet: 1, col: 2, row: 1 } }, 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellRangeToString\",\n    value: function simpleCellRangeToString(cellRange, sheetId) {\n      if (!isSimpleCellRange(cellRange)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'cellRange');\n      }\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return _simpleCellRangeToString(this.sheetMapping.fetchDisplayName, cellRange, sheetId);\n    }\n    /**\n     * Returns all addresses and ranges whose computation depends on input address or range provided.\n     *\n     * @param {SimpleCellAddress | SimpleCellRange} address - object representation of an absolute address or range of addresses\n     *\n     * @throws [[ExpectedValueOfTypeError]] if address is not [[SimpleCellAddress]] or [[SimpleCellRange]]\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n     *\n     * hfInstance.getCellDependents({ sheet: 0, col: 0, row: 0});\n     * // should return [{ sheet: 0, col: 1, row: 0}, { sheet: 0, col: 2, row: 0}]\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"getCellDependents\",\n    value: function getCellDependents(address) {\n      var vertex;\n\n      if (isSimpleCellAddress(address)) {\n        vertex = this._dependencyGraph.addressMapping.getCell(address);\n      } else if (isSimpleCellRange(address)) {\n        vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);\n      } else {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', address);\n      }\n\n      if (vertex === undefined) {\n        return [];\n      }\n\n      return this._dependencyGraph.getAdjacentNodesAddresses(vertex);\n    }\n    /**\n     * Returns all addresses and ranges necessary for computation of a given address or range.\n     *\n     * @param {SimpleCellAddress | SimpleCellRange} address - object representation of an absolute address or range of addresses\n     *\n     * @throws [[ExpectedValueOfTypeError]] if address is of wrong type\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n     *\n     * hfInstance.getCellPrecedents({ sheet: 0, col: 2, row: 0});\n     * // should return [{ sheet: 0, col: 0, row: 0}, { sheet: 0, col: 1, row: 0}]\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"getCellPrecedents\",\n    value: function getCellPrecedents(address) {\n      var vertex;\n\n      if (isSimpleCellAddress(address)) {\n        vertex = this._dependencyGraph.addressMapping.getCell(address);\n      } else if (isSimpleCellRange(address)) {\n        vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);\n      } else {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', address);\n      }\n\n      if (vertex === undefined) {\n        return [];\n      }\n\n      return this._dependencyGraph.dependencyQueryAddresses(vertex);\n    }\n    /**\n     * Returns a unique sheet name assigned to the sheet of a given ID or `undefined` if the there is no sheet with a given ID.\n     *\n     * @param {number} sheetId - ID of the sheet, for which we want to retrieve name\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'MySheet2' as this sheet is the second one\n     * const sheetName = hfInstance.getSheetName(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetName\",\n    value: function getSheetName(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return this.sheetMapping.getDisplayName(sheetId);\n    }\n    /**\n     * List all sheet names.\n     * Returns an array of sheet names as strings.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return all sheets names: ['MySheet1', 'MySheet2']\n     * const sheetNames = hfInstance.getSheetNames();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetNames\",\n    value: function getSheetNames() {\n      return this.sheetMapping.sheetNames();\n    }\n    /**\n     * Returns a unique sheet ID assigned to the sheet with a given name or `undefined` if the sheet does not exist.\n     *\n     * @param {string} sheetName - name of the sheet, for which we want to retrieve ID, case insensitive.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return '0' because 'MySheet1' is of ID '0'\n     * const sheetID = hfInstance.getSheetId('MySheet1');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetId\",\n    value: function getSheetId(sheetName) {\n      validateArgToType(sheetName, 'string', 'sheetName');\n      return this.sheetMapping.get(sheetName);\n    }\n    /**\n     * Returns `true` whether sheet with a given name exists. The methods accepts sheet name to be checked.\n     *\n     * @param {string} sheetName - name of the sheet, case insensitive.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' since 'MySheet1' exists\n     * const sheetExist = hfInstance.doesSheetExist('MySheet1');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"doesSheetExist\",\n    value: function doesSheetExist(sheetName) {\n      validateArgToType(sheetName, 'string', 'sheetName');\n      return this.sheetMapping.hasSheetWithName(sheetName);\n    }\n    /**\n     * Returns type of a specified cell of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'FORMULA', the cell of given coordinates is of this type\n     * const cellA1Type = hfInstance.getCellType({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'VALUE', the cell of given coordinates is of this type\n     * const cellB1Type = hfInstance.getCellType({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      var vertex = this.dependencyGraph.getCell(cellAddress);\n      return _getCellType(vertex, cellAddress);\n    }\n    /**\n     * Returns `true` if the specified cell contains a simple value.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'true' since the selected cell contains a simple value\n     * const isA1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false' since the selected cell does not contain a simple value\n     * const isB1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"doesCellHaveSimpleValue\",\n    value: function doesCellHaveSimpleValue(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      return this.getCellType(cellAddress) === CellType.VALUE;\n    }\n    /**\n     * Returns `true` if the specified cell contains a formula.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'true' since the A1 cell contains a formula\n     * const A1Formula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false' since the B1 cell does not contain a formula\n     * const B1NoFormula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"doesCellHaveFormula\",\n    value: function doesCellHaveFormula(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      var cellType = this.getCellType(cellAddress);\n      return cellType === CellType.FORMULA || cellType === CellType.ARRAYFORMULA;\n    }\n    /**\n     * Returns`true` if the specified cell is empty.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   [null, '1'],\n     * ]);\n     *\n     * // should return 'true', cell of provided coordinates is empty\n     * const isEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false', cell of provided coordinates is not empty\n     * const isNotEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isCellEmpty\",\n    value: function isCellEmpty(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      return this.getCellType(cellAddress) === CellType.EMPTY;\n    }\n    /**\n     * Returns `true` if a given cell is a part of a array.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *    ['{=TRANSPOSE(B1:B1)}'],\n     * ]);\n     *\n     * // should return 'true', cell of provided coordinates is a part of a array\n     * const isPartOfArray = hfInstance.isCellPartOfArray({ sheet: 0, col: 0, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isCellPartOfArray\",\n    value: function isCellPartOfArray(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      var cellType = this.getCellType(cellAddress);\n      return cellType === CellType.ARRAY || cellType === CellType.ARRAYFORMULA;\n    }\n    /**\n     * Returns type of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '2'],\n     * ]);\n     *\n     * // should return 'NUMBER', cell value type of provided coordinates is a number\n     * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });\n     *\n     * // should return 'NUMBER', cell value type of provided coordinates is a number\n     * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueType\",\n    value: function getCellValueType(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueType(value);\n    }\n    /**\n     * Returns detailed type of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1%', '1$'],\n     * ]);\n     *\n     * // should return 'NUMBER_PERCENT', cell value type of provided coordinates is a number with a format inference percent.\n     * const cellType = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'NUMBER_CURRENCY', cell value type of provided coordinates is a number with a format inference currency.\n     * const cellType = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueDetailedType\",\n    value: function getCellValueDetailedType(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueDetailedType(value);\n    }\n    /**\n     * Returns auxilary format information of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1$', '1'],\n     * ]);\n     *\n     * // should return '$', cell value type of provided coordinates is a number with a format inference currency, parsed as using '$' as currency.\n     * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return undefined, cell value type of provided coordinates is a number with no format information.\n     * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueFormat\",\n    value: function getCellValueFormat(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueFormat(value);\n    }\n    /**\n     * Returns the number of existing sheets.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return the number of sheets which is '1'\n     * const sheetsCount = hfInstance.countSheets();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"countSheets\",\n    value: function countSheets() {\n      return this.sheetMapping.numberOfSheets();\n    }\n    /**\n     * Returns information whether it is possible to rename sheet.\n     * Returns `true` if the sheet with provided id exists and new name is available\n     * Returns `false` if sheet cannot be renamed\n     *\n     * @param {number} sheetId - a sheet number\n     * @param {string} newName - a name of the sheet to be given\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // returns true\n     * hfInstance.isItPossibleToRenameSheet(0, 'MySheet0');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToRenameSheet\",\n    value: function isItPossibleToRenameSheet(sheetId, newName) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(newName, 'string', 'newName');\n\n      try {\n        this._crudOperations.ensureItIsPossibleToRenameSheet(sheetId, newName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Renames a specified sheet.\n     *\n     * @param {number} sheetId - a sheet number\n     * @param {string} newName - a name of the sheet to be given, if is the same as the old one the method does nothing\n     *\n     * @fires [[sheetRenamed]] after the sheet was renamed\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[SheetNameAlreadyTakenError]] when the provided sheet name already exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // renames the sheet 'MySheet1'\n     * hfInstance.renameSheet(0, 'MySheet0');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"renameSheet\",\n    value: function renameSheet(sheetId, newName) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(newName, 'string', 'newName');\n\n      var oldName = this._crudOperations.renameSheet(sheetId, newName);\n\n      if (oldName !== undefined) {\n        this._emitter.emit(Events.SheetRenamed, oldName, newName);\n      }\n    }\n    /**\n     * Runs multiple operations and recomputes formulas at the end.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {() => void} batchOperations\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     * @fires [[evaluationSuspended]] always\n     * @fires [[evaluationResumed]] after the recomputation of necessary values\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // multiple operations in a single callback will trigger evaluation only once\n     * // and only one set of changes is returned as a combined result of all\n     * // the operations that were triggered within the callback\n     * const changes = hfInstance.batch(() => {\n     *  hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     *  hfInstance.setCellContents({ col: 4, row: 0, sheet: 0 }, [['=A1']]);\n     * });\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch(batchOperations) {\n      this.suspendEvaluation();\n\n      this._crudOperations.beginUndoRedoBatchMode();\n\n      try {\n        batchOperations();\n      } catch (e) {\n        this._crudOperations.commitUndoRedoBatchMode();\n\n        this.resumeEvaluation();\n        throw e;\n      }\n\n      this._crudOperations.commitUndoRedoBatchMode();\n\n      return this.resumeEvaluation();\n    }\n    /**\n     * Suspends the dependency graph recalculation.\n     * It allows optimizing the performance.\n     * With this method, multiple CRUD operations can be done without triggering recalculation after every operation.\n     * Suspending evaluation should result in an overall faster calculation compared to recalculating after each operation separately.\n     * To resume the evaluation use [[resumeEvaluation]].\n     *\n     * @fires [[evaluationSuspended]] always\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // similar to batch() but operations are not within a callback,\n     * // one method suspends the recalculation\n     * // the second will resume calculations and return the changes\n     *\n     * // suspend the evaluation with this method\n     * hfInstance.suspendEvaluation();\n     *\n     * // perform operations\n     * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * hfInstance.setSheetContent('MySheet2', [['50'], ['60']]);\n     *\n     * // use resumeEvaluation to resume\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"suspendEvaluation\",\n    value: function suspendEvaluation() {\n      this._evaluationSuspended = true;\n\n      this._emitter.emit(Events.EvaluationSuspended);\n    }\n    /**\n     * Resumes the dependency graph recalculation that was suspended with [[suspendEvaluation]].\n     * It also triggers the recalculation and returns changes that are a result of all batched operations.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     * @fires [[evaluationResumed]] after the recomputation of necessary values\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // similar to batch() but operations are not within a callback,\n     * // one method suspends the recalculation\n     * // the second will resume calculations and return the changes\n     *\n     * // first, suspend the evaluation\n     * hfInstance.suspendEvaluation();\n     *\n     * // perform operations\n     * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * hfInstance.setSheetContent('MySheet2', [['50'], ['60']]);\n     *\n     * // resume the evaluation\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"resumeEvaluation\",\n    value: function resumeEvaluation() {\n      this._evaluationSuspended = false;\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.EvaluationResumed, changes);\n\n      return changes;\n    }\n    /**\n     * Checks if the dependency graph recalculation process is suspended or not.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // suspend the evaluation\n     * hfInstance.suspendEvaluation();\n     *\n     * // between suspendEvaluation() and resumeEvaluation()\n     * // or inside batch() callback it will return 'true', otherwise 'false'\n     * const isEvaluationSuspended = hfInstance.isEvaluationSuspended();\n     *\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"isEvaluationSuspended\",\n    value: function isEvaluationSuspended() {\n      return this._evaluationSuspended;\n    }\n    /**\n     * Returns information whether it is possible to add named expression into a specific scope.\n     * Checks against particular rules to ascertain that addNamedExpression can be called.\n     * If returns `true`, doing [[addNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - a name of the expression to be added\n     * @param {RawCellContent} expression - the expression\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add named expression to global scope\n     * const isAddable = hfInstance.isItPossibleToAddNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToAddNamedExpression\",\n    value: function isItPossibleToAddNamedExpression(expressionName, expression, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      try {\n        this._crudOperations.ensureItIsPossibleToAddNamedExpression(expressionName, expression, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds a specified named expression.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - a name of the expression to be added\n     * @param {RawCellContent} expression - the expression\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     * @param {NamedExpressionOptions?} options - additional metadata related to named expression\n     *\n     * @fires [[namedExpressionAdded]] always, unless [[batch]] mode is used\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NamedExpressionNameIsAlreadyTakenError]] when the named expression name is not available.\n     * @throws [[NamedExpressionNameIsInvalidError]] when the named expression name is not valid\n     * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add own expression, scope limited to 'Sheet1' (sheetId=0), the method should return a list of cells which values\n     * // changed after the operation, their absolute addresses and new values\n     * // for this example:\n     * // [{\n     * //   name: 'prettyName',\n     * //   newValue: 142,\n     * // }]\n     * const changes = hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"addNamedExpression\",\n    value: function addNamedExpression(expressionName, expression, scope, options) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this._crudOperations.addNamedExpression(expressionName, expression, scope, options);\n\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.NamedExpressionAdded, expressionName, changes);\n\n      return changes;\n    }\n    /**\n     * Gets specified named expression value.\n     * Returns a [[CellValue]] or undefined if the given named expression does not exists.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression, only 'Sheet1' (sheetId=0) considered as it is the scope\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // returns the calculated value of a passed named expression, '142' for this example\n     * const myFormula = hfInstance.getNamedExpressionValue('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpressionValue\",\n    value: function getNamedExpressionValue(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n\n      this._crudOperations.ensureScopeIdIsValid(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);\n\n      if (namedExpression) {\n        return this._serialization.getCellValue(namedExpression.address);\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a normalized formula string for given named expression, or `undefined` for a named expression that does not exist or does not hold a formula.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression in 'Sheet1' (sheetId=0)\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     *\n     * // returns a normalized formula string corresponding to the passed name from 'Sheet1' (sheetId=0),\n     * // '=Sheet1!A1+100' for this example\n     * const myFormula = hfInstance.getNamedExpressionFormula('prettyName', 0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpressionFormula\",\n    value: function getNamedExpressionFormula(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this._crudOperations.ensureScopeIdIsValid(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);\n\n      if (namedExpression === undefined) {\n        return undefined;\n      } else {\n        return this._serialization.getCellFormula(namedExpression.address);\n      }\n    }\n    /**\n     * Returns a named expression, or `undefined` for a named expression that does not exist or does not hold a formula.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression in 'Sheet1' (sheetId=0)\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     *\n     * // returns a named expression that corresponds to the passed name from 'Sheet1' (sheetId=0)\n     * // for this example, returns:\n     * // {name: 'prettyName', expression: '=Sheet1!$A$1+100', options: undefined, scope: 0}\n     * const myFormula = hfInstance.getNamedExpression('prettyName', 0);\n     *\n     * // for a named expression that doesn't exist, returns 'undefined':\n     * const myFormulaTwo = hfInstance.getNamedExpression('uglyName', 0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpression\",\n    value: function getNamedExpression(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);\n\n      if (namedExpression === undefined) {\n        return undefined;\n      }\n\n      var expression = this._serialization.getCellFormula(namedExpression.address);\n\n      return {\n        name: expressionName,\n        scope: scope,\n        expression: expression,\n        options: namedExpression.options\n      };\n    }\n    /**\n     * Returns information whether it is possible to change named expression in a specific scope.\n     * Checks against particular rules to ascertain that changeNamedExpression can be called.\n     * If returns `true`, doing [[changeNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {RawCellContent} newExpression - a new expression\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     *\n     * // should return 'true' for this example,\n     * // it is possible to change named expression\n     * const isAddable = hfInstance.isItPossibleToChangeNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToChangeNamedExpression\",\n    value: function isItPossibleToChangeNamedExpression(expressionName, newExpression, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      try {\n        this._crudOperations.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Changes a given named expression to a specified formula.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {RawCellContent} newExpression - a new expression\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     * @param {NamedExpressionOptions?} options - additional metadata related to named expression\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     * @throws [[ArrayFormulasNotSupportedError]] when the named expression formula is an array formula\n     * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression, scope limited to 'Sheet1' (sheetId=0)\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     *\n     * // change the named expression\n     * const changes = hfInstance.changeNamedExpression('prettyName', '=Sheet1!$A$1+200');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"changeNamedExpression\",\n    value: function changeNamedExpression(expressionName, newExpression, scope, options) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this._crudOperations.changeNamedExpressionExpression(expressionName, scope, newExpression, options);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove named expression from a specific scope.\n     * Checks against particular rules to ascertain that removeNamedExpression can be called.\n     * If returns `true`, doing [[removeNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     *\n     * // should return 'true' for this example,\n     * // it is possible to change named expression\n     * const isAddable = hfInstance.isItPossibleToRemoveNamedExpression('prettyName');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveNamedExpression\",\n    value: function isItPossibleToRemoveNamedExpression(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      try {\n        this._crudOperations.isItPossibleToRemoveNamedExpression(expressionName, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes a named expression.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @fires [[namedExpressionRemoved]] after the expression was removed\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     *\n     * // remove the named expression\n     * const changes = hfInstance.removeNamedExpression('prettyName', 0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"removeNamedExpression\",\n    value: function removeNamedExpression(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      var removedNamedExpression = this._crudOperations.removeNamedExpression(expressionName, scope);\n\n      if (removedNamedExpression) {\n        var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n        this._emitter.emit(Events.NamedExpressionRemoved, removedNamedExpression.displayName, changes);\n\n        return changes;\n      } else {\n        return [];\n      }\n    }\n    /**\n     * Lists all named expressions.\n     * Returns an array of expression names defined in a scope, as strings.\n     *\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     *  ['60'],\n     * ]);\n     *\n     * // add two named expressions and one scoped\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * hfInstance.addNamedExpression('anotherPrettyName', '=Sheet1!$A$2+100');\n     * hfInstance.addNamedExpression('alsoPrettyName', '=Sheet1!$A$3+100', 0);\n     *\n     * // list the expressions, should return: ['prettyName', 'anotherPrettyName'] for this example\n     * const listOfExpressions = hfInstance.listNamedExpressions();\n     *\n     *  // list the expressions, should return: ['alsoPrettyName'] for this example\n     * const listOfExpressions = hfInstance.listNamedExpressions(0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"listNamedExpressions\",\n    value: function listNamedExpressions(scope) {\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this._crudOperations.ensureScopeIdIsValid(scope);\n\n      return this._namedExpressions.getAllNamedExpressionsNamesInScope(scope);\n    }\n    /**\n     * Returns all named expressions serialized.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     *  ['60'],\n     * ]);\n     *\n     * // add two named expressions and one scoped\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * hfInstance.addNamedExpression('anotherPrettyName', '=Sheet1!$A$2+100');\n     * hfInstance.addNamedExpression('prettyName3', '=Sheet1!$A$3+100', 0);\n     *\n     * // get all expressions serialized\n     * // should return:\n     * // [\n     * // {name: 'prettyName', expression: '=Sheet1!$A$1+100', options: undefined, scope: undefined},\n     * // {name: 'anotherPrettyName', expression: '=Sheet1!$A$2+100', options: undefined, scope: undefined},\n     * // {name: 'alsoPrettyName', expression: '=Sheet1!$A$3+100', options: undefined, scope: 0}\n     * // ]\n     * const allExpressions = hfInstance.getAllNamedExpressionsSerialized();\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getAllNamedExpressionsSerialized\",\n    value: function getAllNamedExpressionsSerialized() {\n      return this._serialization.getAllNamedExpressionsSerialized();\n    }\n    /**\n     * Parses and then unparses a formula.\n     * Returns a normalized formula (e.g. restores the original capitalization of sheet names, function names, cell addresses, and named expressions).\n     *\n     * @param {string} formulaString - a formula in a proper format - it must start with \"=\"\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NotAFormulaError]] when the provided string is not a valid formula, i.e does not start with \"=\"\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     * ]);\n     *\n     * // returns '=Sheet1!$A$1+10'\n     * const normalizedFormula = hfInstance.normalizeFormula('=SHEET1!$A$1+10');\n     *\n     * // returns '=3*$A$1'\n     * const normalizedFormula = hfInstance.normalizeFormula('=3*$a$1');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"normalizeFormula\",\n    value: function normalizeFormula(formulaString) {\n      validateArgToType(formulaString, 'string', 'formulaString');\n\n      var _this$extractTemporar = this.extractTemporaryFormula(formulaString),\n          ast = _this$extractTemporar.ast,\n          address = _this$extractTemporar.address;\n\n      if (ast === undefined) {\n        throw new NotAFormulaError();\n      }\n\n      return this._unparser.unparse(ast, address);\n    }\n    /**\n     * Calculates fire-and-forget formula, returns the calculated value.\n     *\n     * @param {string} formulaString - A formula in a proper format, starting with `=`.\n     * @param {number} sheetId - The ID of a sheet in context of which the formula gets evaluated.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type arguments is of wrong type.\n     * @throws [[NotAFormulaError]] when the provided string is not a valid formula (i.e. doesn't start with `=`).\n     * @throws [[NoSheetWithIdError]] when the provided `sheetID` doesn't exist.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  Sheet1: [['58']],\n     *  Sheet2: [['1', '2', '3'], ['4', '5', '6']]\n     * });\n     *\n     * // returns the calculated formula's value\n     * // for this example, returns `68`\n     * const calculatedFormula = hfInstance.calculateFormula('=A1+10', 0);\n     *\n     * // for this example, returns [['11', '12', '13'], ['14', '15', '16']]\n     * const calculatedFormula = hfInstance.calculateFormula('=A1:B3+10', 1);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"calculateFormula\",\n    value: function calculateFormula(formulaString, sheetId) {\n      validateArgToType(formulaString, 'string', 'formulaString');\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.ensureScopeIdIsValid(sheetId);\n\n      var _this$extractTemporar2 = this.extractTemporaryFormula(formulaString, sheetId),\n          ast = _this$extractTemporar2.ast,\n          address = _this$extractTemporar2.address,\n          dependencies = _this$extractTemporar2.dependencies;\n\n      if (ast === undefined) {\n        throw new NotAFormulaError();\n      }\n\n      var internalCellValue = this.evaluator.runAndForget(ast, address, dependencies);\n      return this._exporter.exportScalarOrRange(internalCellValue);\n    }\n    /**\n     * Validates the formula.\n     * If the provided string starts with \"=\" and is a parsable formula, the method returns `true`.\n     * The validation is purely grammatical: the method doesn't verify if the formula can be calculated or not.\n     *\n     * @param {string} formulaString -  a formula in a proper format - it must start with \"=\"\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // checks if the given string is a valid formula, should return 'true' for this example\n     * const isFormula = hfInstance.validateFormula('=SUM(1,2)');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"validateFormula\",\n    value: function validateFormula(formulaString) {\n      validateArgToType(formulaString, 'string', 'formulaString');\n\n      var _this$extractTemporar3 = this.extractTemporaryFormula(formulaString),\n          ast = _this$extractTemporar3.ast;\n\n      if (ast === undefined) {\n        return false;\n      }\n\n      if (ast.type === AstNodeType.ERROR && !ast.error) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Returns translated names of all functions registered in this instance of HyperFormula\n     * according to the language set in the configuration\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // return translated names of all functions, assign to a variable\n     * const allNames = hfInstance.getRegisteredFunctionNames();\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getRegisteredFunctionNames\",\n    value: function getRegisteredFunctionNames() {\n      var language = HyperFormula.getLanguage(this._config.language);\n      return language.getFunctionTranslations(this._functionRegistry.getRegisteredFunctionIds());\n    }\n    /**\n     * Returns class of a plugin used by function with given id\n     *\n     * @param {string} functionId - id of a function, e.g. 'SUMIF'\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // register a plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     *\n     * // get the plugin\n     * const myPlugin = hfInstance.getFunctionPlugin('EXAMPLE');\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getFunctionPlugin\",\n    value: function getFunctionPlugin(functionId) {\n      validateArgToType(functionId, 'string', 'functionId');\n      return this._functionRegistry.getFunctionPlugin(functionId);\n    }\n    /**\n     * Returns classes of all plugins registered in this instance of HyperFormula\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // return classes of all plugins registered, assign to a variable\n     * const allNames = hfInstance.getAllFunctionPlugins();\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getAllFunctionPlugins\",\n    value: function getAllFunctionPlugins() {\n      return this._functionRegistry.getPlugins();\n    }\n    /**\n     * Interprets number as a date + time.\n     *\n     * @param {number} inputNumber - number of days since nullDate, should be nonnegative, fractions are interpreted as hours/minutes/seconds.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass the number of days since nullDate\n     * // the method should return formatted date and time, for this example:\n     * // {year: 2020, month: 1, day: 15, hours: 2, minutes: 24, seconds: 0}\n     * const dateTimeFromNumber = hfInstance.numberToDateTime(43845.1);\n     *\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToDateTime\",\n    value: function numberToDateTime(inputNumber) {\n      validateArgToType(inputNumber, 'number', 'val');\n      return this._evaluator.interpreter.dateTimeHelper.numberToSimpleDateTime(inputNumber);\n    }\n    /**\n     * Interprets number as a date.\n     *\n     * @param {number} inputNumber - number of days since nullDate, should be nonnegative, fractions are ignored.\n        * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n        * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass the number of days since nullDate\n     * // the method should return formatted date, for this example:\n     * // {year: 2020, month: 1, day: 15}\n     * const dateFromNumber = hfInstance.numberToDate(43845);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToDate\",\n    value: function numberToDate(inputNumber) {\n      validateArgToType(inputNumber, 'number', 'val');\n      return this._evaluator.interpreter.dateTimeHelper.numberToSimpleDate(inputNumber);\n    }\n    /**\n     * Interprets number as a time (hours/minutes/seconds).\n     *\n     * @param {number} inputNumber - time in 24h units.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass a number to be interpreted as a time\n     * // should return {hours: 26, minutes: 24} for this example\n     * const timeFromNumber = hfInstance.numberToTime(1.1);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToTime\",\n    value: function numberToTime(inputNumber) {\n      validateArgToType(inputNumber, 'number', 'val');\n      return numberToSimpleTime(inputNumber);\n    }\n  }, {\n    key: \"extractTemporaryFormula\",\n    value: function extractTemporaryFormula(formulaString) {\n      var sheetId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var parsedCellContent = this._cellContentParser.parse(formulaString);\n\n      var address = {\n        sheet: sheetId,\n        col: 0,\n        row: 0\n      };\n\n      if (!(parsedCellContent instanceof CellContent.Formula)) {\n        return {\n          address: address,\n          dependencies: []\n        };\n      }\n\n      var _this$_parser$parse = this._parser.parse(parsedCellContent.formula, address),\n          ast = _this$_parser$parse.ast,\n          errors = _this$_parser$parse.errors,\n          dependencies = _this$_parser$parse.dependencies;\n\n      if (errors.length > 0) {\n        return {\n          address: address,\n          dependencies: []\n        };\n      }\n\n      return {\n        ast: ast,\n        address: address,\n        dependencies: dependencies\n      };\n    }\n    /**\n     * Subscribes to an event.\n     * For the list of all available events, see [[Listeners]].\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // subscribe to a 'sheetAdded', pass a simple handler\n     * hfInstance.on('sheetAdded', ( ) => { console.log('foo') });\n     *\n     * // add a sheet to trigger an event,\n     * // console should print 'foo' after each time sheet is added in this example\n     * hfInstance.addSheet('FooBar');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this._emitter.on(event, listener);\n    }\n    /**\n     * Subscribes to an event once.\n     * For the list of all available events, see [[Listeners]].\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // subscribe to a 'sheetAdded', pass a simple handler\n     * hfInstance.once('sheetAdded', ( ) => { console.log('foo') });\n     *\n     * // call addSheet twice,\n     * // console should print 'foo' only once when the sheet is added in this example\n     * hfInstance.addSheet('FooBar');\n     * hfInstance.addSheet('FooBaz');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(event, listener) {\n      this._emitter.once(event, listener);\n    }\n    /**\n     * Unsubscribes from an event or from all events.\n     * For the list of all available events, see [[Listeners]].\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // define a simple function to be called upon emitting an event\n     * const handler = ( ) => { console.log('baz') }\n     *\n     * // subscribe to a 'sheetAdded', pass the handler\n     * hfInstance.on('sheetAdded', handler);\n     *\n     * // add a sheet to trigger an event,\n     * // console should print 'baz' each time a sheet is added\n     * hfInstance.addSheet('FooBar');\n     *\n     * // unsubscribe from a 'sheetAdded'\n     * hfInstance.off('sheetAdded', handler);\n     *\n     * // add a sheet, the console should not print anything\n     * hfInstance.addSheet('FooBaz');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.off(event, listener);\n    }\n    /**\n     * Destroys instance of HyperFormula.\n     *\n     * @example\n     * ```js\n     * // destroys the instance\n     * hfInstance.destroy();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._evaluator.interpreter.destroyGpu();\n\n      objectDestroy(this);\n    }\n    /**\n     * Runs a recomputation starting from recently changed vertices.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     */\n\n  }, {\n    key: \"recomputeIfDependencyGraphNeedsIt\",\n    value: function recomputeIfDependencyGraphNeedsIt() {\n      if (!this._evaluationSuspended) {\n        var changes = this._crudOperations.getAndClearContentChanges();\n\n        var verticesToRecomputeFrom = Array.from(this.dependencyGraph.verticesToRecompute());\n        this.dependencyGraph.clearRecentlyChangedVertices();\n\n        if (verticesToRecomputeFrom.length > 0) {\n          changes.addAll(this.evaluator.partialRun(verticesToRecomputeFrom));\n        }\n\n        var exportedChanges = changes.exportChanges(this._exporter);\n\n        if (!changes.isEmpty()) {\n          this._emitter.emit(Events.ValuesUpdated, exportedChanges);\n        }\n\n        return exportedChanges;\n      } else {\n        return [];\n      }\n    }\n  }], [{\n    key: \"buildFromEngineState\",\n    value: function buildFromEngineState(engine) {\n      return new HyperFormula(engine.config, engine.stats, engine.dependencyGraph, engine.columnSearch, engine.parser, engine.unparser, engine.cellContentParser, engine.evaluator, engine.lazilyTransformingAstService, engine.crudOperations, engine.exporter, engine.namedExpressions, engine.serialization, engine.functionRegistry);\n    }\n    /**\n     * Builds the engine for a sheet from a two-dimensional array representation.\n     * The engine is created with a single sheet.\n     * Can be configured with the optional second parameter that represents a [[ConfigParams]].\n     * If not specified, the engine will be built with the default configuration.\n     *\n     * @param {Sheet} sheet - two-dimensional array representation of sheet\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions\n     *\n     * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits\n     * @throws [[InvalidArgumentsError]] when sheet is not an array of arrays\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     *\n     * @example\n     * ```js\n     * // data represented as an array\n     * const sheetData = [\n     *  ['0', '=SUM(1,2,3)', '52'],\n     *  ['=SUM(A1:C1)', '', '=A1'],\n     *  ['2', '=SUM(A1:C1)', '91'],\n     * ];\n     *\n     * // method with optional config parameter maxColumns\n     * const hfInstance = HyperFormula.buildFromArray(sheetData, { maxColumns: 1000 });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildFromArray\",\n    value: function buildFromArray(sheet) {\n      var configInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var namedExpressions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return this.buildFromEngineState(BuildEngineFactory.buildFromSheet(sheet, configInput, namedExpressions));\n    }\n    /**\n     * Builds the engine from an object containing multiple sheets with names.\n     * The engine is created with one or more sheets.\n     * Can be configured with the optional second parameter that represents a [[ConfigParams]].\n     * If not specified the engine will be built with the default configuration.\n     *\n     * @param {Sheet} sheets - object with sheets definition\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions\n     *\n     * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits\n     * @throws [[InvalidArgumentsError]] when any sheet is not an array of arrays\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     *\n     * @example\n     * ```js\n     * // data represented as an object with sheets: Sheet1 and Sheet2\n     * const sheetData = {\n     *  'Sheet1': [\n     *    ['1', '', '=Sheet2!$A1'],\n     *    ['', '2', '=SUM(1,2,3)'],\n     *    ['=Sheet2!$A2', '2', ''],\n     *   ],\n     *  'Sheet2': [\n     *    ['', '4', '=Sheet1!$B1'],\n     *    ['', '8', '=SUM(9,3,3)'],\n     *    ['=Sheet1!$B1', '2', ''],\n     *   ],\n     * };\n     *\n     * // method with optional config parameter useColumnIndex\n     * const hfInstance = HyperFormula.buildFromSheets(sheetData, { useColumnIndex: true });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildFromSheets\",\n    value: function buildFromSheets(sheets) {\n      var configInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var namedExpressions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return this.buildFromEngineState(BuildEngineFactory.buildFromSheets(sheets, configInput, namedExpressions));\n    }\n    /**\n     * Builds an empty engine instance.\n     * Can be configured with the optional parameter that represents a [[ConfigParams]].\n     * If not specified the engine will be built with the default configuration.\n     *\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions\n     *\n     * @example\n     * ```js\n     * // build with no initial data and with optional config parameter maxColumns\n     * const hfInstance = HyperFormula.buildEmpty({ maxColumns: 1000 });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildEmpty\",\n    value: function buildEmpty() {\n      var configInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var namedExpressions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      return this.buildFromEngineState(BuildEngineFactory.buildEmpty(configInput, namedExpressions));\n    }\n    /**\n     * Returns registered language from its code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[LanguageNotRegisteredError]] when trying to retrieve not registered language\n     *\n     * @example\n     * ```js\n     * // return registered language\n     * const language = HyperFormula.getLanguage('enGB');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getLanguage\",\n    value: function getLanguage(languageCode) {\n      validateArgToType(languageCode, 'string', 'languageCode');\n      var val = this.registeredLanguages.get(languageCode);\n\n      if (val === undefined) {\n        throw new LanguageNotRegisteredError();\n      } else {\n        return val;\n      }\n    }\n    /**\n     * Registers language from under given code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     * @param {RawTranslationPackage} languagePackage - translation package to be registered\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     * @throws [[LanguageAlreadyRegisteredError]] when given language is already registered\n     *\n     * @example\n     * ```js\n     * // return registered language\n     * HyperFormula.registerLanguage('plPL', plPL);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerLanguage\",\n    value: function registerLanguage(languageCode, languagePackage) {\n      validateArgToType(languageCode, 'string', 'languageCode');\n\n      if (this.registeredLanguages.has(languageCode)) {\n        throw new LanguageAlreadyRegisteredError();\n      } else {\n        this.registeredLanguages.set(languageCode, buildTranslationPackage(languagePackage));\n      }\n    }\n    /**\n     * Unregisters language that is registered under given code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[LanguageNotRegisteredError]] when given language is not registered\n     *\n     * @example\n     * ```js\n     * // register the language for the instance\n     * HyperFormula.registerLanguage('plPL', plPL);\n     *\n     * // unregister plPL\n     * HyperFormula.unregisterLanguage('plPL');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterLanguage\",\n    value: function unregisterLanguage(languageCode) {\n      validateArgToType(languageCode, 'string', 'languageCode');\n\n      if (this.registeredLanguages.has(languageCode)) {\n        this.registeredLanguages.delete(languageCode);\n      } else {\n        throw new LanguageNotRegisteredError();\n      }\n    }\n    /**\n     * Returns all registered languages codes.\n     *\n     * @example\n     * ```js\n     * // should return all registered language codes: ['enGB', 'plPL']\n     * const registeredLangugaes = HyperFormula.getRegisteredLanguagesCodes();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getRegisteredLanguagesCodes\",\n    value: function getRegisteredLanguagesCodes() {\n      return Array.from(this.registeredLanguages.keys());\n    }\n    /**\n     * Registers all functions in a given plugin with optional translations\n     *\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     * @param {FunctionTranslationsPackage} translations - optional package of function names translations\n     *\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register the plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerFunctionPlugin\",\n    value: function registerFunctionPlugin(plugin, translations) {\n      FunctionRegistry.registerFunctionPlugin(plugin, translations);\n    }\n    /**\n     * Unregisters all functions defined in given plugin\n     *\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     *\n     * @example\n     * ```js\n     * // get the class of a plugin\n     * const registeredPluginClass = HyperFormula.getFunctionPlugin('EXAMPLE');\n     *\n     * // unregister all functions defined in a plugin of ID 'EXAMPLE'\n     * HyperFormula.unregisterFunctionPlugin(registeredPluginClass);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterFunctionPlugin\",\n    value: function unregisterFunctionPlugin(plugin) {\n      FunctionRegistry.unregisterFunctionPlugin(plugin);\n    }\n    /**\n     * Registers a function with a given id if such exists in a plugin.\n     *\n     * @param {string} functionId - function id, e.g. 'SUMIF'\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     * @param translations\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[FunctionPluginValidationError]] when function with a given id does not exists in plugin or plugin class definition is not consistent with metadata\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a function\n     * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerFunction\",\n    value: function registerFunction(functionId, plugin, translations) {\n      validateArgToType(functionId, 'string', 'functionId');\n      FunctionRegistry.registerFunction(functionId, plugin, translations);\n    }\n    /**\n     * Unregisters a function with a given id\n     *\n     * @param {string} functionId - function id, e.g. 'SUMIF'\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a function\n     * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);\n     *\n     * // unregister a function\n     * HyperFormula.unregisterFunction('EXAMPLE');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterFunction\",\n    value: function unregisterFunction(functionId) {\n      validateArgToType(functionId, 'string', 'functionId');\n      FunctionRegistry.unregisterFunction(functionId);\n    }\n    /**\n     * Clears function registry\n     *\n     * @example\n     * ```js\n     * HyperFormula.unregisterAllFunctions();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterAllFunctions\",\n    value: function unregisterAllFunctions() {\n      FunctionRegistry.unregisterAll();\n    }\n    /**\n     * Returns translated names of all registered functions for a given language\n     *\n     * @param {string} code - language code\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // return a list of function names registered for enGB\n     * const allNames = HyperFormula.getRegisteredFunctionNames('enGB');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getRegisteredFunctionNames\",\n    value: function getRegisteredFunctionNames(code) {\n      validateArgToType(code, 'string', 'code');\n      var functionIds = FunctionRegistry.getRegisteredFunctionIds();\n      var language = this.getLanguage(code);\n      return language.getFunctionTranslations(functionIds);\n    }\n    /**\n     * Returns class of a plugin used by function with given id\n     *\n     * @param {string} functionId - id of a function, e.g. 'SUMIF'\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     *\n     * // return the class of a given plugin\n     * const myFunctionClass = HyperFormula.getFunctionPlugin('EXAMPLE');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getFunctionPlugin\",\n    value: function getFunctionPlugin(functionId) {\n      validateArgToType(functionId, 'string', 'functionId');\n      return FunctionRegistry.getFunctionPlugin(functionId);\n    }\n    /**\n     * Returns classes of all plugins registered in this instance of HyperFormula\n     *\n     * @example\n     * ```js\n     * // return classes of all plugins\n     * const allClasses = HyperFormula.getAllFunctionPlugins();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getAllFunctionPlugins\",\n    value: function getAllFunctionPlugins() {\n      return FunctionRegistry.getPlugins();\n    }\n  }]);\n\n  return HyperFormula;\n}();\n/**\n * Version of the HyperFormula.\n *\n * @category Static Properties\n */\n\nHyperFormula.version = \"1.1.0\";\n/**\n * Latest build date.\n *\n * @category Static Properties\n */\n\nHyperFormula.buildDate = \"12/08/2021 10:43:28\";\n/**\n * A release date.\n *\n * @category Static Properties\n */\n\nHyperFormula.releaseDate = \"12/08/2021\";\n/**\n * Contains all available languages to use in registerLanguage.\n *\n * @category Static Properties\n */\n\nHyperFormula.languages = {};\nHyperFormula.registeredLanguages = new Map();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/HyperFormula.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_createForOfIteratorHelper","o","allowArrayLike","it","length","i","F","s","n","done","value","e","_e","f","normalCompletion","didErr","err","call","step","next","_e2","return","minLen","Object","prototype","toString","slice","constructor","name","test","len","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","AbsoluteCellRange","isSimpleCellRange","validateArgToType","BuildEngineFactory","CellType","getCellType","_getCellType","getCellValueDetailedType","_getCellValueDetailedType","getCellValueFormat","_getCellValueFormat","getCellValueType","_getCellValueType","isSimpleCellAddress","CellContent","numberToSimpleTime","objectDestroy","Emitter","Events","EvaluationSuspendedError","ExpectedValueOfTypeError","LanguageAlreadyRegisteredError","LanguageNotRegisteredError","NotAFormulaError","SheetsNotEqual","buildTranslationPackage","FunctionRegistry","normalizeAddedIndexes","normalizeRemovedIndexes","AstNodeType","simpleCellAddressFromString","_simpleCellAddressFromString","simpleCellAddressToString","_simpleCellAddressToString","simpleCellRangeFromString","_simpleCellRangeFromString","simpleCellRangeToString","_simpleCellRangeToString","HyperFormula","_config","_stats","_dependencyGraph","_columnSearch","_parser","_unparser","_cellContentParser","_evaluator","_lazilyTransformingAstService","_crudOperations","_exporter","_namedExpressions","_serialization","_functionRegistry","_emitter","_evaluationSuspended","get","dependencyGraph","graph","rangeMapping","arrayMapping","sheetMapping","addressMapping","licenseKeyValidityState","getCellValue","cellAddress","ensureEvaluationIsNotSuspended","getCellFormula","getCellSerialized","getSheetValues","sheetId","getSheetFormulas","getSheetSerialized","getAllSheetsDimensions","_this","genericAllSheetsGetter","arg","getSheetDimensions","width","getSheetWidth","height","getSheetHeight","getAllSheetsValues","getAllSheetsFormulas","getAllSheetsSerialized","updateConfig","newParams","newConfig","mergeConfig","configNewLanguage","language","serializedSheets","withNewConfig","serializedNamedExpressions","getAllNamedExpressionsSerialized","newEngine","rebuildWithConfig","config","stats","columnSearch","parser","unparser","cellContentParser","evaluator","lazilyTransformingAstService","crudOperations","exporter","namedExpressions","serialization","functionRegistry","getConfig","rebuildAndRecalculate","getStats","snapshot","undo","recomputeIfDependencyGraphNeedsIt","redo","isThereSomethingToUndo","isThereSomethingToRedo","isItPossibleToSetCellContents","address","range","start","end","ensureRangeInSizeLimits","_iterator","addresses","_step","ensureItIsPossibleToChangeContent","setCellContents","topLeftCornerAddress","cellContents","swapRowIndexes","rowMapping","setRowOrder","isItPossibleToSwapRowIndexes","validateSwapRowIndexes","testRowOrderForArrays","newRowOrder","mapping","mappingFromOrder","isItPossibleToSetRowOrder","swapColumnIndexes","columnMapping","setColumnOrder","isItPossibleToSwapColumnIndexes","validateSwapColumnIndexes","testColumnOrderForArrays","newColumnOrder","isItPossibleToSetColumnOrder","isItPossibleToAddRows","_len","arguments","indexes","_key","normalizedIndexes","_this$_crudOperations","ensureItIsPossibleToAddRows","apply","concat","addRows","_this$_crudOperations2","_len2","_key2","isItPossibleToRemoveRows","_len3","_key3","_this$_crudOperations3","ensureItIsPossibleToRemoveRows","removeRows","_this$_crudOperations4","_len4","_key4","isItPossibleToAddColumns","_len5","_key5","_this$_crudOperations5","ensureItIsPossibleToAddColumns","addColumns","_this$_crudOperations6","_len6","_key6","isItPossibleToRemoveColumns","_len7","_key7","_this$_crudOperations7","ensureItIsPossibleToRemoveColumns","removeColumns","_this$_crudOperations8","_len8","_key8","isItPossibleToMoveCells","source","destinationLeftCorner","operations","ensureItIsPossibleToMoveCells","moveCells","isItPossibleToMoveRows","startRow","numberOfRows","targetRow","ensureItIsPossibleToMoveRows","moveRows","isItPossibleToMoveColumns","startColumn","numberOfColumns","targetColumn","ensureItIsPossibleToMoveColumns","moveColumns","copy","getRangeValues","cut","paste","targetLeftCorner","isClipboardEmpty","clearClipboard","clearRedoStack","undoRedo","clearUndoStack","_this2","cellRange","arrayOfAddressesInRange","map","subarray","getRangeFormulas","_this3","getRangeSerialized","_this4","getFillRangeData","_this5","offsetsFromTarget","undefined","sourceRange","targetRange","sheet","row","col","isItPossibleToAddSheet","sheetName","ensureItIsPossibleToAddSheet","addSheet","addedSheetName","emit","SheetAdded","isItPossibleToRemoveSheet","ensureScopeIdIsValid","removeSheet","displayName","getDisplayName","changes","SheetRemoved","isItPossibleToClearSheet","clearSheet","isItPossibleToReplaceSheetContent","values","ensureItIsPossibleToChangeSheetContents","setSheetContent","fetchDisplayName","getCellDependents","vertex","getCell","getRange","getAdjacentNodesAddresses","getCellPrecedents","dependencyQueryAddresses","getSheetName","getSheetNames","sheetNames","getSheetId","doesSheetExist","hasSheetWithName","doesCellHaveSimpleValue","VALUE","doesCellHaveFormula","cellType","FORMULA","ARRAYFORMULA","isCellEmpty","EMPTY","isCellPartOfArray","ARRAY","countSheets","numberOfSheets","isItPossibleToRenameSheet","newName","ensureItIsPossibleToRenameSheet","renameSheet","oldName","SheetRenamed","batch","batchOperations","suspendEvaluation","beginUndoRedoBatchMode","commitUndoRedoBatchMode","resumeEvaluation","EvaluationSuspended","EvaluationResumed","isEvaluationSuspended","isItPossibleToAddNamedExpression","expressionName","expression","scope","ensureItIsPossibleToAddNamedExpression","addNamedExpression","options","NamedExpressionAdded","getNamedExpressionValue","namedExpression","namedExpressionForScope","getNamedExpressionFormula","getNamedExpression","isItPossibleToChangeNamedExpression","newExpression","ensureItIsPossibleToChangeNamedExpression","changeNamedExpression","changeNamedExpressionExpression","isItPossibleToRemoveNamedExpression","removeNamedExpression","removedNamedExpression","NamedExpressionRemoved","listNamedExpressions","getAllNamedExpressionsNamesInScope","normalizeFormula","formulaString","_this$extractTemporar","extractTemporaryFormula","ast","unparse","calculateFormula","_this$extractTemporar2","dependencies","internalCellValue","runAndForget","exportScalarOrRange","validateFormula","_this$extractTemporar3","type","ERROR","error","getRegisteredFunctionNames","getLanguage","getFunctionTranslations","getRegisteredFunctionIds","getFunctionPlugin","functionId","getAllFunctionPlugins","getPlugins","numberToDateTime","inputNumber","interpreter","dateTimeHelper","numberToSimpleDateTime","numberToDate","numberToSimpleDate","numberToTime","parsedCellContent","parse","Formula","_this$_parser$parse","formula","errors","on","event","listener","once","off","destroy","destroyGpu","getAndClearContentChanges","verticesToRecomputeFrom","verticesToRecompute","clearRecentlyChangedVertices","addAll","partialRun","exportedChanges","exportChanges","isEmpty","ValuesUpdated","buildFromEngineState","engine","buildFromArray","configInput","buildFromSheet","buildFromSheets","sheets","buildEmpty","languageCode","val","registeredLanguages","registerLanguage","languagePackage","has","set","unregisterLanguage","delete","getRegisteredLanguagesCodes","keys","registerFunctionPlugin","plugin","translations","unregisterFunctionPlugin","registerFunction","unregisterFunction","unregisterAllFunctions","unregisterAll","code","functionIds","version","buildDate","releaseDate","languages","Map"],"mappings":"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AL,CAAqBoP,uBAArB;;AAEA,aAAKC,gBAAL;AACA,cAAMzU,CAAN;AACD;;AAED,WAAKoF,eAAL,CAAqBoP,uBAArB;;AAEA,aAAO,KAAKC,gBAAL,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApDK,GAtqGwB,EA4tGxB;AACDzS,IAAAA,GAAG,EAAE,mBADJ;AAEDjC,IAAAA,KAAK,EAAE,SAASuU,iBAAT,GAA6B;AAClC,WAAK5O,oBAAL,GAA4B,IAA5B;;AAEA,WAAKD,QAAL,CAAc4L,IAAd,CAAmB/N,MAAM,CAACoR,mBAA1B;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArCK,GA5tGwB,EAmwGxB;AACD1S,IAAAA,GAAG,EAAE,kBADJ;AAEDjC,IAAAA,KAAK,EAAE,SAAS0U,gBAAT,GAA4B;AACjC,WAAK/O,oBAAL,GAA4B,KAA5B;AACA,UAAIkM,OAAO,GAAG,KAAKtI,iCAAL,EAAd;;AAEA,WAAK7D,QAAL,CAAc4L,IAAd,CAAmB/N,MAAM,CAACqR,iBAA1B,EAA6C/C,OAA7C;;AAEA,aAAOA,OAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GAnwGwB,EAiyGxB;AACD5P,IAAAA,GAAG,EAAE,uBADJ;AAEDjC,IAAAA,KAAK,EAAE,SAAS6U,qBAAT,GAAiC;AACtC,aAAO,KAAKlP,oBAAZ;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","sourcesContent":["import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AbsoluteCellRange, isSimpleCellRange } from './AbsoluteCellRange';\nimport { validateArgToType } from './ArgumentSanitization';\nimport { BuildEngineFactory } from './BuildEngineFactory';\nimport { CellType, getCellType as _getCellType, getCellValueDetailedType as _getCellValueDetailedType, getCellValueFormat as _getCellValueFormat, getCellValueType as _getCellValueType, isSimpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { numberToSimpleTime } from './DateTimeHelper';\nimport { objectDestroy } from './Destroy';\nimport { Emitter, Events } from './Emitter';\nimport { EvaluationSuspendedError, ExpectedValueOfTypeError, LanguageAlreadyRegisteredError, LanguageNotRegisteredError, NotAFormulaError, SheetsNotEqual } from './errors';\nimport { buildTranslationPackage } from './i18n';\nimport { FunctionRegistry } from './interpreter/FunctionRegistry';\nimport { normalizeAddedIndexes, normalizeRemovedIndexes } from './Operations';\nimport { AstNodeType, simpleCellAddressFromString as _simpleCellAddressFromString, simpleCellAddressToString as _simpleCellAddressToString, simpleCellRangeFromString as _simpleCellRangeFromString, simpleCellRangeToString as _simpleCellRangeToString } from './parser';\n/**\n * This is a class for creating HyperFormula instance, all the following public methods\n * ale related to this class.\n *\n * The instance can be created only by calling one of the static methods\n * `buildFromArray`, `buildFromSheets` or `buildEmpty` and should be disposed of with the\n * `destroy` method when it's no longer needed to free the resources.\n *\n * The instance can be seen as a workbook where worksheets can be created and\n * manipulated. They are organized within a widely know structure of columns and rows\n * which can be manipulated as well. The smallest possible data unit are the cells, which\n * may contain simple values or formulas to be calculated.\n *\n * All CRUD methods are called directly on HyperFormula instance and will trigger\n * corresponding lifecycle events. The events are marked accordingly, as well as thrown\n * errors so they can be correctly handled.\n */\n\nexport var HyperFormula = /*#__PURE__*/function () {\n  function HyperFormula(_config, _stats, _dependencyGraph, _columnSearch, _parser, _unparser, _cellContentParser, _evaluator, _lazilyTransformingAstService, _crudOperations, _exporter, _namedExpressions, _serialization, _functionRegistry) {\n    _classCallCheck(this, HyperFormula);\n\n    this._config = _config;\n    this._stats = _stats;\n    this._dependencyGraph = _dependencyGraph;\n    this._columnSearch = _columnSearch;\n    this._parser = _parser;\n    this._unparser = _unparser;\n    this._cellContentParser = _cellContentParser;\n    this._evaluator = _evaluator;\n    this._lazilyTransformingAstService = _lazilyTransformingAstService;\n    this._crudOperations = _crudOperations;\n    this._exporter = _exporter;\n    this._namedExpressions = _namedExpressions;\n    this._serialization = _serialization;\n    this._functionRegistry = _functionRegistry;\n    this._emitter = new Emitter();\n    this._evaluationSuspended = false;\n  }\n  /**\n   * Calls the `graph` method on the dependency graph.\n   * Allows to execute `graph` directly without a need to refer to `dependencyGraph`.\n   *\n   * @internal\n   */\n\n\n  _createClass(HyperFormula, [{\n    key: \"graph\",\n    get: function get() {\n      return this.dependencyGraph.graph;\n    }\n    /**\n     * Calls the `rangeMapping` method on the dependency graph.\n     * Allows to execute `rangeMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"rangeMapping\",\n    get: function get() {\n      return this.dependencyGraph.rangeMapping;\n    }\n    /**\n     * Calls the `arrayMapping` method on the dependency graph.\n     * Allows to execute `arrayMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"arrayMapping\",\n    get: function get() {\n      return this.dependencyGraph.arrayMapping;\n    }\n    /**\n     * Calls the `sheetMapping` method on the dependency graph.\n     * Allows to execute `sheetMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"sheetMapping\",\n    get: function get() {\n      return this.dependencyGraph.sheetMapping;\n    }\n    /**\n     * Calls the `addressMapping` method on the dependency graph.\n     * Allows to execute `addressMapping` directly without a need to refer to `dependencyGraph`.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"addressMapping\",\n    get: function get() {\n      return this.dependencyGraph.addressMapping;\n    }\n    /** @internal */\n\n  }, {\n    key: \"dependencyGraph\",\n    get: function get() {\n      return this._dependencyGraph;\n    }\n    /** @internal */\n\n  }, {\n    key: \"evaluator\",\n    get: function get() {\n      return this._evaluator;\n    }\n    /** @internal */\n\n  }, {\n    key: \"columnSearch\",\n    get: function get() {\n      return this._columnSearch;\n    }\n    /** @internal */\n\n  }, {\n    key: \"lazilyTransformingAstService\",\n    get: function get() {\n      return this._lazilyTransformingAstService;\n    }\n    /**\n     * Returns state of the validity of the license key.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"licenseKeyValidityState\",\n    get: function get() {\n      return this._config.licenseKeyValidityState;\n    }\n  }, {\n    key: \"getCellValue\",\n    value:\n    /**\n     * Returns the cell value of a given address.\n     * Applies rounding and post-processing.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '2'],\n     * ]);\n     *\n     * // get value of A1 cell, should be '6'\n     * const A1Value = hfInstance.getCellValue({ sheet: 0, col: 0, row: 0 });\n     *\n     * // get value of B1 cell, should be '2'\n     * const B1Value = hfInstance.getCellValue({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n    function getCellValue(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getCellValue(cellAddress);\n    }\n  }, {\n    key: \"ensureEvaluationIsNotSuspended\",\n    value: function ensureEvaluationIsNotSuspended() {\n      if (this._evaluationSuspended) {\n        throw new EvaluationSuspendedError();\n      }\n    }\n    /**\n     * Returns a normalized formula string from the cell of a given address or `undefined` for an address that does not exist and empty values.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '0'],\n     * ]);\n     *\n     * // should return a normalized A1 cell formula: '=SUM(1,2,3)'\n     * const A1Formula = hfInstance.getCellFormula({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return a normalized B1 cell formula: 'undefined'\n     * const B1Formula = hfInstance.getCellFormula({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellFormula\",\n    value: function getCellFormula(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      return this._serialization.getCellFormula(cellAddress);\n    }\n    /**\n     * Returns [[RawCellContent]] with a serialized content of the cell of a given address: either a cell formula, an explicit value, or an error.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '0'],\n     * ]);\n     *\n     * // should return serialized content of A1 cell: '=SUM(1,2,3)'\n     * const cellA1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return serialized content of B1 cell: '0'\n     * const cellB1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellSerialized\",\n    value: function getCellSerialized(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getCellSerialized(cellAddress);\n    }\n    /**\n     * Returns an array of arrays of [[CellValue]] with values of all cells from [[Sheet]].\n     * Applies rounding and post-processing.\n     *\n     * @param {number} sheetId - sheet ID number\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return all values of a sheet: [[0, 6, 0], [1, '1.0%', 0], [2, 6, 0]]\n     * const sheetValues = hfInstance.getSheetValues(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetValues\",\n    value: function getSheetValues(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getSheetValues(sheetId);\n    }\n    /**\n     * Returns an array with normalized formula strings from [[Sheet]] or `undefined` for a cells that have no value.\n     *\n     * @param {SimpleCellAddress} sheetId - sheet ID number\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return all formulas of a sheet:\n     * // [\n     * //  [undefined, '=SUM(1,2,3)', '=A1'],\n     * //  [undefined, '=TEXT(A2, \"0.0%\")', '=C1'],\n     * //  [undefined, '=SUM(A1:C1)', '=C1'],\n     * // ];\n     * const sheetFormulas = hfInstance.getSheetFormulas(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetFormulas\",\n    value: function getSheetFormulas(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return this._serialization.getSheetFormulas(sheetId);\n    }\n    /**\n     * Returns an array of arrays of [[RawCellContent]] with serialized content of cells from [[Sheet]], either a cell formula or an explicit value.\n     *\n     * @param {SimpleCellAddress} sheetId - sheet ID number\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     *  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     *  ['2', '=SUM(A1:C1)', '=C1'],\n     * ]);\n     *\n     * // should return:\n     * // [\n     * //  ['0', '=SUM(1,2,3)', '=A1'],\n     * //  ['1', '=TEXT(A2, \"0.0%\")', '=C1'],\n     * //  ['2', '=SUM(A1:C1)', '=C1'],\n     * // ];\n     * const serializedContent = hfInstance.getSheetSerialized(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetSerialized\",\n    value: function getSheetSerialized(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getSheetSerialized(sheetId);\n    }\n    /**\n     * Returns a map containing dimensions of all sheets for the engine instance represented as a key-value pairs where keys are sheet IDs and dimensions are returned as numbers, width and height respectively.\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   Sheet1: [\n     *    ['1', '2', '=Sheet2!$A1'],\n     *   ],\n     *   Sheet2: [\n     *    ['3'],\n     *    ['4'],\n     *   ],\n     * });\n     *\n     * // should return the dimensions of all sheets:\n     * // { Sheet1: { width: 3, height: 1 }, Sheet2: { width: 1, height: 2 } }\n     * const allSheetsDimensions = hfInstance.getAllSheetsDimensions();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsDimensions\",\n    value: function getAllSheetsDimensions() {\n      var _this = this;\n\n      return this._serialization.genericAllSheetsGetter(function (arg) {\n        return _this.getSheetDimensions(arg);\n      });\n    }\n    /**\n     * Returns dimensions of a specified sheet.\n     * The sheet dimensions is represented with numbers: width and height.\n     *\n     * @param {number} sheetId - sheet ID number\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *    ['1', '2', '=Sheet2!$A1'],\n     * ]);\n     *\n     * // should return provided sheet's dimensions: { width: 3, height: 1 }\n     * const sheetDimensions = hfInstance.getSheetDimensions(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetDimensions\",\n    value: function getSheetDimensions(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return {\n        width: this.dependencyGraph.getSheetWidth(sheetId),\n        height: this.dependencyGraph.getSheetHeight(sheetId)\n      };\n    }\n    /**\n     * Returns values of all sheets in a form of an object which property keys are strings and values are arrays of arrays of [[CellValue]].\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '=A1+10', '3'],\n     * ]);\n     *\n     * // should return all sheets values: { Sheet1: [ [ 1, 11, 3 ] ] }\n     * const allSheetsValues = hfInstance.getAllSheetsValues();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsValues\",\n    value: function getAllSheetsValues() {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getAllSheetsValues();\n    }\n    /**\n     * Returns formulas of all sheets in a form of an object which property keys are strings and values are arrays of arrays of strings or possibly `undefined` when the call does not contain a formula.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1+10'],\n     * ]);\n     *\n     * // should return only formulas: { Sheet1: [ [ undefined, undefined, '=A1+10' ] ] }\n     * const allSheetsFormulas = hfInstance.getAllSheetsFormulas();\n     * ```\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsFormulas\",\n    value: function getAllSheetsFormulas() {\n      return this._serialization.getAllSheetsFormulas();\n    }\n    /**\n     * Returns formulas or values of all sheets in a form of an object which property keys are strings and values are arrays of arrays of [[RawCellContent]].\n     *\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1+10'],\n     * ]);\n     *\n     * // should return all sheets serialized content: { Sheet1: [ [ 1, 2, '=A1+10' ] ] }\n     * const allSheetsSerialized = hfInstance.getAllSheetsSerialized();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getAllSheetsSerialized\",\n    value: function getAllSheetsSerialized() {\n      this.ensureEvaluationIsNotSuspended();\n      return this._serialization.getAllSheetsSerialized();\n    }\n    /**\n     * Updates the config with given new metadata.\n     *\n     * @param {Partial<ConfigParams>} newParams configuration options to be updated or added\n     *\n     * @throws [[ExpectedValueOfTypeError]] when some parameters of config are of wrong type (e.g. currencySymbol)\n     * @throws [[ConfigValueEmpty]] when some parameters of config are of invalid value (e.g. currencySymbol)\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // add a config param, for example maxColumns,\n     * // you can check the configuration with getConfig method\n     * hfInstance.updateConfig({ maxColumns: 1000 });\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(newParams) {\n      var newConfig = this._config.mergeConfig(newParams);\n\n      var configNewLanguage = this._config.mergeConfig({\n        language: newParams.language\n      });\n\n      var serializedSheets = this._serialization.withNewConfig(configNewLanguage, this._namedExpressions).getAllSheetsSerialized();\n\n      var serializedNamedExpressions = this._serialization.getAllNamedExpressionsSerialized();\n\n      var newEngine = BuildEngineFactory.rebuildWithConfig(newConfig, serializedSheets, serializedNamedExpressions, this._stats);\n      this._config = newEngine.config;\n      this._stats = newEngine.stats;\n      this._dependencyGraph = newEngine.dependencyGraph;\n      this._columnSearch = newEngine.columnSearch;\n      this._parser = newEngine.parser;\n      this._unparser = newEngine.unparser;\n      this._cellContentParser = newEngine.cellContentParser;\n      this._evaluator = newEngine.evaluator;\n      this._lazilyTransformingAstService = newEngine.lazilyTransformingAstService;\n      this._crudOperations = newEngine.crudOperations;\n      this._exporter = newEngine.exporter;\n      this._namedExpressions = newEngine.namedExpressions;\n      this._serialization = newEngine.serialization;\n      this._functionRegistry = newEngine.functionRegistry;\n    }\n    /**\n     * Returns current configuration of the engine instance.\n     *\n     * @example\n     * ```js\n     * // should return all config metadata including default and those which were added\n     * const hfConfig = hfInstance.getConfig();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this._config.getConfig();\n    }\n    /**\n     * Serializes and deserializes whole engine, effectively reloading it.\n     *\n     * @example\n     * ```js\n     * hfInstance.rebuildAndRecalculate();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"rebuildAndRecalculate\",\n    value: function rebuildAndRecalculate() {\n      this.updateConfig({});\n    }\n    /**\n     * Returns a snapshot of computation time statistics.\n     * It returns a map with key-value pairs where keys are enums for stat type and time (number).\n     *\n     * @internal\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return this._stats.snapshot();\n    }\n    /**\n     * Undo the previous operation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoOperationToUndoError]] when there is no operation running that can be undone\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     *  ['3', ''],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // do an undo, it should return the changes\n     * const changes = hfInstance.undo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      this._crudOperations.undo();\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Re-do recently undone operation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoOperationToRedoError]] when there is no operation running that can be re-done\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     *  ['3'],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // do an undo, it should return prvious values: [['1'], ['2'], ['3']]\n     * hfInstance.undo();\n     *\n     * // do a redo, it should return the values after removing the second row: [['1'], ['3']]\n     * const changes = hfInstance.redo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      this._crudOperations.redo();\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if there is at least one operation that can be undone.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     *  ['3'],\n     * ]);\n     *\n     * // perform CRUD operation, for example remove the second row\n     * hfInstance.removeRows(0, [1, 1]);\n     *\n     * // should return 'true', it is possible to undo last operation\n     * // which is removing rows in this example\n     * const isSomethingToUndo = hfInstance.isThereSomethingToUndo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"isThereSomethingToUndo\",\n    value: function isThereSomethingToUndo() {\n      return this._crudOperations.isThereSomethingToUndo();\n    }\n    /**\n     * Checks if there is at least one operation that can be re-done.\n     *\n     * @example\n     * ```js\n     * hfInstance.undo();\n     *\n     * // when there is an action to redo, this returns 'true'\n     * const isSomethingToRedo = hfInstance.isThereSomethingToRedo();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"isThereSomethingToRedo\",\n    value: function isThereSomethingToRedo() {\n      return this._crudOperations.isThereSomethingToRedo();\n    }\n    /**\n     * Returns information whether it is possible to change the content in a rectangular area bounded by the box.\n     * If returns `true`, doing [[setCellContents]] operation won't throw any errors.\n     * Returns `false` if the address is invalid or the sheet does not exist.\n     *\n     * @param {SimpleCellAddress | SimpleCellRange} address - single cell or block of cells to check\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // top left corner\n     * const address1 = { col: 0, row: 0, sheet: 0 };\n     * // bottom right corner\n     * const address2 = { col: 1, row: 0, sheet: 0 };\n     *\n     * // should return 'true' for this example, it is possible to set content of\n     * // width 2, height 1 in the first row and column of sheet 0\n     * const isSettable = hfInstance.isItPossibleToSetCellContents({ start: address1, end: address2 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isItPossibleToSetCellContents\",\n    value: function isItPossibleToSetCellContents(address) {\n      var range;\n\n      if (isSimpleCellAddress(address)) {\n        range = new AbsoluteCellRange(address, address);\n      } else if (isSimpleCellRange(address)) {\n        range = new AbsoluteCellRange(address.start, address.end);\n      } else {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', 'address');\n      }\n\n      try {\n        this._crudOperations.ensureRangeInSizeLimits(range);\n\n        var _iterator = _createForOfIteratorHelper(range.addresses(this._dependencyGraph)),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var it = _step.value;\n\n            this._crudOperations.ensureItIsPossibleToChangeContent(it);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } catch (e) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Sets the content for a block of cells of a given coordinates.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} topLeftCornerAddress - top left corner of block of cells\n     * @param {(RawCellContent[][]|RawCellContent)} cellContents - array with content\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the value is not an array of arrays or a raw cell value\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[ExpectedValueOfTypeError]] if topLeftCornerAddress argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '=A1'],\n     * ]);\n     *\n     * // should set the content, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 3, row: 0 },\n     * //   newValue: 2,\n     * // }]\n     * const changes = hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"setCellContents\",\n    value: function setCellContents(topLeftCornerAddress, cellContents) {\n      this._crudOperations.setCellContents(topLeftCornerAddress, cellContents);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Reorders rows of a sheet according to a source-target mapping.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet\n     * @throws [[SourceLocationHasArrayError]] when the selected position has array inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // should set swap rows 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 2 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 2 },\n     * //   newValue: null,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 5,\n     * // }]\n     * const changes = hfInstance.swapRowIndexes(0, [[0,2],[2,0]]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"swapRowIndexes\",\n    value: function swapRowIndexes(sheetId, rowMapping) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.setRowOrder(sheetId, rowMapping);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if it is possible to reorder rows of a sheet according to a source-target mapping.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // returns true\n     * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0,2],[2,0]]);\n     *\n     * // returns false\n     * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0,1]]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToSwapRowIndexes\",\n    value: function isItPossibleToSwapRowIndexes(sheetId, rowMapping) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);\n\n        this._crudOperations.testRowOrderForArrays(sheetId, rowMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders rows of a sheet according to a permutation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newRowOrder - permutation of rows\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet\n     * @throws [[SourceLocationHasArrayError]] when the selected position has array inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     * // rows 0 and 2 swap places\n     *\n     * // returns:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 2 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 2 },\n     * //   newValue: null,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 5,\n     * // }]\n     * const changes = hfInstance.setRowOrder(0, [2, 1, 0]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"setRowOrder\",\n    value: function setRowOrder(sheetId, newRowOrder) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      var mapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');\n\n      return this.swapRowIndexes(sheetId, mapping);\n    }\n    /**\n     * Checks if it is possible to reorder rows of a sheet according to a permutation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newRowOrder - permutation of rows\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1],\n     *  [2],\n     *  [4, 5],\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSetRowOrder(0, [2, 1, 0]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSetRowOrder(0, [2]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToSetRowOrder\",\n    value: function isItPossibleToSetRowOrder(sheetId, newRowOrder) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        var rowMapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');\n\n        this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);\n\n        this._crudOperations.testRowOrderForArrays(sheetId, rowMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders columns of a sheet according to a source-target mapping.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {[number, number][]} columnMapping - array mapping original positions to final positions of columns\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet\n     * @throws [[SourceLocationHasArrayError]] when the selected position has array inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // should set swap columns 0 and 2 in place, returns:\n     * // [{\n     * //   address: { sheet: 0, col: 2, row: 0 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 2, row: 1 },\n     * //   newValue: 5,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 1 },\n     * //   newValue: null,\n     * // }]\n     * const changes = hfInstance.swapColumnIndexes(0, [[0,2],[2,0]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"swapColumnIndexes\",\n    value: function swapColumnIndexes(sheetId, columnMapping) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.setColumnOrder(sheetId, columnMapping);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Checks if it is possible to reorder columns of a sheet according to a source-target mapping.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0,2],[2,0]]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0,1]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToSwapColumnIndexes\",\n    value: function isItPossibleToSwapColumnIndexes(sheetId, columnMapping) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);\n\n        this._crudOperations.testColumnOrderForArrays(sheetId, columnMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Reorders columns of a sheet according to a permutation.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newColumnOrder - permutation of columns\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet\n     * @throws [[SourceLocationHasArrayError]] when the selected position has array inside\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     * // columns 0 and 2 swap places\n     *\n     * // returns:\n     * // [{\n     * //   address: { sheet: 0, col: 2, row: 0 },\n     * //   newValue: 1,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 2, row: 1 },\n     * //   newValue: 5,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 4,\n     * // },\n     * // {\n     * //   address: { sheet: 0, col: 0, row: 1 },\n     * //   newValue: null,\n     * // }]\n     * const changes = hfInstance.setColumnOrder(0, [2, 1, 0]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"setColumnOrder\",\n    value: function setColumnOrder(sheetId, newColumnOrder) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      var mapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');\n\n      return this.swapColumnIndexes(sheetId, mapping);\n    }\n    /**\n     * Checks if it possible to reorder columns of a sheet according to a permutation.\n     *\n     * @param {number} sheetId - ID of a sheet to operate on\n     * @param {number[]} newColumnOrder - permutation of columns\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  [1, 2, 4],\n     *  [5]\n     * ]);\n     *\n     * // returns true\n     * hfInstance.isItPossibleToSetColumnOrder(0, [2, 1, 0]]);\n     *\n     * // returns false\n     * hfInstance.isItPossibleToSetColumnOrder(0, [1]]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToSetColumnOrder\",\n    value: function isItPossibleToSetColumnOrder(sheetId, newColumnOrder) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        var columnMapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');\n\n        this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);\n\n        this._crudOperations.testColumnOrderForArrays(sheetId, columnMapping);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Returns information whether it is possible to add rows into a specified position in a given sheet.\n     * Checks against particular rules to ascertain that addRows can be called.\n     * If returns `true`, doing [[addRows]] operation won't throw any errors.\n     * Returns `false` if adding rows would exceed the sheet size limit or given arguments are invalid.\n     *\n     * @param {number} sheetId - sheet ID in which rows will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '3'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add one row in the second row of sheet 0\n     * const isAddable = hfInstance.isItPossibleToAddRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToAddRows\",\n    value: function isItPossibleToAddRows(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len = arguments.length, indexes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        indexes[_key - 1] = arguments[_key];\n      }\n\n      var normalizedIndexes = normalizeAddedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations;\n\n        (_this$_crudOperations = this._crudOperations).ensureItIsPossibleToAddRows.apply(_this$_crudOperations, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds multiple rows into a specified position in a given sheet.\n     * Does nothing if rows are outside of effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID in which rows will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.addRows(0, [0, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"addRows\",\n    value: function addRows(sheetId) {\n      var _this$_crudOperations2;\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len2 = arguments.length, indexes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        indexes[_key2 - 1] = arguments[_key2];\n      }\n\n      (_this$_crudOperations2 = this._crudOperations).addRows.apply(_this$_crudOperations2, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove rows from a specified position in a given sheet.\n     * Checks against particular rules to ascertain that removeRows can be called.\n     * If returns `true`, doing [[removeRows]] operation won't throw any errors.\n     * Returns `false` if given arguments are invalid.\n     *\n     * @param {number} sheetId - sheet ID from which rows will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to remove one row from row 1 of sheet 0\n     * const isRemovable = hfInstance.isItPossibleToRemoveRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveRows\",\n    value: function isItPossibleToRemoveRows(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len3 = arguments.length, indexes = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        indexes[_key3 - 1] = arguments[_key3];\n      }\n\n      var normalizedIndexes = normalizeRemovedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations3;\n\n        (_this$_crudOperations3 = this._crudOperations).ensureItIsPossibleToRemoveRows.apply(_this$_crudOperations3, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes multiple rows from a specified position in a given sheet.\n     * Does nothing if rows are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID from which rows will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return: [{ sheet: 0, col: 1, row: 2, value: null }] for this example\n     * const changes = hfInstance.removeRows(0, [1, 1]);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"removeRows\",\n    value: function removeRows(sheetId) {\n      var _this$_crudOperations4;\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len4 = arguments.length, indexes = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        indexes[_key4 - 1] = arguments[_key4];\n      }\n\n      (_this$_crudOperations4 = this._crudOperations).removeRows.apply(_this$_crudOperations4, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to add columns into a specified position in a given sheet.\n     * Checks against particular rules to ascertain that addColumns can be called.\n     * If returns `true`, doing [[addColumns]] operation won't throw any errors.\n     * Returns `false` if adding columns would exceed the sheet size limit or given arguments are invalid.\n     *\n     * @param {number} sheetId - sheet ID in which columns will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add 1 column in sheet 0, at column 1\n     * const isAddable = hfInstance.isItPossibleToAddColumns(0, [1, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToAddColumns\",\n    value: function isItPossibleToAddColumns(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len5 = arguments.length, indexes = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        indexes[_key5 - 1] = arguments[_key5];\n      }\n\n      var normalizedIndexes = normalizeAddedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations5;\n\n        (_this$_crudOperations5 = this._crudOperations).ensureItIsPossibleToAddColumns.apply(_this$_crudOperations5, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds multiple columns into a specified position in a given sheet.\n     * Does nothing if the columns are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID in which columns will be added\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=RAND()', '42'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 0.92754862796338,\n     * // }]\n     * const changes = hfInstance.addColumns(0, [0, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"addColumns\",\n    value: function addColumns(sheetId) {\n      var _this$_crudOperations6;\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len6 = arguments.length, indexes = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        indexes[_key6 - 1] = arguments[_key6];\n      }\n\n      (_this$_crudOperations6 = this._crudOperations).addColumns.apply(_this$_crudOperations6, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove columns from a specified position in a given sheet.\n     * Checks against particular rules to ascertain that removeColumns can be called.\n     * If returns `true`, doing [[removeColumns]] operation won't throw any errors.\n     * Returns `false` if given arguments are invalid.\n     *\n     * @param {number} sheetId - sheet ID from which columns will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [column, amount]\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to remove one column, in place of the second column of sheet 0\n     * const isRemovable = hfInstance.isItPossibleToRemoveColumns(0, [1, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveColumns\",\n    value: function isItPossibleToRemoveColumns(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len7 = arguments.length, indexes = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        indexes[_key7 - 1] = arguments[_key7];\n      }\n\n      var normalizedIndexes = normalizeRemovedIndexes(indexes);\n\n      try {\n        var _this$_crudOperations7;\n\n        (_this$_crudOperations7 = this._crudOperations).ensureItIsPossibleToRemoveColumns.apply(_this$_crudOperations7, [sheetId].concat(_toConsumableArray(normalizedIndexes)));\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes multiple columns from a specified position in a given sheet.\n     * Does nothing if columns are outside of the effective sheet size.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID from which columns will be removed\n     * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount]\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['0', '=SUM(1,2,3)', '=A1'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: { error: [CellError], value: '#REF!' },\n     * // }]\n     * const changes = hfInstance.removeColumns(0, [0, 1]);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"removeColumns\",\n    value: function removeColumns(sheetId) {\n      var _this$_crudOperations8;\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      for (var _len8 = arguments.length, indexes = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        indexes[_key8 - 1] = arguments[_key8];\n      }\n\n      (_this$_crudOperations8 = this._crudOperations).removeColumns.apply(_this$_crudOperations8, [sheetId].concat(indexes));\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move cells to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveCells can be called.\n     * If returns `true`, doing [[moveCells]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is an array inside the selected columns, the target location has array or the provided address is invalid.\n     *\n     * @param {SimpleCellRange} source - range for a moved block\n     * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block\n     *\n     * @throws [[ExpectedValueOfTypeError]] if destinationLeftCorner, source, or any of basic type arguments are of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // choose the coordinates and assign them to variables\n     * const source = { sheet: 0, col: 1, row: 0 };\n     * const destination = { sheet: 0, col: 3, row: 0 };\n     *\n     * // should return 'true' for this example\n     * // it is possible to move a block of width 1 and height 1\n     * // from the corner: column 1 and row 0 of sheet 0\n     * // into destination corner: column 3, row 0 of sheet 0\n     * const isMovable = hfInstance.isItPossibleToMoveCells({ start: source, end: source }, destination);\n     * ```\n     * @category Cells\n     */\n\n  }, {\n    key: \"isItPossibleToMoveCells\",\n    value: function isItPossibleToMoveCells(source, destinationLeftCorner) {\n      if (!isSimpleCellAddress(destinationLeftCorner)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'destinationLeftCorner');\n      }\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      try {\n        var range = new AbsoluteCellRange(source.start, source.end);\n\n        this._crudOperations.operations.ensureItIsPossibleToMoveCells(range.start, range.width(), range.height(), destinationLeftCorner);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves the content of a cell block from source to the target location.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellRange} source - range for a moved block\n     * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if destinationLeftCorner or source are of wrong type\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved\n     * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=RAND()', '42'],\n     * ]);\n     *\n     * // choose the coordinates and assign them to variables\n     * const source = { sheet: 0, col: 1, row: 0 };\n     * const destination = { sheet: 0, col: 3, row: 0 };\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 0.93524248002062,\n     * // }]\n     * const changes = hfInstance.moveCells({ start: source, end: source }, destination);\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"moveCells\",\n    value: function moveCells(source, destinationLeftCorner) {\n      if (!isSimpleCellAddress(destinationLeftCorner)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'destinationLeftCorner');\n      }\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var range = new AbsoluteCellRange(source.start, source.end);\n\n      this._crudOperations.moveCells(range.start, range.width(), range.height(), destinationLeftCorner);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move a particular number of rows to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveRows can be called.\n     * If returns `true`, doing [[moveRows]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is an array inside the selected rows, the target location has array or the provided address is invalid.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startRow - number of the first row to move\n     * @param {number} numberOfRows - number of rows to move\n     * @param {number} targetRow - row number before which rows will be moved\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to move one row from row 0 into row 2\n     * const isMovable = hfInstance.isItPossibleToMoveRows(0, 0, 1, 2);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"isItPossibleToMoveRows\",\n    value: function isItPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(startRow, 'number', 'startRow');\n      validateArgToType(numberOfRows, 'number', 'numberOfRows');\n      validateArgToType(targetRow, 'number', 'targetRow');\n\n      try {\n        this._crudOperations.ensureItIsPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves a particular number of rows to a specified position in a given sheet.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startRow - number of the first row to move\n     * @param {number} numberOfRows - number of rows to move\n     * @param {number} targetRow - row number before which rows will be moved\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved\n     * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1'],\n     *  ['2'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.moveRows(0, 0, 1, 2);\n     * ```\n     *\n     * @category Rows\n     */\n\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(sheetId, startRow, numberOfRows, targetRow) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(startRow, 'number', 'startRow');\n      validateArgToType(numberOfRows, 'number', 'numberOfRows');\n      validateArgToType(targetRow, 'number', 'targetRow');\n\n      this._crudOperations.moveRows(sheetId, startRow, numberOfRows, targetRow);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to move a particular number of columns to a specified position in a given sheet.\n     * Checks against particular rules to ascertain that moveColumns can be called.\n     * If returns `true`, doing [[moveColumns]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted and causes side-effects by the fact that there is an array inside the selected columns, the target location has array or the provided address is invalid.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startColumn - number of the first column to move\n     * @param {number} numberOfColumns - number of columns to move\n     * @param {number} targetColumn - column number before which columns will be moved\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return 'true' for this example\n     * // it is possible to move one column from column 1 into column 2 of sheet 0\n     * const isMovable = hfInstance.isItPossibleToMoveColumns(0, 1, 1, 2);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"isItPossibleToMoveColumns\",\n    value: function isItPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(startColumn, 'number', 'startColumn');\n      validateArgToType(numberOfColumns, 'number', 'numberOfColumns');\n      validateArgToType(targetColumn, 'number', 'targetColumn');\n\n      try {\n        this._crudOperations.ensureItIsPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Moves a particular number of columns to a specified position in a given sheet.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - a sheet number in which the operation will be performed\n     * @param {number} startColumn - number of the first column to move\n     * @param {number} numberOfColumns - number of columns to move\n     * @param {number} targetColumn - column number before which columns will be moved\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[InvalidArgumentsError]] when the given arguments are invalid\n     * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved\n     * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2', '3', '=RAND()', '=SUM(A1:C1)'],\n     * ]);\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, for this example:\n     * // [{\n     * //   address: { sheet: 0, col: 1, row: 0 },\n     * //   newValue: 0.16210054671639,\n     * //  }, {\n     * //   address: { sheet: 0, col: 4, row: 0 },\n     * //   newValue: 6.16210054671639,\n     * // }]\n     * const changes = hfInstance.moveColumns(0, 1, 1, 2);\n     * ```\n     *\n     * @category Columns\n     */\n\n  }, {\n    key: \"moveColumns\",\n    value: function moveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(startColumn, 'number', 'startColumn');\n      validateArgToType(numberOfColumns, 'number', 'numberOfColumns');\n      validateArgToType(targetColumn, 'number', 'targetColumn');\n\n      this._crudOperations.moveColumns(sheetId, startColumn, numberOfColumns, targetColumn);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Stores a copy of the cell block in internal clipboard for the further paste.\n     * Returns values of cells for use in external clipboard.\n     *\n     * @param {SimpleCellRange} source - rectangle range to copy\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return: [ [ 2 ] ]\n     * const clipboardContent = hfInstance.copy({ start: { sheet: 0, col: 1, row: 0 }, end: { sheet: 0, col: 1, row: 0 } });\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var range = new AbsoluteCellRange(source.start, source.end);\n\n      this._crudOperations.copy(range.start, range.width(), range.height());\n\n      return this.getRangeValues(source);\n    }\n    /**\n     * Stores information of the cell block in internal clipboard for further paste.\n     * Calling [[paste]] right after this method is equivalent to call [[moveCells]].\n     * Almost any CRUD operation called after this method will abort the cut operation.\n     * Returns values of cells for use in external clipboard.\n     *\n     * @param {SimpleCellRange} source - rectangle range to cut\n     *\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return values that were cut: [ [ 1 ] ]\n     * const clipboardContent = hfInstance.cut({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 0, row: 0 } });\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"cut\",\n    value: function cut(source) {\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var range = new AbsoluteCellRange(source.start, source.end);\n\n      this._crudOperations.cut(range.start, range.width(), range.height());\n\n      return this.getRangeValues(source);\n    }\n    /**\n     * When called after [[copy]] it pastes copied values and formulas into a cell block.\n     * When called after [[cut]] it performs [[moveCells]] operation into the cell block.\n     * Does nothing if the clipboard is empty.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {SimpleCellAddress} targetLeftCorner - upper left address of the target cell block\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding\n     * @throws [[NothingToPasteError]] when clipboard is empty\n     * @throws [[TargetLocationHasArrayError]] when the selected target area has array inside\n     * @throws [[ExpectedValueOfTypeError]] if targetLeftCorner is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // do a copy, [ [ 2 ] ] was copied\n     * hfInstance.copy({ sheet: 0, col: 0, row: 0 }, 1, 1);\n     *\n     * // do a paste, should return a list of cells which values changed\n     * // after the operation, their absolute addresses and new values\n     * const changes = hfInstance.paste({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"paste\",\n    value: function paste(targetLeftCorner) {\n      if (!isSimpleCellAddress(targetLeftCorner)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'targetLeftCorner');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n\n      this._crudOperations.paste(targetLeftCorner);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether there is something in the clipboard.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // copy desired content\n     * hfInstance.copy({ sheet: 0, col: 1, row: 0 }, 1, 1);\n     *\n     * // returns 'false', there is content in the clipboard\n     * const isClipboardEmpty = hfInstance.isClipboardEmpty();\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"isClipboardEmpty\",\n    value: function isClipboardEmpty() {\n      return this._crudOperations.isClipboardEmpty();\n    }\n    /**\n     * Clears the clipboard content.\n     *\n     * @example\n     * ```js\n     * // clears the clipboard, isClipboardEmpty() should return true if called afterwards\n     * hfInstance.clearClipboard();\n     * ```\n     *\n     * @category Clipboard\n     */\n\n  }, {\n    key: \"clearClipboard\",\n    value: function clearClipboard() {\n      this._crudOperations.clearClipboard();\n    }\n    /**\n     * Clears the redo stack in undoRedo history.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   ['1', '2', '3'],\n     * ]);\n     *\n     * // do an operation, for example remove columns\n     * hfInstance.removeColumns(0, [0, 1]);\n     *\n     * // undo the operation\n     * hfInstance.undo();\n     *\n     * // redo the operation\n     * hfInstance.redo();\n     *\n     * // clear the redo stack\n     * hfInstance.clearRedoStack();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"clearRedoStack\",\n    value: function clearRedoStack() {\n      this._crudOperations.undoRedo.clearRedoStack();\n    }\n    /**\n     * Clears the undo stack in undoRedo history.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   ['1', '2', '3'],\n     * ]);\n     *\n     * // do an operation, for example remove columns\n     * hfInstance.removeColumns(0, [0, 1]);\n     *\n     * // undo the operation\n     * hfInstance.undo();\n     *\n     * // clear the undo stack\n     * hfInstance.clearUndoStack();\n     * ```\n     *\n     * @category Undo and Redo\n     */\n\n  }, {\n    key: \"clearUndoStack\",\n    value: function clearUndoStack() {\n      this._crudOperations.undoRedo.clearUndoStack();\n    }\n    /**\n     * Returns the cell content of a given range in a [[CellValue]][][] format.\n     *\n     * @param {SimpleCellRange} source - rectangular range\n     *\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     *\n     * // returns calculated cells content: [ [ 3, 2 ], [ 5, 6 ] ]\n     * const rangeValues = hfInstance.getRangeValues({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeValues\",\n    value: function getRangeValues(source) {\n      var _this2 = this;\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var cellRange = new AbsoluteCellRange(source.start, source.end);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this2.getCellValue(address);\n        });\n      });\n    }\n    /**\n     * Returns cell formulas in given range.\n     *\n     * @param {SimpleCellRange} source - rectangular range\n     *\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     * // returns cell formulas of a given range only:\n     * // [ [ '=SUM(1,2)', undefined ], [ undefined, undefined ] ]\n     * const rangeFormulas = hfInstance.getRangeFormulas({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeFormulas\",\n    value: function getRangeFormulas(source) {\n      var _this3 = this;\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var cellRange = new AbsoluteCellRange(source.start, source.end);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this3.getCellFormula(address);\n        });\n      });\n    }\n    /**\n     * Returns serialized cells in given range.\n     *\n     * @param {SimpleCellRange} source - rectangular range\n     *\n     * @throws [[ExpectedValueOfTypeError]] if source is of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2)', '2', '10'],\n     *  ['5', '6', '7'],\n     *  ['40', '30', '20'],\n     * ]);\n     *\n     * // should return serialized cell content for the given range:\n     * // [ [ '=SUM(1,2)', 2 ], [ 5, 6 ] ]\n     * const rangeSerialized = hfInstance.getRangeSerialized({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getRangeSerialized\",\n    value: function getRangeSerialized(source) {\n      var _this4 = this;\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      var cellRange = new AbsoluteCellRange(source.start, source.end);\n      return cellRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          return _this4.getCellSerialized(address);\n        });\n      });\n    }\n    /**\n     * Returns values to fill target range using source range, with properly extending the range using wrap-around heuristic.\n     *\n     * @param {SimpleCellRange} source of data\n     * @param {SimpleCellRange} target range where data is intended to be put\n     * @param {boolean} offsetsFromTarget if true, offsets are computed from target corner, otherwise from source corner\n     *\n     * @throws [[SheetsNotEqual]] if both ranges are not from the same sheet\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] if source or target are of wrong type\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([[1, '=A1'], ['=$A$1', '2']]);\n     *\n     * // should return [['2', '=$A$1', '2'], ['=A3', 1, '=C3'], ['2', '=$A$1', '2']]\n     * hfInstance.getFillRangeData( {start: {sheet: 0, row: 0, col: 0}}, end: {sheet: 0, row: 1, col: 1}},\n     * {start: {sheet: 0, row: 1, col: 1}, end: {sheet: 0, row: 3, col: 3}});\n     * ```\n     *\n     * @category Ranges\n     */\n\n  }, {\n    key: \"getFillRangeData\",\n    value: function getFillRangeData(source, target) {\n      var _this5 = this;\n\n      var offsetsFromTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (!isSimpleCellRange(source)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'source');\n      }\n\n      if (!isSimpleCellRange(target)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'target');\n      }\n\n      var sourceRange = new AbsoluteCellRange(source.start, source.end);\n      var targetRange = new AbsoluteCellRange(target.start, target.end);\n\n      if (sourceRange.sheet !== targetRange.sheet) {\n        throw new SheetsNotEqual(sourceRange.sheet, targetRange.sheet);\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      return targetRange.arrayOfAddressesInRange().map(function (subarray) {\n        return subarray.map(function (address) {\n          var row = ((address.row - (offsetsFromTarget ? target : source).start.row) % sourceRange.height() + sourceRange.height()) % sourceRange.height() + source.start.row;\n          var col = ((address.col - (offsetsFromTarget ? target : source).start.col) % sourceRange.width() + sourceRange.width()) % sourceRange.width() + source.start.col;\n          return _this5._serialization.getCellSerialized({\n            row: row,\n            col: col,\n            sheet: targetRange.sheet\n          }, address);\n        });\n      });\n    }\n    /**\n     * Returns information whether it is possible to add a sheet to the engine.\n     * Checks against particular rules to ascertain that addSheet can be called.\n     * If returns `true`, doing [[addSheet]] operation won't throw any errors and it possible to add sheet with provided name.\n     * Returns `false` if the chosen name is already used.\n     *\n     * @param {string} sheetName - sheet name, case insensitive\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'false' because 'MySheet2' already exists\n     * const isAddable = hfInstance.isItPossibleToAddSheet('MySheet2');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToAddSheet\",\n    value: function isItPossibleToAddSheet(sheetName) {\n      validateArgToType(sheetName, 'string', 'sheetName');\n\n      try {\n        this._crudOperations.ensureItIsPossibleToAddSheet(sheetName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds a new sheet to the HyperFormula instance. Returns given or autogenerated name of a new sheet.\n     *\n     * @param {string} [sheetName] - if not specified, name is autogenerated\n     *\n     * @fires [[sheetAdded]] after the sheet was added\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[SheetNameAlreadyTakenError]] when sheet with a given name already exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'MySheet3'\n     * const nameProvided = hfInstance.addSheet('MySheet3');\n     *\n     * // should return autogenerated 'Sheet4'\n     * // because no name was provided and 3 other ones already exist\n     * const generatedName = hfInstance.addSheet();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName) {\n      if (sheetName !== undefined) {\n        validateArgToType(sheetName, 'string', 'sheetName');\n      }\n\n      var addedSheetName = this._crudOperations.addSheet(sheetName);\n\n      this._emitter.emit(Events.SheetAdded, addedSheetName);\n\n      return addedSheetName;\n    }\n    /**\n     * Returns information whether it is possible to remove sheet for the engine.\n     * Returns `true` if the provided name of a sheet exists and therefore it can be removed, doing [[removeSheet]] operation won't throw any errors.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {number} sheetId - sheet ID.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because sheet with ID 1 exists and is removable\n     * const isRemovable = hfInstance.isItPossibleToRemoveSheet(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveSheet\",\n    value: function isItPossibleToRemoveSheet(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.ensureScopeIdIsValid(sheetId);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes sheet with a specified name.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID.\n     *\n     * @fires [[sheetRemoved]] after the sheet was removed\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: { error: [CellError], value: '#REF!' },\n     * // }]\n     * const changes = hfInstance.removeSheet(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"removeSheet\",\n    value: function removeSheet(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      var displayName = this.sheetMapping.getDisplayName(sheetId);\n\n      this._crudOperations.removeSheet(sheetId);\n\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.SheetRemoved, displayName, changes);\n\n      return changes;\n    }\n    /**\n     * Returns information whether it is possible to clear a specified sheet.\n     * If returns `true`, doing [[clearSheet]] operation won't throw any errors, provided name of a sheet exists and then its content can be cleared.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {number} sheetId - sheet ID.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet2' exists and can be cleared\n     * const isClearable = hfInstance.isItPossibleToClearSheet(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToClearSheet\",\n    value: function isItPossibleToClearSheet(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.ensureScopeIdIsValid(sheetId);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Clears the sheet content. Based on that the method finds the ID of a sheet to be cleared.\n     * Double-checks if the sheet exists.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {number} sheetId - sheet ID.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values, in this example it will return:\n     * // [{\n     * //   address: { sheet: 0, col: 0, row: 0 },\n     * //   newValue: 0,\n     * // }]\n     * const changes = hfInstance.clearSheet(0);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"clearSheet\",\n    value: function clearSheet(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.clearSheet(sheetId);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to replace the sheet content.\n     * If returns `true`, doing [[setSheetContent]] operation won't throw any errors, the provided name of a sheet exists and then its content can be replaced.\n     * Returns `false` if there is no sheet with a given name.\n     *\n     * @param {number} sheetId - sheet ID.\n     * @param {RawCellContent[][]} values - array of new values\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' because 'MySheet1' (sheetId=0) exists\n     * // and the provided content can be placed in this sheet\n     * const isReplaceable = hfInstance.isItPossibleToReplaceSheetContent(0, [['50'], ['60']]);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToReplaceSheetContent\",\n    value: function isItPossibleToReplaceSheetContent(sheetId, values) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      try {\n        this._crudOperations.ensureScopeIdIsValid(sheetId);\n\n        this._crudOperations.ensureItIsPossibleToChangeSheetContents(sheetId, values);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Replaces the sheet content with new values.\n     * The new value is to be provided as an array of arrays of [[RawCellContent]].\n     * The method finds sheet ID based on the provided sheet name.\n     *\n     * @param {number} sheetId - sheet ID.\n     * @param {RawCellContent[][]} values - array of new values\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exists\n     * @throws [[InvalidArgumentsError]] when values is not an array of arrays\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return a list of cells which values changed after the operation,\n     * // their absolute addresses and new values\n     * const changes = hfInstance.setSheetContent(0, [['50'], ['60']]);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"setSheetContent\",\n    value: function setSheetContent(sheetId, values) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.setSheetContent(sheetId, values);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Computes simple (absolute) address of a cell address based on its string representation.\n     * If sheet name is present in string representation but not present in the engine, returns `undefined`.\n     *\n     * @param {string} cellAddress - string representation of cell address in A1 notation\n     * @param {number} sheetId - context used in case of missing sheet in the first argument\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     * hfInstance.addSheet('Sheet0'); //sheetId = 0\n     *\n     * // returns { sheet: 0, col: 0, row: 0 }\n     * const simpleCellAddress = hfInstance.simpleCellAddressFromString('A1', 0);\n     *\n     * // returns { sheet: 0, col: 0, row: 5 }\n     * const simpleCellAddressTwo = hfInstance.simpleCellAddressFromString('Sheet1!A6');\n     *\n     * // returns { sheet: 0, col: 0, row: 5 }\n     * const simpleCellAddressTwo = hfInstance.simpleCellAddressFromString('Sheet1!$A$6');\n     *\n     * // returns 'undefined', as there's no 'Sheet 2' in the HyperFormula instance\n     * const simpleCellAddressTwo = hfInstance.simpleCellAddressFromString('Sheet2!A6');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellAddressFromString\",\n    value: function simpleCellAddressFromString(cellAddress, sheetId) {\n      validateArgToType(cellAddress, 'string', 'cellAddress');\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return _simpleCellAddressFromString(this.sheetMapping.get, cellAddress, sheetId);\n    }\n    /**\n     * Computes simple (absolute) address of a cell range based on its string representation.\n     * If sheet name is present in string representation but not present in the engine, returns `undefined`.\n     *\n     * @param {string} cellRange - string representation of cell range in A1 notation\n     * @param {number} sheetId - context used in case of missing sheet in the first argument\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     * hfInstance.addSheet('Sheet0'); //sheetId = 0\n     *\n     * // should return { start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 0 } }\n     * const simpleCellAddress = hfInstance.simpleCellRangeFromString('A1:A2', 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellRangeFromString\",\n    value: function simpleCellRangeFromString(cellRange, sheetId) {\n      validateArgToType(cellRange, 'string', 'cellRange');\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return _simpleCellRangeFromString(this.sheetMapping.get, cellRange, sheetId);\n    }\n    /**\n     * Returns string representation of an absolute address in A1 notation or `undefined` if the sheet index is not present in the engine.\n     *\n     * @param {SimpleCellAddress} cellAddress - object representation of an absolute address\n     * @param {number} sheetId - context used in case of missing sheet in the first argument\n     *\n     * @throws [[ExpectedValueOfTypeError]] if its arguments are of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     * hfInstance.addSheet('Sheet0'); //sheetId = 0\n     *\n     * // should return 'B2'\n     * const A1Notation = hfInstance.simpleCellAddressToString({ sheet: 0, col: 1, row: 1 }, 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellAddressToString\",\n    value: function simpleCellAddressToString(cellAddress, sheetId) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return _simpleCellAddressToString(this.sheetMapping.fetchDisplayName, cellAddress, sheetId);\n    }\n    /**\n     * Returns string representation of an absolute range in A1 notation or `undefined` if the sheet index is not present in the engine.\n     *\n     * @param {SimpleCellRange} cellRange - object representation of an absolute range\n     * @param {number} sheetId - context used in case of missing sheet in the first argument\n     *\n     * @throws [[ExpectedValueOfTypeError]] if its arguments are of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     * hfInstance.addSheet('Sheet0'); //sheetId = 0\n     * hfInstance.addSheet('Sheet1'); //sheetId = 1\n     *\n     * // should return 'B2:C2'\n     * const A1Notation = hfInstance.simpleCellRangeToString({ start: { sheet: 0, col: 1, row: 1 }, end: { sheet: 0, col: 2, row: 1 } }, 0);\n     *\n     *  // should return 'Sheet1!B2:C2'\n     * const another = hfInstance.simpleCellRangeToString({ start: { sheet: 1, col: 1, row: 1 }, end: { sheet: 1, col: 2, row: 1 } }, 0);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"simpleCellRangeToString\",\n    value: function simpleCellRangeToString(cellRange, sheetId) {\n      if (!isSimpleCellRange(cellRange)) {\n        throw new ExpectedValueOfTypeError('SimpleCellRange', 'cellRange');\n      }\n\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return _simpleCellRangeToString(this.sheetMapping.fetchDisplayName, cellRange, sheetId);\n    }\n    /**\n     * Returns all addresses and ranges whose computation depends on input address or range provided.\n     *\n     * @param {SimpleCellAddress | SimpleCellRange} address - object representation of an absolute address or range of addresses\n     *\n     * @throws [[ExpectedValueOfTypeError]] if address is not [[SimpleCellAddress]] or [[SimpleCellRange]]\n     * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n     *\n     * hfInstance.getCellDependents({ sheet: 0, col: 0, row: 0});\n     * // should return [{ sheet: 0, col: 1, row: 0}, { sheet: 0, col: 2, row: 0}]\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"getCellDependents\",\n    value: function getCellDependents(address) {\n      var vertex;\n\n      if (isSimpleCellAddress(address)) {\n        vertex = this._dependencyGraph.addressMapping.getCell(address);\n      } else if (isSimpleCellRange(address)) {\n        vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);\n      } else {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', address);\n      }\n\n      if (vertex === undefined) {\n        return [];\n      }\n\n      return this._dependencyGraph.getAdjacentNodesAddresses(vertex);\n    }\n    /**\n     * Returns all addresses and ranges necessary for computation of a given address or range.\n     *\n     * @param {SimpleCellAddress | SimpleCellRange} address - object representation of an absolute address or range of addresses\n     *\n     * @throws [[ExpectedValueOfTypeError]] if address is of wrong type\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n     *\n     * hfInstance.getCellPrecedents({ sheet: 0, col: 2, row: 0});\n     * // should return [{ sheet: 0, col: 0, row: 0}, { sheet: 0, col: 1, row: 0}]\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"getCellPrecedents\",\n    value: function getCellPrecedents(address) {\n      var vertex;\n\n      if (isSimpleCellAddress(address)) {\n        vertex = this._dependencyGraph.addressMapping.getCell(address);\n      } else if (isSimpleCellRange(address)) {\n        vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);\n      } else {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', address);\n      }\n\n      if (vertex === undefined) {\n        return [];\n      }\n\n      return this._dependencyGraph.dependencyQueryAddresses(vertex);\n    }\n    /**\n     * Returns a unique sheet name assigned to the sheet of a given ID or `undefined` if the there is no sheet with a given ID.\n     *\n     * @param {number} sheetId - ID of the sheet, for which we want to retrieve name\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'MySheet2' as this sheet is the second one\n     * const sheetName = hfInstance.getSheetName(1);\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetName\",\n    value: function getSheetName(sheetId) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      return this.sheetMapping.getDisplayName(sheetId);\n    }\n    /**\n     * List all sheet names.\n     * Returns an array of sheet names as strings.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return all sheets names: ['MySheet1', 'MySheet2']\n     * const sheetNames = hfInstance.getSheetNames();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetNames\",\n    value: function getSheetNames() {\n      return this.sheetMapping.sheetNames();\n    }\n    /**\n     * Returns a unique sheet ID assigned to the sheet with a given name or `undefined` if the sheet does not exist.\n     *\n     * @param {string} sheetName - name of the sheet, for which we want to retrieve ID, case insensitive.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return '0' because 'MySheet1' is of ID '0'\n     * const sheetID = hfInstance.getSheetId('MySheet1');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"getSheetId\",\n    value: function getSheetId(sheetName) {\n      validateArgToType(sheetName, 'string', 'sheetName');\n      return this.sheetMapping.get(sheetName);\n    }\n    /**\n     * Returns `true` whether sheet with a given name exists. The methods accepts sheet name to be checked.\n     *\n     * @param {string} sheetName - name of the sheet, case insensitive.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // should return 'true' since 'MySheet1' exists\n     * const sheetExist = hfInstance.doesSheetExist('MySheet1');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"doesSheetExist\",\n    value: function doesSheetExist(sheetName) {\n      validateArgToType(sheetName, 'string', 'sheetName');\n      return this.sheetMapping.hasSheetWithName(sheetName);\n    }\n    /**\n     * Returns type of a specified cell of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'FORMULA', the cell of given coordinates is of this type\n     * const cellA1Type = hfInstance.getCellType({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'VALUE', the cell of given coordinates is of this type\n     * const cellB1Type = hfInstance.getCellType({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      var vertex = this.dependencyGraph.getCell(cellAddress);\n      return _getCellType(vertex, cellAddress);\n    }\n    /**\n     * Returns `true` if the specified cell contains a simple value.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'true' since the selected cell contains a simple value\n     * const isA1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false' since the selected cell does not contain a simple value\n     * const isB1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"doesCellHaveSimpleValue\",\n    value: function doesCellHaveSimpleValue(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      return this.getCellType(cellAddress) === CellType.VALUE;\n    }\n    /**\n     * Returns `true` if the specified cell contains a formula.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(A2:A3)', '2'],\n     * ]);\n     *\n     * // should return 'true' since the A1 cell contains a formula\n     * const A1Formula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false' since the B1 cell does not contain a formula\n     * const B1NoFormula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"doesCellHaveFormula\",\n    value: function doesCellHaveFormula(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      var cellType = this.getCellType(cellAddress);\n      return cellType === CellType.FORMULA || cellType === CellType.ARRAYFORMULA;\n    }\n    /**\n     * Returns`true` if the specified cell is empty.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *   [null, '1'],\n     * ]);\n     *\n     * // should return 'true', cell of provided coordinates is empty\n     * const isEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'false', cell of provided coordinates is not empty\n     * const isNotEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isCellEmpty\",\n    value: function isCellEmpty(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      return this.getCellType(cellAddress) === CellType.EMPTY;\n    }\n    /**\n     * Returns `true` if a given cell is a part of a array.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *    ['{=TRANSPOSE(B1:B1)}'],\n     * ]);\n     *\n     * // should return 'true', cell of provided coordinates is a part of a array\n     * const isPartOfArray = hfInstance.isCellPartOfArray({ sheet: 0, col: 0, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"isCellPartOfArray\",\n    value: function isCellPartOfArray(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      var cellType = this.getCellType(cellAddress);\n      return cellType === CellType.ARRAY || cellType === CellType.ARRAYFORMULA;\n    }\n    /**\n     * Returns type of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['=SUM(1,2,3)', '2'],\n     * ]);\n     *\n     * // should return 'NUMBER', cell value type of provided coordinates is a number\n     * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });\n     *\n     * // should return 'NUMBER', cell value type of provided coordinates is a number\n     * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueType\",\n    value: function getCellValueType(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueType(value);\n    }\n    /**\n     * Returns detailed type of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1%', '1$'],\n     * ]);\n     *\n     * // should return 'NUMBER_PERCENT', cell value type of provided coordinates is a number with a format inference percent.\n     * const cellType = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return 'NUMBER_CURRENCY', cell value type of provided coordinates is a number with a format inference currency.\n     * const cellType = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueDetailedType\",\n    value: function getCellValueDetailedType(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueDetailedType(value);\n    }\n    /**\n     * Returns auxilary format information of the cell value of a given address.\n     * The methods accepts cell coordinates as object with column, row and sheet numbers.\n     *\n     * @param {SimpleCellAddress} cellAddress - cell coordinates\n     *\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[EvaluationSuspendedError]] when the evaluation is suspended\n     * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1$', '1'],\n     * ]);\n     *\n     * // should return '$', cell value type of provided coordinates is a number with a format inference currency, parsed as using '$' as currency.\n     * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 0, row: 0 });\n     *\n     * // should return undefined, cell value type of provided coordinates is a number with no format information.\n     * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 1, row: 0 });\n     * ```\n     *\n     * @category Cells\n     */\n\n  }, {\n    key: \"getCellValueFormat\",\n    value: function getCellValueFormat(cellAddress) {\n      if (!isSimpleCellAddress(cellAddress)) {\n        throw new ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n      var value = this.dependencyGraph.getCellValue(cellAddress);\n      return _getCellValueFormat(value);\n    }\n    /**\n     * Returns the number of existing sheets.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['1', '2'],\n     * ]);\n     *\n     * // should return the number of sheets which is '1'\n     * const sheetsCount = hfInstance.countSheets();\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"countSheets\",\n    value: function countSheets() {\n      return this.sheetMapping.numberOfSheets();\n    }\n    /**\n     * Returns information whether it is possible to rename sheet.\n     * Returns `true` if the sheet with provided id exists and new name is available\n     * Returns `false` if sheet cannot be renamed\n     *\n     * @param {number} sheetId - a sheet number\n     * @param {string} newName - a name of the sheet to be given\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // returns true\n     * hfInstance.isItPossibleToRenameSheet(0, 'MySheet0');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"isItPossibleToRenameSheet\",\n    value: function isItPossibleToRenameSheet(sheetId, newName) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(newName, 'string', 'newName');\n\n      try {\n        this._crudOperations.ensureItIsPossibleToRenameSheet(sheetId, newName);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Renames a specified sheet.\n     *\n     * @param {number} sheetId - a sheet number\n     * @param {string} newName - a name of the sheet to be given, if is the same as the old one the method does nothing\n     *\n     * @fires [[sheetRenamed]] after the sheet was renamed\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist\n     * @throws [[SheetNameAlreadyTakenError]] when the provided sheet name already exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *   MySheet1: [ ['1'] ],\n     *   MySheet2: [ ['10'] ],\n     * });\n     *\n     * // renames the sheet 'MySheet1'\n     * hfInstance.renameSheet(0, 'MySheet0');\n     * ```\n     *\n     * @category Sheets\n     */\n\n  }, {\n    key: \"renameSheet\",\n    value: function renameSheet(sheetId, newName) {\n      validateArgToType(sheetId, 'number', 'sheetId');\n      validateArgToType(newName, 'string', 'newName');\n\n      var oldName = this._crudOperations.renameSheet(sheetId, newName);\n\n      if (oldName !== undefined) {\n        this._emitter.emit(Events.SheetRenamed, oldName, newName);\n      }\n    }\n    /**\n     * Runs multiple operations and recomputes formulas at the end.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {() => void} batchOperations\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     * @fires [[evaluationSuspended]] always\n     * @fires [[evaluationResumed]] after the recomputation of necessary values\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // multiple operations in a single callback will trigger evaluation only once\n     * // and only one set of changes is returned as a combined result of all\n     * // the operations that were triggered within the callback\n     * const changes = hfInstance.batch(() => {\n     *  hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     *  hfInstance.setCellContents({ col: 4, row: 0, sheet: 0 }, [['=A1']]);\n     * });\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch(batchOperations) {\n      this.suspendEvaluation();\n\n      this._crudOperations.beginUndoRedoBatchMode();\n\n      try {\n        batchOperations();\n      } catch (e) {\n        this._crudOperations.commitUndoRedoBatchMode();\n\n        this.resumeEvaluation();\n        throw e;\n      }\n\n      this._crudOperations.commitUndoRedoBatchMode();\n\n      return this.resumeEvaluation();\n    }\n    /**\n     * Suspends the dependency graph recalculation.\n     * It allows optimizing the performance.\n     * With this method, multiple CRUD operations can be done without triggering recalculation after every operation.\n     * Suspending evaluation should result in an overall faster calculation compared to recalculating after each operation separately.\n     * To resume the evaluation use [[resumeEvaluation]].\n     *\n     * @fires [[evaluationSuspended]] always\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // similar to batch() but operations are not within a callback,\n     * // one method suspends the recalculation\n     * // the second will resume calculations and return the changes\n     *\n     * // suspend the evaluation with this method\n     * hfInstance.suspendEvaluation();\n     *\n     * // perform operations\n     * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * hfInstance.setSheetContent('MySheet2', [['50'], ['60']]);\n     *\n     * // use resumeEvaluation to resume\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"suspendEvaluation\",\n    value: function suspendEvaluation() {\n      this._evaluationSuspended = true;\n\n      this._emitter.emit(Events.EvaluationSuspended);\n    }\n    /**\n     * Resumes the dependency graph recalculation that was suspended with [[suspendEvaluation]].\n     * It also triggers the recalculation and returns changes that are a result of all batched operations.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     * @fires [[evaluationResumed]] after the recomputation of necessary values\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  MySheet1: [ ['1'] ],\n     *  MySheet2: [ ['10'] ],\n     * });\n     *\n     * // similar to batch() but operations are not within a callback,\n     * // one method suspends the recalculation\n     * // the second will resume calculations and return the changes\n     *\n     * // first, suspend the evaluation\n     * hfInstance.suspendEvaluation();\n     *\n     * // perform operations\n     * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);\n     * hfInstance.setSheetContent('MySheet2', [['50'], ['60']]);\n     *\n     * // resume the evaluation\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"resumeEvaluation\",\n    value: function resumeEvaluation() {\n      this._evaluationSuspended = false;\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.EvaluationResumed, changes);\n\n      return changes;\n    }\n    /**\n     * Checks if the dependency graph recalculation process is suspended or not.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // suspend the evaluation\n     * hfInstance.suspendEvaluation();\n     *\n     * // between suspendEvaluation() and resumeEvaluation()\n     * // or inside batch() callback it will return 'true', otherwise 'false'\n     * const isEvaluationSuspended = hfInstance.isEvaluationSuspended();\n     *\n     * const changes = hfInstance.resumeEvaluation();\n     * ```\n     *\n     * @category Batch\n     */\n\n  }, {\n    key: \"isEvaluationSuspended\",\n    value: function isEvaluationSuspended() {\n      return this._evaluationSuspended;\n    }\n    /**\n     * Returns information whether it is possible to add named expression into a specific scope.\n     * Checks against particular rules to ascertain that addNamedExpression can be called.\n     * If returns `true`, doing [[addNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - a name of the expression to be added\n     * @param {RawCellContent} expression - the expression\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // should return 'true' for this example,\n     * // it is possible to add named expression to global scope\n     * const isAddable = hfInstance.isItPossibleToAddNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToAddNamedExpression\",\n    value: function isItPossibleToAddNamedExpression(expressionName, expression, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      try {\n        this._crudOperations.ensureItIsPossibleToAddNamedExpression(expressionName, expression, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Adds a specified named expression.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - a name of the expression to be added\n     * @param {RawCellContent} expression - the expression\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     * @param {NamedExpressionOptions?} options - additional metadata related to named expression\n     *\n     * @fires [[namedExpressionAdded]] always, unless [[batch]] mode is used\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NamedExpressionNameIsAlreadyTakenError]] when the named expression name is not available.\n     * @throws [[NamedExpressionNameIsInvalidError]] when the named expression name is not valid\n     * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add own expression, scope limited to 'Sheet1' (sheetId=0), the method should return a list of cells which values\n     * // changed after the operation, their absolute addresses and new values\n     * // for this example:\n     * // [{\n     * //   name: 'prettyName',\n     * //   newValue: 142,\n     * // }]\n     * const changes = hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"addNamedExpression\",\n    value: function addNamedExpression(expressionName, expression, scope, options) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this._crudOperations.addNamedExpression(expressionName, expression, scope, options);\n\n      var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n      this._emitter.emit(Events.NamedExpressionAdded, expressionName, changes);\n\n      return changes;\n    }\n    /**\n     * Gets specified named expression value.\n     * Returns a [[CellValue]] or undefined if the given named expression does not exists.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression, only 'Sheet1' (sheetId=0) considered as it is the scope\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');\n     *\n     * // returns the calculated value of a passed named expression, '142' for this example\n     * const myFormula = hfInstance.getNamedExpressionValue('prettyName', 'Sheet1');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpressionValue\",\n    value: function getNamedExpressionValue(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this.ensureEvaluationIsNotSuspended();\n\n      this._crudOperations.ensureScopeIdIsValid(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);\n\n      if (namedExpression) {\n        return this._serialization.getCellValue(namedExpression.address);\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a normalized formula string for given named expression, or `undefined` for a named expression that does not exist or does not hold a formula.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression in 'Sheet1' (sheetId=0)\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     *\n     * // returns a normalized formula string corresponding to the passed name from 'Sheet1' (sheetId=0),\n     * // '=Sheet1!A1+100' for this example\n     * const myFormula = hfInstance.getNamedExpressionFormula('prettyName', 0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpressionFormula\",\n    value: function getNamedExpressionFormula(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this._crudOperations.ensureScopeIdIsValid(scope);\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);\n\n      if (namedExpression === undefined) {\n        return undefined;\n      } else {\n        return this._serialization.getCellFormula(namedExpression.address);\n      }\n    }\n    /**\n     * Returns a named expression, or `undefined` for a named expression that does not exist or does not hold a formula.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression in 'Sheet1' (sheetId=0)\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     *\n     * // returns a named expression that corresponds to the passed name from 'Sheet1' (sheetId=0)\n     * // for this example, returns:\n     * // {name: 'prettyName', expression: '=Sheet1!$A$1+100', options: undefined, scope: 0}\n     * const myFormula = hfInstance.getNamedExpression('prettyName', 0);\n     *\n     * // for a named expression that doesn't exist, returns 'undefined':\n     * const myFormulaTwo = hfInstance.getNamedExpression('uglyName', 0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getNamedExpression\",\n    value: function getNamedExpression(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      var namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);\n\n      if (namedExpression === undefined) {\n        return undefined;\n      }\n\n      var expression = this._serialization.getCellFormula(namedExpression.address);\n\n      return {\n        name: expressionName,\n        scope: scope,\n        expression: expression,\n        options: namedExpression.options\n      };\n    }\n    /**\n     * Returns information whether it is possible to change named expression in a specific scope.\n     * Checks against particular rules to ascertain that changeNamedExpression can be called.\n     * If returns `true`, doing [[changeNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {RawCellContent} newExpression - a new expression\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     *\n     * // should return 'true' for this example,\n     * // it is possible to change named expression\n     * const isAddable = hfInstance.isItPossibleToChangeNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToChangeNamedExpression\",\n    value: function isItPossibleToChangeNamedExpression(expressionName, newExpression, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      try {\n        this._crudOperations.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Changes a given named expression to a specified formula.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {RawCellContent} newExpression - a new expression\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     * @param {NamedExpressionOptions?} options - additional metadata related to named expression\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     * @throws [[ArrayFormulasNotSupportedError]] when the named expression formula is an array formula\n     * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression, scope limited to 'Sheet1' (sheetId=0)\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     *\n     * // change the named expression\n     * const changes = hfInstance.changeNamedExpression('prettyName', '=Sheet1!$A$1+200');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"changeNamedExpression\",\n    value: function changeNamedExpression(expressionName, newExpression, scope, options) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this._crudOperations.changeNamedExpressionExpression(expressionName, scope, newExpression, options);\n\n      return this.recomputeIfDependencyGraphNeedsIt();\n    }\n    /**\n     * Returns information whether it is possible to remove named expression from a specific scope.\n     * Checks against particular rules to ascertain that removeNamedExpression can be called.\n     * If returns `true`, doing [[removeNamedExpression]] operation won't throw any errors.\n     * Returns `false` if the operation might be disrupted.\n     *\n     * @param {string} expressionName - an expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     *\n     * // should return 'true' for this example,\n     * // it is possible to change named expression\n     * const isAddable = hfInstance.isItPossibleToRemoveNamedExpression('prettyName');\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"isItPossibleToRemoveNamedExpression\",\n    value: function isItPossibleToRemoveNamedExpression(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      try {\n        this._crudOperations.isItPossibleToRemoveNamedExpression(expressionName, scope);\n\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Removes a named expression.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @param {string} expressionName - expression name, case insensitive.\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @fires [[namedExpressionRemoved]] after the expression was removed\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     * ]);\n     *\n     * // add a named expression\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);\n     *\n     * // remove the named expression\n     * const changes = hfInstance.removeNamedExpression('prettyName', 0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"removeNamedExpression\",\n    value: function removeNamedExpression(expressionName, scope) {\n      validateArgToType(expressionName, 'string', 'expressionName');\n\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      var removedNamedExpression = this._crudOperations.removeNamedExpression(expressionName, scope);\n\n      if (removedNamedExpression) {\n        var changes = this.recomputeIfDependencyGraphNeedsIt();\n\n        this._emitter.emit(Events.NamedExpressionRemoved, removedNamedExpression.displayName, changes);\n\n        return changes;\n      } else {\n        return [];\n      }\n    }\n    /**\n     * Lists all named expressions.\n     * Returns an array of expression names defined in a scope, as strings.\n     *\n     * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     *  ['60'],\n     * ]);\n     *\n     * // add two named expressions and one scoped\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * hfInstance.addNamedExpression('anotherPrettyName', '=Sheet1!$A$2+100');\n     * hfInstance.addNamedExpression('alsoPrettyName', '=Sheet1!$A$3+100', 0);\n     *\n     * // list the expressions, should return: ['prettyName', 'anotherPrettyName'] for this example\n     * const listOfExpressions = hfInstance.listNamedExpressions();\n     *\n     *  // list the expressions, should return: ['alsoPrettyName'] for this example\n     * const listOfExpressions = hfInstance.listNamedExpressions(0);\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"listNamedExpressions\",\n    value: function listNamedExpressions(scope) {\n      if (scope !== undefined) {\n        validateArgToType(scope, 'number', 'scope');\n      }\n\n      this._crudOperations.ensureScopeIdIsValid(scope);\n\n      return this._namedExpressions.getAllNamedExpressionsNamesInScope(scope);\n    }\n    /**\n     * Returns all named expressions serialized.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     *  ['60'],\n     * ]);\n     *\n     * // add two named expressions and one scoped\n     * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');\n     * hfInstance.addNamedExpression('anotherPrettyName', '=Sheet1!$A$2+100');\n     * hfInstance.addNamedExpression('prettyName3', '=Sheet1!$A$3+100', 0);\n     *\n     * // get all expressions serialized\n     * // should return:\n     * // [\n     * // {name: 'prettyName', expression: '=Sheet1!$A$1+100', options: undefined, scope: undefined},\n     * // {name: 'anotherPrettyName', expression: '=Sheet1!$A$2+100', options: undefined, scope: undefined},\n     * // {name: 'alsoPrettyName', expression: '=Sheet1!$A$3+100', options: undefined, scope: 0}\n     * // ]\n     * const allExpressions = hfInstance.getAllNamedExpressionsSerialized();\n     * ```\n     *\n     * @category Named Expressions\n     */\n\n  }, {\n    key: \"getAllNamedExpressionsSerialized\",\n    value: function getAllNamedExpressionsSerialized() {\n      return this._serialization.getAllNamedExpressionsSerialized();\n    }\n    /**\n     * Parses and then unparses a formula.\n     * Returns a normalized formula (e.g. restores the original capitalization of sheet names, function names, cell addresses, and named expressions).\n     *\n     * @param {string} formulaString - a formula in a proper format - it must start with \"=\"\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[NotAFormulaError]] when the provided string is not a valid formula, i.e does not start with \"=\"\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromArray([\n     *  ['42'],\n     *  ['50'],\n     * ]);\n     *\n     * // returns '=Sheet1!$A$1+10'\n     * const normalizedFormula = hfInstance.normalizeFormula('=SHEET1!$A$1+10');\n     *\n     * // returns '=3*$A$1'\n     * const normalizedFormula = hfInstance.normalizeFormula('=3*$a$1');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"normalizeFormula\",\n    value: function normalizeFormula(formulaString) {\n      validateArgToType(formulaString, 'string', 'formulaString');\n\n      var _this$extractTemporar = this.extractTemporaryFormula(formulaString),\n          ast = _this$extractTemporar.ast,\n          address = _this$extractTemporar.address;\n\n      if (ast === undefined) {\n        throw new NotAFormulaError();\n      }\n\n      return this._unparser.unparse(ast, address);\n    }\n    /**\n     * Calculates fire-and-forget formula, returns the calculated value.\n     *\n     * @param {string} formulaString - A formula in a proper format, starting with `=`.\n     * @param {number} sheetId - The ID of a sheet in context of which the formula gets evaluated.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type arguments is of wrong type.\n     * @throws [[NotAFormulaError]] when the provided string is not a valid formula (i.e. doesn't start with `=`).\n     * @throws [[NoSheetWithIdError]] when the provided `sheetID` doesn't exist.\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildFromSheets({\n     *  Sheet1: [['58']],\n     *  Sheet2: [['1', '2', '3'], ['4', '5', '6']]\n     * });\n     *\n     * // returns the calculated formula's value\n     * // for this example, returns `68`\n     * const calculatedFormula = hfInstance.calculateFormula('=A1+10', 0);\n     *\n     * // for this example, returns [['11', '12', '13'], ['14', '15', '16']]\n     * const calculatedFormula = hfInstance.calculateFormula('=A1:B3+10', 1);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"calculateFormula\",\n    value: function calculateFormula(formulaString, sheetId) {\n      validateArgToType(formulaString, 'string', 'formulaString');\n      validateArgToType(sheetId, 'number', 'sheetId');\n\n      this._crudOperations.ensureScopeIdIsValid(sheetId);\n\n      var _this$extractTemporar2 = this.extractTemporaryFormula(formulaString, sheetId),\n          ast = _this$extractTemporar2.ast,\n          address = _this$extractTemporar2.address,\n          dependencies = _this$extractTemporar2.dependencies;\n\n      if (ast === undefined) {\n        throw new NotAFormulaError();\n      }\n\n      var internalCellValue = this.evaluator.runAndForget(ast, address, dependencies);\n      return this._exporter.exportScalarOrRange(internalCellValue);\n    }\n    /**\n     * Validates the formula.\n     * If the provided string starts with \"=\" and is a parsable formula, the method returns `true`.\n     * The validation is purely grammatical: the method doesn't verify if the formula can be calculated or not.\n     *\n     * @param {string} formulaString -  a formula in a proper format - it must start with \"=\"\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // checks if the given string is a valid formula, should return 'true' for this example\n     * const isFormula = hfInstance.validateFormula('=SUM(1,2)');\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"validateFormula\",\n    value: function validateFormula(formulaString) {\n      validateArgToType(formulaString, 'string', 'formulaString');\n\n      var _this$extractTemporar3 = this.extractTemporaryFormula(formulaString),\n          ast = _this$extractTemporar3.ast;\n\n      if (ast === undefined) {\n        return false;\n      }\n\n      if (ast.type === AstNodeType.ERROR && !ast.error) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Returns translated names of all functions registered in this instance of HyperFormula\n     * according to the language set in the configuration\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // return translated names of all functions, assign to a variable\n     * const allNames = hfInstance.getRegisteredFunctionNames();\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getRegisteredFunctionNames\",\n    value: function getRegisteredFunctionNames() {\n      var language = HyperFormula.getLanguage(this._config.language);\n      return language.getFunctionTranslations(this._functionRegistry.getRegisteredFunctionIds());\n    }\n    /**\n     * Returns class of a plugin used by function with given id\n     *\n     * @param {string} functionId - id of a function, e.g. 'SUMIF'\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // register a plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     *\n     * // get the plugin\n     * const myPlugin = hfInstance.getFunctionPlugin('EXAMPLE');\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getFunctionPlugin\",\n    value: function getFunctionPlugin(functionId) {\n      validateArgToType(functionId, 'string', 'functionId');\n      return this._functionRegistry.getFunctionPlugin(functionId);\n    }\n    /**\n     * Returns classes of all plugins registered in this instance of HyperFormula\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // return classes of all plugins registered, assign to a variable\n     * const allNames = hfInstance.getAllFunctionPlugins();\n     * ```\n     *\n     * @category Custom Functions\n     */\n\n  }, {\n    key: \"getAllFunctionPlugins\",\n    value: function getAllFunctionPlugins() {\n      return this._functionRegistry.getPlugins();\n    }\n    /**\n     * Interprets number as a date + time.\n     *\n     * @param {number} inputNumber - number of days since nullDate, should be nonnegative, fractions are interpreted as hours/minutes/seconds.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass the number of days since nullDate\n     * // the method should return formatted date and time, for this example:\n     * // {year: 2020, month: 1, day: 15, hours: 2, minutes: 24, seconds: 0}\n     * const dateTimeFromNumber = hfInstance.numberToDateTime(43845.1);\n     *\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToDateTime\",\n    value: function numberToDateTime(inputNumber) {\n      validateArgToType(inputNumber, 'number', 'val');\n      return this._evaluator.interpreter.dateTimeHelper.numberToSimpleDateTime(inputNumber);\n    }\n    /**\n     * Interprets number as a date.\n     *\n     * @param {number} inputNumber - number of days since nullDate, should be nonnegative, fractions are ignored.\n        * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n        * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass the number of days since nullDate\n     * // the method should return formatted date, for this example:\n     * // {year: 2020, month: 1, day: 15}\n     * const dateFromNumber = hfInstance.numberToDate(43845);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToDate\",\n    value: function numberToDate(inputNumber) {\n      validateArgToType(inputNumber, 'number', 'val');\n      return this._evaluator.interpreter.dateTimeHelper.numberToSimpleDate(inputNumber);\n    }\n    /**\n     * Interprets number as a time (hours/minutes/seconds).\n     *\n     * @param {number} inputNumber - time in 24h units.\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // pass a number to be interpreted as a time\n     * // should return {hours: 26, minutes: 24} for this example\n     * const timeFromNumber = hfInstance.numberToTime(1.1);\n     * ```\n     *\n     * @category Helpers\n     */\n\n  }, {\n    key: \"numberToTime\",\n    value: function numberToTime(inputNumber) {\n      validateArgToType(inputNumber, 'number', 'val');\n      return numberToSimpleTime(inputNumber);\n    }\n  }, {\n    key: \"extractTemporaryFormula\",\n    value: function extractTemporaryFormula(formulaString) {\n      var sheetId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var parsedCellContent = this._cellContentParser.parse(formulaString);\n\n      var address = {\n        sheet: sheetId,\n        col: 0,\n        row: 0\n      };\n\n      if (!(parsedCellContent instanceof CellContent.Formula)) {\n        return {\n          address: address,\n          dependencies: []\n        };\n      }\n\n      var _this$_parser$parse = this._parser.parse(parsedCellContent.formula, address),\n          ast = _this$_parser$parse.ast,\n          errors = _this$_parser$parse.errors,\n          dependencies = _this$_parser$parse.dependencies;\n\n      if (errors.length > 0) {\n        return {\n          address: address,\n          dependencies: []\n        };\n      }\n\n      return {\n        ast: ast,\n        address: address,\n        dependencies: dependencies\n      };\n    }\n    /**\n     * Subscribes to an event.\n     * For the list of all available events, see [[Listeners]].\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // subscribe to a 'sheetAdded', pass a simple handler\n     * hfInstance.on('sheetAdded', ( ) => { console.log('foo') });\n     *\n     * // add a sheet to trigger an event,\n     * // console should print 'foo' after each time sheet is added in this example\n     * hfInstance.addSheet('FooBar');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this._emitter.on(event, listener);\n    }\n    /**\n     * Subscribes to an event once.\n     * For the list of all available events, see [[Listeners]].\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // subscribe to a 'sheetAdded', pass a simple handler\n     * hfInstance.once('sheetAdded', ( ) => { console.log('foo') });\n     *\n     * // call addSheet twice,\n     * // console should print 'foo' only once when the sheet is added in this example\n     * hfInstance.addSheet('FooBar');\n     * hfInstance.addSheet('FooBaz');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(event, listener) {\n      this._emitter.once(event, listener);\n    }\n    /**\n     * Unsubscribes from an event or from all events.\n     * For the list of all available events, see [[Listeners]].\n     *\n     * @param {Event} event the name of the event to subscribe to\n     * @param {Listener} listener to be called when event is emitted\n     *\n     * @example\n     * ```js\n     * const hfInstance = HyperFormula.buildEmpty();\n     *\n     * // define a simple function to be called upon emitting an event\n     * const handler = ( ) => { console.log('baz') }\n     *\n     * // subscribe to a 'sheetAdded', pass the handler\n     * hfInstance.on('sheetAdded', handler);\n     *\n     * // add a sheet to trigger an event,\n     * // console should print 'baz' each time a sheet is added\n     * hfInstance.addSheet('FooBar');\n     *\n     * // unsubscribe from a 'sheetAdded'\n     * hfInstance.off('sheetAdded', handler);\n     *\n     * // add a sheet, the console should not print anything\n     * hfInstance.addSheet('FooBaz');\n     * ```\n     *\n     * @category Events\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.off(event, listener);\n    }\n    /**\n     * Destroys instance of HyperFormula.\n     *\n     * @example\n     * ```js\n     * // destroys the instance\n     * hfInstance.destroy();\n     * ```\n     *\n     * @category Instance\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._evaluator.interpreter.destroyGpu();\n\n      objectDestroy(this);\n    }\n    /**\n     * Runs a recomputation starting from recently changed vertices.\n     *\n     * Note that this method may trigger dependency graph recalculation.\n     *\n     * @fires [[valuesUpdated]] if recalculation was triggered by this change\n     */\n\n  }, {\n    key: \"recomputeIfDependencyGraphNeedsIt\",\n    value: function recomputeIfDependencyGraphNeedsIt() {\n      if (!this._evaluationSuspended) {\n        var changes = this._crudOperations.getAndClearContentChanges();\n\n        var verticesToRecomputeFrom = Array.from(this.dependencyGraph.verticesToRecompute());\n        this.dependencyGraph.clearRecentlyChangedVertices();\n\n        if (verticesToRecomputeFrom.length > 0) {\n          changes.addAll(this.evaluator.partialRun(verticesToRecomputeFrom));\n        }\n\n        var exportedChanges = changes.exportChanges(this._exporter);\n\n        if (!changes.isEmpty()) {\n          this._emitter.emit(Events.ValuesUpdated, exportedChanges);\n        }\n\n        return exportedChanges;\n      } else {\n        return [];\n      }\n    }\n  }], [{\n    key: \"buildFromEngineState\",\n    value: function buildFromEngineState(engine) {\n      return new HyperFormula(engine.config, engine.stats, engine.dependencyGraph, engine.columnSearch, engine.parser, engine.unparser, engine.cellContentParser, engine.evaluator, engine.lazilyTransformingAstService, engine.crudOperations, engine.exporter, engine.namedExpressions, engine.serialization, engine.functionRegistry);\n    }\n    /**\n     * Builds the engine for a sheet from a two-dimensional array representation.\n     * The engine is created with a single sheet.\n     * Can be configured with the optional second parameter that represents a [[ConfigParams]].\n     * If not specified, the engine will be built with the default configuration.\n     *\n     * @param {Sheet} sheet - two-dimensional array representation of sheet\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions\n     *\n     * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits\n     * @throws [[InvalidArgumentsError]] when sheet is not an array of arrays\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     *\n     * @example\n     * ```js\n     * // data represented as an array\n     * const sheetData = [\n     *  ['0', '=SUM(1,2,3)', '52'],\n     *  ['=SUM(A1:C1)', '', '=A1'],\n     *  ['2', '=SUM(A1:C1)', '91'],\n     * ];\n     *\n     * // method with optional config parameter maxColumns\n     * const hfInstance = HyperFormula.buildFromArray(sheetData, { maxColumns: 1000 });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildFromArray\",\n    value: function buildFromArray(sheet) {\n      var configInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var namedExpressions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return this.buildFromEngineState(BuildEngineFactory.buildFromSheet(sheet, configInput, namedExpressions));\n    }\n    /**\n     * Builds the engine from an object containing multiple sheets with names.\n     * The engine is created with one or more sheets.\n     * Can be configured with the optional second parameter that represents a [[ConfigParams]].\n     * If not specified the engine will be built with the default configuration.\n     *\n     * @param {Sheet} sheets - object with sheets definition\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions\n     *\n     * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits\n     * @throws [[InvalidArgumentsError]] when any sheet is not an array of arrays\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     *\n     * @example\n     * ```js\n     * // data represented as an object with sheets: Sheet1 and Sheet2\n     * const sheetData = {\n     *  'Sheet1': [\n     *    ['1', '', '=Sheet2!$A1'],\n     *    ['', '2', '=SUM(1,2,3)'],\n     *    ['=Sheet2!$A2', '2', ''],\n     *   ],\n     *  'Sheet2': [\n     *    ['', '4', '=Sheet1!$B1'],\n     *    ['', '8', '=SUM(9,3,3)'],\n     *    ['=Sheet1!$B1', '2', ''],\n     *   ],\n     * };\n     *\n     * // method with optional config parameter useColumnIndex\n     * const hfInstance = HyperFormula.buildFromSheets(sheetData, { useColumnIndex: true });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildFromSheets\",\n    value: function buildFromSheets(sheets) {\n      var configInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var namedExpressions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return this.buildFromEngineState(BuildEngineFactory.buildFromSheets(sheets, configInput, namedExpressions));\n    }\n    /**\n     * Builds an empty engine instance.\n     * Can be configured with the optional parameter that represents a [[ConfigParams]].\n     * If not specified the engine will be built with the default configuration.\n     *\n     * @param {Partial<ConfigParams>} configInput - engine configuration\n     * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions\n     *\n     * @example\n     * ```js\n     * // build with no initial data and with optional config parameter maxColumns\n     * const hfInstance = HyperFormula.buildEmpty({ maxColumns: 1000 });\n     * ```\n     *\n     * @category Factories\n     */\n\n  }, {\n    key: \"buildEmpty\",\n    value: function buildEmpty() {\n      var configInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var namedExpressions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      return this.buildFromEngineState(BuildEngineFactory.buildEmpty(configInput, namedExpressions));\n    }\n    /**\n     * Returns registered language from its code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[LanguageNotRegisteredError]] when trying to retrieve not registered language\n     *\n     * @example\n     * ```js\n     * // return registered language\n     * const language = HyperFormula.getLanguage('enGB');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getLanguage\",\n    value: function getLanguage(languageCode) {\n      validateArgToType(languageCode, 'string', 'languageCode');\n      var val = this.registeredLanguages.get(languageCode);\n\n      if (val === undefined) {\n        throw new LanguageNotRegisteredError();\n      } else {\n        return val;\n      }\n    }\n    /**\n     * Registers language from under given code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     * @param {RawTranslationPackage} languagePackage - translation package to be registered\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     * @throws [[LanguageAlreadyRegisteredError]] when given language is already registered\n     *\n     * @example\n     * ```js\n     * // return registered language\n     * HyperFormula.registerLanguage('plPL', plPL);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerLanguage\",\n    value: function registerLanguage(languageCode, languagePackage) {\n      validateArgToType(languageCode, 'string', 'languageCode');\n\n      if (this.registeredLanguages.has(languageCode)) {\n        throw new LanguageAlreadyRegisteredError();\n      } else {\n        this.registeredLanguages.set(languageCode, buildTranslationPackage(languagePackage));\n      }\n    }\n    /**\n     * Unregisters language that is registered under given code string.\n     *\n     * @param {string} languageCode - code string of the translation package\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[LanguageNotRegisteredError]] when given language is not registered\n     *\n     * @example\n     * ```js\n     * // register the language for the instance\n     * HyperFormula.registerLanguage('plPL', plPL);\n     *\n     * // unregister plPL\n     * HyperFormula.unregisterLanguage('plPL');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterLanguage\",\n    value: function unregisterLanguage(languageCode) {\n      validateArgToType(languageCode, 'string', 'languageCode');\n\n      if (this.registeredLanguages.has(languageCode)) {\n        this.registeredLanguages.delete(languageCode);\n      } else {\n        throw new LanguageNotRegisteredError();\n      }\n    }\n    /**\n     * Returns all registered languages codes.\n     *\n     * @example\n     * ```js\n     * // should return all registered language codes: ['enGB', 'plPL']\n     * const registeredLangugaes = HyperFormula.getRegisteredLanguagesCodes();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getRegisteredLanguagesCodes\",\n    value: function getRegisteredLanguagesCodes() {\n      return Array.from(this.registeredLanguages.keys());\n    }\n    /**\n     * Registers all functions in a given plugin with optional translations\n     *\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     * @param {FunctionTranslationsPackage} translations - optional package of function names translations\n     *\n     * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register the plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerFunctionPlugin\",\n    value: function registerFunctionPlugin(plugin, translations) {\n      FunctionRegistry.registerFunctionPlugin(plugin, translations);\n    }\n    /**\n     * Unregisters all functions defined in given plugin\n     *\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     *\n     * @example\n     * ```js\n     * // get the class of a plugin\n     * const registeredPluginClass = HyperFormula.getFunctionPlugin('EXAMPLE');\n     *\n     * // unregister all functions defined in a plugin of ID 'EXAMPLE'\n     * HyperFormula.unregisterFunctionPlugin(registeredPluginClass);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterFunctionPlugin\",\n    value: function unregisterFunctionPlugin(plugin) {\n      FunctionRegistry.unregisterFunctionPlugin(plugin);\n    }\n    /**\n     * Registers a function with a given id if such exists in a plugin.\n     *\n     * @param {string} functionId - function id, e.g. 'SUMIF'\n     * @param {FunctionPluginDefinition} plugin - plugin class\n     * @param translations\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     * @throws [[FunctionPluginValidationError]] when function with a given id does not exists in plugin or plugin class definition is not consistent with metadata\n     * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a function\n     * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"registerFunction\",\n    value: function registerFunction(functionId, plugin, translations) {\n      validateArgToType(functionId, 'string', 'functionId');\n      FunctionRegistry.registerFunction(functionId, plugin, translations);\n    }\n    /**\n     * Unregisters a function with a given id\n     *\n     * @param {string} functionId - function id, e.g. 'SUMIF'\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a function\n     * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);\n     *\n     * // unregister a function\n     * HyperFormula.unregisterFunction('EXAMPLE');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterFunction\",\n    value: function unregisterFunction(functionId) {\n      validateArgToType(functionId, 'string', 'functionId');\n      FunctionRegistry.unregisterFunction(functionId);\n    }\n    /**\n     * Clears function registry\n     *\n     * @example\n     * ```js\n     * HyperFormula.unregisterAllFunctions();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"unregisterAllFunctions\",\n    value: function unregisterAllFunctions() {\n      FunctionRegistry.unregisterAll();\n    }\n    /**\n     * Returns translated names of all registered functions for a given language\n     *\n     * @param {string} code - language code\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // return a list of function names registered for enGB\n     * const allNames = HyperFormula.getRegisteredFunctionNames('enGB');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getRegisteredFunctionNames\",\n    value: function getRegisteredFunctionNames(code) {\n      validateArgToType(code, 'string', 'code');\n      var functionIds = FunctionRegistry.getRegisteredFunctionIds();\n      var language = this.getLanguage(code);\n      return language.getFunctionTranslations(functionIds);\n    }\n    /**\n     * Returns class of a plugin used by function with given id\n     *\n     * @param {string} functionId - id of a function, e.g. 'SUMIF'\n     *\n     * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type\n     *\n     * @example\n     * ```js\n     * // import your own plugin\n     * import { MyExamplePlugin } from './file_with_your_plugin';\n     *\n     * // register a plugin\n     * HyperFormula.registerFunctionPlugin(MyExamplePlugin);\n     *\n     * // return the class of a given plugin\n     * const myFunctionClass = HyperFormula.getFunctionPlugin('EXAMPLE');\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getFunctionPlugin\",\n    value: function getFunctionPlugin(functionId) {\n      validateArgToType(functionId, 'string', 'functionId');\n      return FunctionRegistry.getFunctionPlugin(functionId);\n    }\n    /**\n     * Returns classes of all plugins registered in this instance of HyperFormula\n     *\n     * @example\n     * ```js\n     * // return classes of all plugins\n     * const allClasses = HyperFormula.getAllFunctionPlugins();\n     * ```\n     *\n     * @category Static Methods\n     */\n\n  }, {\n    key: \"getAllFunctionPlugins\",\n    value: function getAllFunctionPlugins() {\n      return FunctionRegistry.getPlugins();\n    }\n  }]);\n\n  return HyperFormula;\n}();\n/**\n * Version of the HyperFormula.\n *\n * @category Static Properties\n */\n\nHyperFormula.version = \"1.1.0\";\n/**\n * Latest build date.\n *\n * @category Static Properties\n */\n\nHyperFormula.buildDate = \"12/08/2021 10:43:28\";\n/**\n * A release date.\n *\n * @category Static Properties\n */\n\nHyperFormula.releaseDate = \"12/08/2021\";\n/**\n * Contains all available languages to use in registerLanguage.\n *\n * @category Static Properties\n */\n\nHyperFormula.languages = {};\nHyperFormula.registeredLanguages = new Map();"]},"metadata":{},"sourceType":"module"}