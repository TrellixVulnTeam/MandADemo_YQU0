{"ast":null,"code":"import { uniq, map, flatten } from \"../../utils/utils\";\nimport { NonTerminal, Terminal } from \"./gast/gast_public\";\nimport { isBranchingProd, isOptionalProd, isSequenceProd } from \"./gast/gast\";\nexport function first(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first(prod.referencedRule);\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(prod);\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function firstForSequence(prod) {\n  var firstSet = [];\n  var seq = prod.definition;\n  var nextSubProdIdx = 0;\n  var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  var currSubProd; // so we enter the loop at least once (if the definition is not empty\n\n  var isLastInnerProdOptional = true; // scan a sequence until it's end or until we have found a NONE optional production in it\n\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n\n  return uniq(firstSet);\n}\nexport function firstForBranching(prod) {\n  var allAlternativesFirsts = map(prod.definition, function (innerProd) {\n    return first(innerProd);\n  });\n  return uniq(flatten(allAlternativesFirsts));\n}\nexport function firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/grammar/first.js"],"names":["uniq","map","flatten","NonTerminal","Terminal","isBranchingProd","isOptionalProd","isSequenceProd","first","prod","referencedRule","firstForTerminal","firstForSequence","firstForBranching","Error","firstSet","seq","definition","nextSubProdIdx","hasInnerProdsRemaining","length","currSubProd","isLastInnerProdOptional","concat","allAlternativesFirsts","innerProd","terminal","terminalType"],"mappings":"AAAA,SAASA,IAAT,EAAeC,GAAf,EAAoBC,OAApB,QAAmC,mBAAnC;AACA,SAASC,WAAT,EAAsBC,QAAtB,QAAsC,oBAAtC;AACA,SAASC,eAAT,EAA0BC,cAA1B,EAA0CC,cAA1C,QAAgE,aAAhE;AACA,OAAO,SAASC,KAAT,CAAeC,IAAf,EAAqB;AACxB;AACA,MAAIA,IAAI,YAAYN,WAApB,EAAiC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAOK,KAAK,CAACC,IAAI,CAACC,cAAN,CAAZ;AACH,GAVD,MAWK,IAAID,IAAI,YAAYL,QAApB,EAA8B;AAC/B,WAAOO,gBAAgB,CAACF,IAAD,CAAvB;AACH,GAFI,MAGA,IAAIF,cAAc,CAACE,IAAD,CAAlB,EAA0B;AAC3B,WAAOG,gBAAgB,CAACH,IAAD,CAAvB;AACH,GAFI,MAGA,IAAIJ,eAAe,CAACI,IAAD,CAAnB,EAA2B;AAC5B,WAAOI,iBAAiB,CAACJ,IAAD,CAAxB;AACH,GAFI,MAGA;AACD,UAAMK,KAAK,CAAC,sBAAD,CAAX;AACH;AACJ;AACD,OAAO,SAASF,gBAAT,CAA0BH,IAA1B,EAAgC;AACnC,MAAIM,QAAQ,GAAG,EAAf;AACA,MAAIC,GAAG,GAAGP,IAAI,CAACQ,UAAf;AACA,MAAIC,cAAc,GAAG,CAArB;AACA,MAAIC,sBAAsB,GAAGH,GAAG,CAACI,MAAJ,GAAaF,cAA1C;AACA,MAAIG,WAAJ,CALmC,CAMnC;;AACA,MAAIC,uBAAuB,GAAG,IAA9B,CAPmC,CAQnC;;AACA,SAAOH,sBAAsB,IAAIG,uBAAjC,EAA0D;AACtDD,IAAAA,WAAW,GAAGL,GAAG,CAACE,cAAD,CAAjB;AACAI,IAAAA,uBAAuB,GAAGhB,cAAc,CAACe,WAAD,CAAxC;AACAN,IAAAA,QAAQ,GAAGA,QAAQ,CAACQ,MAAT,CAAgBf,KAAK,CAACa,WAAD,CAArB,CAAX;AACAH,IAAAA,cAAc,GAAGA,cAAc,GAAG,CAAlC;AACAC,IAAAA,sBAAsB,GAAGH,GAAG,CAACI,MAAJ,GAAaF,cAAtC;AACH;;AACD,SAAOlB,IAAI,CAACe,QAAD,CAAX;AACH;AACD,OAAO,SAASF,iBAAT,CAA2BJ,IAA3B,EAAiC;AACpC,MAAIe,qBAAqB,GAAGvB,GAAG,CAACQ,IAAI,CAACQ,UAAN,EAAkB,UAAUQ,SAAV,EAAqB;AAClE,WAAOjB,KAAK,CAACiB,SAAD,CAAZ;AACH,GAF8B,CAA/B;AAGA,SAAOzB,IAAI,CAACE,OAAO,CAACsB,qBAAD,CAAR,CAAX;AACH;AACD,OAAO,SAASb,gBAAT,CAA0Be,QAA1B,EAAoC;AACvC,SAAO,CAACA,QAAQ,CAACC,YAAV,CAAP;AACH","sourcesContent":["import { uniq, map, flatten } from \"../../utils/utils\";\nimport { NonTerminal, Terminal } from \"./gast/gast_public\";\nimport { isBranchingProd, isOptionalProd, isSequenceProd } from \"./gast/gast\";\nexport function first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if (isSequenceProd(prod)) {\n        return firstForSequence(prod);\n    }\n    else if (isBranchingProd(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function firstForSequence(prod) {\n    var firstSet = [];\n    var seq = prod.definition;\n    var nextSubProdIdx = 0;\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    var currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    var isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return uniq(firstSet);\n}\nexport function firstForBranching(prod) {\n    var allAlternativesFirsts = map(prod.definition, function (innerProd) {\n        return first(innerProd);\n    });\n    return uniq(flatten(allAlternativesFirsts));\n}\nexport function firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\n//# sourceMappingURL=first.js.map"]},"metadata":{},"sourceType":"module"}