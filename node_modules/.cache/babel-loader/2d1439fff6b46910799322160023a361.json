{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { absoluteSheetReference, invalidSimpleColumnAddress, simpleColumnAddress } from '../Cell';\nimport { columnIndexToLabel } from './addressRepresentationConverters';\nexport var ReferenceType;\n\n(function (ReferenceType) {\n  ReferenceType[\"RELATIVE\"] = \"RELATIVE\";\n  ReferenceType[\"ABSOLUTE\"] = \"ABSOLUTE\";\n})(ReferenceType || (ReferenceType = {}));\n\nexport var ColumnAddress = /*#__PURE__*/function () {\n  function ColumnAddress(sheet, col, type) {\n    _classCallCheck(this, ColumnAddress);\n\n    this.sheet = sheet;\n    this.col = col;\n    this.type = type;\n  }\n\n  _createClass(ColumnAddress, [{\n    key: \"isColumnAbsolute\",\n    value: function isColumnAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE;\n    }\n  }, {\n    key: \"isColumnRelative\",\n    value: function isColumnRelative() {\n      return this.type === ReferenceType.RELATIVE;\n    }\n  }, {\n    key: \"isAbsolute\",\n    value: function isAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE && this.sheet !== null;\n    }\n  }, {\n    key: \"moved\",\n    value: function moved(toSheet, toRight, _toBottom) {\n      var newSheet = this.sheet === null ? null : toSheet;\n      return new ColumnAddress(newSheet, this.col + toRight, this.type);\n    }\n  }, {\n    key: \"shiftedByColumns\",\n    value: function shiftedByColumns(numberOfColumns) {\n      return new ColumnAddress(this.sheet, this.col + numberOfColumns, this.type);\n    }\n  }, {\n    key: \"toSimpleColumnAddress\",\n    value: function toSimpleColumnAddress(baseAddress) {\n      var sheet = absoluteSheetReference(this, baseAddress);\n      var column = this.col;\n\n      if (this.isColumnRelative()) {\n        column = baseAddress.col + this.col;\n      }\n\n      return simpleColumnAddress(sheet, column);\n    }\n  }, {\n    key: \"shiftRelativeDimensions\",\n    value: function shiftRelativeDimensions(toRight, _toBottom) {\n      var col = this.isColumnRelative() ? this.col + toRight : this.col;\n      return new ColumnAddress(this.sheet, col, this.type);\n    }\n  }, {\n    key: \"shiftAbsoluteDimensions\",\n    value: function shiftAbsoluteDimensions(toRight, _toBottom) {\n      var col = this.isColumnAbsolute() ? this.col + toRight : this.col;\n      return new ColumnAddress(this.sheet, col, this.type);\n    }\n  }, {\n    key: \"withAbsoluteSheet\",\n    value: function withAbsoluteSheet(sheet) {\n      return new ColumnAddress(sheet, this.col, this.type);\n    }\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid(baseAddress) {\n      return this.toSimpleColumnAddress(baseAddress).col < 0;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(withSheet) {\n      var sheetPart = withSheet && this.sheet !== null ? \"#\".concat(this.sheet) : '';\n\n      switch (this.type) {\n        case ReferenceType.RELATIVE:\n          {\n            return \"\".concat(sheetPart, \"#COLR\").concat(this.col);\n          }\n\n        case ReferenceType.ABSOLUTE:\n          {\n            return \"\".concat(sheetPart, \"#COLA\").concat(this.col);\n          }\n      }\n    }\n  }, {\n    key: \"unparse\",\n    value: function unparse(baseAddress) {\n      var simpleAddress = this.toSimpleColumnAddress(baseAddress);\n\n      if (invalidSimpleColumnAddress(simpleAddress)) {\n        return undefined;\n      }\n\n      var column = columnIndexToLabel(simpleAddress.col);\n      var dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n      return \"\".concat(dollar).concat(column);\n    }\n  }, {\n    key: \"exceedsSheetSizeLimits\",\n    value: function exceedsSheetSizeLimits(maxColumns) {\n      return this.col >= maxColumns;\n    }\n  }], [{\n    key: \"absolute\",\n    value: function absolute(sheet, column) {\n      return new ColumnAddress(sheet, column, ReferenceType.ABSOLUTE);\n    }\n  }, {\n    key: \"relative\",\n    value: function relative(sheet, column) {\n      return new ColumnAddress(sheet, column, ReferenceType.RELATIVE);\n    }\n  }]);\n\n  return ColumnAddress;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/ColumnAddress.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","absoluteSheetReference","invalidSimpleColumnAddress","simpleColumnAddress","columnIndexToLabel","ReferenceType","ColumnAddress","sheet","col","type","value","isColumnAbsolute","ABSOLUTE","isColumnRelative","RELATIVE","isAbsolute","moved","toSheet","toRight","_toBottom","newSheet","shiftedByColumns","numberOfColumns","toSimpleColumnAddress","baseAddress","column","shiftRelativeDimensions","shiftAbsoluteDimensions","withAbsoluteSheet","isInvalid","hash","withSheet","sheetPart","concat","unparse","simpleAddress","undefined","dollar","exceedsSheetSizeLimits","maxColumns","absolute","relative"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.concat.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { absoluteSheetReference, invalidSimpleColumnAddress, simpleColumnAddress } from '../Cell';\nimport { columnIndexToLabel } from './addressRepresentationConverters';\nexport var ReferenceType;\n\n(function (ReferenceType) {\n  ReferenceType[\"RELATIVE\"] = \"RELATIVE\";\n  ReferenceType[\"ABSOLUTE\"] = \"ABSOLUTE\";\n})(ReferenceType || (ReferenceType = {}));\n\nexport var ColumnAddress = /*#__PURE__*/function () {\n  function ColumnAddress(sheet, col, type) {\n    _classCallCheck(this, ColumnAddress);\n\n    this.sheet = sheet;\n    this.col = col;\n    this.type = type;\n  }\n\n  _createClass(ColumnAddress, [{\n    key: \"isColumnAbsolute\",\n    value: function isColumnAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE;\n    }\n  }, {\n    key: \"isColumnRelative\",\n    value: function isColumnRelative() {\n      return this.type === ReferenceType.RELATIVE;\n    }\n  }, {\n    key: \"isAbsolute\",\n    value: function isAbsolute() {\n      return this.type === ReferenceType.ABSOLUTE && this.sheet !== null;\n    }\n  }, {\n    key: \"moved\",\n    value: function moved(toSheet, toRight, _toBottom) {\n      var newSheet = this.sheet === null ? null : toSheet;\n      return new ColumnAddress(newSheet, this.col + toRight, this.type);\n    }\n  }, {\n    key: \"shiftedByColumns\",\n    value: function shiftedByColumns(numberOfColumns) {\n      return new ColumnAddress(this.sheet, this.col + numberOfColumns, this.type);\n    }\n  }, {\n    key: \"toSimpleColumnAddress\",\n    value: function toSimpleColumnAddress(baseAddress) {\n      var sheet = absoluteSheetReference(this, baseAddress);\n      var column = this.col;\n\n      if (this.isColumnRelative()) {\n        column = baseAddress.col + this.col;\n      }\n\n      return simpleColumnAddress(sheet, column);\n    }\n  }, {\n    key: \"shiftRelativeDimensions\",\n    value: function shiftRelativeDimensions(toRight, _toBottom) {\n      var col = this.isColumnRelative() ? this.col + toRight : this.col;\n      return new ColumnAddress(this.sheet, col, this.type);\n    }\n  }, {\n    key: \"shiftAbsoluteDimensions\",\n    value: function shiftAbsoluteDimensions(toRight, _toBottom) {\n      var col = this.isColumnAbsolute() ? this.col + toRight : this.col;\n      return new ColumnAddress(this.sheet, col, this.type);\n    }\n  }, {\n    key: \"withAbsoluteSheet\",\n    value: function withAbsoluteSheet(sheet) {\n      return new ColumnAddress(sheet, this.col, this.type);\n    }\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid(baseAddress) {\n      return this.toSimpleColumnAddress(baseAddress).col < 0;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(withSheet) {\n      var sheetPart = withSheet && this.sheet !== null ? \"#\".concat(this.sheet) : '';\n\n      switch (this.type) {\n        case ReferenceType.RELATIVE:\n          {\n            return \"\".concat(sheetPart, \"#COLR\").concat(this.col);\n          }\n\n        case ReferenceType.ABSOLUTE:\n          {\n            return \"\".concat(sheetPart, \"#COLA\").concat(this.col);\n          }\n      }\n    }\n  }, {\n    key: \"unparse\",\n    value: function unparse(baseAddress) {\n      var simpleAddress = this.toSimpleColumnAddress(baseAddress);\n\n      if (invalidSimpleColumnAddress(simpleAddress)) {\n        return undefined;\n      }\n\n      var column = columnIndexToLabel(simpleAddress.col);\n      var dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n      return \"\".concat(dollar).concat(column);\n    }\n  }, {\n    key: \"exceedsSheetSizeLimits\",\n    value: function exceedsSheetSizeLimits(maxColumns) {\n      return this.col >= maxColumns;\n    }\n  }], [{\n    key: \"absolute\",\n    value: function absolute(sheet, column) {\n      return new ColumnAddress(sheet, column, ReferenceType.ABSOLUTE);\n    }\n  }, {\n    key: \"relative\",\n    value: function relative(sheet, column) {\n      return new ColumnAddress(sheet, column, ReferenceType.RELATIVE);\n    }\n  }]);\n\n  return ColumnAddress;\n}();"]},"metadata":{},"sourceType":"module"}