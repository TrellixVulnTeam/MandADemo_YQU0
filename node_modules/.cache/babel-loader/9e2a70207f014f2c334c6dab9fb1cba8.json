{"ast":null,"code":"import { forEach, has, isArray, isFunction, peek, some } from \"../../../utils/utils\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"../../grammar/gast/gast_public\";\nimport { Lexer } from \"../../../scan/lexer_public\";\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\";\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\";\nimport { END_OF_FILE } from \"../parser\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\";\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = createToken({\n  name: \"RECORDING_PHASE_TOKEN\",\n  pattern: Lexer.NA\n});\naugmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" + \"\" + \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\", // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" + \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\n\nvar GastRecorder = function () {\n  function GastRecorder() {}\n\n  GastRecorder.prototype.initGastRecorder = function (config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  };\n\n  GastRecorder.prototype.enableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", function () {\n      var _loop_1 = function (i) {\n        var idx = i > 0 ? i : \"\";\n\n        _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"OPTION\" + idx] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n\n        _this[\"OR\" + idx] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n\n        _this[\"MANY\" + idx] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n\n        _this[\"MANY_SEP\" + idx] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      };\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n\n\n      for (var i = 0; i < 10; i++) {\n        _loop_1(i);\n      } // DSL methods with the idx(suffix) as an argument\n\n\n      _this[\"consume\"] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"subrule\"] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"option\"] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n\n      _this[\"or\"] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n\n      _this[\"many\"] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n\n      _this[\"atLeastOne\"] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n\n      _this.ACTION = _this.ACTION_RECORD;\n      _this.BACKTRACK = _this.BACKTRACK_RECORD;\n      _this.LA = _this.LA_RECORD;\n    });\n  };\n\n  GastRecorder.prototype.disableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = false; // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n\n    this.TRACE_INIT(\"Deleting Recording methods\", function () {\n      for (var i = 0; i < 10; i++) {\n        var idx = i > 0 ? i : \"\";\n        delete _this[\"CONSUME\" + idx];\n        delete _this[\"SUBRULE\" + idx];\n        delete _this[\"OPTION\" + idx];\n        delete _this[\"OR\" + idx];\n        delete _this[\"MANY\" + idx];\n        delete _this[\"MANY_SEP\" + idx];\n        delete _this[\"AT_LEAST_ONE\" + idx];\n        delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n      }\n\n      delete _this[\"consume\"];\n      delete _this[\"subrule\"];\n      delete _this[\"option\"];\n      delete _this[\"or\"];\n      delete _this[\"many\"];\n      delete _this[\"atLeastOne\"];\n      delete _this.ACTION;\n      delete _this.BACKTRACK;\n      delete _this.LA;\n    });\n  }; // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n\n\n  GastRecorder.prototype.ACTION_RECORD = function (impl) {\n    // NO-OP during recording\n    return;\n  }; // Executing backtracking logic will break our recording logic assumptions\n\n\n  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n    return function () {\n      return true;\n    };\n  }; // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n\n\n  GastRecorder.prototype.LA_RECORD = function (howMuch) {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE;\n  };\n\n  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n    try {\n      var newTopLevelRule = new Rule({\n        definition: [],\n        name: name\n      });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' + \"https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n\n      throw originalError;\n    }\n  }; // Implementation of parsing DSL\n\n\n  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  };\n\n  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = peek(this.recordingProdStack);\n    var ruleName = ruleToCall[\"ruleName\"];\n    var newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  };\n\n  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!hasShortKeyProperty(tokType)) {\n      var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = peek(this.recordingProdStack);\n    var newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  };\n\n  return GastRecorder;\n}();\n\nexport { GastRecorder };\n\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n  if (handleSep === void 0) {\n    handleSep = false;\n  }\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = peek(this.recordingProdStack);\n  var grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  var newProd = new prodConstructor({\n    definition: [],\n    idx: occurrence\n  });\n\n  if (has(mainProdArg, \"NAME\")) {\n    newProd.name = mainProdArg.NAME;\n  }\n\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction recordOrProd(mainProdArg, occurrence) {\n  var _this = this;\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = peek(this.recordingProdStack); // Only an array of alternatives\n\n  var hasOptions = isArray(mainProdArg) === false;\n  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  var newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n\n  if (has(mainProdArg, \"NAME\")) {\n    newOrProd.name = mainProdArg.NAME;\n  }\n\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  var hasPredicates = some(alts, function (currAlt) {\n    return isFunction(currAlt.GATE);\n  });\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  forEach(alts, function (currAlt) {\n    var currAltFlat = new Flat({\n      definition: []\n    });\n    newOrProd.definition.push(currAltFlat);\n\n    if (has(currAlt, \"NAME\")) {\n      currAltFlat.name = currAlt.NAME;\n    }\n\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    } // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n\n    _this.recordingProdStack.push(currAltFlat);\n\n    currAlt.ALT.call(_this);\n\n    _this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : \"\" + idx;\n}\n\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    var error = new Error( // The stack trace will contain all the needed details\n    \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" + (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js"],"names":["forEach","has","isArray","isFunction","peek","some","Alternation","Flat","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Rule","Terminal","Lexer","augmentTokenTypes","hasShortKeyProperty","createToken","createTokenInstance","END_OF_FILE","BITS_FOR_OCCURRENCE_IDX","RECORDING_NULL_OBJECT","description","Object","freeze","HANDLE_SEPARATOR","MAX_METHOD_IDX","Math","pow","RFT","name","pattern","NA","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","children","GastRecorder","prototype","initGastRecorder","config","recordingProdStack","RECORDING_PHASE","enableRecording","_this","TRACE_INIT","_loop_1","i","idx","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION","ACTION_RECORD","BACKTRACK","BACKTRACK_RECORD","LA","LA_RECORD","disableRecording","impl","grammarRule","args","howMuch","topLevelRuleRecord","def","newTopLevelRule","definition","push","call","pop","originalError","KNOWN_RECORDER_ERROR","message","mutabilityError","actionORMethodDef","occurrence","recordProd","options","altsOrOpts","recordOrProd","ruleToCall","assertMethodIdxIsValid","error","Error","getIdxSuffix","JSON","stringify","prevProd","ruleName","newNoneTerminal","nonTerminalName","referencedRule","undefined","outputCst","tokType","terminalType","prodConstructor","mainProdArg","handleSep","grammarAction","DEF","newProd","NAME","separator","SEP","maxLookahead","MAX_LOOKAHEAD","hasOptions","alts","newOrProd","ignoreAmbiguities","IGNORE_AMBIGUITIES","hasPredicates","currAlt","GATE","currAltFlat","ALT"],"mappings":"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","sourcesContent":["import { forEach, has, isArray, isFunction, peek, some } from \"../../../utils/utils\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"../../grammar/gast/gast_public\";\nimport { Lexer } from \"../../../scan/lexer_public\";\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\";\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\";\nimport { END_OF_FILE } from \"../parser\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\";\nvar RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */ (function () {\n    function GastRecorder() {\n    }\n    GastRecorder.prototype.initGastRecorder = function (config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    };\n    GastRecorder.prototype.enableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop_1 = function (i) {\n                var idx = i > 0 ? i : \"\";\n                _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                _this[\"OPTION\" + idx] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                _this[\"OR\" + idx] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                _this[\"MANY\" + idx] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                _this[\"MANY_SEP\" + idx] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            };\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (var i = 0; i < 10; i++) {\n                _loop_1(i);\n            }\n            // DSL methods with the idx(suffix) as an argument\n            _this[\"consume\"] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"subrule\"] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"option\"] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            _this[\"or\"] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            _this[\"many\"] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            _this[\"atLeastOne\"] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this.ACTION = _this.ACTION_RECORD;\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\n            _this.LA = _this.LA_RECORD;\n        });\n    };\n    GastRecorder.prototype.disableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            for (var i = 0; i < 10; i++) {\n                var idx = i > 0 ? i : \"\";\n                delete _this[\"CONSUME\" + idx];\n                delete _this[\"SUBRULE\" + idx];\n                delete _this[\"OPTION\" + idx];\n                delete _this[\"OR\" + idx];\n                delete _this[\"MANY\" + idx];\n                delete _this[\"MANY_SEP\" + idx];\n                delete _this[\"AT_LEAST_ONE\" + idx];\n                delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n            }\n            delete _this[\"consume\"];\n            delete _this[\"subrule\"];\n            delete _this[\"option\"];\n            delete _this[\"or\"];\n            delete _this[\"many\"];\n            delete _this[\"atLeastOne\"];\n            delete _this.ACTION;\n            delete _this.BACKTRACK;\n            delete _this.LA;\n        });\n    };\n    // TODO: is there any way to use this method to check no\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\n        // NO-OP during recording\n        return;\n    };\n    // Executing backtracking logic will break our recording logic assumptions\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n        return function () { return true; };\n    };\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return END_OF_FILE;\n    };\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n        try {\n            var newTopLevelRule = new Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    };\n    // Implementation of parsing DSL\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n        return recordProd.call(this, Option, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    };\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = peek(this.recordingProdStack);\n        var ruleName = ruleToCall[\"ruleName\"];\n        var newNoneTerminal = new NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst\n            ? RECORDING_PHASE_CSTNODE\n            : RECORDING_NULL_OBJECT;\n    };\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!hasShortKeyProperty(tokType)) {\n            var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = peek(this.recordingProdStack);\n        var newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    };\n    return GastRecorder;\n}());\nexport { GastRecorder };\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n    if (handleSep === void 0) { handleSep = false; }\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = peek(this.recordingProdStack);\n    var grammarAction = isFunction(mainProdArg)\n        ? mainProdArg\n        : mainProdArg.DEF;\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (has(mainProdArg, \"NAME\")) {\n        newProd.name = mainProdArg.NAME;\n    }\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    var _this = this;\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = peek(this.recordingProdStack);\n    // Only an array of alternatives\n    var hasOptions = isArray(mainProdArg) === false;\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    var newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if (has(mainProdArg, \"NAME\")) {\n        newOrProd.name = mainProdArg.NAME;\n    }\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    var hasPredicates = some(alts, function (currAlt) { return isFunction(currAlt.GATE); });\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    forEach(alts, function (currAlt) {\n        var currAltFlat = new Flat({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if (has(currAlt, \"NAME\")) {\n            currAltFlat.name = currAlt.NAME;\n        }\n        if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if (has(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        _this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this);\n        _this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : \"\" + idx;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error(\n        // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" +\n            (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX +\n                1)));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map"]},"metadata":{},"sourceType":"module"}