{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport \"regenerator-runtime/runtime.js\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n/*\n * A class representing a set of rows in specific sheet\n */\n\n\nexport var RowsSpan = /*#__PURE__*/function () {\n  function RowsSpan(sheet, rowStart, rowEnd) {\n    _classCallCheck(this, RowsSpan);\n\n    this.sheet = sheet;\n    this.rowStart = rowStart;\n    this.rowEnd = rowEnd;\n\n    if (rowStart < 0) {\n      throw Error('Starting row cant be less than 0');\n    }\n\n    if (rowEnd < rowStart) {\n      throw Error('Row span cant end before start');\n    }\n  }\n\n  _createClass(RowsSpan, [{\n    key: \"numberOfRows\",\n    get: function get() {\n      return this.rowEnd - this.rowStart + 1;\n    }\n  }, {\n    key: \"rows\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function rows() {\n      var col;\n      return _regeneratorRuntime.wrap(function rows$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              col = this.rowStart;\n\n            case 1:\n              if (!(col <= this.rowEnd)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 4;\n              return col;\n\n            case 4:\n              ++col;\n              _context.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, rows, this);\n    })\n  }, {\n    key: \"intersect\",\n    value: function intersect(otherSpan) {\n      if (this.sheet !== otherSpan.sheet) {\n        throw Error('Can\\'t intersect spans from different sheets');\n      }\n\n      var start = Math.max(this.rowStart, otherSpan.rowStart);\n      var end = Math.min(this.rowEnd, otherSpan.rowEnd);\n\n      if (start > end) {\n        return null;\n      }\n\n      return new RowsSpan(this.sheet, start, end);\n    }\n  }, {\n    key: \"firstRow\",\n    value: function firstRow() {\n      return new RowsSpan(this.sheet, this.rowStart, this.rowStart);\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.rowStart;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.rowEnd;\n    }\n  }], [{\n    key: \"fromNumberOfRows\",\n    value: function fromNumberOfRows(sheet, rowStart, numberOfRows) {\n      return new RowsSpan(sheet, rowStart, rowStart + numberOfRows - 1);\n    }\n  }, {\n    key: \"fromRowStartAndEnd\",\n    value: function fromRowStartAndEnd(sheet, rowStart, rowEnd) {\n      return new RowsSpan(sheet, rowStart, rowEnd);\n    }\n  }]);\n\n  return RowsSpan;\n}();\n/*\n * A class representing a set of columns in specific sheet\n */\n\nexport var ColumnsSpan = /*#__PURE__*/function () {\n  function ColumnsSpan(sheet, columnStart, columnEnd) {\n    _classCallCheck(this, ColumnsSpan);\n\n    this.sheet = sheet;\n    this.columnStart = columnStart;\n    this.columnEnd = columnEnd;\n\n    if (columnStart < 0) {\n      throw Error('Starting column cant be less than 0');\n    }\n\n    if (columnEnd < columnStart) {\n      throw Error('Column span cant end before start');\n    }\n  }\n\n  _createClass(ColumnsSpan, [{\n    key: \"numberOfColumns\",\n    get: function get() {\n      return this.columnEnd - this.columnStart + 1;\n    }\n  }, {\n    key: \"columns\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function columns() {\n      var col;\n      return _regeneratorRuntime.wrap(function columns$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              col = this.columnStart;\n\n            case 1:\n              if (!(col <= this.columnEnd)) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 4;\n              return col;\n\n            case 4:\n              ++col;\n              _context2.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, columns, this);\n    })\n  }, {\n    key: \"intersect\",\n    value: function intersect(otherSpan) {\n      if (this.sheet !== otherSpan.sheet) {\n        throw Error('Can\\'t intersect spans from different sheets');\n      }\n\n      var start = Math.max(this.columnStart, otherSpan.columnStart);\n      var end = Math.min(this.columnEnd, otherSpan.columnEnd);\n\n      if (start > end) {\n        return null;\n      }\n\n      return new ColumnsSpan(this.sheet, start, end);\n    }\n  }, {\n    key: \"firstColumn\",\n    value: function firstColumn() {\n      return new ColumnsSpan(this.sheet, this.columnStart, this.columnStart);\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.columnStart;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.columnEnd;\n    }\n  }], [{\n    key: \"fromNumberOfColumns\",\n    value: function fromNumberOfColumns(sheet, columnStart, numberOfColumns) {\n      return new ColumnsSpan(sheet, columnStart, columnStart + numberOfColumns - 1);\n    }\n  }, {\n    key: \"fromColumnStartAndEnd\",\n    value: function fromColumnStartAndEnd(sheet, columnStart, columnEnd) {\n      return new ColumnsSpan(sheet, columnStart, columnEnd);\n    }\n  }]);\n\n  return ColumnsSpan;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/Span.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","RowsSpan","sheet","rowStart","rowEnd","Error","get","value","mark","rows","col","wrap","rows$","_context","prev","next","stop","intersect","otherSpan","start","Math","max","end","min","firstRow","fromNumberOfRows","numberOfRows","fromRowStartAndEnd","ColumnsSpan","columnStart","columnEnd","columns","columns$","_context2","firstColumn","fromNumberOfColumns","numberOfColumns","fromColumnStartAndEnd"],"mappings":"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","sourcesContent":["import \"regenerator-runtime/runtime.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n/*\n * A class representing a set of rows in specific sheet\n */\nexport var RowsSpan = /*#__PURE__*/function () {\n  function RowsSpan(sheet, rowStart, rowEnd) {\n    _classCallCheck(this, RowsSpan);\n\n    this.sheet = sheet;\n    this.rowStart = rowStart;\n    this.rowEnd = rowEnd;\n\n    if (rowStart < 0) {\n      throw Error('Starting row cant be less than 0');\n    }\n\n    if (rowEnd < rowStart) {\n      throw Error('Row span cant end before start');\n    }\n  }\n\n  _createClass(RowsSpan, [{\n    key: \"numberOfRows\",\n    get: function get() {\n      return this.rowEnd - this.rowStart + 1;\n    }\n  }, {\n    key: \"rows\",\n    value: /*#__PURE__*/regeneratorRuntime.mark(function rows() {\n      var col;\n      return regeneratorRuntime.wrap(function rows$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              col = this.rowStart;\n\n            case 1:\n              if (!(col <= this.rowEnd)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 4;\n              return col;\n\n            case 4:\n              ++col;\n              _context.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, rows, this);\n    })\n  }, {\n    key: \"intersect\",\n    value: function intersect(otherSpan) {\n      if (this.sheet !== otherSpan.sheet) {\n        throw Error('Can\\'t intersect spans from different sheets');\n      }\n\n      var start = Math.max(this.rowStart, otherSpan.rowStart);\n      var end = Math.min(this.rowEnd, otherSpan.rowEnd);\n\n      if (start > end) {\n        return null;\n      }\n\n      return new RowsSpan(this.sheet, start, end);\n    }\n  }, {\n    key: \"firstRow\",\n    value: function firstRow() {\n      return new RowsSpan(this.sheet, this.rowStart, this.rowStart);\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.rowStart;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.rowEnd;\n    }\n  }], [{\n    key: \"fromNumberOfRows\",\n    value: function fromNumberOfRows(sheet, rowStart, numberOfRows) {\n      return new RowsSpan(sheet, rowStart, rowStart + numberOfRows - 1);\n    }\n  }, {\n    key: \"fromRowStartAndEnd\",\n    value: function fromRowStartAndEnd(sheet, rowStart, rowEnd) {\n      return new RowsSpan(sheet, rowStart, rowEnd);\n    }\n  }]);\n\n  return RowsSpan;\n}();\n/*\n * A class representing a set of columns in specific sheet\n */\n\nexport var ColumnsSpan = /*#__PURE__*/function () {\n  function ColumnsSpan(sheet, columnStart, columnEnd) {\n    _classCallCheck(this, ColumnsSpan);\n\n    this.sheet = sheet;\n    this.columnStart = columnStart;\n    this.columnEnd = columnEnd;\n\n    if (columnStart < 0) {\n      throw Error('Starting column cant be less than 0');\n    }\n\n    if (columnEnd < columnStart) {\n      throw Error('Column span cant end before start');\n    }\n  }\n\n  _createClass(ColumnsSpan, [{\n    key: \"numberOfColumns\",\n    get: function get() {\n      return this.columnEnd - this.columnStart + 1;\n    }\n  }, {\n    key: \"columns\",\n    value: /*#__PURE__*/regeneratorRuntime.mark(function columns() {\n      var col;\n      return regeneratorRuntime.wrap(function columns$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              col = this.columnStart;\n\n            case 1:\n              if (!(col <= this.columnEnd)) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 4;\n              return col;\n\n            case 4:\n              ++col;\n              _context2.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, columns, this);\n    })\n  }, {\n    key: \"intersect\",\n    value: function intersect(otherSpan) {\n      if (this.sheet !== otherSpan.sheet) {\n        throw Error('Can\\'t intersect spans from different sheets');\n      }\n\n      var start = Math.max(this.columnStart, otherSpan.columnStart);\n      var end = Math.min(this.columnEnd, otherSpan.columnEnd);\n\n      if (start > end) {\n        return null;\n      }\n\n      return new ColumnsSpan(this.sheet, start, end);\n    }\n  }, {\n    key: \"firstColumn\",\n    value: function firstColumn() {\n      return new ColumnsSpan(this.sheet, this.columnStart, this.columnStart);\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.columnStart;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.columnEnd;\n    }\n  }], [{\n    key: \"fromNumberOfColumns\",\n    value: function fromNumberOfColumns(sheet, columnStart, numberOfColumns) {\n      return new ColumnsSpan(sheet, columnStart, columnStart + numberOfColumns - 1);\n    }\n  }, {\n    key: \"fromColumnStartAndEnd\",\n    value: function fromColumnStartAndEnd(sheet, columnStart, columnEnd) {\n      return new ColumnsSpan(sheet, columnStart, columnEnd);\n    }\n  }]);\n\n  return ColumnsSpan;\n}();"]},"metadata":{},"sourceType":"module"}