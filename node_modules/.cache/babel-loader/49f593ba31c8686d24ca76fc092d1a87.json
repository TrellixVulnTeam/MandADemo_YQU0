{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AddressDependency, collectDependencies } from '../parser';\nimport { FormulaCellVertex } from './FormulaCellVertex';\nimport { MatrixVertex } from './MatrixVertex';\nimport { RangeVertex } from './RangeVertex';\nexport var collectAddressesDependentToMatrix = function collectAddressesDependentToMatrix(funcitonRegistry, vertex, matrix, lazilyTransformingAstService, dependencyGraph) {\n  var range = matrix.getRange();\n\n  if (vertex instanceof RangeVertex) {\n    var intersection = vertex.range.intersectionWith(range);\n\n    if (intersection !== null) {\n      return Array.from(intersection.addresses(dependencyGraph));\n    } else {\n      return [];\n    }\n  }\n\n  var formula;\n  var address;\n\n  if (vertex instanceof FormulaCellVertex) {\n    formula = vertex.getFormula(lazilyTransformingAstService);\n    address = vertex.getAddress(lazilyTransformingAstService);\n  } else if (vertex instanceof MatrixVertex && vertex.isFormula()) {\n    formula = vertex.getFormula();\n    address = vertex.getAddress();\n  } else {\n    return [];\n  }\n\n  return collectDependencies(formula, funcitonRegistry).filter(function (d) {\n    return d instanceof AddressDependency;\n  }).map(function (d) {\n    return d.dependency.toSimpleCellAddress(address);\n  }).filter(function (d) {\n    return range.addressInRange(d);\n  });\n};","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/DependencyGraph/collectAddressesDependentToMatrix.js"],"names":["AddressDependency","collectDependencies","FormulaCellVertex","MatrixVertex","RangeVertex","collectAddressesDependentToMatrix","funcitonRegistry","vertex","matrix","lazilyTransformingAstService","dependencyGraph","range","getRange","intersection","intersectionWith","Array","from","addresses","formula","address","getFormula","getAddress","isFormula","filter","d","map","dependency","toSimpleCellAddress","addressInRange"],"mappings":"AAKA;AACA;AACA;AACA;AACA,SAASA,iBAAT,EAA4BC,mBAA5B,QAAuD,WAAvD;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,OAAO,IAAIC,iCAAiC,GAAG,SAASA,iCAAT,CAA2CC,gBAA3C,EAA6DC,MAA7D,EAAqEC,MAArE,EAA6EC,4BAA7E,EAA2GC,eAA3G,EAA4H;AACzK,MAAIC,KAAK,GAAGH,MAAM,CAACI,QAAP,EAAZ;;AAEA,MAAIL,MAAM,YAAYH,WAAtB,EAAmC;AACjC,QAAIS,YAAY,GAAGN,MAAM,CAACI,KAAP,CAAaG,gBAAb,CAA8BH,KAA9B,CAAnB;;AAEA,QAAIE,YAAY,KAAK,IAArB,EAA2B;AACzB,aAAOE,KAAK,CAACC,IAAN,CAAWH,YAAY,CAACI,SAAb,CAAuBP,eAAvB,CAAX,CAAP;AACD,KAFD,MAEO;AACL,aAAO,EAAP;AACD;AACF;;AAED,MAAIQ,OAAJ;AACA,MAAIC,OAAJ;;AAEA,MAAIZ,MAAM,YAAYL,iBAAtB,EAAyC;AACvCgB,IAAAA,OAAO,GAAGX,MAAM,CAACa,UAAP,CAAkBX,4BAAlB,CAAV;AACAU,IAAAA,OAAO,GAAGZ,MAAM,CAACc,UAAP,CAAkBZ,4BAAlB,CAAV;AACD,GAHD,MAGO,IAAIF,MAAM,YAAYJ,YAAlB,IAAkCI,MAAM,CAACe,SAAP,EAAtC,EAA0D;AAC/DJ,IAAAA,OAAO,GAAGX,MAAM,CAACa,UAAP,EAAV;AACAD,IAAAA,OAAO,GAAGZ,MAAM,CAACc,UAAP,EAAV;AACD,GAHM,MAGA;AACL,WAAO,EAAP;AACD;;AAED,SAAOpB,mBAAmB,CAACiB,OAAD,EAAUZ,gBAAV,CAAnB,CAA+CiB,MAA/C,CAAsD,UAAUC,CAAV,EAAa;AACxE,WAAOA,CAAC,YAAYxB,iBAApB;AACD,GAFM,EAEJyB,GAFI,CAEA,UAAUD,CAAV,EAAa;AAClB,WAAOA,CAAC,CAACE,UAAF,CAAaC,mBAAb,CAAiCR,OAAjC,CAAP;AACD,GAJM,EAIJI,MAJI,CAIG,UAAUC,CAAV,EAAa;AACrB,WAAOb,KAAK,CAACiB,cAAN,CAAqBJ,CAArB,CAAP;AACD,GANM,CAAP;AAOD,CAjCM","sourcesContent":["import \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { AddressDependency, collectDependencies } from '../parser';\nimport { FormulaCellVertex } from './FormulaCellVertex';\nimport { MatrixVertex } from './MatrixVertex';\nimport { RangeVertex } from './RangeVertex';\nexport var collectAddressesDependentToMatrix = function collectAddressesDependentToMatrix(funcitonRegistry, vertex, matrix, lazilyTransformingAstService, dependencyGraph) {\n  var range = matrix.getRange();\n\n  if (vertex instanceof RangeVertex) {\n    var intersection = vertex.range.intersectionWith(range);\n\n    if (intersection !== null) {\n      return Array.from(intersection.addresses(dependencyGraph));\n    } else {\n      return [];\n    }\n  }\n\n  var formula;\n  var address;\n\n  if (vertex instanceof FormulaCellVertex) {\n    formula = vertex.getFormula(lazilyTransformingAstService);\n    address = vertex.getAddress(lazilyTransformingAstService);\n  } else if (vertex instanceof MatrixVertex && vertex.isFormula()) {\n    formula = vertex.getFormula();\n    address = vertex.getAddress();\n  } else {\n    return [];\n  }\n\n  return collectDependencies(formula, funcitonRegistry).filter(function (d) {\n    return d instanceof AddressDependency;\n  }).map(function (d) {\n    return d.dependency.toSimpleCellAddress(address);\n  }).filter(function (d) {\n    return range.addressInRange(d);\n  });\n};"]},"metadata":{},"sourceType":"module"}