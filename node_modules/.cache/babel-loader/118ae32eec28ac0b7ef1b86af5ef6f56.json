{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\n\n\nimport { EmbeddedActionsParser, EMPTY_ALT, Lexer, tokenMatcher } from 'chevrotain';\nimport { CellError, ErrorType, simpleCellAddress } from '../Cell';\nimport { ErrorMessage } from '../error-message';\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from './addressRepresentationConverters';\nimport { AstNodeType, buildArrayAst, buildCellErrorAst, buildCellRangeAst, buildCellReferenceAst, buildColumnRangeAst, buildConcatenateOpAst, buildDivOpAst, buildEmptyArgAst, buildEqualsOpAst, buildErrorWithRawInputAst, buildGreaterThanOpAst, buildGreaterThanOrEqualOpAst, buildLessThanOpAst, buildLessThanOrEqualOpAst, buildMinusOpAst, buildMinusUnaryOpAst, buildNamedExpressionAst, buildNotEqualOpAst, buildNumberAst, buildParenthesisAst, buildParsingErrorAst, buildPercentOpAst, buildPlusOpAst, buildPlusUnaryOpAst, buildPowerOpAst, buildProcedureAst, buildRowRangeAst, buildStringAst, buildTimesOpAst, parsingError as _parsingError, ParsingErrorType, RangeSheetReferenceType } from './Ast';\nimport { CellAddress, CellReferenceType } from './CellAddress';\nimport { AdditionOp, ArrayLParen, ArrayRParen, BooleanOp, CellReference, ColumnRange, ConcatenateOp, DivOp, EqualsOp, ErrorLiteral, GreaterThanOp, GreaterThanOrEqualOp, LessThanOp, LessThanOrEqualOp, LParen, MinusOp, MultiplicationOp, NamedExpression, NotEqualOp, PercentOp, PlusOp, PowerOp, ProcedureName, RangeSeparator, RowRange, RParen, StringLiteral, TimesOp, WhiteSpace } from './LexerConfig';\n/**\n * LL(k) formula parser described using Chevrotain DSL\n *\n * It is equivalent to the grammar below:\n *\n * F -> '=' E <br/>\n * B -> K < B | K >= B ... | K <br/>\n * K -> E & K | E <br/>\n * E -> M + E | M - E | M <br/>\n * M -> W * M | W / M | W <br/>\n * W -> C * W | C <br/>\n * C -> N | R | O | A | P | num <br/>\n * N -> '(' E ')' <br/>\n * R -> A:OFFSET(..) | A:A <br/>\n * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>\n * A -> A1 | $A1 | A$1 | $A$1 <br/>\n * P -> SUM(..) <br/>\n */\n\nexport var FormulaParser = /*#__PURE__*/function (_EmbeddedActionsParse) {\n  _inherits(FormulaParser, _EmbeddedActionsParse);\n\n  var _super = _createSuper(FormulaParser);\n\n  function FormulaParser(lexerConfig, sheetMapping) {\n    var _this;\n\n    _classCallCheck(this, FormulaParser);\n\n    _this = _super.call(this, lexerConfig.allTokens, {\n      outputCst: false,\n      maxLookahead: 7\n    });\n    /**\n     * Entry rule\n     */\n\n    _this.formula = _this.RULE('formula', function () {\n      _this.CONSUME(EqualsOp);\n\n      return _this.SUBRULE(_this.booleanExpression);\n    });\n    /**\n     * Rule for boolean expression (e.g. 1 <= A1)\n     */\n\n    _this.booleanExpression = _this.RULE('booleanExpression', function () {\n      var lhs = _this.SUBRULE(_this.concatenateExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(BooleanOp);\n\n        var rhs = _this.SUBRULE2(_this.concatenateExpression);\n\n        if (tokenMatcher(op, EqualsOp)) {\n          lhs = buildEqualsOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, NotEqualOp)) {\n          lhs = buildNotEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOp)) {\n          lhs = buildGreaterThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOp)) {\n          lhs = buildLessThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOrEqualOp)) {\n          lhs = buildGreaterThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOrEqualOp)) {\n          lhs = buildLessThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    _this.booleanExpressionOrEmpty = _this.RULE('booleanExpressionOrEmpty', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.booleanExpression);\n        }\n      }, {\n        ALT: EMPTY_ALT(buildEmptyArgAst())\n      }]);\n    });\n    /**\n     * Rule for concatenation operator expression (e.g. \"=\" & A1)\n     */\n\n    _this.concatenateExpression = _this.RULE('concatenateExpression', function () {\n      var lhs = _this.SUBRULE(_this.additionExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(ConcatenateOp);\n\n        var rhs = _this.SUBRULE2(_this.additionExpression);\n\n        lhs = buildConcatenateOpAst(lhs, rhs, op.leadingWhitespace);\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for addition category operators (e.g. 1 + A1, 1 - A1)\n     */\n\n    _this.additionExpression = _this.RULE('additionExpression', function () {\n      var lhs = _this.SUBRULE(_this.multiplicationExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(AdditionOp);\n\n        var rhs = _this.SUBRULE2(_this.multiplicationExpression);\n\n        if (tokenMatcher(op, PlusOp)) {\n          lhs = buildPlusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, MinusOp)) {\n          lhs = buildMinusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for multiplication category operators (e.g. 1 * A1, 1 / A1)\n     */\n\n    _this.multiplicationExpression = _this.RULE('multiplicationExpression', function () {\n      var lhs = _this.SUBRULE(_this.powerExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(MultiplicationOp);\n\n        var rhs = _this.SUBRULE2(_this.powerExpression);\n\n        if (tokenMatcher(op, TimesOp)) {\n          lhs = buildTimesOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, DivOp)) {\n          lhs = buildDivOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for power expression\n     */\n\n    _this.powerExpression = _this.RULE('powerExpression', function () {\n      var lhs = _this.SUBRULE(_this.atomicExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(PowerOp);\n\n        var rhs = _this.SUBRULE2(_this.atomicExpression);\n\n        if (tokenMatcher(op, PowerOp)) {\n          lhs = buildPowerOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for atomic expressions, which is positive atomic expression or negation of it\n     */\n\n    _this.atomicExpression = _this.RULE('atomicExpression', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          var op = _this.CONSUME(AdditionOp);\n\n          var value = _this.SUBRULE(_this.atomicExpression);\n\n          if (tokenMatcher(op, PlusOp)) {\n            return buildPlusUnaryOpAst(value, op.leadingWhitespace);\n          } else if (tokenMatcher(op, MinusOp)) {\n            return buildMinusUnaryOpAst(value, op.leadingWhitespace);\n          } else {\n            _this.customParsingError = _parsingError(ParsingErrorType.ParserError, 'Mismatched token type');\n            return _this.customParsingError;\n          }\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE2(_this.rightUnaryOpAtomicExpression);\n        }\n      }]);\n    });\n    _this.rightUnaryOpAtomicExpression = _this.RULE('rightUnaryOpAtomicExpression', function () {\n      var positiveAtomicExpression = _this.SUBRULE(_this.positiveAtomicExpression);\n\n      var percentage = _this.OPTION(function () {\n        return _this.CONSUME(PercentOp);\n      });\n\n      if (percentage) {\n        return buildPercentOpAst(positiveAtomicExpression, percentage.leadingWhitespace);\n      }\n\n      return positiveAtomicExpression;\n    });\n    /**\n     * Rule for positive atomic expressions\n     */\n\n    _this.positiveAtomicExpression = _this.RULE('positiveAtomicExpression', function () {\n      var _a;\n\n      return _this.OR((_a = _this.atomicExpCache) !== null && _a !== void 0 ? _a : _this.atomicExpCache = [{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.arrayExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.cellRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.columnRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.rowRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.offsetExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.cellReference);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.procedureExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.namedExpressionExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          var number = _this.CONSUME(_this.lexerConfig.NumberLiteral);\n\n          return buildNumberAst(_this.numericStringToNumber(number.image), number.leadingWhitespace);\n        }\n      }, {\n        ALT: function ALT() {\n          var str = _this.CONSUME(StringLiteral);\n\n          return buildStringAst(str);\n        }\n      }, {\n        ALT: function ALT() {\n          var token = _this.CONSUME(ErrorLiteral);\n\n          var errString = token.image.toUpperCase();\n          var errorType = _this.lexerConfig.errorMapping[errString];\n\n          if (errorType) {\n            return buildCellErrorAst(new CellError(errorType), token.leadingWhitespace);\n          } else {\n            return _this.parsingError(ParsingErrorType.ParserError, 'Unknown error literal');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for procedure expressions: SUM(1,A1)\n     */\n\n    _this.procedureExpression = _this.RULE('procedureExpression', function () {\n      var _a;\n\n      var procedureNameToken = _this.CONSUME(ProcedureName);\n\n      var procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);\n      var canonicalProcedureName = (_a = _this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n      var args = [];\n\n      var argument = _this.SUBRULE(_this.booleanExpressionOrEmpty);\n\n      _this.MANY(function () {\n        var _a;\n\n        var separator = _this.CONSUME(_this.lexerConfig.ArgSeparator);\n\n        if (argument.type === AstNodeType.EMPTY) {\n          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;\n        }\n\n        args.push(argument);\n        argument = _this.SUBRULE2(_this.booleanExpressionOrEmpty);\n      });\n\n      args.push(argument);\n\n      if (args.length === 1 && args[0].type === AstNodeType.EMPTY) {\n        args.length = 0;\n      }\n\n      var rParenToken = _this.CONSUME(RParen);\n\n      return buildProcedureAst(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    _this.namedExpressionExpression = _this.RULE('namedExpressionExpression', function () {\n      var name = _this.CONSUME(NamedExpression);\n\n      return buildNamedExpressionAst(name.image, name.leadingWhitespace);\n    });\n    /**\n     * Rule for expressions that start with OFFSET() function\n     *\n     * OFFSET() function can occur as cell reference or part of cell range.\n     * In order to preserve LL(k) properties, expressions that starts with OFFSET() functions needs to have separate rule.\n     *\n     * Proper {@link Ast} node type is built depending on the presence of {@link RangeSeparator}\n     */\n\n    _this.offsetExpression = _this.RULE('offsetExpression', function () {\n      var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n      var end;\n\n      _this.OPTION(function () {\n        _this.CONSUME(RangeSeparator);\n\n        if (offsetProcedure.type === AstNodeType.CELL_RANGE) {\n          end = _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n        } else {\n          end = _this.SUBRULE(_this.endOfRangeWithOffsetStartExpression, {\n            ARGS: [offsetProcedure]\n          });\n        }\n      });\n\n      if (end !== undefined) {\n        return end;\n      }\n\n      return offsetProcedure;\n    });\n    /**\n     * Rule for OFFSET() function expression\n     */\n\n    _this.offsetProcedureExpression = _this.RULE('offsetProcedureExpression', function () {\n      var args = [];\n\n      _this.CONSUME(_this.lexerConfig.OffsetProcedureName);\n\n      _this.CONSUME(LParen);\n\n      _this.MANY_SEP({\n        SEP: _this.lexerConfig.ArgSeparator,\n        DEF: function DEF() {\n          args.push(_this.SUBRULE(_this.booleanExpression));\n        }\n      });\n\n      _this.CONSUME(RParen);\n\n      return _this.handleOffsetHeuristic(args);\n    });\n    /**\n     * Rule for cell ranges (e.g. A1:B$3, A1:OFFSET())\n     */\n\n    _this.cellRangeExpression = _this.RULE('cellRangeExpression', function () {\n      var start = _this.CONSUME(CellReference);\n\n      _this.CONSUME2(RangeSeparator);\n\n      return _this.SUBRULE(_this.endOfRangeExpression, {\n        ARGS: [start]\n      });\n    });\n    /**\n     * Rule for column range, e.g. A:B, Sheet1!A:B, Sheet1!A:Sheet1!B\n     */\n\n    _this.columnRangeExpression = _this.RULE('columnRangeExpression', function () {\n      var range = _this.CONSUME(ColumnRange);\n\n      var _range$image$split = range.image.split(':'),\n          _range$image$split2 = _slicedToArray(_range$image$split, 2),\n          startImage = _range$image$split2[0],\n          endImage = _range$image$split2[1];\n\n      var start = _this.ACTION(function () {\n        return columnAddressFromString(_this.sheetMapping, startImage, _this.formulaAddress);\n      });\n\n      var end = _this.ACTION(function () {\n        return columnAddressFromString(_this.sheetMapping, endImage, _this.formulaAddress);\n      });\n\n      if (start === undefined || end === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n\n      if (start.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns) || end.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n\n      if (start.sheet === undefined && end.sheet !== undefined) {\n        return _this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = _this.rangeSheetReferenceType(start.sheet, end.sheet);\n\n      if (start.sheet !== undefined && end.sheet === undefined) {\n        end = end.withAbsoluteSheet(start.sheet);\n      }\n\n      return buildColumnRangeAst(start, end, sheetReferenceType, range.leadingWhitespace);\n    });\n    /**\n     * Rule for row range, e.g. 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2\n     */\n\n    _this.rowRangeExpression = _this.RULE('rowRangeExpression', function () {\n      var range = _this.CONSUME(RowRange);\n\n      var _range$image$split3 = range.image.split(':'),\n          _range$image$split4 = _slicedToArray(_range$image$split3, 2),\n          startImage = _range$image$split4[0],\n          endImage = _range$image$split4[1];\n\n      var start = _this.ACTION(function () {\n        return rowAddressFromString(_this.sheetMapping, startImage, _this.formulaAddress);\n      });\n\n      var end = _this.ACTION(function () {\n        return rowAddressFromString(_this.sheetMapping, endImage, _this.formulaAddress);\n      });\n\n      if (start === undefined || end === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n\n      if (start.exceedsSheetSizeLimits(_this.lexerConfig.maxRows) || end.exceedsSheetSizeLimits(_this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n\n      if (start.sheet === undefined && end.sheet !== undefined) {\n        return _this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = _this.rangeSheetReferenceType(start.sheet, end.sheet);\n\n      if (start.sheet !== undefined && end.sheet === undefined) {\n        end = end.withAbsoluteSheet(start.sheet);\n      }\n\n      return buildRowRangeAst(start, end, sheetReferenceType, range.leadingWhitespace);\n    });\n    /**\n     * Rule for cell reference expression (e.g. A1, $A1, A$1, $A$1, $Sheet42!A$17)\n     */\n\n    _this.cellReference = _this.RULE('cellReference', function () {\n      var cell = _this.CONSUME(CellReference);\n\n      var address = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, cell.image, _this.formulaAddress);\n      });\n\n      if (address === undefined) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.REF), cell.leadingWhitespace);\n      } else if (address.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.NAME), cell.leadingWhitespace);\n      } else {\n        return buildCellReferenceAst(address, cell.leadingWhitespace);\n      }\n    });\n    /**\n     * Rule for end of range expression\n     *\n     * End of range may be a cell reference or OFFSET() function call\n     */\n\n    _this.endOfRangeExpression = _this.RULE('endOfRangeExpression', function (start) {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.endRangeReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: function ALT() {\n          var _a;\n\n          var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n          var startAddress = _this.ACTION(function () {\n            return cellAddressFromString(_this.sheetMapping, start.image, _this.formulaAddress);\n          });\n\n          if (startAddress === undefined) {\n            return buildCellErrorAst(new CellError(ErrorType.REF));\n          }\n\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            var end = offsetProcedure.reference;\n            var sheetReferenceType = RangeSheetReferenceType.RELATIVE;\n\n            if (startAddress.sheet !== undefined) {\n              sheetReferenceType = RangeSheetReferenceType.START_ABSOLUTE;\n              end = end.withAbsoluteSheet(startAddress.sheet);\n            }\n\n            return buildCellRangeAst(startAddress, end, sheetReferenceType, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n          } else {\n            return _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for end of range expression\n     *\n     * End of range may be a cell reference or OFFSET() function call\n     */\n\n    _this.endOfRangeWithOffsetStartExpression = _this.RULE('endOfRangeWithOffsetStartExpression', function (start) {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.endRangeWithOffsetStartReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: function ALT() {\n          var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            var end = offsetProcedure.reference;\n            var sheetReferenceType = RangeSheetReferenceType.RELATIVE;\n\n            if (start.reference.sheet !== undefined) {\n              sheetReferenceType = RangeSheetReferenceType.START_ABSOLUTE;\n              end = end.withAbsoluteSheet(start.reference.sheet);\n            }\n\n            return buildCellRangeAst(start.reference, end, sheetReferenceType, start.leadingWhitespace);\n          } else {\n            return _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for end range reference expression with additional checks considering range start\n     */\n\n    _this.endRangeReference = _this.RULE('endRangeReference', function (start) {\n      var _a;\n\n      var end = _this.CONSUME(CellReference);\n\n      var startAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, start.image, _this.formulaAddress);\n      });\n\n      var endAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, end.image, _this.formulaAddress);\n      });\n\n      if (startAddress === undefined || endAddress === undefined) {\n        return _this.ACTION(function () {\n          return buildErrorWithRawInputAst(\"\".concat(start.image, \":\").concat(end.image), new CellError(ErrorType.REF), start.leadingWhitespace);\n        });\n      } else if (startAddress.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows)) {\n        return _this.ACTION(function () {\n          return buildErrorWithRawInputAst(\"\".concat(start.image, \":\").concat(end.image), new CellError(ErrorType.NAME), start.leadingWhitespace);\n        });\n      }\n\n      return _this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n    });\n    /**\n     * Rule for end range reference expression starting with offset procedure with additional checks considering range start\n     */\n\n    _this.endRangeWithOffsetStartReference = _this.RULE('endRangeWithOffsetStartReference', function (start) {\n      var end = _this.CONSUME(CellReference);\n\n      var endAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, end.image, _this.formulaAddress);\n      });\n\n      if (endAddress === undefined) {\n        return _this.ACTION(function () {\n          return buildCellErrorAst(new CellError(ErrorType.REF));\n        });\n      }\n\n      return _this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);\n    });\n    _this.arrayExpression = _this.RULE('arrayExpression', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          var ltoken = _this.CONSUME(ArrayLParen);\n\n          var ret = _this.SUBRULE(_this.insideArrayExpression);\n\n          var rtoken = _this.CONSUME(ArrayRParen);\n\n          return buildArrayAst(ret.args, ltoken.leadingWhitespace, rtoken.leadingWhitespace);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.parenthesisExpression);\n        }\n      }]);\n    });\n    _this.insideArrayExpression = _this.RULE('insideArrayExpression', function () {\n      var ret = [[]];\n      ret[ret.length - 1].push(_this.SUBRULE(_this.booleanExpression));\n\n      _this.MANY(function () {\n        _this.OR([{\n          ALT: function ALT() {\n            _this.CONSUME(_this.lexerConfig.ArrayColSeparator);\n\n            ret[ret.length - 1].push(_this.SUBRULE2(_this.booleanExpression));\n          }\n        }, {\n          ALT: function ALT() {\n            _this.CONSUME(_this.lexerConfig.ArrayRowSeparator);\n\n            ret.push([]);\n            ret[ret.length - 1].push(_this.SUBRULE3(_this.booleanExpression));\n          }\n        }]);\n      });\n\n      return buildArrayAst(ret);\n    });\n    /**\n     * Rule for parenthesis expression\n     */\n\n    _this.parenthesisExpression = _this.RULE('parenthesisExpression', function () {\n      var lParenToken = _this.CONSUME(LParen);\n\n      var expression = _this.SUBRULE(_this.booleanExpression);\n\n      var rParenToken = _this.CONSUME(RParen);\n\n      return buildParenthesisAst(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n\n    _this.numericStringToNumber = function (input) {\n      var normalized = input.replace(_this.lexerConfig.decimalSeparator, '.');\n      return Number(normalized);\n    };\n\n    _this.lexerConfig = lexerConfig;\n    _this.sheetMapping = sheetMapping;\n    _this.formulaAddress = simpleCellAddress(0, 0, 0);\n\n    _this.performSelfAnalysis();\n\n    return _this;\n  }\n  /**\n   * Parses tokenized formula and builds abstract syntax tree\n   *\n   * @param tokens - tokenized formula\n   * @param formulaAddress - address of the cell in which formula is located\n   */\n\n\n  _createClass(FormulaParser, [{\n    key: \"parseFromTokens\",\n    value: function parseFromTokens(tokens, formulaAddress) {\n      this.input = tokens;\n      var ast = this.formulaWithContext(formulaAddress);\n      var errors = [];\n\n      if (this.customParsingError) {\n        errors.push(this.customParsingError);\n      }\n\n      errors = errors.concat(this.errors.map(function (e) {\n        return {\n          type: ParsingErrorType.ParserError,\n          message: e.message\n        };\n      }));\n\n      if (errors.length > 0) {\n        ast = buildParsingErrorAst();\n      }\n\n      return {\n        ast: ast,\n        errors: errors\n      };\n    }\n    /**\n     * Entry rule wrapper that sets formula address\n     *\n     * @param address - address of the cell in which formula is located\n     */\n\n  }, {\n    key: \"formulaWithContext\",\n    value: function formulaWithContext(address) {\n      this.formulaAddress = address;\n      return this.formula();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(FormulaParser.prototype), \"reset\", this).call(this);\n\n      this.customParsingError = undefined;\n    }\n  }, {\n    key: \"buildCellRange\",\n    value: function buildCellRange(startAddress, endAddress, leadingWhitespace) {\n      if (startAddress.sheet === undefined && endAddress.sheet !== undefined) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = this.rangeSheetReferenceType(startAddress.sheet, endAddress.sheet);\n\n      if (startAddress.sheet !== undefined && endAddress.sheet === undefined) {\n        endAddress = endAddress.withAbsoluteSheet(startAddress.sheet);\n      }\n\n      return buildCellRangeAst(startAddress, endAddress, sheetReferenceType, leadingWhitespace);\n    }\n    /**\n     * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments\n     *\n     * @param args - OFFSET function arguments\n     */\n\n  }, {\n    key: \"handleOffsetHeuristic\",\n    value: function handleOffsetHeuristic(args) {\n      var cellArg = args[0];\n\n      if (cellArg.type !== AstNodeType.CELL_REFERENCE) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');\n      }\n\n      var rowsArg = args[1];\n      var rowShift;\n\n      if (rowsArg.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {\n        rowShift = rowsArg.value;\n      } else if (rowsArg.type === AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n        rowShift = rowsArg.value.value;\n      } else if (rowsArg.type === AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n        rowShift = -rowsArg.value.value;\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');\n      }\n\n      var columnsArg = args[2];\n      var colShift;\n\n      if (columnsArg.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {\n        colShift = columnsArg.value;\n      } else if (columnsArg.type === AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n        colShift = columnsArg.value.value;\n      } else if (columnsArg.type === AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n        colShift = -columnsArg.value.value;\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');\n      }\n\n      var heightArg = args[3];\n      var height;\n\n      if (heightArg === undefined) {\n        height = 1;\n      } else if (heightArg.type === AstNodeType.NUMBER) {\n        height = heightArg.value;\n\n        if (height < 1) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');\n        } else if (!Number.isInteger(height)) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');\n        }\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');\n      }\n\n      var widthArg = args[4];\n      var width;\n\n      if (widthArg === undefined) {\n        width = 1;\n      } else if (widthArg.type === AstNodeType.NUMBER) {\n        width = widthArg.value;\n\n        if (width < 1) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');\n        } else if (!Number.isInteger(width)) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');\n        }\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');\n      }\n\n      var topLeftCorner = new CellAddress(cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);\n      var absoluteCol = topLeftCorner.col;\n      var absoluteRow = topLeftCorner.row;\n\n      if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n        absoluteRow = absoluteRow + this.formulaAddress.row;\n      }\n\n      if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        absoluteCol = absoluteCol + this.formulaAddress.col;\n      }\n\n      if (absoluteCol < 0 || absoluteRow < 0) {\n        return buildCellErrorAst(new CellError(ErrorType.REF, ErrorMessage.OutOfSheet));\n      }\n\n      if (width === 1 && height === 1) {\n        return buildCellReferenceAst(topLeftCorner);\n      } else {\n        var bottomRightCorner = new CellAddress(topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);\n        return buildCellRangeAst(topLeftCorner, bottomRightCorner, RangeSheetReferenceType.RELATIVE);\n      }\n    }\n  }, {\n    key: \"parsingError\",\n    value: function parsingError(type, message) {\n      this.customParsingError = _parsingError(type, message);\n      return buildParsingErrorAst();\n    }\n  }, {\n    key: \"rangeSheetReferenceType\",\n    value: function rangeSheetReferenceType(start, end) {\n      if (start === undefined) {\n        return RangeSheetReferenceType.RELATIVE;\n      } else if (end === undefined) {\n        return RangeSheetReferenceType.START_ABSOLUTE;\n      } else {\n        return RangeSheetReferenceType.BOTH_ABSOLUTE;\n      }\n    }\n  }]);\n\n  return FormulaParser;\n}(EmbeddedActionsParser);\nexport var FormulaLexer = /*#__PURE__*/function () {\n  function FormulaLexer(lexerConfig) {\n    _classCallCheck(this, FormulaLexer);\n\n    this.lexerConfig = lexerConfig;\n    this.lexer = new Lexer(lexerConfig.allTokens, {\n      ensureOptimizations: true\n    });\n  }\n  /**\n   * Returns Lexer tokens from formula string\n   *\n   * @param text - string representation of a formula\n   */\n\n\n  _createClass(FormulaLexer, [{\n    key: \"tokenizeFormula\",\n    value: function tokenizeFormula(text) {\n      var lexingResult = this.lexer.tokenize(text);\n      var tokens = lexingResult.tokens;\n      tokens = this.trimTrailingWhitespaces(tokens);\n      tokens = this.skipWhitespacesInsideRanges(tokens);\n      tokens = this.skipWhitespacesBeforeArgSeparators(tokens);\n      lexingResult.tokens = tokens;\n      return lexingResult;\n    }\n  }, {\n    key: \"skipWhitespacesInsideRanges\",\n    value: function skipWhitespacesInsideRanges(tokens) {\n      return this.filterTokensByNeighbors(tokens, function (previous, current, next) {\n        return (tokenMatcher(previous, CellReference) || tokenMatcher(previous, RangeSeparator)) && tokenMatcher(current, WhiteSpace) && (tokenMatcher(next, CellReference) || tokenMatcher(next, RangeSeparator));\n      });\n    }\n  }, {\n    key: \"skipWhitespacesBeforeArgSeparators\",\n    value: function skipWhitespacesBeforeArgSeparators(tokens) {\n      var _this2 = this;\n\n      return this.filterTokensByNeighbors(tokens, function (previous, current, next) {\n        return !tokenMatcher(previous, _this2.lexerConfig.ArgSeparator) && tokenMatcher(current, WhiteSpace) && tokenMatcher(next, _this2.lexerConfig.ArgSeparator);\n      });\n    }\n  }, {\n    key: \"filterTokensByNeighbors\",\n    value: function filterTokensByNeighbors(tokens, shouldBeSkipped) {\n      if (tokens.length < 3) {\n        return tokens;\n      }\n\n      var i = 0;\n      var filteredTokens = [tokens[i++]];\n\n      while (i < tokens.length - 1) {\n        if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {\n          filteredTokens.push(tokens[i]);\n        }\n\n        ++i;\n      }\n\n      filteredTokens.push(tokens[i]);\n      return filteredTokens;\n    }\n  }, {\n    key: \"trimTrailingWhitespaces\",\n    value: function trimTrailingWhitespaces(tokens) {\n      if (tokens.length > 0 && tokenMatcher(tokens[tokens.length - 1], WhiteSpace)) {\n        tokens.pop();\n      }\n\n      return tokens;\n    }\n  }]);\n\n  return FormulaLexer;\n}();","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/FormulaParser.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","object","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","arguments","apply","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","EmbeddedActionsParser","EMPTY_ALT","Lexer","tokenMatcher","CellError","ErrorType","simpleCellAddress","ErrorMessage","cellAddressFromString","columnAddressFromString","rowAddressFromString","AstNodeType","buildArrayAst","buildCellErrorAst","buildCellRangeAst","buildCellReferenceAst","buildColumnRangeAst","buildConcatenateOpAst","buildDivOpAst","buildEmptyArgAst","buildEqualsOpAst","buildErrorWithRawInputAst","buildGreaterThanOpAst","buildGreaterThanOrEqualOpAst","buildLessThanOpAst","buildLessThanOrEqualOpAst","buildMinusOpAst","buildMinusUnaryOpAst","buildNamedExpressionAst","buildNotEqualOpAst","buildNumberAst","buildParenthesisAst","buildParsingErrorAst","buildPercentOpAst","buildPlusOpAst","buildPlusUnaryOpAst","buildPowerOpAst","buildProcedureAst","buildRowRangeAst","buildStringAst","buildTimesOpAst","parsingError","_parsingError","ParsingErrorType","RangeSheetReferenceType","CellAddress","CellReferenceType","AdditionOp","ArrayLParen","ArrayRParen","BooleanOp","CellReference","ColumnRange","ConcatenateOp","DivOp","EqualsOp","ErrorLiteral","GreaterThanOp","GreaterThanOrEqualOp","LessThanOp","LessThanOrEqualOp","LParen","MinusOp","MultiplicationOp","NamedExpression","NotEqualOp","PercentOp","PlusOp","PowerOp","ProcedureName","RangeSeparator","RowRange","RParen","StringLiteral","TimesOp","WhiteSpace","FormulaParser","_EmbeddedActionsParse","_super","lexerConfig","sheetMapping","_this","allTokens","outputCst","maxLookahead","formula","RULE","CONSUME","SUBRULE","booleanExpression","lhs","concatenateExpression","MANY","op","rhs","SUBRULE2","leadingWhitespace","ACTION","Error","booleanExpressionOrEmpty","OR","ALT","additionExpression","multiplicationExpression","powerExpression","atomicExpression","customParsingError","ParserError","rightUnaryOpAtomicExpression","positiveAtomicExpression","percentage","OPTION","_a","atomicExpCache","arrayExpression","cellRangeExpression","columnRangeExpression","rowRangeExpression","offsetExpression","cellReference","procedureExpression","namedExpressionExpression","number","NumberLiteral","numericStringToNumber","image","str","token","errString","toUpperCase","errorType","errorMapping","procedureNameToken","procedureName","canonicalProcedureName","functionMapping","args","argument","separator","ArgSeparator","type","EMPTY","rParenToken","offsetProcedure","offsetProcedureExpression","end","CELL_RANGE","RangeOffsetNotAllowed","endOfRangeWithOffsetStartExpression","ARGS","undefined","OffsetProcedureName","MANY_SEP","SEP","DEF","handleOffsetHeuristic","start","CONSUME2","endOfRangeExpression","range","_range$image$split","split","_range$image$split2","startImage","endImage","formulaAddress","REF","exceedsSheetSizeLimits","maxColumns","NAME","sheet","sheetReferenceType","rangeSheetReferenceType","withAbsoluteSheet","_range$image$split3","_range$image$split4","maxRows","cell","address","endRangeReference","startAddress","CELL_REFERENCE","reference","RELATIVE","START_ABSOLUTE","endRangeWithOffsetStartReference","endAddress","concat","buildCellRange","ltoken","ret","insideArrayExpression","rtoken","parenthesisExpression","ArrayColSeparator","ArrayRowSeparator","SUBRULE3","lParenToken","expression","input","normalized","replace","decimalSeparator","Number","performSelfAnalysis","parseFromTokens","tokens","ast","formulaWithContext","errors","map","message","reset","cellArg","StaticOffsetError","rowsArg","rowShift","NUMBER","isInteger","PLUS_UNARY_OP","MINUS_UNARY_OP","columnsArg","colShift","heightArg","height","widthArg","width","topLeftCorner","col","row","absoluteCol","absoluteRow","CELL_REFERENCE_RELATIVE","CELL_REFERENCE_ABSOLUTE_COL","CELL_REFERENCE_ABSOLUTE_ROW","OutOfSheet","bottomRightCorner","BOTH_ABSOLUTE","FormulaLexer","lexer","ensureOptimizations","tokenizeFormula","text","lexingResult","tokenize","trimTrailingWhitespaces","skipWhitespacesInsideRanges","skipWhitespacesBeforeArgSeparators","filterTokensByNeighbors","previous","current","_this2","shouldBeSkipped","filteredTokens","pop"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { EmbeddedActionsParser, EMPTY_ALT, Lexer, tokenMatcher } from 'chevrotain';\nimport { CellError, ErrorType, simpleCellAddress } from '../Cell';\nimport { ErrorMessage } from '../error-message';\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from './addressRepresentationConverters';\nimport { AstNodeType, buildArrayAst, buildCellErrorAst, buildCellRangeAst, buildCellReferenceAst, buildColumnRangeAst, buildConcatenateOpAst, buildDivOpAst, buildEmptyArgAst, buildEqualsOpAst, buildErrorWithRawInputAst, buildGreaterThanOpAst, buildGreaterThanOrEqualOpAst, buildLessThanOpAst, buildLessThanOrEqualOpAst, buildMinusOpAst, buildMinusUnaryOpAst, buildNamedExpressionAst, buildNotEqualOpAst, buildNumberAst, buildParenthesisAst, buildParsingErrorAst, buildPercentOpAst, buildPlusOpAst, buildPlusUnaryOpAst, buildPowerOpAst, buildProcedureAst, buildRowRangeAst, buildStringAst, buildTimesOpAst, parsingError as _parsingError, ParsingErrorType, RangeSheetReferenceType } from './Ast';\nimport { CellAddress, CellReferenceType } from './CellAddress';\nimport { AdditionOp, ArrayLParen, ArrayRParen, BooleanOp, CellReference, ColumnRange, ConcatenateOp, DivOp, EqualsOp, ErrorLiteral, GreaterThanOp, GreaterThanOrEqualOp, LessThanOp, LessThanOrEqualOp, LParen, MinusOp, MultiplicationOp, NamedExpression, NotEqualOp, PercentOp, PlusOp, PowerOp, ProcedureName, RangeSeparator, RowRange, RParen, StringLiteral, TimesOp, WhiteSpace } from './LexerConfig';\n/**\n * LL(k) formula parser described using Chevrotain DSL\n *\n * It is equivalent to the grammar below:\n *\n * F -> '=' E <br/>\n * B -> K < B | K >= B ... | K <br/>\n * K -> E & K | E <br/>\n * E -> M + E | M - E | M <br/>\n * M -> W * M | W / M | W <br/>\n * W -> C * W | C <br/>\n * C -> N | R | O | A | P | num <br/>\n * N -> '(' E ')' <br/>\n * R -> A:OFFSET(..) | A:A <br/>\n * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>\n * A -> A1 | $A1 | A$1 | $A$1 <br/>\n * P -> SUM(..) <br/>\n */\n\nexport var FormulaParser = /*#__PURE__*/function (_EmbeddedActionsParse) {\n  _inherits(FormulaParser, _EmbeddedActionsParse);\n\n  var _super = _createSuper(FormulaParser);\n\n  function FormulaParser(lexerConfig, sheetMapping) {\n    var _this;\n\n    _classCallCheck(this, FormulaParser);\n\n    _this = _super.call(this, lexerConfig.allTokens, {\n      outputCst: false,\n      maxLookahead: 7\n    });\n    /**\n     * Entry rule\n     */\n\n    _this.formula = _this.RULE('formula', function () {\n      _this.CONSUME(EqualsOp);\n\n      return _this.SUBRULE(_this.booleanExpression);\n    });\n    /**\n     * Rule for boolean expression (e.g. 1 <= A1)\n     */\n\n    _this.booleanExpression = _this.RULE('booleanExpression', function () {\n      var lhs = _this.SUBRULE(_this.concatenateExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(BooleanOp);\n\n        var rhs = _this.SUBRULE2(_this.concatenateExpression);\n\n        if (tokenMatcher(op, EqualsOp)) {\n          lhs = buildEqualsOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, NotEqualOp)) {\n          lhs = buildNotEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOp)) {\n          lhs = buildGreaterThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOp)) {\n          lhs = buildLessThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOrEqualOp)) {\n          lhs = buildGreaterThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOrEqualOp)) {\n          lhs = buildLessThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    _this.booleanExpressionOrEmpty = _this.RULE('booleanExpressionOrEmpty', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.booleanExpression);\n        }\n      }, {\n        ALT: EMPTY_ALT(buildEmptyArgAst())\n      }]);\n    });\n    /**\n     * Rule for concatenation operator expression (e.g. \"=\" & A1)\n     */\n\n    _this.concatenateExpression = _this.RULE('concatenateExpression', function () {\n      var lhs = _this.SUBRULE(_this.additionExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(ConcatenateOp);\n\n        var rhs = _this.SUBRULE2(_this.additionExpression);\n\n        lhs = buildConcatenateOpAst(lhs, rhs, op.leadingWhitespace);\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for addition category operators (e.g. 1 + A1, 1 - A1)\n     */\n\n    _this.additionExpression = _this.RULE('additionExpression', function () {\n      var lhs = _this.SUBRULE(_this.multiplicationExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(AdditionOp);\n\n        var rhs = _this.SUBRULE2(_this.multiplicationExpression);\n\n        if (tokenMatcher(op, PlusOp)) {\n          lhs = buildPlusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, MinusOp)) {\n          lhs = buildMinusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for multiplication category operators (e.g. 1 * A1, 1 / A1)\n     */\n\n    _this.multiplicationExpression = _this.RULE('multiplicationExpression', function () {\n      var lhs = _this.SUBRULE(_this.powerExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(MultiplicationOp);\n\n        var rhs = _this.SUBRULE2(_this.powerExpression);\n\n        if (tokenMatcher(op, TimesOp)) {\n          lhs = buildTimesOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, DivOp)) {\n          lhs = buildDivOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for power expression\n     */\n\n    _this.powerExpression = _this.RULE('powerExpression', function () {\n      var lhs = _this.SUBRULE(_this.atomicExpression);\n\n      _this.MANY(function () {\n        var op = _this.CONSUME(PowerOp);\n\n        var rhs = _this.SUBRULE2(_this.atomicExpression);\n\n        if (tokenMatcher(op, PowerOp)) {\n          lhs = buildPowerOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          _this.ACTION(function () {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n\n      return lhs;\n    });\n    /**\n     * Rule for atomic expressions, which is positive atomic expression or negation of it\n     */\n\n    _this.atomicExpression = _this.RULE('atomicExpression', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          var op = _this.CONSUME(AdditionOp);\n\n          var value = _this.SUBRULE(_this.atomicExpression);\n\n          if (tokenMatcher(op, PlusOp)) {\n            return buildPlusUnaryOpAst(value, op.leadingWhitespace);\n          } else if (tokenMatcher(op, MinusOp)) {\n            return buildMinusUnaryOpAst(value, op.leadingWhitespace);\n          } else {\n            _this.customParsingError = _parsingError(ParsingErrorType.ParserError, 'Mismatched token type');\n            return _this.customParsingError;\n          }\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE2(_this.rightUnaryOpAtomicExpression);\n        }\n      }]);\n    });\n    _this.rightUnaryOpAtomicExpression = _this.RULE('rightUnaryOpAtomicExpression', function () {\n      var positiveAtomicExpression = _this.SUBRULE(_this.positiveAtomicExpression);\n\n      var percentage = _this.OPTION(function () {\n        return _this.CONSUME(PercentOp);\n      });\n\n      if (percentage) {\n        return buildPercentOpAst(positiveAtomicExpression, percentage.leadingWhitespace);\n      }\n\n      return positiveAtomicExpression;\n    });\n    /**\n     * Rule for positive atomic expressions\n     */\n\n    _this.positiveAtomicExpression = _this.RULE('positiveAtomicExpression', function () {\n      var _a;\n\n      return _this.OR((_a = _this.atomicExpCache) !== null && _a !== void 0 ? _a : _this.atomicExpCache = [{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.arrayExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.cellRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.columnRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.rowRangeExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.offsetExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.cellReference);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.procedureExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.namedExpressionExpression);\n        }\n      }, {\n        ALT: function ALT() {\n          var number = _this.CONSUME(_this.lexerConfig.NumberLiteral);\n\n          return buildNumberAst(_this.numericStringToNumber(number.image), number.leadingWhitespace);\n        }\n      }, {\n        ALT: function ALT() {\n          var str = _this.CONSUME(StringLiteral);\n\n          return buildStringAst(str);\n        }\n      }, {\n        ALT: function ALT() {\n          var token = _this.CONSUME(ErrorLiteral);\n\n          var errString = token.image.toUpperCase();\n          var errorType = _this.lexerConfig.errorMapping[errString];\n\n          if (errorType) {\n            return buildCellErrorAst(new CellError(errorType), token.leadingWhitespace);\n          } else {\n            return _this.parsingError(ParsingErrorType.ParserError, 'Unknown error literal');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for procedure expressions: SUM(1,A1)\n     */\n\n    _this.procedureExpression = _this.RULE('procedureExpression', function () {\n      var _a;\n\n      var procedureNameToken = _this.CONSUME(ProcedureName);\n\n      var procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);\n      var canonicalProcedureName = (_a = _this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n      var args = [];\n\n      var argument = _this.SUBRULE(_this.booleanExpressionOrEmpty);\n\n      _this.MANY(function () {\n        var _a;\n\n        var separator = _this.CONSUME(_this.lexerConfig.ArgSeparator);\n\n        if (argument.type === AstNodeType.EMPTY) {\n          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;\n        }\n\n        args.push(argument);\n        argument = _this.SUBRULE2(_this.booleanExpressionOrEmpty);\n      });\n\n      args.push(argument);\n\n      if (args.length === 1 && args[0].type === AstNodeType.EMPTY) {\n        args.length = 0;\n      }\n\n      var rParenToken = _this.CONSUME(RParen);\n\n      return buildProcedureAst(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    _this.namedExpressionExpression = _this.RULE('namedExpressionExpression', function () {\n      var name = _this.CONSUME(NamedExpression);\n\n      return buildNamedExpressionAst(name.image, name.leadingWhitespace);\n    });\n    /**\n     * Rule for expressions that start with OFFSET() function\n     *\n     * OFFSET() function can occur as cell reference or part of cell range.\n     * In order to preserve LL(k) properties, expressions that starts with OFFSET() functions needs to have separate rule.\n     *\n     * Proper {@link Ast} node type is built depending on the presence of {@link RangeSeparator}\n     */\n\n    _this.offsetExpression = _this.RULE('offsetExpression', function () {\n      var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n      var end;\n\n      _this.OPTION(function () {\n        _this.CONSUME(RangeSeparator);\n\n        if (offsetProcedure.type === AstNodeType.CELL_RANGE) {\n          end = _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n        } else {\n          end = _this.SUBRULE(_this.endOfRangeWithOffsetStartExpression, {\n            ARGS: [offsetProcedure]\n          });\n        }\n      });\n\n      if (end !== undefined) {\n        return end;\n      }\n\n      return offsetProcedure;\n    });\n    /**\n     * Rule for OFFSET() function expression\n     */\n\n    _this.offsetProcedureExpression = _this.RULE('offsetProcedureExpression', function () {\n      var args = [];\n\n      _this.CONSUME(_this.lexerConfig.OffsetProcedureName);\n\n      _this.CONSUME(LParen);\n\n      _this.MANY_SEP({\n        SEP: _this.lexerConfig.ArgSeparator,\n        DEF: function DEF() {\n          args.push(_this.SUBRULE(_this.booleanExpression));\n        }\n      });\n\n      _this.CONSUME(RParen);\n\n      return _this.handleOffsetHeuristic(args);\n    });\n    /**\n     * Rule for cell ranges (e.g. A1:B$3, A1:OFFSET())\n     */\n\n    _this.cellRangeExpression = _this.RULE('cellRangeExpression', function () {\n      var start = _this.CONSUME(CellReference);\n\n      _this.CONSUME2(RangeSeparator);\n\n      return _this.SUBRULE(_this.endOfRangeExpression, {\n        ARGS: [start]\n      });\n    });\n    /**\n     * Rule for column range, e.g. A:B, Sheet1!A:B, Sheet1!A:Sheet1!B\n     */\n\n    _this.columnRangeExpression = _this.RULE('columnRangeExpression', function () {\n      var range = _this.CONSUME(ColumnRange);\n\n      var _range$image$split = range.image.split(':'),\n          _range$image$split2 = _slicedToArray(_range$image$split, 2),\n          startImage = _range$image$split2[0],\n          endImage = _range$image$split2[1];\n\n      var start = _this.ACTION(function () {\n        return columnAddressFromString(_this.sheetMapping, startImage, _this.formulaAddress);\n      });\n\n      var end = _this.ACTION(function () {\n        return columnAddressFromString(_this.sheetMapping, endImage, _this.formulaAddress);\n      });\n\n      if (start === undefined || end === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n\n      if (start.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns) || end.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n\n      if (start.sheet === undefined && end.sheet !== undefined) {\n        return _this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = _this.rangeSheetReferenceType(start.sheet, end.sheet);\n\n      if (start.sheet !== undefined && end.sheet === undefined) {\n        end = end.withAbsoluteSheet(start.sheet);\n      }\n\n      return buildColumnRangeAst(start, end, sheetReferenceType, range.leadingWhitespace);\n    });\n    /**\n     * Rule for row range, e.g. 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2\n     */\n\n    _this.rowRangeExpression = _this.RULE('rowRangeExpression', function () {\n      var range = _this.CONSUME(RowRange);\n\n      var _range$image$split3 = range.image.split(':'),\n          _range$image$split4 = _slicedToArray(_range$image$split3, 2),\n          startImage = _range$image$split4[0],\n          endImage = _range$image$split4[1];\n\n      var start = _this.ACTION(function () {\n        return rowAddressFromString(_this.sheetMapping, startImage, _this.formulaAddress);\n      });\n\n      var end = _this.ACTION(function () {\n        return rowAddressFromString(_this.sheetMapping, endImage, _this.formulaAddress);\n      });\n\n      if (start === undefined || end === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n\n      if (start.exceedsSheetSizeLimits(_this.lexerConfig.maxRows) || end.exceedsSheetSizeLimits(_this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n\n      if (start.sheet === undefined && end.sheet !== undefined) {\n        return _this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = _this.rangeSheetReferenceType(start.sheet, end.sheet);\n\n      if (start.sheet !== undefined && end.sheet === undefined) {\n        end = end.withAbsoluteSheet(start.sheet);\n      }\n\n      return buildRowRangeAst(start, end, sheetReferenceType, range.leadingWhitespace);\n    });\n    /**\n     * Rule for cell reference expression (e.g. A1, $A1, A$1, $A$1, $Sheet42!A$17)\n     */\n\n    _this.cellReference = _this.RULE('cellReference', function () {\n      var cell = _this.CONSUME(CellReference);\n\n      var address = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, cell.image, _this.formulaAddress);\n      });\n\n      if (address === undefined) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.REF), cell.leadingWhitespace);\n      } else if (address.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.NAME), cell.leadingWhitespace);\n      } else {\n        return buildCellReferenceAst(address, cell.leadingWhitespace);\n      }\n    });\n    /**\n     * Rule for end of range expression\n     *\n     * End of range may be a cell reference or OFFSET() function call\n     */\n\n    _this.endOfRangeExpression = _this.RULE('endOfRangeExpression', function (start) {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.endRangeReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: function ALT() {\n          var _a;\n\n          var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n          var startAddress = _this.ACTION(function () {\n            return cellAddressFromString(_this.sheetMapping, start.image, _this.formulaAddress);\n          });\n\n          if (startAddress === undefined) {\n            return buildCellErrorAst(new CellError(ErrorType.REF));\n          }\n\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            var end = offsetProcedure.reference;\n            var sheetReferenceType = RangeSheetReferenceType.RELATIVE;\n\n            if (startAddress.sheet !== undefined) {\n              sheetReferenceType = RangeSheetReferenceType.START_ABSOLUTE;\n              end = end.withAbsoluteSheet(startAddress.sheet);\n            }\n\n            return buildCellRangeAst(startAddress, end, sheetReferenceType, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n          } else {\n            return _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for end of range expression\n     *\n     * End of range may be a cell reference or OFFSET() function call\n     */\n\n    _this.endOfRangeWithOffsetStartExpression = _this.RULE('endOfRangeWithOffsetStartExpression', function (start) {\n      return _this.OR([{\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.endRangeWithOffsetStartReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: function ALT() {\n          var offsetProcedure = _this.SUBRULE(_this.offsetProcedureExpression);\n\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            var end = offsetProcedure.reference;\n            var sheetReferenceType = RangeSheetReferenceType.RELATIVE;\n\n            if (start.reference.sheet !== undefined) {\n              sheetReferenceType = RangeSheetReferenceType.START_ABSOLUTE;\n              end = end.withAbsoluteSheet(start.reference.sheet);\n            }\n\n            return buildCellRangeAst(start.reference, end, sheetReferenceType, start.leadingWhitespace);\n          } else {\n            return _this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\n     * Rule for end range reference expression with additional checks considering range start\n     */\n\n    _this.endRangeReference = _this.RULE('endRangeReference', function (start) {\n      var _a;\n\n      var end = _this.CONSUME(CellReference);\n\n      var startAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, start.image, _this.formulaAddress);\n      });\n\n      var endAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, end.image, _this.formulaAddress);\n      });\n\n      if (startAddress === undefined || endAddress === undefined) {\n        return _this.ACTION(function () {\n          return buildErrorWithRawInputAst(\"\".concat(start.image, \":\").concat(end.image), new CellError(ErrorType.REF), start.leadingWhitespace);\n        });\n      } else if (startAddress.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(_this.lexerConfig.maxColumns, _this.lexerConfig.maxRows)) {\n        return _this.ACTION(function () {\n          return buildErrorWithRawInputAst(\"\".concat(start.image, \":\").concat(end.image), new CellError(ErrorType.NAME), start.leadingWhitespace);\n        });\n      }\n\n      return _this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n    });\n    /**\n     * Rule for end range reference expression starting with offset procedure with additional checks considering range start\n     */\n\n    _this.endRangeWithOffsetStartReference = _this.RULE('endRangeWithOffsetStartReference', function (start) {\n      var end = _this.CONSUME(CellReference);\n\n      var endAddress = _this.ACTION(function () {\n        return cellAddressFromString(_this.sheetMapping, end.image, _this.formulaAddress);\n      });\n\n      if (endAddress === undefined) {\n        return _this.ACTION(function () {\n          return buildCellErrorAst(new CellError(ErrorType.REF));\n        });\n      }\n\n      return _this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);\n    });\n    _this.arrayExpression = _this.RULE('arrayExpression', function () {\n      return _this.OR([{\n        ALT: function ALT() {\n          var ltoken = _this.CONSUME(ArrayLParen);\n\n          var ret = _this.SUBRULE(_this.insideArrayExpression);\n\n          var rtoken = _this.CONSUME(ArrayRParen);\n\n          return buildArrayAst(ret.args, ltoken.leadingWhitespace, rtoken.leadingWhitespace);\n        }\n      }, {\n        ALT: function ALT() {\n          return _this.SUBRULE(_this.parenthesisExpression);\n        }\n      }]);\n    });\n    _this.insideArrayExpression = _this.RULE('insideArrayExpression', function () {\n      var ret = [[]];\n      ret[ret.length - 1].push(_this.SUBRULE(_this.booleanExpression));\n\n      _this.MANY(function () {\n        _this.OR([{\n          ALT: function ALT() {\n            _this.CONSUME(_this.lexerConfig.ArrayColSeparator);\n\n            ret[ret.length - 1].push(_this.SUBRULE2(_this.booleanExpression));\n          }\n        }, {\n          ALT: function ALT() {\n            _this.CONSUME(_this.lexerConfig.ArrayRowSeparator);\n\n            ret.push([]);\n            ret[ret.length - 1].push(_this.SUBRULE3(_this.booleanExpression));\n          }\n        }]);\n      });\n\n      return buildArrayAst(ret);\n    });\n    /**\n     * Rule for parenthesis expression\n     */\n\n    _this.parenthesisExpression = _this.RULE('parenthesisExpression', function () {\n      var lParenToken = _this.CONSUME(LParen);\n\n      var expression = _this.SUBRULE(_this.booleanExpression);\n\n      var rParenToken = _this.CONSUME(RParen);\n\n      return buildParenthesisAst(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n\n    _this.numericStringToNumber = function (input) {\n      var normalized = input.replace(_this.lexerConfig.decimalSeparator, '.');\n      return Number(normalized);\n    };\n\n    _this.lexerConfig = lexerConfig;\n    _this.sheetMapping = sheetMapping;\n    _this.formulaAddress = simpleCellAddress(0, 0, 0);\n\n    _this.performSelfAnalysis();\n\n    return _this;\n  }\n  /**\n   * Parses tokenized formula and builds abstract syntax tree\n   *\n   * @param tokens - tokenized formula\n   * @param formulaAddress - address of the cell in which formula is located\n   */\n\n\n  _createClass(FormulaParser, [{\n    key: \"parseFromTokens\",\n    value: function parseFromTokens(tokens, formulaAddress) {\n      this.input = tokens;\n      var ast = this.formulaWithContext(formulaAddress);\n      var errors = [];\n\n      if (this.customParsingError) {\n        errors.push(this.customParsingError);\n      }\n\n      errors = errors.concat(this.errors.map(function (e) {\n        return {\n          type: ParsingErrorType.ParserError,\n          message: e.message\n        };\n      }));\n\n      if (errors.length > 0) {\n        ast = buildParsingErrorAst();\n      }\n\n      return {\n        ast: ast,\n        errors: errors\n      };\n    }\n    /**\n     * Entry rule wrapper that sets formula address\n     *\n     * @param address - address of the cell in which formula is located\n     */\n\n  }, {\n    key: \"formulaWithContext\",\n    value: function formulaWithContext(address) {\n      this.formulaAddress = address;\n      return this.formula();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(FormulaParser.prototype), \"reset\", this).call(this);\n\n      this.customParsingError = undefined;\n    }\n  }, {\n    key: \"buildCellRange\",\n    value: function buildCellRange(startAddress, endAddress, leadingWhitespace) {\n      if (startAddress.sheet === undefined && endAddress.sheet !== undefined) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n\n      var sheetReferenceType = this.rangeSheetReferenceType(startAddress.sheet, endAddress.sheet);\n\n      if (startAddress.sheet !== undefined && endAddress.sheet === undefined) {\n        endAddress = endAddress.withAbsoluteSheet(startAddress.sheet);\n      }\n\n      return buildCellRangeAst(startAddress, endAddress, sheetReferenceType, leadingWhitespace);\n    }\n    /**\n     * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments\n     *\n     * @param args - OFFSET function arguments\n     */\n\n  }, {\n    key: \"handleOffsetHeuristic\",\n    value: function handleOffsetHeuristic(args) {\n      var cellArg = args[0];\n\n      if (cellArg.type !== AstNodeType.CELL_REFERENCE) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');\n      }\n\n      var rowsArg = args[1];\n      var rowShift;\n\n      if (rowsArg.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {\n        rowShift = rowsArg.value;\n      } else if (rowsArg.type === AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n        rowShift = rowsArg.value.value;\n      } else if (rowsArg.type === AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n        rowShift = -rowsArg.value.value;\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');\n      }\n\n      var columnsArg = args[2];\n      var colShift;\n\n      if (columnsArg.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {\n        colShift = columnsArg.value;\n      } else if (columnsArg.type === AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n        colShift = columnsArg.value.value;\n      } else if (columnsArg.type === AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n        colShift = -columnsArg.value.value;\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');\n      }\n\n      var heightArg = args[3];\n      var height;\n\n      if (heightArg === undefined) {\n        height = 1;\n      } else if (heightArg.type === AstNodeType.NUMBER) {\n        height = heightArg.value;\n\n        if (height < 1) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');\n        } else if (!Number.isInteger(height)) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');\n        }\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');\n      }\n\n      var widthArg = args[4];\n      var width;\n\n      if (widthArg === undefined) {\n        width = 1;\n      } else if (widthArg.type === AstNodeType.NUMBER) {\n        width = widthArg.value;\n\n        if (width < 1) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');\n        } else if (!Number.isInteger(width)) {\n          return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');\n        }\n      } else {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');\n      }\n\n      var topLeftCorner = new CellAddress(cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);\n      var absoluteCol = topLeftCorner.col;\n      var absoluteRow = topLeftCorner.row;\n\n      if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n        absoluteRow = absoluteRow + this.formulaAddress.row;\n      }\n\n      if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        absoluteCol = absoluteCol + this.formulaAddress.col;\n      }\n\n      if (absoluteCol < 0 || absoluteRow < 0) {\n        return buildCellErrorAst(new CellError(ErrorType.REF, ErrorMessage.OutOfSheet));\n      }\n\n      if (width === 1 && height === 1) {\n        return buildCellReferenceAst(topLeftCorner);\n      } else {\n        var bottomRightCorner = new CellAddress(topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);\n        return buildCellRangeAst(topLeftCorner, bottomRightCorner, RangeSheetReferenceType.RELATIVE);\n      }\n    }\n  }, {\n    key: \"parsingError\",\n    value: function parsingError(type, message) {\n      this.customParsingError = _parsingError(type, message);\n      return buildParsingErrorAst();\n    }\n  }, {\n    key: \"rangeSheetReferenceType\",\n    value: function rangeSheetReferenceType(start, end) {\n      if (start === undefined) {\n        return RangeSheetReferenceType.RELATIVE;\n      } else if (end === undefined) {\n        return RangeSheetReferenceType.START_ABSOLUTE;\n      } else {\n        return RangeSheetReferenceType.BOTH_ABSOLUTE;\n      }\n    }\n  }]);\n\n  return FormulaParser;\n}(EmbeddedActionsParser);\nexport var FormulaLexer = /*#__PURE__*/function () {\n  function FormulaLexer(lexerConfig) {\n    _classCallCheck(this, FormulaLexer);\n\n    this.lexerConfig = lexerConfig;\n    this.lexer = new Lexer(lexerConfig.allTokens, {\n      ensureOptimizations: true\n    });\n  }\n  /**\n   * Returns Lexer tokens from formula string\n   *\n   * @param text - string representation of a formula\n   */\n\n\n  _createClass(FormulaLexer, [{\n    key: \"tokenizeFormula\",\n    value: function tokenizeFormula(text) {\n      var lexingResult = this.lexer.tokenize(text);\n      var tokens = lexingResult.tokens;\n      tokens = this.trimTrailingWhitespaces(tokens);\n      tokens = this.skipWhitespacesInsideRanges(tokens);\n      tokens = this.skipWhitespacesBeforeArgSeparators(tokens);\n      lexingResult.tokens = tokens;\n      return lexingResult;\n    }\n  }, {\n    key: \"skipWhitespacesInsideRanges\",\n    value: function skipWhitespacesInsideRanges(tokens) {\n      return this.filterTokensByNeighbors(tokens, function (previous, current, next) {\n        return (tokenMatcher(previous, CellReference) || tokenMatcher(previous, RangeSeparator)) && tokenMatcher(current, WhiteSpace) && (tokenMatcher(next, CellReference) || tokenMatcher(next, RangeSeparator));\n      });\n    }\n  }, {\n    key: \"skipWhitespacesBeforeArgSeparators\",\n    value: function skipWhitespacesBeforeArgSeparators(tokens) {\n      var _this2 = this;\n\n      return this.filterTokensByNeighbors(tokens, function (previous, current, next) {\n        return !tokenMatcher(previous, _this2.lexerConfig.ArgSeparator) && tokenMatcher(current, WhiteSpace) && tokenMatcher(next, _this2.lexerConfig.ArgSeparator);\n      });\n    }\n  }, {\n    key: \"filterTokensByNeighbors\",\n    value: function filterTokensByNeighbors(tokens, shouldBeSkipped) {\n      if (tokens.length < 3) {\n        return tokens;\n      }\n\n      var i = 0;\n      var filteredTokens = [tokens[i++]];\n\n      while (i < tokens.length - 1) {\n        if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {\n          filteredTokens.push(tokens[i]);\n        }\n\n        ++i;\n      }\n\n      filteredTokens.push(tokens[i]);\n      return filteredTokens;\n    }\n  }, {\n    key: \"trimTrailingWhitespaces\",\n    value: function trimTrailingWhitespaces(tokens) {\n      if (tokens.length > 0 && tokenMatcher(tokens[tokens.length - 1], WhiteSpace)) {\n        tokens.pop();\n      }\n\n      return tokens;\n    }\n  }]);\n\n  return FormulaLexer;\n}();"]},"metadata":{},"sourceType":"module"}