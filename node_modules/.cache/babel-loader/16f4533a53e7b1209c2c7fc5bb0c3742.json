{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, groupBy, isEmpty, map, pick, reduce, reject, values } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { NamedDSLMethodsCollectorVisitor } from \"../cst/cst\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, ignoredIssues, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, ignoredIssues, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tokenNameErrors = utils.map(tokenTypes, function (currTokType) {\n    return validateTokenName(currTokType, errMsgProvider);\n  });\n  var nestedRulesNameErrors = validateNestedRulesNames(topLevels, errMsgProvider);\n  var nestedRulesDuplicateErrors = validateDuplicateNestedRules(topLevels, errMsgProvider);\n  var tooManyAltsErrors = map(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var ruleNameErrors = map(topLevels, function (curRule) {\n    return validateRuleName(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = map(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(tokenNameErrors, nestedRulesNameErrors, nestedRulesDuplicateErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError));\n}\n\nfunction validateNestedRulesNames(topLevels, errMsgProvider) {\n  var result = [];\n  forEach(topLevels, function (curTopLevel) {\n    var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(\"\");\n    curTopLevel.accept(namedCollectorVisitor);\n    var nestedProds = map(namedCollectorVisitor.result, function (currItem) {\n      return currItem.orgProd;\n    });\n    result.push(map(nestedProds, function (currNestedProd) {\n      return validateNestedRuleName(curTopLevel, currNestedProd, errMsgProvider);\n    }));\n  });\n  return flatten(result);\n}\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = getProductionDslName(firstProd);\n    var defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nexport function identifyProductionForDuplicates(prod) {\n  return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nvar OccurrenceValidationCollector = function (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n\n  return OccurrenceValidationCollector;\n}(GAstVisitor);\n\nexport { OccurrenceValidationCollector };\nexport var validTermsPattern = /^[a-zA-Z_]\\w*$/;\nexport var validNestedRuleName = new RegExp(validTermsPattern.source.replace(\"^\", \"^\\\\$\")); // TODO: remove this limitation now that we use recorders\n\nexport function validateRuleName(rule, errMsgProvider) {\n  var errors = [];\n  var ruleName = rule.name;\n\n  if (!ruleName.match(validTermsPattern)) {\n    errors.push({\n      message: errMsgProvider.buildInvalidRuleNameError({\n        topLevelRule: rule,\n        expectedPattern: validTermsPattern\n      }),\n      type: ParserDefinitionErrorType.INVALID_RULE_NAME,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n} // TODO: did the nested rule name regExp now change?\n\nexport function validateNestedRuleName(topLevel, nestedProd, errMsgProvider) {\n  var errors = [];\n  var errMsg;\n\n  if (!nestedProd.name.match(validNestedRuleName)) {\n    errMsg = errMsgProvider.buildInvalidNestedRuleNameError(topLevel, nestedProd);\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,\n      ruleName: topLevel.name\n    });\n  }\n\n  return errors;\n} // TODO: remove this limitation now that we use recorders\n\nexport function validateTokenName(tokenType, errMsgProvider) {\n  var errors = [];\n  var tokTypeName = tokenType.name;\n\n  if (!tokTypeName.match(validTermsPattern)) {\n    errors.push({\n      message: errMsgProvider.buildTokenNameError({\n        tokenType: tokenType,\n        expectedPattern: validTermsPattern\n      }),\n      type: ParserDefinitionErrorType.INVALID_TOKEN_NAME\n    });\n  }\n\n  return errors;\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = reduce(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n} // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\nexport function getFirstNoneTerminal(definition) {\n  var result = [];\n\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof Flat || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  var isFirstOptional = isOptionalProd(firstProd);\n  var hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nvar OrCollector = function (_super) {\n  __extends(OrCollector, _super);\n\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.alternations = [];\n    return _this;\n  }\n\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n\n  return OrCollector;\n}(GAstVisitor);\n\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, ignoredIssues, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations; // TODO: this filtering should be deprecated once we remove the ignoredIssues\n  //  IParserConfig property\n\n  var ignoredIssuesForCurrentRule = ignoredIssues[topLevelRule.name];\n\n  if (ignoredIssuesForCurrentRule) {\n    ors = reject(ors, function (currOr) {\n      return ignoredIssuesForCurrentRule[getProductionDslName(currOr) + (currOr.idx === 0 ? \"\" : currOr.idx)];\n    });\n  } // New Handling of ignoring ambiguities\n  // - https://github.com/SAP/chevrotain/issues/869\n\n\n  ors = reject(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\n\nvar RepetionCollector = function (_super) {\n  __extends(RepetionCollector, _super);\n\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  return RepetionCollector;\n}(GAstVisitor);\n\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n\n    return errors;\n  }, []);\n  return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  forEach(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, function (currProd) {\n      var prodType = getProdType(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    forEach(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\n\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = []; // flatten\n\n  var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = map(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  forEach(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = map(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  forEach(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n\n    if (contains(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}\n\nfunction validateDuplicateNestedRules(topLevelRules, errMsgProvider) {\n  var errors = [];\n  forEach(topLevelRules, function (currTopRule) {\n    var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(\"\");\n    currTopRule.accept(namedCollectorVisitor);\n    var prodsByGroup = groupBy(namedCollectorVisitor.result, function (item) {\n      return item.name;\n    });\n    var duplicates = pick(prodsByGroup, function (currGroup) {\n      return currGroup.length > 1;\n    });\n    forEach(values(duplicates), function (currDupGroup) {\n      var currDupProds = map(currDupGroup, function (dupGroup) {\n        return dupGroup.orgProd;\n      });\n      var errMsg = errMsgProvider.buildDuplicateNestedRuleNameError(currTopRule, currDupProds);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,\n        ruleName: currTopRule.name\n      });\n    });\n  });\n  return errors;\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","utils","contains","every","findAll","flatten","forEach","groupBy","isEmpty","map","pick","reduce","reject","values","ParserDefinitionErrorType","getProductionDslName","isOptionalProd","containsPath","getLookaheadPathsForOptionalProd","getLookaheadPathsForOr","getProdType","isStrictPrefixOfPath","NamedDSLMethodsCollectorVisitor","nextPossibleTokensAfter","Alternation","Flat","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","GAstVisitor","validateGrammar","topLevels","globalMaxLookahead","tokenTypes","ignoredIssues","errMsgProvider","grammarName","duplicateErrors","currTopLevel","validateDuplicateProductions","leftRecursionErrors","currTopRule","validateNoLeftRecursion","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","validateEmptyOrAlternative","validateAmbiguousAlternationAlternatives","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tokenNameErrors","currTokType","validateTokenName","nestedRulesNameErrors","validateNestedRulesNames","nestedRulesDuplicateErrors","validateDuplicateNestedRules","tooManyAltsErrors","curRule","validateTooManyAlts","ruleNameErrors","validateRuleName","duplicateRulesError","validateRuleDoesNotAlreadyExist","concat","result","curTopLevel","namedCollectorVisitor","accept","nestedProds","currItem","orgProd","push","currNestedProd","validateNestedRuleName","topLevelRule","collectorVisitor","OccurrenceValidationCollector","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","first","msg","buildDuplicateFoundError","dslName","defError","message","type","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","terminalType","nonTerminalName","_super","_this","apply","arguments","visitNonTerminal","subrule","visitOption","option","visitRepetitionWithSeparator","manySep","visitRepetitionMandatory","atLeastOne","visitRepetitionMandatoryWithSeparator","atLeastOneSep","visitRepetition","many","visitAlternation","or","visitTerminal","terminal","validTermsPattern","validNestedRuleName","RegExp","source","replace","rule","match","buildInvalidRuleNameError","expectedPattern","INVALID_RULE_NAME","topLevel","nestedProd","errMsg","buildInvalidNestedRuleNameError","INVALID_NESTED_RULE_NAME","tokenType","tokTypeName","buildTokenNameError","INVALID_TOKEN_NAME","allRules","className","occurrences","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","difference","errorsFromNextSteps","currRefRule","newPath","cloneArr","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","drop","OrCollector","alternations","node","orCollector","ors","currOr","exceptLast","dropRight","currErrors","currAlternative","currAltIdx","possibleFirstInAlt","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","compact","ignoredIssuesForCurrentRule","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetionCollector","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE","prodsByGroup","item","currDupGroup","currDupProds","dupGroup","buildDuplicateNestedRuleNameError","DUPLICATE_NESTED_NAME"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIA,CAAC,CAACM,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAF9E;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASO,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBT,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACU,SAAF,GAAcT,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACS,MAAP,CAAcV,CAAd,CAAb,IAAiCO,EAAE,CAACE,SAAH,GAAeT,CAAC,CAACS,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaA,OAAO,KAAKI,KAAZ,MAAuB,mBAAvB;AACA,SAASC,QAAT,EAAmBC,KAAnB,EAA0BC,OAA1B,EAAmCC,OAAnC,EAA4CC,OAA5C,EAAqDC,OAArD,EAA8DC,OAA9D,EAAuEC,GAAvE,EAA4EC,IAA5E,EAAkFC,MAAlF,EAA0FC,MAA1F,EAAkGC,MAAlG,QAAgH,mBAAhH;AACA,SAASC,yBAAT,QAA0C,kBAA1C;AACA,SAASC,oBAAT,EAA+BC,cAA/B,QAAqD,aAArD;AACA,SAASC,YAAT,EAAuBC,gCAAvB,EAAyDC,sBAAzD,EAAiFC,WAAjF,EAA8FC,oBAA9F,QAA0H,aAA1H;AACA,SAASC,+BAAT,QAAgD,YAAhD;AACA,SAASC,uBAAT,QAAwC,eAAxC;AACA,SAASC,WAAT,EAAsBC,IAAtB,EAA4BC,WAA5B,EAAyCC,MAAzC,EAAiDC,UAAjD,EAA6DC,mBAA7D,EAAkFC,gCAAlF,EAAoHC,uBAApH,EAA6IC,QAA7I,QAA6J,oBAA7J;AACA,SAASC,WAAT,QAA4B,4BAA5B;AACA,OAAO,SAASC,eAAT,CAAyBC,SAAzB,EAAoCC,kBAApC,EAAwDC,UAAxD,EAAoEC,aAApE,EAAmFC,cAAnF,EAAmGC,WAAnG,EAAgH;AACnH,MAAIC,eAAe,GAAGxC,KAAK,CAACQ,GAAN,CAAU0B,SAAV,EAAqB,UAAUO,YAAV,EAAwB;AAC/D,WAAOC,4BAA4B,CAACD,YAAD,EAAeH,cAAf,CAAnC;AACH,GAFqB,CAAtB;AAGA,MAAIK,mBAAmB,GAAG3C,KAAK,CAACQ,GAAN,CAAU0B,SAAV,EAAqB,UAAUU,WAAV,EAAuB;AAClE,WAAOC,uBAAuB,CAACD,WAAD,EAAcA,WAAd,EAA2BN,cAA3B,CAA9B;AACH,GAFyB,CAA1B;AAGA,MAAIQ,cAAc,GAAG,EAArB;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACA,MAAIC,qBAAqB,GAAG,EAA5B,CATmH,CAUnH;AACA;;AACA,MAAI9C,KAAK,CAACyC,mBAAD,EAAsBpC,OAAtB,CAAT,EAAyC;AACrCuC,IAAAA,cAAc,GAAGtC,GAAG,CAAC0B,SAAD,EAAY,UAAUU,WAAV,EAAuB;AACnD,aAAOK,0BAA0B,CAACL,WAAD,EAAcN,cAAd,CAAjC;AACH,KAFmB,CAApB;AAGAS,IAAAA,mBAAmB,GAAGvC,GAAG,CAAC0B,SAAD,EAAY,UAAUU,WAAV,EAAuB;AACxD,aAAOM,wCAAwC,CAACN,WAAD,EAAcT,kBAAd,EAAkCE,aAAlC,EAAiDC,cAAjD,CAA/C;AACH,KAFwB,CAAzB;AAGAU,IAAAA,qBAAqB,GAAGG,iCAAiC,CAACjB,SAAD,EAAYC,kBAAZ,EAAgCG,cAAhC,CAAzD;AACH;;AACD,MAAIc,4BAA4B,GAAGC,sCAAsC,CAACnB,SAAD,EAAYE,UAAZ,EAAwBE,cAAxB,CAAzE;AACA,MAAIgB,eAAe,GAAGtD,KAAK,CAACQ,GAAN,CAAU4B,UAAV,EAAsB,UAAUmB,WAAV,EAAuB;AAC/D,WAAOC,iBAAiB,CAACD,WAAD,EAAcjB,cAAd,CAAxB;AACH,GAFqB,CAAtB;AAGA,MAAImB,qBAAqB,GAAGC,wBAAwB,CAACxB,SAAD,EAAYI,cAAZ,CAApD;AACA,MAAIqB,0BAA0B,GAAGC,4BAA4B,CAAC1B,SAAD,EAAYI,cAAZ,CAA7D;AACA,MAAIuB,iBAAiB,GAAGrD,GAAG,CAAC0B,SAAD,EAAY,UAAU4B,OAAV,EAAmB;AACtD,WAAOC,mBAAmB,CAACD,OAAD,EAAUxB,cAAV,CAA1B;AACH,GAF0B,CAA3B;AAGA,MAAI0B,cAAc,GAAGxD,GAAG,CAAC0B,SAAD,EAAY,UAAU4B,OAAV,EAAmB;AACnD,WAAOG,gBAAgB,CAACH,OAAD,EAAUxB,cAAV,CAAvB;AACH,GAFuB,CAAxB;AAGA,MAAI4B,mBAAmB,GAAG1D,GAAG,CAAC0B,SAAD,EAAY,UAAU4B,OAAV,EAAmB;AACxD,WAAOK,+BAA+B,CAACL,OAAD,EAAU5B,SAAV,EAAqBK,WAArB,EAAkCD,cAAlC,CAAtC;AACH,GAF4B,CAA7B;AAGA,SAAQtC,KAAK,CAACI,OAAN,CAAcoC,eAAe,CAAC4B,MAAhB,CAAuBd,eAAvB,EAAwCG,qBAAxC,EAA+DE,0BAA/D,EAA2FX,qBAA3F,EAAkHL,mBAAlH,EAAuIG,cAAvI,EAAuJC,mBAAvJ,EAA4KK,4BAA5K,EAA0MS,iBAA1M,EAA6NG,cAA7N,EAA6OE,mBAA7O,CAAd,CAAR;AACH;;AACD,SAASR,wBAAT,CAAkCxB,SAAlC,EAA6CI,cAA7C,EAA6D;AACzD,MAAI+B,MAAM,GAAG,EAAb;AACAhE,EAAAA,OAAO,CAAC6B,SAAD,EAAY,UAAUoC,WAAV,EAAuB;AACtC,QAAIC,qBAAqB,GAAG,IAAIlD,+BAAJ,CAAoC,EAApC,CAA5B;AACAiD,IAAAA,WAAW,CAACE,MAAZ,CAAmBD,qBAAnB;AACA,QAAIE,WAAW,GAAGjE,GAAG,CAAC+D,qBAAqB,CAACF,MAAvB,EAA+B,UAAUK,QAAV,EAAoB;AAAE,aAAOA,QAAQ,CAACC,OAAhB;AAA0B,KAA/E,CAArB;AACAN,IAAAA,MAAM,CAACO,IAAP,CAAYpE,GAAG,CAACiE,WAAD,EAAc,UAAUI,cAAV,EAA0B;AACnD,aAAOC,sBAAsB,CAACR,WAAD,EAAcO,cAAd,EAA8BvC,cAA9B,CAA7B;AACH,KAFc,CAAf;AAGH,GAPM,CAAP;AAQA,SAAOlC,OAAO,CAACiE,MAAD,CAAd;AACH;;AACD,SAAS3B,4BAAT,CAAsCqC,YAAtC,EAAoDzC,cAApD,EAAoE;AAChE,MAAI0C,gBAAgB,GAAG,IAAIC,6BAAJ,EAAvB;AACAF,EAAAA,YAAY,CAACP,MAAb,CAAoBQ,gBAApB;AACA,MAAIE,kBAAkB,GAAGF,gBAAgB,CAACG,cAA1C;AACA,MAAIC,gBAAgB,GAAGpF,KAAK,CAACM,OAAN,CAAc4E,kBAAd,EAAkCG,+BAAlC,CAAvB;AACA,MAAIC,UAAU,GAAGtF,KAAK,CAACS,IAAN,CAAW2E,gBAAX,EAA6B,UAAUG,SAAV,EAAqB;AAC/D,WAAOA,SAAS,CAACC,MAAV,GAAmB,CAA1B;AACH,GAFgB,CAAjB;AAGA,MAAIC,MAAM,GAAGzF,KAAK,CAACQ,GAAN,CAAUR,KAAK,CAACY,MAAN,CAAa0E,UAAb,CAAV,EAAoC,UAAUI,cAAV,EAA0B;AACvE,QAAIC,SAAS,GAAG3F,KAAK,CAAC4F,KAAN,CAAYF,cAAZ,CAAhB;AACA,QAAIG,GAAG,GAAGvD,cAAc,CAACwD,wBAAf,CAAwCf,YAAxC,EAAsDW,cAAtD,CAAV;AACA,QAAIK,OAAO,GAAGjF,oBAAoB,CAAC6E,SAAD,CAAlC;AACA,QAAIK,QAAQ,GAAG;AACXC,MAAAA,OAAO,EAAEJ,GADE;AAEXK,MAAAA,IAAI,EAAErF,yBAAyB,CAACsF,qBAFrB;AAGXC,MAAAA,QAAQ,EAAErB,YAAY,CAACsB,IAHZ;AAIXN,MAAAA,OAAO,EAAEA,OAJE;AAKXO,MAAAA,UAAU,EAAEX,SAAS,CAACY;AALX,KAAf;AAOA,QAAIC,KAAK,GAAGC,0BAA0B,CAACd,SAAD,CAAtC;;AACA,QAAIa,KAAJ,EAAW;AACPR,MAAAA,QAAQ,CAACU,SAAT,GAAqBF,KAArB;AACH;;AACD,WAAOR,QAAP;AACH,GAhBY,CAAb;AAiBA,SAAOP,MAAP;AACH;;AACD,OAAO,SAASJ,+BAAT,CAAyCsB,IAAzC,EAA+C;AAClD,SAAO7F,oBAAoB,CAAC6F,IAAD,CAApB,GAA6B,KAA7B,GAAqCA,IAAI,CAACJ,GAA1C,GAAgD,KAAhD,GAAwDE,0BAA0B,CAACE,IAAD,CAAzF;AACH;;AACD,SAASF,0BAAT,CAAoCE,IAApC,EAA0C;AACtC,MAAIA,IAAI,YAAY5E,QAApB,EAA8B;AAC1B,WAAO4E,IAAI,CAACC,YAAL,CAAkBP,IAAzB;AACH,GAFD,MAGK,IAAIM,IAAI,YAAYlF,WAApB,EAAiC;AAClC,WAAOkF,IAAI,CAACE,eAAZ;AACH,GAFI,MAGA;AACD,WAAO,EAAP;AACH;AACJ;;AACD,IAAI5B,6BAA6B,GAAkB,UAAU6B,MAAV,EAAkB;AACjE5H,EAAAA,SAAS,CAAC+F,6BAAD,EAAgC6B,MAAhC,CAAT;;AACA,WAAS7B,6BAAT,GAAyC;AACrC,QAAI8B,KAAK,GAAGD,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AACAF,IAAAA,KAAK,CAAC5B,cAAN,GAAuB,EAAvB;AACA,WAAO4B,KAAP;AACH;;AACD9B,EAAAA,6BAA6B,CAACnF,SAA9B,CAAwCoH,gBAAxC,GAA2D,UAAUC,OAAV,EAAmB;AAC1E,SAAKhC,cAAL,CAAoBP,IAApB,CAAyBuC,OAAzB;AACH,GAFD;;AAGAlC,EAAAA,6BAA6B,CAACnF,SAA9B,CAAwCsH,WAAxC,GAAsD,UAAUC,MAAV,EAAkB;AACpE,SAAKlC,cAAL,CAAoBP,IAApB,CAAyByC,MAAzB;AACH,GAFD;;AAGApC,EAAAA,6BAA6B,CAACnF,SAA9B,CAAwCwH,4BAAxC,GAAuE,UAAUC,OAAV,EAAmB;AACtF,SAAKpC,cAAL,CAAoBP,IAApB,CAAyB2C,OAAzB;AACH,GAFD;;AAGAtC,EAAAA,6BAA6B,CAACnF,SAA9B,CAAwC0H,wBAAxC,GAAmE,UAAUC,UAAV,EAAsB;AACrF,SAAKtC,cAAL,CAAoBP,IAApB,CAAyB6C,UAAzB;AACH,GAFD;;AAGAxC,EAAAA,6BAA6B,CAACnF,SAA9B,CAAwC4H,qCAAxC,GAAgF,UAAUC,aAAV,EAAyB;AACrG,SAAKxC,cAAL,CAAoBP,IAApB,CAAyB+C,aAAzB;AACH,GAFD;;AAGA1C,EAAAA,6BAA6B,CAACnF,SAA9B,CAAwC8H,eAAxC,GAA0D,UAAUC,IAAV,EAAgB;AACtE,SAAK1C,cAAL,CAAoBP,IAApB,CAAyBiD,IAAzB;AACH,GAFD;;AAGA5C,EAAAA,6BAA6B,CAACnF,SAA9B,CAAwCgI,gBAAxC,GAA2D,UAAUC,EAAV,EAAc;AACrE,SAAK5C,cAAL,CAAoBP,IAApB,CAAyBmD,EAAzB;AACH,GAFD;;AAGA9C,EAAAA,6BAA6B,CAACnF,SAA9B,CAAwCkI,aAAxC,GAAwD,UAAUC,QAAV,EAAoB;AACxE,SAAK9C,cAAL,CAAoBP,IAApB,CAAyBqD,QAAzB;AACH,GAFD;;AAGA,SAAOhD,6BAAP;AACH,CAhCkD,CAgCjDjD,WAhCiD,CAAnD;;AAiCA,SAASiD,6BAAT;AACA,OAAO,IAAIiD,iBAAiB,GAAG,gBAAxB;AACP,OAAO,IAAIC,mBAAmB,GAAG,IAAIC,MAAJ,CAAWF,iBAAiB,CAACG,MAAlB,CAAyBC,OAAzB,CAAiC,GAAjC,EAAsC,MAAtC,CAAX,CAA1B,C,CACP;;AACA,OAAO,SAASrE,gBAAT,CAA0BsE,IAA1B,EAAgCjG,cAAhC,EAAgD;AACnD,MAAImD,MAAM,GAAG,EAAb;AACA,MAAIW,QAAQ,GAAGmC,IAAI,CAAClC,IAApB;;AACA,MAAI,CAACD,QAAQ,CAACoC,KAAT,CAAeN,iBAAf,CAAL,EAAwC;AACpCzC,IAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,MAAAA,OAAO,EAAE3D,cAAc,CAACmG,yBAAf,CAAyC;AAC9C1D,QAAAA,YAAY,EAAEwD,IADgC;AAE9CG,QAAAA,eAAe,EAAER;AAF6B,OAAzC,CADD;AAKRhC,MAAAA,IAAI,EAAErF,yBAAyB,CAAC8H,iBALxB;AAMRvC,MAAAA,QAAQ,EAAEA;AANF,KAAZ;AAQH;;AACD,SAAOX,MAAP;AACH,C,CACD;;AACA,OAAO,SAASX,sBAAT,CAAgC8D,QAAhC,EAA0CC,UAA1C,EAAsDvG,cAAtD,EAAsE;AACzE,MAAImD,MAAM,GAAG,EAAb;AACA,MAAIqD,MAAJ;;AACA,MAAI,CAACD,UAAU,CAACxC,IAAX,CAAgBmC,KAAhB,CAAsBL,mBAAtB,CAAL,EAAiD;AAC7CW,IAAAA,MAAM,GAAGxG,cAAc,CAACyG,+BAAf,CAA+CH,QAA/C,EAAyDC,UAAzD,CAAT;AACApD,IAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,MAAAA,OAAO,EAAE6C,MADD;AAER5C,MAAAA,IAAI,EAAErF,yBAAyB,CAACmI,wBAFxB;AAGR5C,MAAAA,QAAQ,EAAEwC,QAAQ,CAACvC;AAHX,KAAZ;AAKH;;AACD,SAAOZ,MAAP;AACH,C,CACD;;AACA,OAAO,SAASjC,iBAAT,CAA2ByF,SAA3B,EAAsC3G,cAAtC,EAAsD;AACzD,MAAImD,MAAM,GAAG,EAAb;AACA,MAAIyD,WAAW,GAAGD,SAAS,CAAC5C,IAA5B;;AACA,MAAI,CAAC6C,WAAW,CAACV,KAAZ,CAAkBN,iBAAlB,CAAL,EAA2C;AACvCzC,IAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,MAAAA,OAAO,EAAE3D,cAAc,CAAC6G,mBAAf,CAAmC;AACxCF,QAAAA,SAAS,EAAEA,SAD6B;AAExCP,QAAAA,eAAe,EAAER;AAFuB,OAAnC,CADD;AAKRhC,MAAAA,IAAI,EAAErF,yBAAyB,CAACuI;AALxB,KAAZ;AAOH;;AACD,SAAO3D,MAAP;AACH;AACD,OAAO,SAAStB,+BAAT,CAAyCoE,IAAzC,EAA+Cc,QAA/C,EAAyDC,SAAzD,EAAoEhH,cAApE,EAAoF;AACvF,MAAImD,MAAM,GAAG,EAAb;AACA,MAAI8D,WAAW,GAAG7I,MAAM,CAAC2I,QAAD,EAAW,UAAUhF,MAAV,EAAkBP,OAAlB,EAA2B;AAC1D,QAAIA,OAAO,CAACuC,IAAR,KAAiBkC,IAAI,CAAClC,IAA1B,EAAgC;AAC5B,aAAOhC,MAAM,GAAG,CAAhB;AACH;;AACD,WAAOA,MAAP;AACH,GALuB,EAKrB,CALqB,CAAxB;;AAMA,MAAIkF,WAAW,GAAG,CAAlB,EAAqB;AACjB,QAAIT,MAAM,GAAGxG,cAAc,CAACkH,2BAAf,CAA2C;AACpDzE,MAAAA,YAAY,EAAEwD,IADsC;AAEpDhG,MAAAA,WAAW,EAAE+G;AAFuC,KAA3C,CAAb;AAIA7D,IAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,MAAAA,OAAO,EAAE6C,MADD;AAER5C,MAAAA,IAAI,EAAErF,yBAAyB,CAAC4I,mBAFxB;AAGRrD,MAAAA,QAAQ,EAAEmC,IAAI,CAAClC;AAHP,KAAZ;AAKH;;AACD,SAAOZ,MAAP;AACH,C,CACD;AACA;AACA;;AACA,OAAO,SAASiE,wBAAT,CAAkCtD,QAAlC,EAA4CuD,iBAA5C,EAA+DL,SAA/D,EAA0E;AAC7E,MAAI7D,MAAM,GAAG,EAAb;AACA,MAAIqD,MAAJ;;AACA,MAAI,CAAC9I,KAAK,CAACC,QAAN,CAAe0J,iBAAf,EAAkCvD,QAAlC,CAAL,EAAkD;AAC9C0C,IAAAA,MAAM,GACF,oCAAoC1C,QAApC,GAA+C,4CAA/C,GAA8FkD,SAA9F,GAA0G,IAA1G,GACI,oDAFR;AAGA7D,IAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,MAAAA,OAAO,EAAE6C,MADD;AAER5C,MAAAA,IAAI,EAAErF,yBAAyB,CAAC+I,qBAFxB;AAGRxD,MAAAA,QAAQ,EAAEA;AAHF,KAAZ;AAKH;;AACD,SAAOX,MAAP;AACH;AACD,OAAO,SAAS5C,uBAAT,CAAiCgH,OAAjC,EAA0CC,QAA1C,EAAoDxH,cAApD,EAAoEyH,IAApE,EAA0E;AAC7E,MAAIA,IAAI,KAAK,KAAK,CAAlB,EAAqB;AAAEA,IAAAA,IAAI,GAAG,EAAP;AAAY;;AACnC,MAAItE,MAAM,GAAG,EAAb;AACA,MAAIuE,gBAAgB,GAAGC,oBAAoB,CAACH,QAAQ,CAACI,UAAV,CAA3C;;AACA,MAAIlK,KAAK,CAACO,OAAN,CAAcyJ,gBAAd,CAAJ,EAAqC;AACjC,WAAO,EAAP;AACH,GAFD,MAGK;AACD,QAAI5D,QAAQ,GAAGyD,OAAO,CAACxD,IAAvB;AACA,QAAI8D,kBAAkB,GAAGnK,KAAK,CAACC,QAAN,CAAe+J,gBAAf,EAAiCH,OAAjC,CAAzB;;AACA,QAAIM,kBAAJ,EAAwB;AACpB1E,MAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,QAAAA,OAAO,EAAE3D,cAAc,CAAC8H,uBAAf,CAAuC;AAC5CrF,UAAAA,YAAY,EAAE8E,OAD8B;AAE5CQ,UAAAA,iBAAiB,EAAEN;AAFyB,SAAvC,CADD;AAKR7D,QAAAA,IAAI,EAAErF,yBAAyB,CAACyJ,cALxB;AAMRlE,QAAAA,QAAQ,EAAEA;AANF,OAAZ;AAQH,KAZA,CAaD;AACA;;;AACA,QAAImE,cAAc,GAAGvK,KAAK,CAACwK,UAAN,CAAiBR,gBAAjB,EAAmCD,IAAI,CAAC3F,MAAL,CAAY,CAACyF,OAAD,CAAZ,CAAnC,CAArB;AACA,QAAIY,mBAAmB,GAAGzK,KAAK,CAACQ,GAAN,CAAU+J,cAAV,EAA0B,UAAUG,WAAV,EAAuB;AACvE,UAAIC,OAAO,GAAG3K,KAAK,CAAC4K,QAAN,CAAeb,IAAf,CAAd;AACAY,MAAAA,OAAO,CAAC/F,IAAR,CAAa8F,WAAb;AACA,aAAO7H,uBAAuB,CAACgH,OAAD,EAAUa,WAAV,EAAuBpI,cAAvB,EAAuCqI,OAAvC,CAA9B;AACH,KAJyB,CAA1B;AAKA,WAAOlF,MAAM,CAACrB,MAAP,CAAcpE,KAAK,CAACI,OAAN,CAAcqK,mBAAd,CAAd,CAAP;AACH;AACJ;AACD,OAAO,SAASR,oBAAT,CAA8BC,UAA9B,EAA0C;AAC7C,MAAI7F,MAAM,GAAG,EAAb;;AACA,MAAIrE,KAAK,CAACO,OAAN,CAAc2J,UAAd,CAAJ,EAA+B;AAC3B,WAAO7F,MAAP;AACH;;AACD,MAAIsB,SAAS,GAAG3F,KAAK,CAAC4F,KAAN,CAAYsE,UAAZ,CAAhB;AACA;;AACA,MAAIvE,SAAS,YAAYlE,WAAzB,EAAsC;AAClC4C,IAAAA,MAAM,CAACO,IAAP,CAAYe,SAAS,CAACkF,cAAtB;AACH,GAFD,MAGK,IAAIlF,SAAS,YAAYnE,IAArB,IACLmE,SAAS,YAAYjE,MADhB,IAELiE,SAAS,YAAY/D,mBAFhB,IAGL+D,SAAS,YAAY9D,gCAHhB,IAIL8D,SAAS,YAAY7D,uBAJhB,IAKL6D,SAAS,YAAYhE,UALpB,EAKgC;AACjC0C,IAAAA,MAAM,GAAGA,MAAM,CAACD,MAAP,CAAc6F,oBAAoB,CAACtE,SAAS,CAACuE,UAAX,CAAlC,CAAT;AACH,GAPI,MAQA,IAAIvE,SAAS,YAAYpE,WAAzB,EAAsC;AACvC;AACA8C,IAAAA,MAAM,GAAGrE,KAAK,CAACI,OAAN,CAAcJ,KAAK,CAACQ,GAAN,CAAUmF,SAAS,CAACuE,UAApB,EAAgC,UAAUY,UAAV,EAAsB;AACzE,aAAOb,oBAAoB,CAACa,UAAU,CAACZ,UAAZ,CAA3B;AACH,KAFsB,CAAd,CAAT;AAGH,GALI,MAMA,IAAIvE,SAAS,YAAY5D,QAAzB,EAAmC,CACpC;AACH,GAFI,MAGA;AACD,UAAMgJ,KAAK,CAAC,sBAAD,CAAX;AACH;;AACD,MAAIC,eAAe,GAAGjK,cAAc,CAAC4E,SAAD,CAApC;AACA,MAAIsF,OAAO,GAAGf,UAAU,CAAC1E,MAAX,GAAoB,CAAlC;;AACA,MAAIwF,eAAe,IAAIC,OAAvB,EAAgC;AAC5B,QAAIC,IAAI,GAAGlL,KAAK,CAACmL,IAAN,CAAWjB,UAAX,CAAX;AACA,WAAO7F,MAAM,CAACD,MAAP,CAAc6F,oBAAoB,CAACiB,IAAD,CAAlC,CAAP;AACH,GAHD,MAIK;AACD,WAAO7G,MAAP;AACH;AACJ;;AACD,IAAI+G,WAAW,GAAkB,UAAUtE,MAAV,EAAkB;AAC/C5H,EAAAA,SAAS,CAACkM,WAAD,EAActE,MAAd,CAAT;;AACA,WAASsE,WAAT,GAAuB;AACnB,QAAIrE,KAAK,GAAGD,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AACAF,IAAAA,KAAK,CAACsE,YAAN,GAAqB,EAArB;AACA,WAAOtE,KAAP;AACH;;AACDqE,EAAAA,WAAW,CAACtL,SAAZ,CAAsBgI,gBAAtB,GAAyC,UAAUwD,IAAV,EAAgB;AACrD,SAAKD,YAAL,CAAkBzG,IAAlB,CAAuB0G,IAAvB;AACH,GAFD;;AAGA,SAAOF,WAAP;AACH,CAXgC,CAW/BpJ,WAX+B,CAAjC;;AAYA,OAAO,SAASiB,0BAAT,CAAoC8B,YAApC,EAAkDzC,cAAlD,EAAkE;AACrE,MAAIiJ,WAAW,GAAG,IAAIH,WAAJ,EAAlB;AACArG,EAAAA,YAAY,CAACP,MAAb,CAAoB+G,WAApB;AACA,MAAIC,GAAG,GAAGD,WAAW,CAACF,YAAtB;AACA,MAAI5F,MAAM,GAAGzF,KAAK,CAACU,MAAN,CAAa8K,GAAb,EAAkB,UAAU/F,MAAV,EAAkBgG,MAAlB,EAA0B;AACrD,QAAIC,UAAU,GAAG1L,KAAK,CAAC2L,SAAN,CAAgBF,MAAM,CAACvB,UAAvB,CAAjB;AACA,QAAI0B,UAAU,GAAG5L,KAAK,CAACQ,GAAN,CAAUkL,UAAV,EAAsB,UAAUG,eAAV,EAA2BC,UAA3B,EAAuC;AAC1E,UAAIC,kBAAkB,GAAGzK,uBAAuB,CAAC,CAACuK,eAAD,CAAD,EAAoB,EAApB,EAAwB,IAAxB,EAA8B,CAA9B,CAAhD;;AACA,UAAI7L,KAAK,CAACO,OAAN,CAAcwL,kBAAd,CAAJ,EAAuC;AACnC,eAAO;AACH9F,UAAAA,OAAO,EAAE3D,cAAc,CAAC0J,0BAAf,CAA0C;AAC/CjH,YAAAA,YAAY,EAAEA,YADiC;AAE/CkH,YAAAA,WAAW,EAAER,MAFkC;AAG/CS,YAAAA,cAAc,EAAEJ;AAH+B,WAA1C,CADN;AAMH5F,UAAAA,IAAI,EAAErF,yBAAyB,CAACsL,mBAN7B;AAOH/F,UAAAA,QAAQ,EAAErB,YAAY,CAACsB,IAPpB;AAQHC,UAAAA,UAAU,EAAEmF,MAAM,CAAClF,GARhB;AASH6F,UAAAA,WAAW,EAAEN,UAAU,GAAG;AATvB,SAAP;AAWH,OAZD,MAaK;AACD,eAAO,IAAP;AACH;AACJ,KAlBgB,CAAjB;AAmBA,WAAOrG,MAAM,CAACrB,MAAP,CAAcpE,KAAK,CAACqM,OAAN,CAAcT,UAAd,CAAd,CAAP;AACH,GAtBY,EAsBV,EAtBU,CAAb;AAuBA,SAAOnG,MAAP;AACH;AACD,OAAO,SAASvC,wCAAT,CAAkD6B,YAAlD,EAAgE5C,kBAAhE,EAAoFE,aAApF,EAAmGC,cAAnG,EAAmH;AACtH,MAAIiJ,WAAW,GAAG,IAAIH,WAAJ,EAAlB;AACArG,EAAAA,YAAY,CAACP,MAAb,CAAoB+G,WAApB;AACA,MAAIC,GAAG,GAAGD,WAAW,CAACF,YAAtB,CAHsH,CAItH;AACA;;AACA,MAAIiB,2BAA2B,GAAGjK,aAAa,CAAC0C,YAAY,CAACsB,IAAd,CAA/C;;AACA,MAAIiG,2BAAJ,EAAiC;AAC7Bd,IAAAA,GAAG,GAAG7K,MAAM,CAAC6K,GAAD,EAAM,UAAUC,MAAV,EAAkB;AAChC,aAAOa,2BAA2B,CAACxL,oBAAoB,CAAC2K,MAAD,CAApB,IAC9BA,MAAM,CAAClF,GAAP,KAAe,CAAf,GAAmB,EAAnB,GAAwBkF,MAAM,CAAClF,GADD,CAAD,CAAlC;AAEH,KAHW,CAAZ;AAIH,GAZqH,CAatH;AACA;;;AACAiF,EAAAA,GAAG,GAAG7K,MAAM,CAAC6K,GAAD,EAAM,UAAUC,MAAV,EAAkB;AAAE,WAAOA,MAAM,CAACc,iBAAP,KAA6B,IAApC;AAA2C,GAArE,CAAZ;AACA,MAAI9G,MAAM,GAAGzF,KAAK,CAACU,MAAN,CAAa8K,GAAb,EAAkB,UAAUnH,MAAV,EAAkBoH,MAAlB,EAA0B;AACrD,QAAIe,cAAc,GAAGf,MAAM,CAAClF,GAA5B;AACA,QAAIkG,kBAAkB,GAAGhB,MAAM,CAACiB,YAAP,IAAuBvK,kBAAhD;AACA,QAAIwK,YAAY,GAAGzL,sBAAsB,CAACsL,cAAD,EAAiBzH,YAAjB,EAA+B0H,kBAA/B,EAAmDhB,MAAnD,CAAzC;AACA,QAAImB,mBAAmB,GAAGC,4BAA4B,CAACF,YAAD,EAAelB,MAAf,EAAuB1G,YAAvB,EAAqCzC,cAArC,CAAtD;AACA,QAAIwK,yBAAyB,GAAGC,kCAAkC,CAACJ,YAAD,EAAelB,MAAf,EAAuB1G,YAAvB,EAAqCzC,cAArC,CAAlE;AACA,WAAO+B,MAAM,CAACD,MAAP,CAAcwI,mBAAd,EAAmCE,yBAAnC,CAAP;AACH,GAPY,EAOV,EAPU,CAAb;AAQA,SAAOrH,MAAP;AACH;;AACD,IAAIuH,iBAAiB,GAAkB,UAAUlG,MAAV,EAAkB;AACrD5H,EAAAA,SAAS,CAAC8N,iBAAD,EAAoBlG,MAApB,CAAT;;AACA,WAASkG,iBAAT,GAA6B;AACzB,QAAIjG,KAAK,GAAGD,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AACAF,IAAAA,KAAK,CAAC5B,cAAN,GAAuB,EAAvB;AACA,WAAO4B,KAAP;AACH;;AACDiG,EAAAA,iBAAiB,CAAClN,SAAlB,CAA4BwH,4BAA5B,GAA2D,UAAUC,OAAV,EAAmB;AAC1E,SAAKpC,cAAL,CAAoBP,IAApB,CAAyB2C,OAAzB;AACH,GAFD;;AAGAyF,EAAAA,iBAAiB,CAAClN,SAAlB,CAA4B0H,wBAA5B,GAAuD,UAAUC,UAAV,EAAsB;AACzE,SAAKtC,cAAL,CAAoBP,IAApB,CAAyB6C,UAAzB;AACH,GAFD;;AAGAuF,EAAAA,iBAAiB,CAAClN,SAAlB,CAA4B4H,qCAA5B,GAAoE,UAAUC,aAAV,EAAyB;AACzF,SAAKxC,cAAL,CAAoBP,IAApB,CAAyB+C,aAAzB;AACH,GAFD;;AAGAqF,EAAAA,iBAAiB,CAAClN,SAAlB,CAA4B8H,eAA5B,GAA8C,UAAUC,IAAV,EAAgB;AAC1D,SAAK1C,cAAL,CAAoBP,IAApB,CAAyBiD,IAAzB;AACH,GAFD;;AAGA,SAAOmF,iBAAP;AACH,CApBsC,CAoBrChL,WApBqC,CAAvC;;AAqBA,SAASgL,iBAAT;AACA,OAAO,SAASjJ,mBAAT,CAA6BgB,YAA7B,EAA2CzC,cAA3C,EAA2D;AAC9D,MAAIiJ,WAAW,GAAG,IAAIH,WAAJ,EAAlB;AACArG,EAAAA,YAAY,CAACP,MAAb,CAAoB+G,WAApB;AACA,MAAIC,GAAG,GAAGD,WAAW,CAACF,YAAtB;AACA,MAAI5F,MAAM,GAAGzF,KAAK,CAACU,MAAN,CAAa8K,GAAb,EAAkB,UAAU/F,MAAV,EAAkBgG,MAAlB,EAA0B;AACrD,QAAIA,MAAM,CAACvB,UAAP,CAAkB1E,MAAlB,GAA2B,GAA/B,EAAoC;AAChCC,MAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,QAAAA,OAAO,EAAE3D,cAAc,CAAC2K,6BAAf,CAA6C;AAClDlI,UAAAA,YAAY,EAAEA,YADoC;AAElDkH,UAAAA,WAAW,EAAER;AAFqC,SAA7C,CADD;AAKRvF,QAAAA,IAAI,EAAErF,yBAAyB,CAACqM,aALxB;AAMR9G,QAAAA,QAAQ,EAAErB,YAAY,CAACsB,IANf;AAORC,QAAAA,UAAU,EAAEmF,MAAM,CAAClF;AAPX,OAAZ;AASH;;AACD,WAAOd,MAAP;AACH,GAbY,EAaV,EAbU,CAAb;AAcA,SAAOA,MAAP;AACH;AACD,OAAO,SAAStC,iCAAT,CAA2CgK,aAA3C,EAA0DT,YAA1D,EAAwEpK,cAAxE,EAAwF;AAC3F,MAAImD,MAAM,GAAG,EAAb;AACApF,EAAAA,OAAO,CAAC8M,aAAD,EAAgB,UAAUvK,WAAV,EAAuB;AAC1C,QAAIoC,gBAAgB,GAAG,IAAIgI,iBAAJ,EAAvB;AACApK,IAAAA,WAAW,CAAC4B,MAAZ,CAAmBQ,gBAAnB;AACA,QAAIE,kBAAkB,GAAGF,gBAAgB,CAACG,cAA1C;AACA9E,IAAAA,OAAO,CAAC6E,kBAAD,EAAqB,UAAUkI,QAAV,EAAoB;AAC5C,UAAIC,QAAQ,GAAGlM,WAAW,CAACiM,QAAD,CAA1B;AACA,UAAIX,kBAAkB,GAAGW,QAAQ,CAACV,YAAT,IAAyBA,YAAlD;AACA,UAAIF,cAAc,GAAGY,QAAQ,CAAC7G,GAA9B;AACA,UAAI+G,KAAK,GAAGrM,gCAAgC,CAACuL,cAAD,EAAiB5J,WAAjB,EAA8ByK,QAA9B,EAAwCZ,kBAAxC,CAA5C;AACA,UAAIc,qBAAqB,GAAGD,KAAK,CAAC,CAAD,CAAjC;;AACA,UAAI/M,OAAO,CAACH,OAAO,CAACmN,qBAAD,CAAR,CAAX,EAA6C;AACzC,YAAIzE,MAAM,GAAGxG,cAAc,CAACkL,yBAAf,CAAyC;AAClDzI,UAAAA,YAAY,EAAEnC,WADoC;AAElD6K,UAAAA,UAAU,EAAEL;AAFsC,SAAzC,CAAb;AAIA3H,QAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,UAAAA,OAAO,EAAE6C,MADD;AAER5C,UAAAA,IAAI,EAAErF,yBAAyB,CAAC6M,sBAFxB;AAGRtH,UAAAA,QAAQ,EAAExD,WAAW,CAACyD;AAHd,SAAZ;AAKH;AACJ,KAjBM,CAAP;AAkBH,GAtBM,CAAP;AAuBA,SAAOZ,MAAP;AACH;;AACD,SAASoH,4BAAT,CAAsCF,YAAtC,EAAoDV,WAApD,EAAiE1D,IAAjE,EAAuEjG,cAAvE,EAAuF;AACnF,MAAIqL,mBAAmB,GAAG,EAA1B;AACA,MAAIC,oBAAoB,GAAGlN,MAAM,CAACiM,YAAD,EAAe,UAAUtI,MAAV,EAAkBwJ,OAAlB,EAA2B/B,UAA3B,EAAuC;AACnF;AACA,QAAIG,WAAW,CAAC/B,UAAZ,CAAuB4B,UAAvB,EAAmCS,iBAAnC,KAAyD,IAA7D,EAAmE;AAC/D,aAAOlI,MAAP;AACH;;AACDhE,IAAAA,OAAO,CAACwN,OAAD,EAAU,UAAUC,QAAV,EAAoB;AACjC,UAAIC,qBAAqB,GAAG,CAACjC,UAAD,CAA5B;AACAzL,MAAAA,OAAO,CAACsM,YAAD,EAAe,UAAUqB,YAAV,EAAwBC,eAAxB,EAAyC;AAC3D,YAAInC,UAAU,KAAKmC,eAAf,IACAjN,YAAY,CAACgN,YAAD,EAAeF,QAAf,CADZ,IAEA;AACA7B,QAAAA,WAAW,CAAC/B,UAAZ,CAAuB+D,eAAvB,EACK1B,iBADL,KAC2B,IAJ/B,EAIqC;AACjCwB,UAAAA,qBAAqB,CAACnJ,IAAtB,CAA2BqJ,eAA3B;AACH;AACJ,OARM,CAAP;;AASA,UAAIF,qBAAqB,CAACvI,MAAtB,GAA+B,CAA/B,IACA,CAACxE,YAAY,CAAC2M,mBAAD,EAAsBG,QAAtB,CADjB,EACkD;AAC9CH,QAAAA,mBAAmB,CAAC/I,IAApB,CAAyBkJ,QAAzB;AACAzJ,QAAAA,MAAM,CAACO,IAAP,CAAY;AACRsJ,UAAAA,IAAI,EAAEH,qBADE;AAERhE,UAAAA,IAAI,EAAE+D;AAFE,SAAZ;AAIH;AACJ,KAnBM,CAAP;AAoBA,WAAOzJ,MAAP;AACH,GA1BgC,EA0B9B,EA1B8B,CAAjC;AA2BA,MAAIuH,UAAU,GAAG5L,KAAK,CAACQ,GAAN,CAAUoN,oBAAV,EAAgC,UAAUO,iBAAV,EAA6B;AAC1E,QAAIC,WAAW,GAAG5N,GAAG,CAAC2N,iBAAiB,CAACD,IAAnB,EAAyB,UAAUpC,UAAV,EAAsB;AAAE,aAAOA,UAAU,GAAG,CAApB;AAAwB,KAAzE,CAArB;AACA,QAAIuC,WAAW,GAAG/L,cAAc,CAACgM,8BAAf,CAA8C;AAC5DvJ,MAAAA,YAAY,EAAEwD,IAD8C;AAE5D0D,MAAAA,WAAW,EAAEA,WAF+C;AAG5DsC,MAAAA,gBAAgB,EAAEH,WAH0C;AAI5DI,MAAAA,UAAU,EAAEL,iBAAiB,CAACpE;AAJ8B,KAA9C,CAAlB;AAMA,WAAO;AACH9D,MAAAA,OAAO,EAAEoI,WADN;AAEHnI,MAAAA,IAAI,EAAErF,yBAAyB,CAAC4N,cAF7B;AAGHrI,MAAAA,QAAQ,EAAEmC,IAAI,CAAClC,IAHZ;AAIHC,MAAAA,UAAU,EAAE2F,WAAW,CAAC1F,GAJrB;AAKHoG,MAAAA,YAAY,EAAE,CAACwB,iBAAiB,CAACD,IAAnB;AALX,KAAP;AAOH,GAfgB,CAAjB;AAgBA,SAAOtC,UAAP;AACH;;AACD,OAAO,SAASmB,kCAAT,CAA4CJ,YAA5C,EAA0DV,WAA1D,EAAuE1D,IAAvE,EAA6EjG,cAA7E,EAA6F;AAChG,MAAImD,MAAM,GAAG,EAAb,CADgG,CAEhG;;AACA,MAAIiJ,eAAe,GAAGhO,MAAM,CAACiM,YAAD,EAAe,UAAUtI,MAAV,EAAkBwJ,OAAlB,EAA2BtH,GAA3B,EAAgC;AACvE,QAAIoI,eAAe,GAAGnO,GAAG,CAACqN,OAAD,EAAU,UAAUC,QAAV,EAAoB;AACnD,aAAO;AAAEvH,QAAAA,GAAG,EAAEA,GAAP;AAAYwD,QAAAA,IAAI,EAAE+D;AAAlB,OAAP;AACH,KAFwB,CAAzB;AAGA,WAAOzJ,MAAM,CAACD,MAAP,CAAcuK,eAAd,CAAP;AACH,GAL2B,EAKzB,EALyB,CAA5B;AAMAtO,EAAAA,OAAO,CAACqO,eAAD,EAAkB,UAAUE,cAAV,EAA0B;AAC/C,QAAIC,eAAe,GAAG5C,WAAW,CAAC/B,UAAZ,CAAuB0E,cAAc,CAACrI,GAAtC,CAAtB,CAD+C,CAE/C;;AACA,QAAIsI,eAAe,CAACtC,iBAAhB,KAAsC,IAA1C,EAAgD;AAC5C;AACH;;AACD,QAAIuC,SAAS,GAAGF,cAAc,CAACrI,GAA/B;AACA,QAAIwI,UAAU,GAAGH,cAAc,CAAC7E,IAAhC;AACA,QAAIiF,gCAAgC,GAAG7O,OAAO,CAACuO,eAAD,EAAkB,UAAUO,gBAAV,EAA4B;AACxF;AACA,aACA;AACAhD,QAAAA,WAAW,CAAC/B,UAAZ,CAAuB+E,gBAAgB,CAAC1I,GAAxC,EACKgG,iBADL,KAC2B,IAD3B,IAEI0C,gBAAgB,CAAC1I,GAAjB,GAAuBuI,SAF3B,IAGI;AACA;AACA1N,QAAAA,oBAAoB,CAAC6N,gBAAgB,CAAClF,IAAlB,EAAwBgF,UAAxB;AAPxB;AAQH,KAV6C,CAA9C;AAWA,QAAIG,oBAAoB,GAAG1O,GAAG,CAACwO,gCAAD,EAAmC,UAAUG,iBAAV,EAA6B;AAC1F,UAAIf,WAAW,GAAG,CAACe,iBAAiB,CAAC5I,GAAlB,GAAwB,CAAzB,EAA4BuI,SAAS,GAAG,CAAxC,CAAlB;AACA,UAAIxI,UAAU,GAAG2F,WAAW,CAAC1F,GAAZ,KAAoB,CAApB,GAAwB,EAAxB,GAA6B0F,WAAW,CAAC1F,GAA1D;AACA,UAAIN,OAAO,GAAG3D,cAAc,CAAC8M,oCAAf,CAAoD;AAC9DrK,QAAAA,YAAY,EAAEwD,IADgD;AAE9D0D,QAAAA,WAAW,EAAEA,WAFiD;AAG9DsC,QAAAA,gBAAgB,EAAEH,WAH4C;AAI9DI,QAAAA,UAAU,EAAEW,iBAAiB,CAACpF;AAJgC,OAApD,CAAd;AAMA,aAAO;AACH9D,QAAAA,OAAO,EAAEA,OADN;AAEHC,QAAAA,IAAI,EAAErF,yBAAyB,CAACwO,qBAF7B;AAGHjJ,QAAAA,QAAQ,EAAEmC,IAAI,CAAClC,IAHZ;AAIHC,QAAAA,UAAU,EAAEA,UAJT;AAKHqG,QAAAA,YAAY,EAAEyB;AALX,OAAP;AAOH,KAhB6B,CAA9B;AAiBA3I,IAAAA,MAAM,GAAGA,MAAM,CAACrB,MAAP,CAAc8K,oBAAd,CAAT;AACH,GArCM,CAAP;AAsCA,SAAOzJ,MAAP;AACH;;AACD,SAASpC,sCAAT,CAAgDnB,SAAhD,EAA2DE,UAA3D,EAAuEE,cAAvE,EAAuF;AACnF,MAAImD,MAAM,GAAG,EAAb;AACA,MAAI6J,UAAU,GAAG9O,GAAG,CAAC4B,UAAD,EAAa,UAAUmN,SAAV,EAAqB;AAAE,WAAOA,SAAS,CAAClJ,IAAjB;AAAwB,GAA5D,CAApB;AACAhG,EAAAA,OAAO,CAAC6B,SAAD,EAAY,UAAU4H,QAAV,EAAoB;AACnC,QAAI0F,YAAY,GAAG1F,QAAQ,CAACzD,IAA5B;;AACA,QAAIpG,QAAQ,CAACqP,UAAD,EAAaE,YAAb,CAAZ,EAAwC;AACpC,UAAI1G,MAAM,GAAGxG,cAAc,CAACmN,2BAAf,CAA2C3F,QAA3C,CAAb;AACArE,MAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,QAAAA,OAAO,EAAE6C,MADD;AAER5C,QAAAA,IAAI,EAAErF,yBAAyB,CAAC6O,+BAFxB;AAGRtJ,QAAAA,QAAQ,EAAEoJ;AAHF,OAAZ;AAKH;AACJ,GAVM,CAAP;AAWA,SAAO/J,MAAP;AACH;;AACD,SAAS7B,4BAAT,CAAsCuJ,aAAtC,EAAqD7K,cAArD,EAAqE;AACjE,MAAImD,MAAM,GAAG,EAAb;AACApF,EAAAA,OAAO,CAAC8M,aAAD,EAAgB,UAAUvK,WAAV,EAAuB;AAC1C,QAAI2B,qBAAqB,GAAG,IAAIlD,+BAAJ,CAAoC,EAApC,CAA5B;AACAuB,IAAAA,WAAW,CAAC4B,MAAZ,CAAmBD,qBAAnB;AACA,QAAIoL,YAAY,GAAGrP,OAAO,CAACiE,qBAAqB,CAACF,MAAvB,EAA+B,UAAUuL,IAAV,EAAgB;AAAE,aAAOA,IAAI,CAACvJ,IAAZ;AAAmB,KAApE,CAA1B;AACA,QAAIf,UAAU,GAAG7E,IAAI,CAACkP,YAAD,EAAe,UAAUpK,SAAV,EAAqB;AACrD,aAAOA,SAAS,CAACC,MAAV,GAAmB,CAA1B;AACH,KAFoB,CAArB;AAGAnF,IAAAA,OAAO,CAACO,MAAM,CAAC0E,UAAD,CAAP,EAAqB,UAAUuK,YAAV,EAAwB;AAChD,UAAIC,YAAY,GAAGtP,GAAG,CAACqP,YAAD,EAAe,UAAUE,QAAV,EAAoB;AAAE,eAAOA,QAAQ,CAACpL,OAAhB;AAA0B,OAA/D,CAAtB;AACA,UAAImE,MAAM,GAAGxG,cAAc,CAAC0N,iCAAf,CAAiDpN,WAAjD,EAA8DkN,YAA9D,CAAb;AACArK,MAAAA,MAAM,CAACb,IAAP,CAAY;AACRqB,QAAAA,OAAO,EAAE6C,MADD;AAER5C,QAAAA,IAAI,EAAErF,yBAAyB,CAACoP,qBAFxB;AAGR7J,QAAAA,QAAQ,EAAExD,WAAW,CAACyD;AAHd,OAAZ;AAKH,KARM,CAAP;AASH,GAhBM,CAAP;AAiBA,SAAOZ,MAAP;AACH","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, groupBy, isEmpty, map, pick, reduce, reject, values } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { NamedDSLMethodsCollectorVisitor } from \"../cst/cst\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, ignoredIssues, errMsgProvider, grammarName) {\n    var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n    });\n    var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n    });\n    var emptyAltErrors = [];\n    var ambiguousAltsErrors = [];\n    var emptyRepetitionErrors = [];\n    // left recursion could cause infinite loops in the following validations.\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n    if (every(leftRecursionErrors, isEmpty)) {\n        emptyAltErrors = map(topLevels, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n        });\n        ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, ignoredIssues, errMsgProvider);\n        });\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n    }\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    var tokenNameErrors = utils.map(tokenTypes, function (currTokType) {\n        return validateTokenName(currTokType, errMsgProvider);\n    });\n    var nestedRulesNameErrors = validateNestedRulesNames(topLevels, errMsgProvider);\n    var nestedRulesDuplicateErrors = validateDuplicateNestedRules(topLevels, errMsgProvider);\n    var tooManyAltsErrors = map(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n    });\n    var ruleNameErrors = map(topLevels, function (curRule) {\n        return validateRuleName(curRule, errMsgProvider);\n    });\n    var duplicateRulesError = map(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n    });\n    return (utils.flatten(duplicateErrors.concat(tokenNameErrors, nestedRulesNameErrors, nestedRulesDuplicateErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError)));\n}\nfunction validateNestedRulesNames(topLevels, errMsgProvider) {\n    var result = [];\n    forEach(topLevels, function (curTopLevel) {\n        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(\"\");\n        curTopLevel.accept(namedCollectorVisitor);\n        var nestedProds = map(namedCollectorVisitor.result, function (currItem) { return currItem.orgProd; });\n        result.push(map(nestedProds, function (currNestedProd) {\n            return validateNestedRuleName(curTopLevel, currNestedProd, errMsgProvider);\n        }));\n    });\n    return flatten(result);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    var collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n    var duplicates = utils.pick(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n    });\n    var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n        var firstProd = utils.first(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = getProductionDslName(firstProd);\n        var defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n    return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\n    __extends(OccurrenceValidationCollector, _super);\n    function OccurrenceValidationCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n        this.allProductions.push(subrule);\n    };\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\n        this.allProductions.push(option);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n        this.allProductions.push(or);\n    };\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n        this.allProductions.push(terminal);\n    };\n    return OccurrenceValidationCollector;\n}(GAstVisitor));\nexport { OccurrenceValidationCollector };\nexport var validTermsPattern = /^[a-zA-Z_]\\w*$/;\nexport var validNestedRuleName = new RegExp(validTermsPattern.source.replace(\"^\", \"^\\\\$\"));\n// TODO: remove this limitation now that we use recorders\nexport function validateRuleName(rule, errMsgProvider) {\n    var errors = [];\n    var ruleName = rule.name;\n    if (!ruleName.match(validTermsPattern)) {\n        errors.push({\n            message: errMsgProvider.buildInvalidRuleNameError({\n                topLevelRule: rule,\n                expectedPattern: validTermsPattern\n            }),\n            type: ParserDefinitionErrorType.INVALID_RULE_NAME,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\n// TODO: did the nested rule name regExp now change?\nexport function validateNestedRuleName(topLevel, nestedProd, errMsgProvider) {\n    var errors = [];\n    var errMsg;\n    if (!nestedProd.name.match(validNestedRuleName)) {\n        errMsg = errMsgProvider.buildInvalidNestedRuleNameError(topLevel, nestedProd);\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,\n            ruleName: topLevel.name\n        });\n    }\n    return errors;\n}\n// TODO: remove this limitation now that we use recorders\nexport function validateTokenName(tokenType, errMsgProvider) {\n    var errors = [];\n    var tokTypeName = tokenType.name;\n    if (!tokTypeName.match(validTermsPattern)) {\n        errors.push({\n            message: errMsgProvider.buildTokenNameError({\n                tokenType: tokenType,\n                expectedPattern: validTermsPattern\n            }),\n            type: ParserDefinitionErrorType.INVALID_TOKEN_NAME\n        });\n    }\n    return errors;\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    var errors = [];\n    var occurrences = reduce(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    var errors = [];\n    var errMsg;\n    if (!utils.contains(definedRulesNames, ruleName)) {\n        errMsg =\n            \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" +\n                \"as it is not defined in any of the super grammars \";\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n    if (path === void 0) { path = []; }\n    var errors = [];\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (utils.isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n            var newPath = utils.cloneArr(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(utils.flatten(errorsFromNextSteps));\n    }\n}\nexport function getFirstNoneTerminal(definition) {\n    var result = [];\n    if (utils.isEmpty(definition)) {\n        return result;\n    }\n    var firstProd = utils.first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof Flat ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n            return getFirstNoneTerminal(currSubDef.definition);\n        }));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    var isFirstOptional = isOptionalProd(firstProd);\n    var hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        var rest = utils.drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nvar OrCollector = /** @class */ (function (_super) {\n    __extends(OrCollector, _super);\n    function OrCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.alternations = [];\n        return _this;\n    }\n    OrCollector.prototype.visitAlternation = function (node) {\n        this.alternations.push(node);\n    };\n    return OrCollector;\n}(GAstVisitor));\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        var exceptLast = utils.dropRight(currOr.definition);\n        var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n            var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n            if (utils.isEmpty(possibleFirstInAlt)) {\n                return {\n                    message: errMsgProvider.buildEmptyAlternationError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                        emptyChoiceIdx: currAltIdx\n                    }),\n                    type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                    alternative: currAltIdx + 1\n                };\n            }\n            else {\n                return null;\n            }\n        });\n        return errors.concat(utils.compact(currErrors));\n    }, []);\n    return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, ignoredIssues, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    // TODO: this filtering should be deprecated once we remove the ignoredIssues\n    //  IParserConfig property\n    var ignoredIssuesForCurrentRule = ignoredIssues[topLevelRule.name];\n    if (ignoredIssuesForCurrentRule) {\n        ors = reject(ors, function (currOr) {\n            return ignoredIssuesForCurrentRule[getProductionDslName(currOr) +\n                (currOr.idx === 0 ? \"\" : currOr.idx)];\n        });\n    }\n    // New Handling of ignoring ambiguities\n    // - https://github.com/SAP/chevrotain/issues/869\n    ors = reject(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\n    var errors = utils.reduce(ors, function (result, currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n    }, []);\n    return errors;\n}\nvar RepetionCollector = /** @class */ (function (_super) {\n    __extends(RepetionCollector, _super);\n    function RepetionCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    RepetionCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    return RepetionCollector;\n}(GAstVisitor));\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        if (currOr.definition.length > 255) {\n            errors.push({\n                message: errMsgProvider.buildTooManyAlternativesError({\n                    topLevelRule: topLevelRule,\n                    alternation: currOr\n                }),\n                type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                ruleName: topLevelRule.name,\n                occurrence: currOr.idx\n            });\n        }\n        return errors;\n    }, []);\n    return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    var errors = [];\n    forEach(topLevelRules, function (currTopRule) {\n        var collectorVisitor = new RepetionCollector();\n        currTopRule.accept(collectorVisitor);\n        var allRuleProductions = collectorVisitor.allProductions;\n        forEach(allRuleProductions, function (currProd) {\n            var prodType = getProdType(currProd);\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            var currOccurrence = currProd.idx;\n            var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            var pathsInsideProduction = paths[0];\n            if (isEmpty(flatten(pathsInsideProduction))) {\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var foundAmbiguousPaths = [];\n    var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        forEach(currAlt, function (currPath) {\n            var altsCurrPathAppearsIn = [currAltIdx];\n            forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx]\n                        .ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: [currAmbDescriptor.alts]\n        };\n    });\n    return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var errors = [];\n    // flatten\n    var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = map(currAlt, function (currPath) {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    forEach(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return;\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx]\n                .ignoreAmbiguities !== true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        errors = errors.concat(currPathPrefixErrors);\n    });\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    var errors = [];\n    var tokenNames = map(tokenTypes, function (currToken) { return currToken.name; });\n    forEach(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if (contains(tokenNames, currRuleName)) {\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\nfunction validateDuplicateNestedRules(topLevelRules, errMsgProvider) {\n    var errors = [];\n    forEach(topLevelRules, function (currTopRule) {\n        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(\"\");\n        currTopRule.accept(namedCollectorVisitor);\n        var prodsByGroup = groupBy(namedCollectorVisitor.result, function (item) { return item.name; });\n        var duplicates = pick(prodsByGroup, function (currGroup) {\n            return currGroup.length > 1;\n        });\n        forEach(values(duplicates), function (currDupGroup) {\n            var currDupProds = map(currDupGroup, function (dupGroup) { return dupGroup.orgProd; });\n            var errMsg = errMsgProvider.buildDuplicateNestedRuleNameError(currTopRule, currDupProds);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,\n                ruleName: currTopRule.name\n            });\n        });\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map"]},"metadata":{},"sourceType":"module"}