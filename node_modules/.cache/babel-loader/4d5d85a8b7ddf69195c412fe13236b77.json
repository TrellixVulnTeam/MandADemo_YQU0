{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { simpleCellAddress } from '../Cell';\nimport { CellAddress } from './CellAddress';\nimport { ColumnAddress } from './ColumnAddress';\nimport { sheetNameRegexp, simpleSheetName } from './LexerConfig';\nimport { RowAddress } from './RowAddress';\nvar addressRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\$?)([A-Za-z]+)(\\\\$?)([0-9]+)$\"));\nvar columnRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\$?)([A-Za-z]+)$\"));\nvar rowRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\$?)([0-9]+)$\"));\nvar simpleSheetNameRegex = new RegExp(\"^\".concat(simpleSheetName, \"$\"));\n/**\n * Computes R0C0 representation of cell address based on it's string representation and base address.\n *\n * @param sheetMapping - mapping function needed to change name of a sheet to index\n * @param stringAddress - string representation of cell address, e.g. 'C64'\n * @param baseAddress - base address for R0C0 conversion\n * @returns object representation of address\n */\n\nexport var cellAddressFromString = function cellAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = addressRegex.exec(stringAddress);\n  var col = columnLabelToIndex(result[6]);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  var row = Number(result[8]) - 1;\n\n  if (result[5] === '$' && result[7] === '$') {\n    return CellAddress.absolute(sheet, col, row);\n  } else if (result[5] === '$') {\n    return CellAddress.absoluteCol(sheet, col, row - baseAddress.row);\n  } else if (result[7] === '$') {\n    return CellAddress.absoluteRow(sheet, col - baseAddress.col, row);\n  } else {\n    return CellAddress.relative(sheet, col - baseAddress.col, row - baseAddress.row);\n  }\n};\nexport var columnAddressFromString = function columnAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = columnRegex.exec(stringAddress);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  var col = columnLabelToIndex(result[6]);\n\n  if (result[5] === '$') {\n    return ColumnAddress.absolute(sheet, col);\n  } else {\n    return ColumnAddress.relative(sheet, col - baseAddress.col);\n  }\n};\nexport var rowAddressFromString = function rowAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = rowRegex.exec(stringAddress);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  var row = Number(result[6]) - 1;\n\n  if (result[5] === '$') {\n    return RowAddress.absolute(sheet, row);\n  } else {\n    return RowAddress.relative(sheet, row - baseAddress.row);\n  }\n};\n/**\n * Computes simple (absolute) address of a cell address based on its string representation.\n * If sheet name present in string representation but is not present in sheet mapping, returns undefined.\n * If sheet name is not present in string representation, returns {@param sheetContext} as sheet number\n *\n * @param sheetMapping - mapping function needed to change name of a sheet to index\n * @param stringAddress - string representation of cell address, e.g. 'C64'\n * @param sheetContext - sheet in context of which we should parse the address\n * @returns absolute representation of address, e.g. { sheet: 0, col: 1, row: 1 }\n */\n\nexport var simpleCellAddressFromString = function simpleCellAddressFromString(sheetMapping, stringAddress, sheetContext) {\n  var result = addressRegex.exec(stringAddress);\n  var col = columnLabelToIndex(result[6]);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = sheetContext;\n  }\n\n  var row = Number(result[8]) - 1;\n  return simpleCellAddress(sheet, col, row);\n};\n/**\n * Returns string representation of absolute address\n * If sheet index is not present in sheet mapping, returns undefined\n *\n * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name\n * @param address - object representation of absolute address\n * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name\n * */\n\nexport var simpleCellAddressToString = function simpleCellAddressToString(sheetIndexMapping, address, sheetIndex) {\n  var column = columnIndexToLabel(address.col);\n  var sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);\n\n  if (sheetName === undefined) {\n    return undefined;\n  }\n\n  if (sheetIndex !== address.sheet) {\n    return \"\".concat(sheetName, \"!\").concat(column).concat(address.row + 1);\n  } else {\n    return \"\".concat(column).concat(address.row + 1);\n  }\n};\n/**\n* Convert column label to index\n*\n* @param columnStringRepresentation - column label (e.g. 'AAB')\n* @returns column index\n* */\n\nfunction columnLabelToIndex(columnStringRepresentation) {\n  if (columnStringRepresentation.length === 1) {\n    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;\n  } else {\n    return columnStringRepresentation.split('').reduce(function (currentColumn, nextLetter) {\n      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);\n    }, 0) - 1;\n  }\n}\n/**\n * Converts column index to label\n *\n * @param column - address to convert\n * @returns string representation, e.g. 'AAB'\n */\n\n\nexport function columnIndexToLabel(column) {\n  var result = '';\n\n  while (column >= 0) {\n    result = String.fromCharCode(column % 26 + 97) + result;\n    column = Math.floor(column / 26) - 1;\n  }\n\n  return result.toUpperCase();\n}\nexport function sheetIndexToString(sheetId, sheetMappingFn) {\n  var sheetName = sheetMappingFn(sheetId);\n\n  if (sheetName === undefined) {\n    return undefined;\n  }\n\n  if (simpleSheetNameRegex.test(sheetName)) {\n    return sheetName;\n  } else {\n    sheetName = sheetName.replace(/'/g, \"''\");\n    return \"'\".concat(sheetName, \"'\");\n  }\n}\n\nfunction extractSheetNumber(regexResult, sheetMapping) {\n  var _a;\n\n  var maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];\n  var sheet = null;\n\n  if (maybeSheetName) {\n    maybeSheetName = maybeSheetName.replace(/''/g, \"'\");\n    sheet = sheetMapping(maybeSheetName);\n\n    if (sheet === undefined) {\n      return undefined;\n    }\n  }\n\n  return sheet;\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/parser/addressRepresentationConverters.js"],"names":["simpleCellAddress","CellAddress","ColumnAddress","sheetNameRegexp","simpleSheetName","RowAddress","addressRegex","RegExp","concat","columnRegex","rowRegex","simpleSheetNameRegex","cellAddressFromString","sheetMapping","stringAddress","baseAddress","result","exec","col","columnLabelToIndex","sheet","extractSheetNumber","undefined","row","Number","absolute","absoluteCol","absoluteRow","relative","columnAddressFromString","rowAddressFromString","simpleCellAddressFromString","sheetContext","simpleCellAddressToString","sheetIndexMapping","address","sheetIndex","column","columnIndexToLabel","sheetName","sheetIndexToString","columnStringRepresentation","length","toUpperCase","charCodeAt","split","reduce","currentColumn","nextLetter","String","fromCharCode","Math","floor","sheetId","sheetMappingFn","test","replace","regexResult","_a","maybeSheetName"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.replace.js\";\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nimport { simpleCellAddress } from '../Cell';\nimport { CellAddress } from './CellAddress';\nimport { ColumnAddress } from './ColumnAddress';\nimport { sheetNameRegexp, simpleSheetName } from './LexerConfig';\nimport { RowAddress } from './RowAddress';\nvar addressRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\$?)([A-Za-z]+)(\\\\$?)([0-9]+)$\"));\nvar columnRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\$?)([A-Za-z]+)$\"));\nvar rowRegex = new RegExp(\"^(\".concat(sheetNameRegexp, \")?(\\\\$?)([0-9]+)$\"));\nvar simpleSheetNameRegex = new RegExp(\"^\".concat(simpleSheetName, \"$\"));\n/**\n * Computes R0C0 representation of cell address based on it's string representation and base address.\n *\n * @param sheetMapping - mapping function needed to change name of a sheet to index\n * @param stringAddress - string representation of cell address, e.g. 'C64'\n * @param baseAddress - base address for R0C0 conversion\n * @returns object representation of address\n */\n\nexport var cellAddressFromString = function cellAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = addressRegex.exec(stringAddress);\n  var col = columnLabelToIndex(result[6]);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  var row = Number(result[8]) - 1;\n\n  if (result[5] === '$' && result[7] === '$') {\n    return CellAddress.absolute(sheet, col, row);\n  } else if (result[5] === '$') {\n    return CellAddress.absoluteCol(sheet, col, row - baseAddress.row);\n  } else if (result[7] === '$') {\n    return CellAddress.absoluteRow(sheet, col - baseAddress.col, row);\n  } else {\n    return CellAddress.relative(sheet, col - baseAddress.col, row - baseAddress.row);\n  }\n};\nexport var columnAddressFromString = function columnAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = columnRegex.exec(stringAddress);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  var col = columnLabelToIndex(result[6]);\n\n  if (result[5] === '$') {\n    return ColumnAddress.absolute(sheet, col);\n  } else {\n    return ColumnAddress.relative(sheet, col - baseAddress.col);\n  }\n};\nexport var rowAddressFromString = function rowAddressFromString(sheetMapping, stringAddress, baseAddress) {\n  var result = rowRegex.exec(stringAddress);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  var row = Number(result[6]) - 1;\n\n  if (result[5] === '$') {\n    return RowAddress.absolute(sheet, row);\n  } else {\n    return RowAddress.relative(sheet, row - baseAddress.row);\n  }\n};\n/**\n * Computes simple (absolute) address of a cell address based on its string representation.\n * If sheet name present in string representation but is not present in sheet mapping, returns undefined.\n * If sheet name is not present in string representation, returns {@param sheetContext} as sheet number\n *\n * @param sheetMapping - mapping function needed to change name of a sheet to index\n * @param stringAddress - string representation of cell address, e.g. 'C64'\n * @param sheetContext - sheet in context of which we should parse the address\n * @returns absolute representation of address, e.g. { sheet: 0, col: 1, row: 1 }\n */\n\nexport var simpleCellAddressFromString = function simpleCellAddressFromString(sheetMapping, stringAddress, sheetContext) {\n  var result = addressRegex.exec(stringAddress);\n  var col = columnLabelToIndex(result[6]);\n  var sheet = extractSheetNumber(result, sheetMapping);\n\n  if (sheet === undefined) {\n    return undefined;\n  }\n\n  if (sheet === null) {\n    sheet = sheetContext;\n  }\n\n  var row = Number(result[8]) - 1;\n  return simpleCellAddress(sheet, col, row);\n};\n/**\n * Returns string representation of absolute address\n * If sheet index is not present in sheet mapping, returns undefined\n *\n * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name\n * @param address - object representation of absolute address\n * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name\n * */\n\nexport var simpleCellAddressToString = function simpleCellAddressToString(sheetIndexMapping, address, sheetIndex) {\n  var column = columnIndexToLabel(address.col);\n  var sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);\n\n  if (sheetName === undefined) {\n    return undefined;\n  }\n\n  if (sheetIndex !== address.sheet) {\n    return \"\".concat(sheetName, \"!\").concat(column).concat(address.row + 1);\n  } else {\n    return \"\".concat(column).concat(address.row + 1);\n  }\n};\n/**\n* Convert column label to index\n*\n* @param columnStringRepresentation - column label (e.g. 'AAB')\n* @returns column index\n* */\n\nfunction columnLabelToIndex(columnStringRepresentation) {\n  if (columnStringRepresentation.length === 1) {\n    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;\n  } else {\n    return columnStringRepresentation.split('').reduce(function (currentColumn, nextLetter) {\n      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);\n    }, 0) - 1;\n  }\n}\n/**\n * Converts column index to label\n *\n * @param column - address to convert\n * @returns string representation, e.g. 'AAB'\n */\n\n\nexport function columnIndexToLabel(column) {\n  var result = '';\n\n  while (column >= 0) {\n    result = String.fromCharCode(column % 26 + 97) + result;\n    column = Math.floor(column / 26) - 1;\n  }\n\n  return result.toUpperCase();\n}\nexport function sheetIndexToString(sheetId, sheetMappingFn) {\n  var sheetName = sheetMappingFn(sheetId);\n\n  if (sheetName === undefined) {\n    return undefined;\n  }\n\n  if (simpleSheetNameRegex.test(sheetName)) {\n    return sheetName;\n  } else {\n    sheetName = sheetName.replace(/'/g, \"''\");\n    return \"'\".concat(sheetName, \"'\");\n  }\n}\n\nfunction extractSheetNumber(regexResult, sheetMapping) {\n  var _a;\n\n  var maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];\n  var sheet = null;\n\n  if (maybeSheetName) {\n    maybeSheetName = maybeSheetName.replace(/''/g, \"'\");\n    sheet = sheetMapping(maybeSheetName);\n\n    if (sheet === undefined) {\n      return undefined;\n    }\n  }\n\n  return sheet;\n}"]},"metadata":{},"sourceType":"module"}