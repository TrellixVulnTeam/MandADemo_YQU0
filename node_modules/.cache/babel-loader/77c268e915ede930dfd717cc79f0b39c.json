{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType } from \"./lexer_public\";\nimport { compact, contains, defaults, difference, filter, find, first, flatten, forEach, has, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, mapValues, packArray, PRINT_ERROR, reduce, reject } from \"../utils/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices } from \"./reg_exp\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nvar PATTERN = \"PATTERN\";\nexport var DEFAULT_MODE = \"defaultMode\";\nexport var MODES = \"modes\";\nexport var SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n  SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n  SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: function (msg, action) {\n      return action();\n    }\n  });\n  var tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n    initCharCodeToOptimizedIndexMap();\n  });\n  var onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", function () {\n    onlyRelevantTypes = reject(tokenTypes, function (currType) {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n  var hasCustom = false;\n  var allTransformedPatterns;\n  tracer(\"Transform Patterns\", function () {\n    hasCustom = false;\n    allTransformedPatterns = map(onlyRelevantTypes, function (currType) {\n      var currPattern = currType[PATTERN];\n      /* istanbul ignore else */\n\n      if (isRegExp(currPattern)) {\n        var regExpSource = currPattern.source;\n\n        if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\") {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" && // not a meta character\n        !contains([\"d\", \"D\", \"s\", \"S\", \"t\", \"r\", \"n\", \"t\", \"0\", \"c\", \"b\", \"B\", \"f\", \"v\", \"w\", \"W\"], regExpSource[1])) {\n          // escaped meta Characters: /\\+/ /\\[/\n          // or redundant escaping: /\\a/\n          // without the escaping \"\\\"\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if (isFunction(currPattern)) {\n        hasCustom = true; // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n\n        return {\n          exec: currPattern\n        };\n      } else if (has(currPattern, \"exec\")) {\n        hasCustom = true; // ICustomPattern\n\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          var wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  var patternIdxToType;\n  var patternIdxToGroup;\n  var patternIdxToLongerAltIdx;\n  var patternIdxToPushMode;\n  var patternIdxToPopMode;\n  tracer(\"misc mapping\", function () {\n    patternIdxToType = map(onlyRelevantTypes, function (currType) {\n      return currType.tokenTypeIdx;\n    });\n    patternIdxToGroup = map(onlyRelevantTypes, function (clazz) {\n      var groupName = clazz.GROUP;\n      /* istanbul ignore next */\n\n      if (groupName === Lexer.SKIPPED) {\n        return undefined;\n      } else if (isString(groupName)) {\n        return groupName;\n      } else if (isUndefined(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdx = map(onlyRelevantTypes, function (clazz) {\n      var longerAltType = clazz.LONGER_ALT;\n\n      if (longerAltType) {\n        var longerAltIdx = indexOf(onlyRelevantTypes, longerAltType);\n        return longerAltIdx;\n      }\n    });\n    patternIdxToPushMode = map(onlyRelevantTypes, function (clazz) {\n      return clazz.PUSH_MODE;\n    });\n    patternIdxToPopMode = map(onlyRelevantTypes, function (clazz) {\n      return has(clazz, \"POP_MODE\");\n    });\n  });\n  var patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", function () {\n    var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n      return false;\n    });\n\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return tokType.LINE_BREAKS;\n        } else {\n          if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n            return canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n          }\n        }\n      });\n    }\n  });\n  var patternIdxToIsCustom;\n  var patternIdxToShort;\n  var emptyGroups;\n  var patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", function () {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n    emptyGroups = reduce(onlyRelevantTypes, function (acc, clazz) {\n      var groupName = clazz.GROUP;\n\n      if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n\n      return acc;\n    }, {});\n    patternIdxToConfig = map(allTransformedPatterns, function (x, idx) {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdx[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  var canBeOptimized = true;\n  var charCodeToPatternIdxToConfig = [];\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", function () {\n      charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n        if (typeof currTokType.PATTERN === \"string\") {\n          var charCode = currTokType.PATTERN.charCodeAt(0);\n          var optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if (isArray(currTokType.START_CHARS_HINT)) {\n          var lastOptimizedIdx_1;\n          forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n            var charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            var currOptimizedIdx = charCodeToOptimizedIndex(charCode); // Avoid adding the config multiple times\n\n            if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n              lastOptimizedIdx_1 = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if (isRegExp(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") + \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n            }\n          } else {\n            var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n            /* istanbul ignore if */\n            // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n            // the first should be a different validation and the second cannot be tested.\n\n            if (isEmpty(optimizedCodes)) {\n              // we cannot understand what codes may start possible matches\n              // The optimization correctness requires knowing start codes for ALL patterns.\n              // Not actually sure this is an error, no debug message\n              canBeOptimized = false;\n            }\n\n            forEach(optimizedCodes, function (code) {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            PRINT_ERROR(\"\" + failedOptimizationPrefixMsg + (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n          }\n\n          canBeOptimized = false;\n        }\n\n        return result;\n      }, []);\n    });\n  }\n\n  tracer(\"ArrayPacking\", function () {\n    charCodeToPatternIdxToConfig = packArray(charCodeToPatternIdxToConfig);\n  });\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n  var errors = [];\n  var missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  var invalidResult = findInvalidPatterns(missingResult.valid);\n  var validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\n\nfunction validateRegExpPattern(tokenTypes) {\n  var errors = [];\n  var withRegExpPatterns = filter(tokenTypes, function (currTokType) {\n    return isRegExp(currTokType[PATTERN]);\n  });\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\n\nexport function findMissingPatterns(tokenTypes) {\n  var tokenTypesWithMissingPattern = filter(tokenTypes, function (currType) {\n    return !has(currType, PATTERN);\n  });\n  var errors = map(tokenTypesWithMissingPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nexport function findInvalidPatterns(tokenTypes) {\n  var tokenTypesWithInvalidPattern = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return !isRegExp(pattern) && !isFunction(pattern) && !has(pattern, \"exec\") && !isString(pattern);\n  });\n  var errors = map(tokenTypesWithInvalidPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a\" + \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nvar end_of_input = /[^\\\\][\\$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n  var EndAnchorFinder = function (_super) {\n    __extends(EndAnchorFinder, _super);\n\n    function EndAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.found = false;\n      return _this;\n    }\n\n    EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n      this.found = true;\n    };\n\n    return EndAnchorFinder;\n  }(BaseRegExpVisitor);\n\n  var invalidRegex = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n\n    try {\n      var regexpAst = getRegExpAst(pattern);\n      var endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test(pattern.source);\n    }\n  });\n  var errors = map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" + \"\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n  var matchesEmptyString = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern.test(\"\");\n  });\n  var errors = map(matchesEmptyString, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n  var StartAnchorFinder = function (_super) {\n    __extends(StartAnchorFinder, _super);\n\n    function StartAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.found = false;\n      return _this;\n    }\n\n    StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n      this.found = true;\n    };\n\n    return StartAnchorFinder;\n  }(BaseRegExpVisitor);\n\n  var invalidRegex = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n\n    try {\n      var regexpAst = getRegExpAst(pattern);\n      var startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source);\n    }\n  });\n  var errors = map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" + \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n  var invalidFlags = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  var errors = map(invalidFlags, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n} // This can only test for identical duplicate RegExps, not semantically equivalent ones.\n\nexport function findDuplicatePatterns(tokenTypes) {\n  var found = [];\n  var identicalPatterns = map(tokenTypes, function (outerType) {\n    return reduce(tokenTypes, function (result, innerType) {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !contains(found, innerType) && innerType.PATTERN !== Lexer.NA) {\n        // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n        // in essence we are creating Equivalence classes on equality relation.\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n\n      return result;\n    }, []);\n  });\n  identicalPatterns = compact(identicalPatterns);\n  var duplicatePatterns = filter(identicalPatterns, function (currIdenticalSet) {\n    return currIdenticalSet.length > 1;\n  });\n  var errors = map(duplicatePatterns, function (setOfIdentical) {\n    var tokenTypeNames = map(setOfIdentical, function (currType) {\n      return currType.name;\n    });\n    var dupPatternSrc = first(setOfIdentical).PATTERN;\n    return {\n      message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" + (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n  var invalidTypes = filter(tokenTypes, function (clazz) {\n    if (!has(clazz, \"GROUP\")) {\n      return false;\n    }\n\n    var group = clazz.GROUP;\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n  });\n  var errors = map(invalidTypes, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n  var invalidModes = filter(tokenTypes, function (clazz) {\n    return clazz.PUSH_MODE !== undefined && !contains(validModes, clazz.PUSH_MODE);\n  });\n  var errors = map(invalidModes, function (tokType) {\n    var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" + \"which does not exist\";\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n  var errors = [];\n  var canBeTested = reduce(tokenTypes, function (result, tokType, idx) {\n    var pattern = tokType.PATTERN;\n\n    if (pattern === Lexer.NA) {\n      return result;\n    } // a more comprehensive validation for all forms of regExps would require\n    // deeper regExp analysis capabilities\n\n\n    if (isString(pattern)) {\n      result.push({\n        str: pattern,\n        idx: idx,\n        tokenType: tokType\n      });\n    } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n      result.push({\n        str: pattern.source,\n        idx: idx,\n        tokenType: tokType\n      });\n    }\n\n    return result;\n  }, []);\n  forEach(tokenTypes, function (tokType, testIdx) {\n    forEach(canBeTested, function (_a) {\n      var str = _a.str,\n          idx = _a.idx,\n          tokenType = _a.tokenType;\n\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" + (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") + \"in the lexer's definition.\\n\" + \"See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nfunction testTokenType(str, pattern) {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    var regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {});\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction noMetaChar(regExp) {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  var metaChars = [\".\", \"\\\\\", \"[\", \"]\", \"|\", \"^\", \"$\", \"(\", \")\", \"?\", \"*\", \"+\", \"{\"];\n  return find(metaChars, function (char) {\n    return regExp.source.indexOf(char) !== -1;\n  }) === undefined;\n}\n\nexport function addStartOfInput(pattern) {\n  var flags = pattern.ignoreCase ? \"i\" : \"\"; // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n\n  return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\nexport function addStickyFlag(pattern) {\n  var flags = pattern.ignoreCase ? \"iy\" : \"y\"; // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n\n  return new RegExp(\"\" + pattern.source, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var errors = []; // some run time checks to help the end users.\n\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n\n  if (has(lexerDefinition, MODES) && has(lexerDefinition, DEFAULT_MODE) && !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized with a \" + DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" + \"which does not exist\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n      forEach(currModeValue, function (currTokType, currIdx) {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" + (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        }\n      });\n    });\n  }\n\n  return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var warnings = [];\n  var hasAnyLineBreak = false;\n  var allTokenTypes = compact(flatten(mapValues(lexerDefinition.modes, function (tokTypes) {\n    return tokTypes;\n  })));\n  var concreteTokenTypes = reject(allTokenTypes, function (currType) {\n    return currType[PATTERN] === Lexer.NA;\n  });\n  var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n\n  if (trackLines) {\n    forEach(concreteTokenTypes, function (tokType) {\n      var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n\n      if (currIssue !== false) {\n        var message = buildLineBreakIssueMessage(tokType, currIssue);\n        var warningDescriptor = {\n          message: message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\" + \"\\tThis Lexer has been defined to track line and column information,\\n\" + \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" + \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n\n  return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n  var clonedResult = {};\n  var groupKeys = keys(emptyGroups);\n  forEach(groupKeys, function (currKey) {\n    var currGroupValue = emptyGroups[currKey];\n    /* istanbul ignore else */\n\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n} // TODO: refactor to avoid duplication\n\nexport function isCustomPattern(tokenType) {\n  var pattern = tokenType.PATTERN;\n  /* istanbul ignore else */\n\n  if (isRegExp(pattern)) {\n    return false;\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true;\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true;\n  } else if (isString(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function isShortPattern(pattern) {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\n\nexport var LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    var len = text.length;\n\n    for (var i = this.lastIndex; i < len; i++) {\n      var c = text.charCodeAt(i);\n\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  },\n  lastIndex: 0\n};\n\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false;\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n\n      return false;\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return {\n        issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\n\nexport function buildLineBreakIssueMessage(tokType, details) {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return \"Warning: unable to identify line terminator usage in pattern.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + (\"\\t Root cause: \" + details.errMsg + \".\\n\") + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction getCharCodes(charsOrCodes) {\n  var charCodes = map(charsOrCodes, function (numOrString) {\n    if (isString(numOrString) && numOrString.length > 0) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\n\nfunction addToMapOfArrays(map, key, value) {\n  if (map[key] === undefined) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\n\nexport var minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\n\nexport function charCodeToOptimizedIndex(charCode) {\n  return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\n\nvar charCodeToOptimizedIdxMap = [];\n\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n\n    for (var i = 0; i < 65536; i++) {\n      /* tslint:disable */\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n      /* tslint:enable */\n    }\n  }\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/scan/lexer.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","BaseRegExpVisitor","Lexer","LexerDefinitionErrorType","compact","contains","defaults","difference","filter","find","first","flatten","forEach","has","indexOf","isArray","isEmpty","isFunction","isRegExp","isString","isUndefined","keys","map","mapValues","packArray","PRINT_ERROR","reduce","reject","canMatchCharCode","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","getRegExpAst","PATTERN","DEFAULT_MODE","MODES","SUPPORT_STICKY","RegExp","sticky","disableSticky","enableSticky","analyzeTokenTypes","tokenTypes","options","useSticky","debug","safeMode","positionTracking","lineTerminatorCharacters","tracer","msg","action","initCharCodeToOptimizedIndexMap","onlyRelevantTypes","currType","NA","hasCustom","allTransformedPatterns","currPattern","regExpSource","source","length","addStickyFlag","addStartOfInput","exec","escapedRegExpString","replace","wrappedRegExp","Error","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdx","patternIdxToPushMode","patternIdxToPopMode","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","undefined","longerAltType","LONGER_ALT","longerAltIdx","PUSH_MODE","patternIdxToCanLineTerminator","lineTerminatorCharCodes","getCharCodes","tokType","LINE_BREAKS","checkLineBreaksIssues","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","isCustomPattern","isShortPattern","acc","x","idx","pattern","longerAlt","canLineTerminator","isCustom","short","group","push","pop","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","result","currTokType","charCode","charCodeAt","optimizedIdx","charCodeToOptimizedIndex","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx_1","charOrInt","currOptimizedIdx","unicode","ensureOptimizations","toString","optimizedCodes","code","name","validatePatterns","validModesNames","errors","missingResult","findMissingPatterns","concat","invalidResult","findInvalidPatterns","valid","validTokenTypes","validateRegExpPattern","findInvalidGroupType","findModesThatDoNotExist","findUnreachablePatterns","withRegExpPatterns","findEndOfInputAnchor","findStartOfInputAnchor","findUnsupportedFlags","findDuplicatePatterns","findEmptyMatchRegExps","tokenTypesWithMissingPattern","message","type","MISSING_PATTERN","tokenTypesWithInvalidPattern","INVALID_PATTERN","end_of_input","EndAnchorFinder","_super","_this","apply","arguments","found","visitEndAnchor","node","invalidRegex","regexpAst","endAnchorVisitor","visit","e","test","EOI_ANCHOR_FOUND","matchesEmptyString","EMPTY_MATCH_PATTERN","start_of_input","StartAnchorFinder","visitStartAnchor","startAnchorVisitor","SOI_ANCHOR_FOUND","invalidFlags","multiline","global","UNSUPPORTED_FLAGS_FOUND","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","dupPatternSrc","join","DUPLICATE_PATTERNS_FOUND","invalidTypes","INVALID_GROUP_TYPE_FOUND","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","canBeTested","str","noMetaChar","testIdx","_a","testTokenType","UNREACHABLE_PATTERN","regExpArray","index","regExp","metaChars","char","flags","ignoreCase","performRuntimeChecks","lexerDefinition","trackLines","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","modes","defaultMode","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","tokTypes","concreteTokenTypes","terminatorCharCodes","currIssue","buildLineBreakIssueMessage","warningDescriptor","issue","NO_LINE_BREAKS_FLAGS","cloneEmptyGroups","clonedResult","groupKeys","currKey","currGroupValue","LineTerminatorOptimizedTester","text","len","i","lastIndex","c","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","details","charsOrCodes","charCodes","numOrString","key","value","minOptimizationVal","charCodeToOptimizedIdxMap"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType } from \"./lexer_public\";\nimport { compact, contains, defaults, difference, filter, find, first, flatten, forEach, has, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, mapValues, packArray, PRINT_ERROR, reduce, reject } from \"../utils/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices } from \"./reg_exp\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nvar PATTERN = \"PATTERN\";\nexport var DEFAULT_MODE = \"defaultMode\";\nexport var MODES = \"modes\";\nexport var SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n    SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n    SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n    options = defaults(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: function (msg, action) { return action(); }\n    });\n    var tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n        initCharCodeToOptimizedIndexMap();\n    });\n    var onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", function () {\n        onlyRelevantTypes = reject(tokenTypes, function (currType) {\n            return currType[PATTERN] === Lexer.NA;\n        });\n    });\n    var hasCustom = false;\n    var allTransformedPatterns;\n    tracer(\"Transform Patterns\", function () {\n        hasCustom = false;\n        allTransformedPatterns = map(onlyRelevantTypes, function (currType) {\n            var currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if (isRegExp(currPattern)) {\n                var regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== \"^\" &&\n                    regExpSource !== \"$\" &&\n                    regExpSource !== \".\") {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === \"\\\\\" &&\n                    // not a meta character\n                    !contains([\n                        \"d\",\n                        \"D\",\n                        \"s\",\n                        \"S\",\n                        \"t\",\n                        \"r\",\n                        \"n\",\n                        \"t\",\n                        \"0\",\n                        \"c\",\n                        \"b\",\n                        \"B\",\n                        \"f\",\n                        \"v\",\n                        \"w\",\n                        \"W\"\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping \"\\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if (isFunction(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if (has(currPattern, \"exec\")) {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    var wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    });\n    var patternIdxToType;\n    var patternIdxToGroup;\n    var patternIdxToLongerAltIdx;\n    var patternIdxToPushMode;\n    var patternIdxToPopMode;\n    tracer(\"misc mapping\", function () {\n        patternIdxToType = map(onlyRelevantTypes, function (currType) { return currType.tokenTypeIdx; });\n        patternIdxToGroup = map(onlyRelevantTypes, function (clazz) {\n            var groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === Lexer.SKIPPED) {\n                return undefined;\n            }\n            else if (isString(groupName)) {\n                return groupName;\n            }\n            else if (isUndefined(groupName)) {\n                return false;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n        patternIdxToLongerAltIdx = map(onlyRelevantTypes, function (clazz) {\n            var longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                var longerAltIdx = indexOf(onlyRelevantTypes, longerAltType);\n                return longerAltIdx;\n            }\n        });\n        patternIdxToPushMode = map(onlyRelevantTypes, function (clazz) { return clazz.PUSH_MODE; });\n        patternIdxToPopMode = map(onlyRelevantTypes, function (clazz) {\n            return has(clazz, \"POP_MODE\");\n        });\n    });\n    var patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", function () {\n        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) { return false; });\n        if (options.positionTracking !== \"onlyOffset\") {\n            patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    return tokType.LINE_BREAKS;\n                }\n                else {\n                    if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n                        return canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n                    }\n                }\n            });\n        }\n    });\n    var patternIdxToIsCustom;\n    var patternIdxToShort;\n    var emptyGroups;\n    var patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", function () {\n        patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n        emptyGroups = reduce(onlyRelevantTypes, function (acc, clazz) {\n            var groupName = clazz.GROUP;\n            if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = map(allTransformedPatterns, function (x, idx) {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdx[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx]\n            };\n        });\n    });\n    var canBeOptimized = true;\n    var charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer(\"First Char Optimization\", function () {\n            charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n                if (typeof currTokType.PATTERN === \"string\") {\n                    var charCode = currTokType.PATTERN.charCodeAt(0);\n                    var optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if (isArray(currTokType.START_CHARS_HINT)) {\n                    var lastOptimizedIdx_1;\n                    forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n                        var charCode = typeof charOrInt === \"string\"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n                            lastOptimizedIdx_1 = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if (isRegExp(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            PRINT_ERROR(\"\" + failedOptimizationPrefixMsg +\n                                (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") +\n                                \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                                \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                                \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n                        }\n                    }\n                    else {\n                        var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if (isEmpty(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        forEach(optimizedCodes, function (code) {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        PRINT_ERROR(\"\" + failedOptimizationPrefixMsg +\n                            (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") +\n                            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    tracer(\"ArrayPacking\", function () {\n        charCodeToPatternIdxToConfig = packArray(charCodeToPatternIdxToConfig);\n    });\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized\n    };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n    var errors = [];\n    var missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    var invalidResult = findInvalidPatterns(missingResult.valid);\n    var validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n    var errors = [];\n    var withRegExpPatterns = filter(tokenTypes, function (currTokType) {\n        return isRegExp(currTokType[PATTERN]);\n    });\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nexport function findMissingPatterns(tokenTypes) {\n    var tokenTypesWithMissingPattern = filter(tokenTypes, function (currType) {\n        return !has(currType, PATTERN);\n    });\n    var errors = map(tokenTypesWithMissingPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- missing static 'PATTERN' property\",\n            type: LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors: errors, valid: valid };\n}\nexport function findInvalidPatterns(tokenTypes) {\n    var tokenTypesWithInvalidPattern = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return (!isRegExp(pattern) &&\n            !isFunction(pattern) &&\n            !has(pattern, \"exec\") &&\n            !isString(pattern));\n    });\n    var errors = map(tokenTypesWithInvalidPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' can only be a RegExp, a\" +\n                \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors: errors, valid: valid };\n}\nvar end_of_input = /[^\\\\][\\$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n    var EndAnchorFinder = /** @class */ (function (_super) {\n        __extends(EndAnchorFinder, _super);\n        function EndAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n            this.found = true;\n        };\n        return EndAnchorFinder;\n    }(BaseRegExpVisitor));\n    var invalidRegex = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        try {\n            var regexpAst = getRegExpAst(pattern);\n            var endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    var errors = map(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n                \"\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n    var matchesEmptyString = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return pattern.test(\"\");\n    });\n    var errors = map(matchesEmptyString, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' must not match an empty string\",\n            type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n    var StartAnchorFinder = /** @class */ (function (_super) {\n        __extends(StartAnchorFinder, _super);\n        function StartAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n            this.found = true;\n        };\n        return StartAnchorFinder;\n    }(BaseRegExpVisitor));\n    var invalidRegex = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        try {\n            var regexpAst = getRegExpAst(pattern);\n            var startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    var errors = map(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n                \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n    var invalidFlags = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return (pattern instanceof RegExp && (pattern.multiline || pattern.global));\n    });\n    var errors = map(invalidFlags, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(tokenTypes) {\n    var found = [];\n    var identicalPatterns = map(tokenTypes, function (outerType) {\n        return reduce(tokenTypes, function (result, innerType) {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !contains(found, innerType) &&\n                innerType.PATTERN !== Lexer.NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = compact(identicalPatterns);\n    var duplicatePatterns = filter(identicalPatterns, function (currIdenticalSet) {\n        return currIdenticalSet.length > 1;\n    });\n    var errors = map(duplicatePatterns, function (setOfIdentical) {\n        var tokenTypeNames = map(setOfIdentical, function (currType) {\n            return currType.name;\n        });\n        var dupPatternSrc = first(setOfIdentical).PATTERN;\n        return {\n            message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" +\n                (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n            type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical\n        };\n    });\n    return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n    var invalidTypes = filter(tokenTypes, function (clazz) {\n        if (!has(clazz, \"GROUP\")) {\n            return false;\n        }\n        var group = clazz.GROUP;\n        return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n    });\n    var errors = map(invalidTypes, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n    var invalidModes = filter(tokenTypes, function (clazz) {\n        return (clazz.PUSH_MODE !== undefined &&\n            !contains(validModes, clazz.PUSH_MODE));\n    });\n    var errors = map(invalidModes, function (tokType) {\n        var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" +\n            \"which does not exist\";\n        return {\n            message: msg,\n            type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType]\n        };\n    });\n    return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n    var errors = [];\n    var canBeTested = reduce(tokenTypes, function (result, tokType, idx) {\n        var pattern = tokType.PATTERN;\n        if (pattern === Lexer.NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (isString(pattern)) {\n            result.push({ str: pattern, idx: idx, tokenType: tokType });\n        }\n        else if (isRegExp(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx: idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    forEach(tokenTypes, function (tokType, testIdx) {\n        forEach(canBeTested, function (_a) {\n            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" +\n                    (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") +\n                    \"in the lexer's definition.\\n\" +\n                    \"See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n                errors.push({\n                    message: msg,\n                    type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType]\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        var regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if (isFunction(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if (has(pattern, \"exec\")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === \"string\") {\n        return pattern === str;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    var metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\"\n    ];\n    return (find(metaChars, function (char) { return regExp.source.indexOf(char) !== -1; }) ===\n        undefined);\n}\nexport function addStartOfInput(pattern) {\n    var flags = pattern.ignoreCase ? \"i\" : \"\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\nexport function addStickyFlag(pattern) {\n    var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"\" + pattern.source, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var errors = [];\n    // some run time checks to help the end users.\n    if (!has(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                DEFAULT_MODE +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n        });\n    }\n    if (!has(lexerDefinition, MODES)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                MODES +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n        });\n    }\n    if (has(lexerDefinition, MODES) &&\n        has(lexerDefinition, DEFAULT_MODE) &&\n        !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized with a \" + DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" +\n                \"which does not exist\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n        });\n    }\n    if (has(lexerDefinition, MODES)) {\n        forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n            forEach(currModeValue, function (currTokType, currIdx) {\n                if (isUndefined(currTokType)) {\n                    errors.push({\n                        message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" +\n                            (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n                        type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var warnings = [];\n    var hasAnyLineBreak = false;\n    var allTokenTypes = compact(flatten(mapValues(lexerDefinition.modes, function (tokTypes) { return tokTypes; })));\n    var concreteTokenTypes = reject(allTokenTypes, function (currType) { return currType[PATTERN] === Lexer.NA; });\n    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        forEach(concreteTokenTypes, function (tokType) {\n            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                var message = buildLineBreakIssueMessage(tokType, currIssue);\n                var warningDescriptor = {\n                    message: message,\n                    type: currIssue.issue,\n                    tokenType: tokType\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: \"Warning: No LINE_BREAKS Found.\\n\" +\n                \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n                \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n                \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n        });\n    }\n    return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n    var clonedResult = {};\n    var groupKeys = keys(emptyGroups);\n    forEach(groupKeys, function (currKey) {\n        var currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if (isArray(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    });\n    return clonedResult;\n}\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType) {\n    var pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        return false;\n    }\n    else if (isFunction(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if (has(pattern, \"exec\")) {\n        // ICustomPattern\n        return true;\n    }\n    else if (isString(pattern)) {\n        return false;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function isShortPattern(pattern) {\n    if (isString(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport var LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        var len = text.length;\n        for (var i = this.lastIndex; i < len; i++) {\n            var c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (has(tokType, \"LINE_BREAKS\")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if (isRegExp(tokType.PATTERN)) {\n            try {\n                canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message\n                };\n            }\n            return false;\n        }\n        else if (isString(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n}\nexport function buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return (\"Warning: unable to identify line terminator usage in pattern.\\n\" +\n            (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") +\n            (\"\\t Root cause: \" + details.errMsg + \".\\n\") +\n            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n    }\n    else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return (\"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n            (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") +\n            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction getCharCodes(charsOrCodes) {\n    var charCodes = map(charsOrCodes, function (numOrString) {\n        if (isString(numOrString) && numOrString.length > 0) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nexport var minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nexport function charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nvar charCodeToOptimizedIdxMap = [];\nfunction initCharCodeToOptimizedIndexMap() {\n    if (isEmpty(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (var i = 0; i < 65536; i++) {\n            /* tslint:disable */\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n            /* tslint:enable */\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map"]},"metadata":{},"sourceType":"module"}