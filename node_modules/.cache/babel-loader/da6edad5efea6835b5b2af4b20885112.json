{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nvar dateFormatRegex = /(\\\\.|dd|DD|d|D|mm|MM|m|M|YYYY|YY|yyyy|yy|HH|hh|H|h|ss(\\.(0+|s+))?|s|AM\\/PM|am\\/pm|A\\/P|a\\/p|\\[mm]|\\[MM]|\\[hh]|\\[HH])/g;\nvar numberFormatRegex = /(\\\\.|[#0]+(\\.[#0]*)?)/g;\nexport var TokenType;\n\n(function (TokenType) {\n  TokenType[\"FORMAT\"] = \"FORMAT\";\n  TokenType[\"FREE_TEXT\"] = \"FREE_TEXT\";\n})(TokenType || (TokenType = {}));\n\nexport function formatToken(type, value) {\n  return {\n    type: type,\n    value: value\n  };\n}\nexport var FormatExpressionType;\n\n(function (FormatExpressionType) {\n  FormatExpressionType[\"DATE\"] = \"DATE\";\n  FormatExpressionType[\"NUMBER\"] = \"NUMBER\";\n  FormatExpressionType[\"STRING\"] = \"STRING\";\n})(FormatExpressionType || (FormatExpressionType = {}));\n\nfunction matchDateFormat(str) {\n  dateFormatRegex.lastIndex = 0;\n  var tokens = [];\n  var m;\n\n  do {\n    m = dateFormatRegex.exec(str);\n\n    if (m !== null) {\n      tokens.push(m);\n    }\n  } while (m);\n\n  return tokens;\n}\n\nfunction matchNumberFormat(str) {\n  numberFormatRegex.lastIndex = 0;\n  var numberFormatToken = numberFormatRegex.exec(str);\n\n  if (numberFormatToken !== null) {\n    return [numberFormatToken];\n  } else {\n    return [];\n  }\n}\n\nfunction createTokens(regexTokens, str) {\n  var tokens = [];\n  var start = 0;\n\n  for (var i = 0; i < regexTokens.length; ++i) {\n    var token = regexTokens[i];\n\n    if (token.index !== start) {\n      var beforeToken = str.substr(start, token.index - start);\n      tokens.push(formatToken(TokenType.FREE_TEXT, beforeToken));\n    }\n\n    if (token[0].startsWith('\\\\')) {\n      tokens.push(formatToken(TokenType.FREE_TEXT, token[0]));\n    } else {\n      tokens.push(formatToken(TokenType.FORMAT, token[0]));\n    }\n\n    start = token.index + token[0].length;\n  }\n\n  var lastToken = regexTokens[regexTokens.length - 1];\n\n  if (lastToken.index + lastToken[0].length < str.length) {\n    var afterLastToken = str.substr(lastToken.index + lastToken[0].length, str.length);\n    tokens.push(formatToken(TokenType.FREE_TEXT, afterLastToken));\n  }\n\n  return tokens;\n}\n\nexport function parseForDateTimeFormat(str) {\n  var dateFormatTokens = matchDateFormat(str);\n\n  if (dateFormatTokens.every(function (elem) {\n    return isEscapeToken(elem);\n  })) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.DATE,\n      tokens: createTokens(dateFormatTokens, str)\n    };\n  }\n}\nexport function parseForNumberFormat(str) {\n  var numberFormatTokens = matchNumberFormat(str);\n\n  if (numberFormatTokens.every(function (elem) {\n    return isEscapeToken(elem);\n  })) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.NUMBER,\n      tokens: createTokens(numberFormatTokens, str)\n    };\n  }\n}\nexport function parse(str) {\n  var _a, _b;\n\n  return (_b = (_a = parseForDateTimeFormat(str)) !== null && _a !== void 0 ? _a : parseForNumberFormat(str)) !== null && _b !== void 0 ? _b : {\n    type: FormatExpressionType.STRING,\n    tokens: [{\n      type: TokenType.FREE_TEXT,\n      value: str\n    }]\n  };\n}\nexport function isEscapeToken(token) {\n  return token[0].startsWith('\\\\');\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/hyperformula/es/format/parser.js"],"names":["dateFormatRegex","numberFormatRegex","TokenType","formatToken","type","value","FormatExpressionType","matchDateFormat","str","lastIndex","tokens","m","exec","push","matchNumberFormat","numberFormatToken","createTokens","regexTokens","start","i","length","token","index","beforeToken","substr","FREE_TEXT","startsWith","FORMAT","lastToken","afterLastToken","parseForDateTimeFormat","dateFormatTokens","every","elem","isEscapeToken","undefined","DATE","parseForNumberFormat","numberFormatTokens","NUMBER","parse","_a","_b","STRING"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\n\n/**\n * @license\n * Copyright (c) 2021 Handsoncode. All rights reserved.\n */\nvar dateFormatRegex = /(\\\\.|dd|DD|d|D|mm|MM|m|M|YYYY|YY|yyyy|yy|HH|hh|H|h|ss(\\.(0+|s+))?|s|AM\\/PM|am\\/pm|A\\/P|a\\/p|\\[mm]|\\[MM]|\\[hh]|\\[HH])/g;\nvar numberFormatRegex = /(\\\\.|[#0]+(\\.[#0]*)?)/g;\nexport var TokenType;\n\n(function (TokenType) {\n  TokenType[\"FORMAT\"] = \"FORMAT\";\n  TokenType[\"FREE_TEXT\"] = \"FREE_TEXT\";\n})(TokenType || (TokenType = {}));\n\nexport function formatToken(type, value) {\n  return {\n    type: type,\n    value: value\n  };\n}\nexport var FormatExpressionType;\n\n(function (FormatExpressionType) {\n  FormatExpressionType[\"DATE\"] = \"DATE\";\n  FormatExpressionType[\"NUMBER\"] = \"NUMBER\";\n  FormatExpressionType[\"STRING\"] = \"STRING\";\n})(FormatExpressionType || (FormatExpressionType = {}));\n\nfunction matchDateFormat(str) {\n  dateFormatRegex.lastIndex = 0;\n  var tokens = [];\n  var m;\n\n  do {\n    m = dateFormatRegex.exec(str);\n\n    if (m !== null) {\n      tokens.push(m);\n    }\n  } while (m);\n\n  return tokens;\n}\n\nfunction matchNumberFormat(str) {\n  numberFormatRegex.lastIndex = 0;\n  var numberFormatToken = numberFormatRegex.exec(str);\n\n  if (numberFormatToken !== null) {\n    return [numberFormatToken];\n  } else {\n    return [];\n  }\n}\n\nfunction createTokens(regexTokens, str) {\n  var tokens = [];\n  var start = 0;\n\n  for (var i = 0; i < regexTokens.length; ++i) {\n    var token = regexTokens[i];\n\n    if (token.index !== start) {\n      var beforeToken = str.substr(start, token.index - start);\n      tokens.push(formatToken(TokenType.FREE_TEXT, beforeToken));\n    }\n\n    if (token[0].startsWith('\\\\')) {\n      tokens.push(formatToken(TokenType.FREE_TEXT, token[0]));\n    } else {\n      tokens.push(formatToken(TokenType.FORMAT, token[0]));\n    }\n\n    start = token.index + token[0].length;\n  }\n\n  var lastToken = regexTokens[regexTokens.length - 1];\n\n  if (lastToken.index + lastToken[0].length < str.length) {\n    var afterLastToken = str.substr(lastToken.index + lastToken[0].length, str.length);\n    tokens.push(formatToken(TokenType.FREE_TEXT, afterLastToken));\n  }\n\n  return tokens;\n}\n\nexport function parseForDateTimeFormat(str) {\n  var dateFormatTokens = matchDateFormat(str);\n\n  if (dateFormatTokens.every(function (elem) {\n    return isEscapeToken(elem);\n  })) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.DATE,\n      tokens: createTokens(dateFormatTokens, str)\n    };\n  }\n}\nexport function parseForNumberFormat(str) {\n  var numberFormatTokens = matchNumberFormat(str);\n\n  if (numberFormatTokens.every(function (elem) {\n    return isEscapeToken(elem);\n  })) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.NUMBER,\n      tokens: createTokens(numberFormatTokens, str)\n    };\n  }\n}\nexport function parse(str) {\n  var _a, _b;\n\n  return (_b = (_a = parseForDateTimeFormat(str)) !== null && _a !== void 0 ? _a : parseForNumberFormat(str)) !== null && _b !== void 0 ? _b : {\n    type: FormatExpressionType.STRING,\n    tokens: [{\n      type: TokenType.FREE_TEXT,\n      value: str\n    }]\n  };\n}\nexport function isEscapeToken(token) {\n  return token[0].startsWith('\\\\');\n}"]},"metadata":{},"sourceType":"module"}