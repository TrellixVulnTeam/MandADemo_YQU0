{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { forEach, isUndefined } from \"../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAltIndex, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../grammar/keys\";\nimport { Alternation, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"../grammar/gast/gast_public\";\nimport { GAstVisitor } from \"../grammar/gast/gast_visitor_public\";\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\n\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  } // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\n\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  } // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\n\nvar NamedDSLMethodsCollectorVisitor = function (_super) {\n  __extends(NamedDSLMethodsCollectorVisitor, _super);\n\n  function NamedDSLMethodsCollectorVisitor(ruleIdx) {\n    var _this = _super.call(this) || this;\n\n    _this.result = [];\n    _this.ruleIdx = ruleIdx;\n    return _this;\n  }\n\n  NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {\n    // TODO: better hack to copy what we need here...\n    if (!isUndefined(node.name)) {\n      // copy without name so this will indeed be processed later.\n      var nameLessNode\n      /* istanbul ignore else */\n      = void 0;\n      /* istanbul ignore else */\n\n      if (node instanceof Option || node instanceof Repetition || node instanceof RepetitionMandatory || node instanceof Alternation) {\n        nameLessNode = new newNodeConstructor({\n          definition: node.definition,\n          idx: node.idx\n        });\n      } else if (node instanceof RepetitionMandatoryWithSeparator || node instanceof RepetitionWithSeparator) {\n        nameLessNode = new newNodeConstructor({\n          definition: node.definition,\n          idx: node.idx,\n          separator: node.separator\n        });\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n\n      var def = [nameLessNode];\n      var key = getKeyForAutomaticLookahead(this.ruleIdx, methodIdx, node.idx);\n      this.result.push({\n        def: def,\n        key: key,\n        name: node.name,\n        orgProd: node\n      });\n    }\n  };\n\n  NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {\n    this.collectNamedDSLMethod(node, Option, OPTION_IDX);\n  };\n\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {\n    this.collectNamedDSLMethod(node, Repetition, MANY_IDX);\n  };\n\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionMandatory, AT_LEAST_ONE_IDX);\n  };\n\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionMandatoryWithSeparator, AT_LEAST_ONE_SEP_IDX);\n  };\n\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionWithSeparator, MANY_SEP_IDX);\n  };\n\n  NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {\n    var _this = this;\n\n    this.collectNamedDSLMethod(node, Alternation, OR_IDX);\n    var hasMoreThanOneAlternative = node.definition.length > 1;\n    forEach(node.definition, function (currFlatAlt, altIdx) {\n      if (!isUndefined(currFlatAlt.name)) {\n        var def = currFlatAlt.definition;\n\n        if (hasMoreThanOneAlternative) {\n          def = [new Option({\n            definition: currFlatAlt.definition\n          })];\n        } else {\n          // mandatory\n          def = currFlatAlt.definition;\n        }\n\n        var key = getKeyForAltIndex(_this.ruleIdx, OR_IDX, node.idx, altIdx);\n\n        _this.result.push({\n          def: def,\n          key: key,\n          name: currFlatAlt.name,\n          orgProd: currFlatAlt\n        });\n      }\n    });\n  };\n\n  return NamedDSLMethodsCollectorVisitor;\n}(GAstVisitor);\n\nexport { NamedDSLMethodsCollectorVisitor };\nexport function expandAllNestedRuleNames(topRules, fullToShortName) {\n  var result = {\n    allRuleNames: []\n  };\n  forEach(topRules, function (currTopRule) {\n    var currTopRuleShortName = fullToShortName[currTopRule.name];\n    result.allRuleNames.push(currTopRule.name);\n    var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);\n    currTopRule.accept(namedCollectorVisitor);\n    forEach(namedCollectorVisitor.result, function (_a) {\n      var def = _a.def,\n          key = _a.key,\n          name = _a.name;\n      result.allRuleNames.push(currTopRule.name + name);\n    });\n  });\n  return result;\n}","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/cst/cst.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","forEach","isUndefined","AT_LEAST_ONE_IDX","AT_LEAST_ONE_SEP_IDX","getKeyForAltIndex","getKeyForAutomaticLookahead","MANY_IDX","MANY_SEP_IDX","OPTION_IDX","OR_IDX","Alternation","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","GAstVisitor","setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","startOffset","endOffset","setNodeLocationFull","startColumn","startLine","endColumn","endLine","addTerminalToCst","node","token","tokenTypeName","children","undefined","push","addNoneTerminalToCst","ruleName","ruleResult","NamedDSLMethodsCollectorVisitor","_super","ruleIdx","_this","call","result","collectNamedDSLMethod","newNodeConstructor","methodIdx","name","nameLessNode","definition","idx","separator","Error","def","key","orgProd","visitOption","visitRepetition","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitAlternation","hasMoreThanOneAlternative","length","currFlatAlt","altIdx","expandAllNestedRuleNames","topRules","fullToShortName","allRuleNames","currTopRule","currTopRuleShortName","namedCollectorVisitor","accept","_a"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { forEach, isUndefined } from \"../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAltIndex, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../grammar/keys\";\nimport { Alternation, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"../grammar/gast/gast_public\";\nimport { GAstVisitor } from \"../grammar/gast/gast_visitor_public\";\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\nvar NamedDSLMethodsCollectorVisitor = /** @class */ (function (_super) {\n    __extends(NamedDSLMethodsCollectorVisitor, _super);\n    function NamedDSLMethodsCollectorVisitor(ruleIdx) {\n        var _this = _super.call(this) || this;\n        _this.result = [];\n        _this.ruleIdx = ruleIdx;\n        return _this;\n    }\n    NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {\n        // TODO: better hack to copy what we need here...\n        if (!isUndefined(node.name)) {\n            // copy without name so this will indeed be processed later.\n            var nameLessNode \n            /* istanbul ignore else */\n            = void 0;\n            /* istanbul ignore else */\n            if (node instanceof Option ||\n                node instanceof Repetition ||\n                node instanceof RepetitionMandatory ||\n                node instanceof Alternation) {\n                nameLessNode = new newNodeConstructor({\n                    definition: node.definition,\n                    idx: node.idx\n                });\n            }\n            else if (node instanceof RepetitionMandatoryWithSeparator ||\n                node instanceof RepetitionWithSeparator) {\n                nameLessNode = new newNodeConstructor({\n                    definition: node.definition,\n                    idx: node.idx,\n                    separator: node.separator\n                });\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n            var def = [nameLessNode];\n            var key = getKeyForAutomaticLookahead(this.ruleIdx, methodIdx, node.idx);\n            this.result.push({ def: def, key: key, name: node.name, orgProd: node });\n        }\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {\n        this.collectNamedDSLMethod(node, Option, OPTION_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {\n        this.collectNamedDSLMethod(node, Repetition, MANY_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.collectNamedDSLMethod(node, RepetitionMandatory, AT_LEAST_ONE_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.collectNamedDSLMethod(node, RepetitionMandatoryWithSeparator, AT_LEAST_ONE_SEP_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.collectNamedDSLMethod(node, RepetitionWithSeparator, MANY_SEP_IDX);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {\n        var _this = this;\n        this.collectNamedDSLMethod(node, Alternation, OR_IDX);\n        var hasMoreThanOneAlternative = node.definition.length > 1;\n        forEach(node.definition, function (currFlatAlt, altIdx) {\n            if (!isUndefined(currFlatAlt.name)) {\n                var def = currFlatAlt.definition;\n                if (hasMoreThanOneAlternative) {\n                    def = [new Option({ definition: currFlatAlt.definition })];\n                }\n                else {\n                    // mandatory\n                    def = currFlatAlt.definition;\n                }\n                var key = getKeyForAltIndex(_this.ruleIdx, OR_IDX, node.idx, altIdx);\n                _this.result.push({\n                    def: def,\n                    key: key,\n                    name: currFlatAlt.name,\n                    orgProd: currFlatAlt\n                });\n            }\n        });\n    };\n    return NamedDSLMethodsCollectorVisitor;\n}(GAstVisitor));\nexport { NamedDSLMethodsCollectorVisitor };\nexport function expandAllNestedRuleNames(topRules, fullToShortName) {\n    var result = {\n        allRuleNames: []\n    };\n    forEach(topRules, function (currTopRule) {\n        var currTopRuleShortName = fullToShortName[currTopRule.name];\n        result.allRuleNames.push(currTopRule.name);\n        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);\n        currTopRule.accept(namedCollectorVisitor);\n        forEach(namedCollectorVisitor.result, function (_a) {\n            var def = _a.def, key = _a.key, name = _a.name;\n            result.allRuleNames.push(currTopRule.name + name);\n        });\n    });\n    return result;\n}\n//# sourceMappingURL=cst.js.map"]},"metadata":{},"sourceType":"module"}