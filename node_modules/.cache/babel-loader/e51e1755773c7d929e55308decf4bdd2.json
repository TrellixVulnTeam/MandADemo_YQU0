{"ast":null,"code":"import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\";\nimport * as utils from \"../utils/utils\";\nimport { first, map, reduce } from \"../utils/utils\";\nimport { NonTerminal, Rule, Terminal } from \"./grammar/gast/gast_public\";\nimport { getProductionDslName } from \"./grammar/gast/gast\";\nimport { validNestedRuleName } from \"./grammar/checks\";\nexport var defaultParserErrorProvider = {\n  buildMismatchTokenMessage: function (_a) {\n    var expected = _a.expected,\n        actual = _a.actual,\n        previous = _a.previous,\n        ruleName = _a.ruleName;\n    var hasLabel = hasTokenLabel(expected);\n    var expectedMsg = hasLabel ? \"--> \" + tokenLabel(expected) + \" <--\" : \"token of type --> \" + expected.name + \" <--\";\n    var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n    return msg;\n  },\n  buildNotAllInputParsedMessage: function (_a) {\n    var firstRedundant = _a.firstRedundant,\n        ruleName = _a.ruleName;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage: function (_a) {\n    var expectedPathsPerAlt = _a.expectedPathsPerAlt,\n        actual = _a.actual,\n        previous = _a.previous,\n        customUserDescription = _a.customUserDescription,\n        ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    var actualText = first(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var allLookAheadPaths = reduce(expectedPathsPerAlt, function (result, currAltPaths) {\n        return result.concat(currAltPaths);\n      }, []);\n      var nextValidTokenSequences = map(allLookAheadPaths, function (currPath) {\n        return \"[\" + map(currPath, function (currTokenType) {\n          return tokenLabel(currTokenType);\n        }).join(\", \") + \"]\";\n      });\n      var nextValidSequenceItems = map(nextValidTokenSequences, function (itemMsg, idx) {\n        return \"  \" + (idx + 1) + \". \" + itemMsg;\n      });\n      var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage: function (_a) {\n    var expectedIterationPaths = _a.expectedIterationPaths,\n        actual = _a.actual,\n        customUserDescription = _a.customUserDescription,\n        ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    var actualText = first(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var nextValidTokenSequences = map(expectedIterationPaths, function (currPath) {\n        return \"[\" + map(currPath, function (currTokenType) {\n          return tokenLabel(currTokenType);\n        }).join(\",\") + \"]\";\n      });\n      var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(defaultParserErrorProvider);\nexport var defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n    var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexport var defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n\n    var topLevelName = topLevelRule.name;\n    var duplicateProd = first(duplicateProds);\n    var index = duplicateProd.idx;\n    var dslName = getProductionDslName(duplicateProd);\n    var extraArgument = getExtraProductionArgument(duplicateProd);\n    var hasExplicitIndex = index > 0;\n    var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \"; // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildInvalidNestedRuleNameError: function (topLevelRule, nestedProd) {\n    var msg = \"Invalid nested rule name: ->\" + nestedProd.name + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" + (\"it must match the pattern: ->\" + validNestedRuleName.toString() + \"<-.\\n\") + \"Note that this means a nested rule name must start with the '$'(dollar) sign.\";\n    return msg;\n  },\n  buildDuplicateNestedRuleNameError: function (topLevelRule, nestedProd) {\n    var duplicateName = first(nestedProd).name;\n    var errMsg = \"Duplicate nested rule name: ->\" + duplicateName + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" + \"A nested name must be unique in the scope of a top level grammar rule.\";\n    return errMsg;\n  },\n  buildNamespaceConflictError: function (rule) {\n    var errMsg = \"Namespace conflict found in grammar.\\n\" + (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError: function (options) {\n    var pathMsg = map(options.prefixPath, function (currTok) {\n      return tokenLabel(currTok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" + (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError: function (options) {\n    var pathMsg = map(options.prefixPath, function (currtok) {\n      return tokenLabel(currtok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" + (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError: function (options) {\n    var dslName = getProductionDslName(options.repetition);\n\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n\n    var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  buildTokenNameError: function (options) {\n    var tokTypeName = options.tokenType.name;\n    var errMsg = \"Invalid Grammar Token name: ->\" + tokTypeName + \"<- it must match the pattern: ->\" + options.expectedPattern.toString() + \"<-\";\n    return errMsg;\n  },\n  buildEmptyAlternationError: function (options) {\n    var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" + (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError: function (options) {\n    var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length + 1) + \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError: function (options) {\n    var ruleName = options.topLevelRule.name;\n    var pathNames = utils.map(options.leftRecursionPath, function (currRule) {\n      return currRule.name;\n    });\n    var leftRecursivePath = ruleName + \" --> \" + pathNames.concat([ruleName]).join(\" --> \");\n    var errMsg = \"Left Recursion found in grammar.\\n\" + (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") + (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n    return errMsg;\n  },\n  buildInvalidRuleNameError: function (options) {\n    var ruleName = options.topLevelRule.name;\n    var expectedPatternString = options.expectedPattern.toString();\n    var errMsg = \"Invalid grammar rule name: ->\" + ruleName + \"<- it must match the pattern: ->\" + expectedPatternString + \"<-\";\n    return errMsg;\n  },\n  buildDuplicateRuleNameError: function (options) {\n    var ruleName;\n\n    if (options.topLevelRule instanceof Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n\n    var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n    return errMsg;\n  }\n};","map":{"version":3,"sources":["/Users/mingjie.wang/Documents/Uber/MandA/demo-project/node_modules/chevrotain/lib_esm/src/parse/errors_public.js"],"names":["hasTokenLabel","tokenLabel","utils","first","map","reduce","NonTerminal","Rule","Terminal","getProductionDslName","validNestedRuleName","defaultParserErrorProvider","buildMismatchTokenMessage","_a","expected","actual","previous","ruleName","hasLabel","expectedMsg","name","msg","image","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","actualText","errSuffix","allLookAheadPaths","result","currAltPaths","concat","nextValidTokenSequences","currPath","currTokenType","join","nextValidSequenceItems","itemMsg","idx","calculatedDescription","buildEarlyExitMessage","expectedIterationPaths","Object","freeze","defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","nonTerminalName","defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument","prod","terminalType","topLevelName","duplicateProd","index","dslName","extraArgument","hasExplicitIndex","length","replace","buildInvalidNestedRuleNameError","nestedProd","toString","buildDuplicateNestedRuleNameError","duplicateName","errMsg","buildNamespaceConflictError","rule","buildAlternationPrefixAmbiguityError","options","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","tokTypeName","tokenType","expectedPattern","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","definition","buildLeftRecursionError","pathNames","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","expectedPatternString","buildDuplicateRuleNameError","grammarName"],"mappings":"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","sourcesContent":["import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\";\nimport * as utils from \"../utils/utils\";\nimport { first, map, reduce } from \"../utils/utils\";\nimport { NonTerminal, Rule, Terminal } from \"./grammar/gast/gast_public\";\nimport { getProductionDslName } from \"./grammar/gast/gast\";\nimport { validNestedRuleName } from \"./grammar/checks\";\nexport var defaultParserErrorProvider = {\n    buildMismatchTokenMessage: function (_a) {\n        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;\n        var hasLabel = hasTokenLabel(expected);\n        var expectedMsg = hasLabel\n            ? \"--> \" + tokenLabel(expected) + \" <--\"\n            : \"token of type --> \" + expected.name + \" <--\";\n        var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n        return msg;\n    },\n    buildNotAllInputParsedMessage: function (_a) {\n        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;\n        return (\"Redundant input, expecting EOF but found: \" + firstRedundant.image);\n    },\n    buildNoViableAltMessage: function (_a) {\n        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = first(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var allLookAheadPaths = reduce(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);\n            var nextValidTokenSequences = map(allLookAheadPaths, function (currPath) {\n                return \"[\" + map(currPath, function (currTokenType) {\n                    return tokenLabel(currTokenType);\n                }).join(\", \") + \"]\";\n            });\n            var nextValidSequenceItems = map(nextValidTokenSequences, function (itemMsg, idx) { return \"  \" + (idx + 1) + \". \" + itemMsg; });\n            var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage: function (_a) {\n        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = first(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var nextValidTokenSequences = map(expectedIterationPaths, function (currPath) {\n                return \"[\" + map(currPath, function (currTokenType) {\n                    return tokenLabel(currTokenType);\n                }).join(\",\") + \"]\";\n            });\n            var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" +\n                (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    }\n};\nObject.freeze(defaultParserErrorProvider);\nexport var defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    }\n};\nexport var defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        var topLevelName = topLevelRule.name;\n        var duplicateProd = first(duplicateProds);\n        var index = duplicateProd.idx;\n        var dslName = getProductionDslName(duplicateProd);\n        var extraArgument = getExtraProductionArgument(duplicateProd);\n        var hasExplicitIndex = index > 0;\n        var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildInvalidNestedRuleNameError: function (topLevelRule, nestedProd) {\n        var msg = \"Invalid nested rule name: ->\" + nestedProd.name + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" +\n            (\"it must match the pattern: ->\" + validNestedRuleName.toString() + \"<-.\\n\") +\n            \"Note that this means a nested rule name must start with the '$'(dollar) sign.\";\n        return msg;\n    },\n    buildDuplicateNestedRuleNameError: function (topLevelRule, nestedProd) {\n        var duplicateName = first(nestedProd).name;\n        var errMsg = \"Duplicate nested rule name: ->\" + duplicateName + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" +\n            \"A nested name must be unique in the scope of a top level grammar rule.\";\n        return errMsg;\n    },\n    buildNamespaceConflictError: function (rule) {\n        var errMsg = \"Namespace conflict found in grammar.\\n\" +\n            (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") +\n            \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" +\n            \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" +\n            \"and Non-Terminal names start with a lower case letter.\";\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError: function (options) {\n        var pathMsg = map(options.prefixPath, function (currTok) {\n            return tokenLabel(currTok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" +\n            (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") +\n            \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" +\n            \"For Further details.\";\n        return errMsg;\n    },\n    buildAlternationAmbiguityError: function (options) {\n        var pathMsg = map(options.prefixPath, function (currtok) {\n            return tokenLabel(currtok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" +\n            (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n        currMessage =\n            currMessage +\n                \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" +\n                \"For Further details.\";\n        return currMessage;\n    },\n    buildEmptyRepetitionError: function (options) {\n        var dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" +\n            \"This could lead to an infinite loop.\";\n        return errMsg;\n    },\n    buildTokenNameError: function (options) {\n        var tokTypeName = options.tokenType.name;\n        var errMsg = \"Invalid Grammar Token name: ->\" + tokTypeName + \"<- it must match the pattern: ->\" + options.expectedPattern.toString() + \"<-\";\n        return errMsg;\n    },\n    buildEmptyAlternationError: function (options) {\n        var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" +\n            (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") +\n            \"Only the last alternative may be an empty alternative.\";\n        return errMsg;\n    },\n    buildTooManyAlternativesError: function (options) {\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" +\n            (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length +\n                1) + \" alternatives.\");\n        return errMsg;\n    },\n    buildLeftRecursionError: function (options) {\n        var ruleName = options.topLevelRule.name;\n        var pathNames = utils.map(options.leftRecursionPath, function (currRule) { return currRule.name; });\n        var leftRecursivePath = ruleName + \" --> \" + pathNames\n            .concat([ruleName])\n            .join(\" --> \");\n        var errMsg = \"Left Recursion found in grammar.\\n\" +\n            (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") +\n            (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") +\n            \" To fix this refactor your grammar to remove the left recursion.\\n\" +\n            \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n        return errMsg;\n    },\n    buildInvalidRuleNameError: function (options) {\n        var ruleName = options.topLevelRule.name;\n        var expectedPatternString = options.expectedPattern.toString();\n        var errMsg = \"Invalid grammar rule name: ->\" + ruleName + \"<- it must match the pattern: ->\" + expectedPatternString + \"<-\";\n        return errMsg;\n    },\n    buildDuplicateRuleNameError: function (options) {\n        var ruleName;\n        if (options.topLevelRule instanceof Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n        return errMsg;\n    }\n};\n//# sourceMappingURL=errors_public.js.map"]},"metadata":{},"sourceType":"module"}